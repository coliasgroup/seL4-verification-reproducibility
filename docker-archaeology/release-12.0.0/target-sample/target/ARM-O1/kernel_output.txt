
---------------------------------------------------------------------
       HOL-4 [Kananaskis 13 (stdknl, built Mon Dec 11 07:11:08 2023)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
** Load path (see loadPath variable) now contains 18 entries
** after consulting Holmakefiles

[In non-standard heap: /work/HOL4/examples/machine-code/graph/local-hol-heap]
> > 
Resetting specifications database.

Specializing fetch: 4 -> 1(1)
Specializing decode ARM (cond = 14): 95 -> 95(95)
Specializing decode ARM (cond = 15): 5 -> 5(5)
Specializing decode ARM (cond not in {14, 15}): 95 -> 95(95)
Specializing decode ARM (fallback): 1 -> 1(1)
Specializing eval: 374 -> 348(348)
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
val it = (): unit
> ======================================================================
  Base name: /work/graph-refine/seL4-example/target/ARM-O1/kernel
  Poly/ML: 581
  HOL: Kananaskis 13 (stdknl) commit 6c0c2409e
======================================================================
  Reading /work/graph-refine/seL4-example/target/ARM-O1/kernel.elf.txt, done.
  Reading /work/graph-refine/seL4-example/target/ARM-O1/kernel.elf.txt, done.
  Reading /work/graph-refine/seL4-example/target/ARM-O1/kernel.sigs, done.
No signature info for section: _start
No signature info for section: avail_p_regs
No signature info for section: kernel_devices
No signature info for section: mode_reserved_region
No signature info for section: avail_reg
No signature info for section: reserved
No signature info for section: arm_vector_table
No signature info for section: arm_undefined_inst_exception
No signature info for section: arm_swi_syscall
No signature info for section: arm_prefetch_abort_exception
No signature info for section: kernel_prefetch_fault
No signature info for section: arm_data_abort_exception
No signature info for section: kernel_data_fault
No signature info for section: arm_irq_exception
No signature info for section: arm_reset_exception
No signature info for section: arm_fiq_exception
======================================================================
  Total: 293 functions, 15468 ARM instructions
  Longest function: decodeARMMMUInvocation (1268 instructions)
  0 deps: 98 functions (avail_p_regs, kernel_devices, ...)
  1 deps: 82 functions (arm_reset_exception, str_to_long, memset, ...)
  2 deps: 50 functions (replyFromKernel_error, ...)
  3 deps: 28 functions (slowpath, invokeTCB_ReadRegisters, ...)
  4 deps: 8 functions (decodeSetIPCBuffer, handleVMFaultEvent, ...)
  5 deps: 11 functions (invokeUntyped_Retype, ...)
  6 deps: 2 functions (decodeSetSpace, sendIPC)
  7 deps: 7 functions (handleInvocation, decodeUntypedInvocation, ...)
  8 deps: 1 functions (finaliseCap)
  10 deps: 1 functions (handleSyscall)
  12 deps: 1 functions (decodeInvocation)
  15 deps: 1 functions (decodeTCBInvocation)
  16 deps: 1 functions (decodeCNodeInvocation)
  20 deps: 1 functions (decodeARMMMUInvocation)
  33 deps: 1 functions (init_kernel)
======================================================================

Section avail_p_regs (1 of 293)
===============================

Deriving specifications
-----------------------

Section `avail_p_regs` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `avail_p_regs` has 0 nodes.

Section kernel_devices (2 of 293)
=================================

Deriving specifications
-----------------------

Section `kernel_devices` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `kernel_devices` has 0 nodes.

Section mode_reserved_region (3 of 293)
=======================================

Deriving specifications
-----------------------

Section `mode_reserved_region` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mode_reserved_region` has 0 nodes.

Section avail_reg (4 of 293)
============================

Deriving specifications
-----------------------

Section `avail_reg` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `avail_reg` has 0 nodes.

Section reserved (5 of 293)
===========================

Deriving specifications
-----------------------

Section `reserved` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `reserved` has 0 nodes.

Section c_handle_fastpath_call (6 of 293)
=========================================

Deriving specifications
-----------------------

Section `c_handle_fastpath_call` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_fastpath_call` has 0 nodes.

Section c_handle_fastpath_reply_recv (7 of 293)
===============================================

Deriving specifications
-----------------------

Section `c_handle_fastpath_reply_recv` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_fastpath_reply_recv` has 0 nodes.

Section restore_user_context (8 of 293)
=======================================

Deriving specifications
-----------------------

Section `restore_user_context` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `restore_user_context` has 0 nodes.

Section char_to_long (9 of 293)
===============================

Deriving specifications
-----------------------

Section `char_to_long` consists of 18 instructions.
 SUB (imm)...++
 SXT{A}B,UXT{A}B.......+++++++
 CMP (imm)..+
 BLS..++
 SUBLS (imm)....+++
 MVNHI (imm)..++
 BX.+


Stack analysis
---------------

No stack accesses found. Code for `char_to_long`:

    0xe001b404     0x0    sub r3, r0, #48 
    0xe001b408     0x4    uxtb r3, r3
    0xe001b40c     0x8    cmp r3, #9
    0xe001b410     0xc    bls e001b43c <char_to_long+0x38>
    0xe001b414    0x10    sub r3, r0, #65 
    0xe001b418    0x14    uxtb r3, r3
    0xe001b41c    0x18    cmp r3, #5
    0xe001b420    0x1c    bls e001b444 <char_to_long+0x40>
    0xe001b424    0x20    sub r3, r0, #97 
    0xe001b428    0x24    uxtb r3, r3
    0xe001b42c    0x28    cmp r3, #5
    0xe001b430    0x2c    subls r0, r0, #87 
    0xe001b434    0x30    mvnhi r0, #0
    0xe001b438    0x34    bx lr
    0xe001b43c    0x38    sub r0, r0, #48 
    0xe001b440    0x3c    bx lr
    0xe001b444    0x40    sub r0, r0, #55 
    0xe001b448    0x44    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `char_to_long` has 29 nodes.

Section strncmp (10 of 293)
===========================

Deriving specifications
-----------------------

Section `strncmp` consists of 32 instructions.
 BEQ..++
 STR (-imm,pre,wb)..+
 MOV (reg)...++
 LDRB (+imm,pre)..++
 SUB (reg)..........+++++
 SUBS (reg)..........+++++
 MOVNE (imm)..++
 MOVEQ (imm)..++
 LDRNE (imm,post).. LDRNE (pc,imm,post)..++++
 ADD (reg)..........+++++
 CMP (reg).....++
 LDRB (+imm,pre,wb).+
 LDR (imm,post). LDR (pc,imm,post).++
 MOV (imm).+


Stack analysis
---------------

4 stack accesses found. Annotated code for `strncmp`:

    0xe001b384     0x0    cmp r2, #0
    0xe001b388     0x4    beq e001b3fc <strncmp+0x78>
    0xe001b38c     0x8    push {lr}             ; stack access
    0xe001b390     0xc    mov r3, r0
    0xe001b394    0x10    ldrb lr, [r0]
    0xe001b398    0x14    ldrb ip, [r1]
    0xe001b39c    0x18    sub r0, lr, ip
    0xe001b3a0    0x1c    subs ip, lr, ip
    0xe001b3a4    0x20    movne ip, #1
    0xe001b3a8    0x24    cmp lr, #0
    0xe001b3ac    0x28    moveq ip, #1
    0xe001b3b0    0x2c    cmp ip, #0
    0xe001b3b4    0x30    popne {pc}            ; stack access
    0xe001b3b8    0x34    mov lr, r3
    0xe001b3bc    0x38    sub r3, r3, #1
    0xe001b3c0    0x3c    add r2, r3, r2
    0xe001b3c4    0x40    cmp lr, r2
    0xe001b3c8    0x44    beq e001b3f4 <strncmp+0x70>
    0xe001b3cc    0x48    ldrb ip, [lr, #1]!
    0xe001b3d0    0x4c    ldrb r3, [r1, #1]!
    0xe001b3d4    0x50    sub r0, ip, r3
    0xe001b3d8    0x54    subs r3, ip, r3
    0xe001b3dc    0x58    movne r3, #1
    0xe001b3e0    0x5c    cmp ip, #0
    0xe001b3e4    0x60    moveq r3, #1
    0xe001b3e8    0x64    cmp r3, #0
    0xe001b3ec    0x68    beq e001b3c4 <strncmp+0x40>
    0xe001b3f0    0x6c    pop {pc}              ; stack access
    0xe001b3f4    0x70    mov r0, #0
    0xe001b3f8    0x74    pop {pc}              ; stack access
    0xe001b3fc    0x78    mov r0, #0
    0xe001b400    0x7c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strncmp` has 57 nodes.

Section memcpy (11 of 293)
==========================

Deriving specifications
-----------------------

Section `memcpy` consists of 10 instructions.
 BXEQ..++
 STRB (imm,post).+
 BNE..++


Stack analysis
---------------

No stack accesses found. Code for `memcpy`:

    0xe001b35c     0x0    cmp r2, #0
    0xe001b360     0x4    bxeq lr
    0xe001b364     0x8    sub r1, r1, #1
    0xe001b368     0xc    add r2, r0, r2
    0xe001b36c    0x10    mov r3, r0
    0xe001b370    0x14    ldrb ip, [r1, #1]!
    0xe001b374    0x18    strb ip, [r3], #1
    0xe001b378    0x1c    cmp r3, r2
    0xe001b37c    0x20    bne e001b370 <memcpy+0x14>
    0xe001b380    0x24    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memcpy` has 18 nodes.

Section memzero (12 of 293)
===========================

Deriving specifications
-----------------------

Section `memzero` consists of 7 instructions.
 STR (imm,post)..+
 SUBS (imm)...++


Stack analysis
---------------

No stack accesses found. Code for `memzero`:

    0xe0019244     0x0    cmp r1, #0
    0xe0019248     0x4    bxeq lr
    0xe001924c     0x8    mov r3, #0
    0xe0019250     0xc    str r3, [r0], #4
    0xe0019254    0x10    subs r1, r1, #4
    0xe0019258    0x14    bne e0019250 <memzero+0xc>
    0xe001925c    0x18    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memzero` has 14 nodes.

Section strlcat (13 of 293)
===========================

Deriving specifications
-----------------------

Section `strlcat` consists of 41 instructions.
 STMDB (wb);14,4..+
 ADD (imm)...++
 B.+
 STRB (+imm,pre,wb).+
 STRB (+reg,pre).....+++++
 LDMIA (wb);15,4.+


Stack analysis
---------------

2 stack accesses found. Annotated code for `strlcat`:

    0xe00191a0     0x0    cmp r2, #0
    0xe00191a4     0x4    beq e001923c <strlcat+0x9c>
    0xe00191a8     0x8    push {r4, lr}         ; stack access
    0xe00191ac     0xc    ldrb r3, [r0]
    0xe00191b0    0x10    cmp r3, #0
    0xe00191b4    0x14    beq e0019204 <strlcat+0x64>
    0xe00191b8    0x18    mov ip, r0
    0xe00191bc    0x1c    mov r3, #0
    0xe00191c0    0x20    add r3, r3, #1
    0xe00191c4    0x24    cmp r2, r3
    0xe00191c8    0x28    beq e0019234 <strlcat+0x94>
    0xe00191cc    0x2c    ldrb lr, [ip, #1]!
    0xe00191d0    0x30    cmp lr, #0
    0xe00191d4    0x34    bne e00191c0 <strlcat+0x20>
    0xe00191d8    0x38    add r4, r3, #1
    0xe00191dc    0x3c    cmp r2, r4
    0xe00191e0    0x40    bls e001922c <strlcat+0x8c>
    0xe00191e4    0x44    ldrb ip, [r1]
    0xe00191e8    0x48    cmp ip, #0
    0xe00191ec    0x4c    beq e001922c <strlcat+0x8c>
    0xe00191f0    0x50    sub r3, r3, #1
    0xe00191f4    0x54    add lr, r0, r3
    0xe00191f8    0x58    sub r2, r2, #1
    0xe00191fc    0x5c    mov r3, r4
    0xe0019200    0x60    b e0019210 <strlcat+0x70>
    0xe0019204    0x64    mov r3, #0
    0xe0019208    0x68    b e00191d8 <strlcat+0x38>
    0xe001920c    0x6c    mov r3, r4
    0xe0019210    0x70    strb ip, [lr, #1]!
    0xe0019214    0x74    cmp r3, r2
    0xe0019218    0x78    beq e001922c <strlcat+0x8c>
    0xe001921c    0x7c    ldrb ip, [r1, #1]!
    0xe0019220    0x80    add r4, r3, #1
    0xe0019224    0x84    cmp ip, #0
    0xe0019228    0x88    bne e001920c <strlcat+0x6c>
    0xe001922c    0x8c    mov r2, #0
    0xe0019230    0x90    strb r2, [r0, r3]
    0xe0019234    0x94    mov r0, r3
    0xe0019238    0x98    pop {r4, pc}          ; stack access
    0xe001923c    0x9c    mov r0, r2
    0xe0019240    0xa0    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
41 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strlcat` has 66 nodes.

Section strlcpy (14 of 293)
===========================

Deriving specifications
-----------------------

Section `strlcpy` consists of 29 instructions.
 LDRB (imm,post).+


Stack analysis
---------------

2 stack accesses found. Annotated code for `strlcpy`:

    0xe001912c     0x0    cmp r2, #1
    0xe0019130     0x4    bls e0019184 <strlcpy+0x58>
    0xe0019134     0x8    ldrb ip, [r1]
    0xe0019138     0xc    cmp ip, #0
    0xe001913c    0x10    beq e0019198 <strlcpy+0x6c>
    0xe0019140    0x14    push {r4, lr}         ; stack access
    0xe0019144    0x18    sub lr, r0, #1
    0xe0019148    0x1c    add r3, r1, #1
    0xe001914c    0x20    mov r4, r1
    0xe0019150    0x24    add r2, r1, r2
    0xe0019154    0x28    sub r2, r2, #1
    0xe0019158    0x2c    sub r1, r3, r4
    0xe001915c    0x30    strb ip, [lr, #1]!
    0xe0019160    0x34    cmp r3, r2
    0xe0019164    0x38    beq e0019174 <strlcpy+0x48>
    0xe0019168    0x3c    ldrb ip, [r3], #1
    0xe001916c    0x40    cmp ip, #0
    0xe0019170    0x44    bne e0019158 <strlcpy+0x2c>
    0xe0019174    0x48    mov r3, #0
    0xe0019178    0x4c    strb r3, [r0, r1]
    0xe001917c    0x50    mov r0, r1
    0xe0019180    0x54    pop {r4, pc}          ; stack access
    0xe0019184    0x58    mov r1, #0
    0xe0019188    0x5c    mov r3, #0
    0xe001918c    0x60    strb r3, [r0, r1]
    0xe0019190    0x64    mov r0, r1
    0xe0019194    0x68    bx lr
    0xe0019198    0x6c    mov r1, #0
    0xe001919c    0x70    b e0019188 <strlcpy+0x5c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
29 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strlcpy` has 45 nodes.

Section strnlen (15 of 293)
===========================

Deriving specifications
-----------------------

Section `strnlen` consists of 18 instructions.


Stack analysis
---------------

No stack accesses found. Code for `strnlen`:

    0xe00190e4     0x0    cmp r1, #0
    0xe00190e8     0x4    beq e001911c <strnlen+0x38>
    0xe00190ec     0x8    ldrb r3, [r0]
    0xe00190f0     0xc    cmp r3, #0
    0xe00190f4    0x10    beq e0019124 <strnlen+0x40>
    0xe00190f8    0x14    mov r3, r0
    0xe00190fc    0x18    mov r0, #0
    0xe0019100    0x1c    add r0, r0, #1
    0xe0019104    0x20    cmp r1, r0
    0xe0019108    0x24    bxeq lr
    0xe001910c    0x28    ldrb r2, [r3, #1]!
    0xe0019110    0x2c    cmp r2, #0
    0xe0019114    0x30    bne e0019100 <strnlen+0x1c>
    0xe0019118    0x34    bx lr
    0xe001911c    0x38    mov r0, r1
    0xe0019120    0x3c    bx lr
    0xe0019124    0x40    mov r0, #0
    0xe0019128    0x44    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strnlen` has 32 nodes.

Section copyMRs (16 of 293)
===========================

Deriving specifications
-----------------------

Section `copyMRs` consists of 37 instructions.
 STMDB (wb);14,6,5,4..+
 LDR (+imm,pre)..++
 LDMIAEQ (wb);15,6,5,4..++
 LDR (+imm,pre) LDR (+lit).+
 LDR (+reg,pre).....+++++
 STR (+reg,pre).......+++++
 MOVLS (imm)..++
 MOVHI (imm)..++
 CMPNE (imm)...++
 LDR (+imm,pre,wb).+
 STR (+imm,pre,wb)..+
 LDMIA (wb);15,6,5,4.+


Stack analysis
---------------

6 stack accesses found. Annotated code for `copyMRs`:

    0xe0016c2c     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0016c30     0x4    mov r6, r0
    0xe0016c34     0x8    ldr r0, [sp, #16]     ; stack access
    0xe0016c38     0xc    cmp r0, #0
    0xe0016c3c    0x10    popeq {r4, r5, r6, pc}  ; stack access
    0xe0016c40    0x14    ldr r4, [pc, #116] 
    0xe0016c44    0x18    mov ip, #0
    0xe0016c48    0x1c    ldr lr, [r4], #4
    0xe0016c4c    0x20    ldr r5, [r6, lr, lsl #2]
    0xe0016c50    0x24    str r5, [r2, lr, lsl #2]
    0xe0016c54    0x28    add ip, ip, #1
    0xe0016c58    0x2c    cmp r0, ip
    0xe0016c5c    0x30    movls lr, #0
    0xe0016c60    0x34    movhi lr, #1
    0xe0016c64    0x38    cmp ip, #3
    0xe0016c68    0x3c    movhi lr, #0
    0xe0016c6c    0x40    cmp lr, #0
    0xe0016c70    0x44    bne e0016c48 <copyMRs+0x1c>
    0xe0016c74    0x48    cmp r1, #0
    0xe0016c78    0x4c    cmpne r3, #0
    0xe0016c7c    0x50    beq e0016cac <copyMRs+0x80>
    0xe0016c80    0x54    cmp r0, ip
    0xe0016c84    0x58    bls e0016cb4 <copyMRs+0x88>
    0xe0016c88    0x5c    lsl ip, ip, #2
    0xe0016c8c    0x60    add r2, r1, ip
    0xe0016c90    0x64    add ip, r3, ip
    0xe0016c94    0x68    add r1, r1, r0, lsl #2
    0xe0016c98    0x6c    ldr r3, [r2, #4]!
    0xe0016c9c    0x70    str r3, [ip, #4]!
    0xe0016ca0    0x74    cmp r2, r1
    0xe0016ca4    0x78    bne e0016c98 <copyMRs+0x6c>
    0xe0016ca8    0x7c    pop {r4, r5, r6, pc}  ; stack access
    0xe0016cac    0x80    mov r0, ip
    0xe0016cb0    0x84    pop {r4, r5, r6, pc}  ; stack access
    0xe0016cb4    0x88    mov r0, ip
    0xe0016cb8    0x8c    pop {r4, r5, r6, pc}  ; stack access
    0xe0016cbc    0x90    .word 0xe001b52c

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
36 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `copyMRs` has 65 nodes.

Section setExtraBadge (17 of 293)
=================================

Deriving specifications
-----------------------

Section `setExtraBadge` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setExtraBadge`:

    0xe0016ae8    0x0    add r2, r2, #122 
    0xe0016aec    0x4    str r1, [r0, r2, lsl #2]
    0xe0016af0    0x8    bx lr

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setExtraBadge` has 5 nodes.

Section getExtraCPtr (18 of 293)
================================

Deriving specifications
-----------------------

Section `getExtraCPtr` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `getExtraCPtr`:

    0xe0016adc    0x0    add r1, r1, #122 
    0xe0016ae0    0x4    ldr r0, [r0, r1, lsl #2]
    0xe0016ae4    0x8    bx lr

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getExtraCPtr` has 5 nodes.

Section tcbEPDequeue (19 of 293)
================================

Deriving specifications
-----------------------

Section `tcbEPDequeue` consists of 20 instructions.
 STMDB;3,2...+
 LDRNE (+imm,pre)...+++
 STRNE (+imm,pre)....+++
 LDREQ (+imm,pre)...+++
 STR (+imm,pre)...++


Stack analysis
---------------

Section `tcbEPDequeue` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `tcbEPDequeue`:

    0xe0015538     0x0    push {lr}             ; stack access
    0xe001553c     0x4    sub sp, sp, #12
    0xe0015540     0x8    add ip, sp, #8
    0xe0015544     0xc    stmdb ip, {r2, r3}    ; stack access
    0xe0015548    0x10    ldr r2, [sp, #4]      ; stack access
    0xe001554c    0x14    ldr r3, [r1, #148] 
    0xe0015550    0x18    cmp r3, #0
    0xe0015554    0x1c    ldrne ip, [sp]        ; stack access
    0xe0015558    0x20    ldrne lr, [r1, #144] 
    0xe001555c    0x24    strne lr, [r3, #144] 
    0xe0015560    0x28    ldreq ip, [r1, #144] 
    0xe0015564    0x2c    ldr r3, [r1, #144] 
    0xe0015568    0x30    cmp r3, #0
    0xe001556c    0x34    ldrne r1, [r1, #148] 
    0xe0015570    0x38    strne r1, [r3, #148] 
    0xe0015574    0x3c    ldreq r2, [r1, #148] 
    0xe0015578    0x40    str ip, [r0]          ; stack access
    0xe001557c    0x44    str r2, [r0, #4]      ; stack access
    0xe0015580    0x48    add sp, sp, #12
    0xe0015584    0x4c    pop {pc}              ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbEPDequeue` has 49 nodes.

Section tcbEPAppend (20 of 293)
===============================

Deriving specifications
-----------------------

Section `tcbEPAppend` consists of 15 instructions.
 MOVEQ (reg)....+++


Stack analysis
---------------

Section `tcbEPAppend` expects pointer to stack in r0.
5 stack accesses found. Annotated code for `tcbEPAppend`:

    0xe00154fc     0x0    sub sp, sp, #8
    0xe0015500     0x4    add ip, sp, #8
    0xe0015504     0x8    stmdb ip, {r2, r3}    ; stack access
    0xe0015508     0xc    ldr r3, [sp]          ; stack access
    0xe001550c    0x10    ldr r2, [sp, #4]      ; stack access
    0xe0015510    0x14    cmp r3, #0
    0xe0015514    0x18    strne r1, [r2, #144] 
    0xe0015518    0x1c    moveq r3, r1
    0xe001551c    0x20    str r2, [r1, #148] 
    0xe0015520    0x24    mov r2, #0
    0xe0015524    0x28    str r2, [r1, #144] 
    0xe0015528    0x2c    str r3, [r0]          ; stack access
    0xe001552c    0x30    str r1, [r0, #4]      ; stack access
    0xe0015530    0x34    add sp, sp, #8
    0xe0015534    0x38    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbEPAppend` has 28 nodes.

Section tcbSchedDequeue (21 of 293)
===================================

Deriving specifications
-----------------------

Section `tcbSchedDequeue` consists of 54 instructions.
 TST (imm)..+
 STMDB (wb);14,10,9,8,7,6,5,4..+
 MOVW.+
 MOVT.+
 BIC (imm)...++
 LDMIA (wb);15,10,9,8,7,6,5,4.+
 RSB (imm)...++
 AND (imm)...++
 BIC (reg-shift)...............+++++++++++++++


Stack analysis
---------------

2 stack accesses found. Annotated code for `tcbSchedDequeue`:

    0xe00150f4     0x0    ldr r3, [r0, #84] 
    0xe00150f8     0x4    tst r3, #1
    0xe00150fc     0x8    bxeq lr
    0xe0015100     0xc    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0015104    0x10    ldr r5, [r0, #112] 
    0xe0015108    0x14    ldr r1, [r0, #120] 
    0xe001510c    0x18    add r2, r1, r5, lsl #8
    0xe0015110    0x1c    movw r3, #38092 
    0xe0015114    0x20    movt r3, #57346 
    0xe0015118    0x24    add ip, r3, r2, lsl #3
    0xe001511c    0x28    ldr r6, [ip, #4]
    0xe0015120    0x2c    ldr lr, [r0, #140] 
    0xe0015124    0x30    cmp lr, #0
    0xe0015128    0x34    beq e0015164 <tcbSchedDequeue+0x70>
    0xe001512c    0x38    ldr r4, [r3, r2, lsl #3]
    0xe0015130    0x3c    ldr r1, [r0, #136] 
    0xe0015134    0x40    str r1, [lr, #136] 
    0xe0015138    0x44    ldr r1, [r0, #136] 
    0xe001513c    0x48    cmp r1, #0
    0xe0015140    0x4c    beq e00151c4 <tcbSchedDequeue+0xd0>
    0xe0015144    0x50    ldr lr, [r0, #140] 
    0xe0015148    0x54    str lr, [r1, #140] 
    0xe001514c    0x58    str r4, [r3, r2, lsl #3]
    0xe0015150    0x5c    str r6, [ip, #4]
    0xe0015154    0x60    ldr r3, [r0, #84] 
    0xe0015158    0x64    bic r3, r3, #1
    0xe001515c    0x68    str r3, [r0, #84] 
    0xe0015160    0x6c    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe0015164    0x70    ldr r4, [r0, #136] 
    0xe0015168    0x74    cmp r4, #0
    0xe001516c    0x78    bne e00151bc <tcbSchedDequeue+0xc8>
    0xe0015170    0x7c    lsr r9, r1, #5
    0xe0015174    0x80    rsb r8, r9, #7
    0xe0015178    0x84    and r1, r1, #31
    0xe001517c    0x88    movw r7, #12292 
    0xe0015180    0x8c    movt r7, #57347 
    0xe0015184    0x90    add r8, r8, r5, lsl #3
    0xe0015188    0x94    ldr lr, [r7, r8, lsl #2]
    0xe001518c    0x98    mov sl, #1
    0xe0015190    0x9c    bic r1, lr, sl, lsl r1
    0xe0015194    0xa0    str r1, [r7, r8, lsl #2]
    0xe0015198    0xa4    cmp r1, #0
    0xe001519c    0xa8    bne e0015138 <tcbSchedDequeue+0x44>
    0xe00151a0    0xac    movw r1, #12808 
    0xe00151a4    0xb0    movt r1, #57347 
    0xe00151a8    0xb4    ldr lr, [r1, r5, lsl #2]
    0xe00151ac    0xb8    mov r7, sl
    0xe00151b0    0xbc    bic r9, lr, sl, lsl r9
    0xe00151b4    0xc0    str r9, [r1, r5, lsl #2]
    0xe00151b8    0xc4    b e0015138 <tcbSchedDequeue+0x44>
    0xe00151bc    0xc8    mov r1, r4
    0xe00151c0    0xcc    b e0015144 <tcbSchedDequeue+0x50>
    0xe00151c4    0xd0    ldr r6, [r0, #140] 
    0xe00151c8    0xd4    b e001514c <tcbSchedDequeue+0x58>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
54 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedDequeue` has 88 nodes.

Section tcbSchedAppend (22 of 293)
==================================

Deriving specifications
-----------------------

Section `tcbSchedAppend` consists of 41 instructions.
 BXNE..++
 STMDB (wb);14,9,8,7,6,5,4..+
 ORR (imm)...++
 LDMIA (wb);15,9,8,7,6,5,4.+
 ORR (reg-shift)...............+++++++++++++++


Stack analysis
---------------

2 stack accesses found. Annotated code for `tcbSchedAppend`:

    0xe0014fe4     0x0    ldr r3, [r0, #84] 
    0xe0014fe8     0x4    tst r3, #1
    0xe0014fec     0x8    bxne lr
    0xe0014ff0     0xc    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe0014ff4    0x10    ldr r4, [r0, #112] 
    0xe0014ff8    0x14    ldr ip, [r0, #120] 
    0xe0014ffc    0x18    add r2, ip, r4, lsl #8
    0xe0015000    0x1c    movw r3, #38092 
    0xe0015004    0x20    movt r3, #57346 
    0xe0015008    0x24    add lr, r3, r2, lsl #3
    0xe001500c    0x28    ldr r1, [r3, r2, lsl #3]
    0xe0015010    0x2c    ldr r5, [lr, #4]
    0xe0015014    0x30    cmp r1, #0
    0xe0015018    0x34    strne r0, [r5, #136] 
    0xe001501c    0x38    beq e0015044 <tcbSchedAppend+0x60>
    0xe0015020    0x3c    str r5, [r0, #140] 
    0xe0015024    0x40    mov ip, #0
    0xe0015028    0x44    str ip, [r0, #136] 
    0xe001502c    0x48    str r1, [r3, r2, lsl #3]
    0xe0015030    0x4c    str r0, [lr, #4]
    0xe0015034    0x50    ldr r3, [r0, #84] 
    0xe0015038    0x54    orr r3, r3, #1
    0xe001503c    0x58    str r3, [r0, #84] 
    0xe0015040    0x5c    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0015044    0x60    lsr r9, ip, #5
    0xe0015048    0x64    rsb r6, r9, #7
    0xe001504c    0x68    movw r1, #12808 
    0xe0015050    0x6c    movt r1, #57347 
    0xe0015054    0x70    mov r7, #1
    0xe0015058    0x74    ldr r8, [r1, r4, lsl #2]
    0xe001505c    0x78    orr r8, r8, r7, lsl r9
    0xe0015060    0x7c    str r8, [r1, r4, lsl #2]
    0xe0015064    0x80    movw r1, #12292 
    0xe0015068    0x84    movt r1, #57347 
    0xe001506c    0x88    add r4, r6, r4, lsl #3
    0xe0015070    0x8c    and ip, ip, #31
    0xe0015074    0x90    ldr r6, [r1, r4, lsl #2]
    0xe0015078    0x94    orr ip, r6, r7, lsl ip
    0xe001507c    0x98    str ip, [r1, r4, lsl #2]
    0xe0015080    0x9c    mov r1, r0
    0xe0015084    0xa0    b e0015020 <tcbSchedAppend+0x3c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
41 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedAppend` has 66 nodes.

Section tcbSchedEnqueue (23 of 293)
===================================

Deriving specifications
-----------------------

Section `tcbSchedEnqueue` consists of 41 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `tcbSchedEnqueue`:

    0xe00149a8     0x0    ldr r3, [r0, #84] 
    0xe00149ac     0x4    tst r3, #1
    0xe00149b0     0x8    bxne lr
    0xe00149b4     0xc    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe00149b8    0x10    ldr r4, [r0, #112] 
    0xe00149bc    0x14    ldr ip, [r0, #120] 
    0xe00149c0    0x18    add r2, ip, r4, lsl #8
    0xe00149c4    0x1c    movw r3, #38092 
    0xe00149c8    0x20    movt r3, #57346 
    0xe00149cc    0x24    add lr, r3, r2, lsl #3
    0xe00149d0    0x28    ldr r5, [r3, r2, lsl #3]
    0xe00149d4    0x2c    ldr r1, [lr, #4]
    0xe00149d8    0x30    cmp r1, #0
    0xe00149dc    0x34    strne r0, [r5, #140] 
    0xe00149e0    0x38    beq e0014a08 <tcbSchedEnqueue+0x60>
    0xe00149e4    0x3c    mov ip, #0
    0xe00149e8    0x40    str ip, [r0, #140] 
    0xe00149ec    0x44    str r5, [r0, #136] 
    0xe00149f0    0x48    str r0, [r3, r2, lsl #3]
    0xe00149f4    0x4c    str r1, [lr, #4]
    0xe00149f8    0x50    ldr r3, [r0, #84] 
    0xe00149fc    0x54    orr r3, r3, #1
    0xe0014a00    0x58    str r3, [r0, #84] 
    0xe0014a04    0x5c    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0014a08    0x60    lsr r9, ip, #5
    0xe0014a0c    0x64    rsb r6, r9, #7
    0xe0014a10    0x68    movw r1, #12808 
    0xe0014a14    0x6c    movt r1, #57347 
    0xe0014a18    0x70    mov r7, #1
    0xe0014a1c    0x74    ldr r8, [r1, r4, lsl #2]
    0xe0014a20    0x78    orr r8, r8, r7, lsl r9
    0xe0014a24    0x7c    str r8, [r1, r4, lsl #2]
    0xe0014a28    0x80    movw r1, #12292 
    0xe0014a2c    0x84    movt r1, #57347 
    0xe0014a30    0x88    add r4, r6, r4, lsl #3
    0xe0014a34    0x8c    and ip, ip, #31
    0xe0014a38    0x90    ldr r6, [r1, r4, lsl #2]
    0xe0014a3c    0x94    orr ip, r6, r7, lsl ip
    0xe0014a40    0x98    str ip, [r1, r4, lsl #2]
    0xe0014a44    0x9c    mov r1, r0
    0xe0014a48    0xa0    b e00149e4 <tcbSchedEnqueue+0x3c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
41 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedEnqueue` has 66 nodes.

Section updateCapData (24 of 293)
=================================

Deriving specifications
-----------------------

Section `updateCapData` consists of 68 instructions.
 ANDNE (imm)....+++
 SXT{A}B,UXT{A}BEQ........++++++++
 MOVS (reg)...++
 ORR (reg)..........+++++
 SBFX,UBFX..++
 STRHI (+imm,pre)....+++
 BHI..++
 MVN (imm).+
 AND (reg)..........+++++


Stack analysis
---------------

Section `updateCapData` expects pointer to stack in r0.
20 stack accesses found. Annotated code for `updateCapData`:

    0xe0014500      0x0    sub sp, sp, #8
    0xe0014504      0x4    push {lr}             ; stack access
    0xe0014508      0x8    str r3, [sp, #8]      ; stack access
    0xe001450c      0xc    ldr lr, [sp, #12]     ; stack access
    0xe0014510     0x10    and ip, r3, #14
    0xe0014514     0x14    cmp ip, #14
    0xe0014518     0x18    andne ip, r3, #15
    0xe001451c     0x1c    uxtbeq ip, r3
    0xe0014520     0x20    tst ip, #1
    0xe0014524     0x24    strne r3, [r0]        ; stack access
    0xe0014528     0x28    strne lr, [r0, #4]    ; stack access
    0xe001452c     0x2c    bne e0014550 <updateCapData+0x50>
    0xe0014530     0x30    cmp ip, #6
    0xe0014534     0x34    beq e0014590 <updateCapData+0x90>
    0xe0014538     0x38    cmp ip, #10
    0xe001453c     0x3c    beq e00145c4 <updateCapData+0xc4>
    0xe0014540     0x40    cmp ip, #4
    0xe0014544     0x44    strne r3, [r0]        ; stack access
    0xe0014548     0x48    strne lr, [r0, #4]    ; stack access
    0xe001454c     0x4c    beq e001455c <updateCapData+0x5c>
    0xe0014550     0x50    pop {lr}              ; stack access
    0xe0014554     0x54    add sp, sp, #8
    0xe0014558     0x58    bx lr
    0xe001455c     0x5c    cmp r1, #0
    0xe0014560     0x60    bne e0014580 <updateCapData+0x80>
    0xe0014564     0x64    lsrs r1, r3, #4
    0xe0014568     0x68    bne e0014580 <updateCapData+0x80>
    0xe001456c     0x6c    and r3, r3, #15
    0xe0014570     0x70    orr r2, r3, r2, lsl #4
    0xe0014574     0x74    str r2, [r0]          ; stack access
    0xe0014578     0x78    str lr, [r0, #4]      ; stack access
    0xe001457c     0x7c    b e0014550 <updateCapData+0x50>
    0xe0014580     0x80    mov r3, #0
    0xe0014584     0x84    str r3, [r0]          ; stack access
    0xe0014588     0x88    str r3, [r0, #4]      ; stack access
    0xe001458c     0x8c    b e0014550 <updateCapData+0x50>
    0xe0014590     0x90    cmp r1, #0
    0xe0014594     0x94    bne e00145b4 <updateCapData+0xb4>
    0xe0014598     0x98    lsrs r1, lr, #4
    0xe001459c     0x9c    bne e00145b4 <updateCapData+0xb4>
    0xe00145a0     0xa0    str r3, [r0]          ; stack access
    0xe00145a4     0xa4    and lr, lr, #15
    0xe00145a8     0xa8    orr r2, lr, r2, lsl #4
    0xe00145ac     0xac    str r2, [r0, #4]      ; stack access
    0xe00145b0     0xb0    b e0014550 <updateCapData+0x50>
    0xe00145b4     0xb4    mov r3, #0
    0xe00145b8     0xb8    str r3, [r0]          ; stack access
    0xe00145bc     0xbc    str r3, [r0, #4]      ; stack access
    0xe00145c0     0xc0    b e0014550 <updateCapData+0x50>
    0xe00145c4     0xc4    ubfx ip, r2, #3, #5
    0xe00145c8     0xc8    ubfx r1, lr, #18, #5
    0xe00145cc     0xcc    add r1, r1, ip
    0xe00145d0     0xd0    cmp r1, #32
    0xe00145d4     0xd4    movhi r3, #0
    0xe00145d8     0xd8    strhi r3, [r0]        ; stack access
    0xe00145dc     0xdc    strhi r3, [r0, #4]    ; stack access
    0xe00145e0     0xe0    bhi e0014550 <updateCapData+0x50>
    0xe00145e4     0xe4    str r3, [r0]          ; stack access
    0xe00145e8     0xe8    ubfx r2, r2, #8, #18
    0xe00145ec     0xec    mvn r3, #0
    0xe00145f0     0xf0    bic r2, r2, r3, lsl ip
    0xe00145f4     0xf4    mov r3, #0
    0xe00145f8     0xf8    movt r3, #61564 
    0xe00145fc     0xfc    and r3, r3, lr
    0xe0014600    0x100    orr r2, r3, r2
    0xe0014604    0x104    orr r2, r2, ip, lsl #23
    0xe0014608    0x108    str r2, [r0, #4]      ; stack access
    0xe001460c    0x10c    b e0014550 <updateCapData+0x50>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
68 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `updateCapData` has 125 nodes.

Section hasCancelSendRights (25 of 293)
=======================================

Deriving specifications
-----------------------

Section `hasCancelSendRights` consists of 23 instructions.
 STMDB;1,0...+


Stack analysis
---------------

3 stack accesses found. Annotated code for `hasCancelSendRights`:

    0xe0013890     0x0    sub sp, sp, #8
    0xe0013894     0x4    add r3, sp, #8
    0xe0013898     0x8    stmdb r3, {r0, r1}    ; stack access
    0xe001389c     0xc    ldr r3, [sp]          ; stack access
    0xe00138a0    0x10    and r2, r3, #14
    0xe00138a4    0x14    cmp r2, #14
    0xe00138a8    0x18    andne r3, r3, #15
    0xe00138ac    0x1c    uxtbeq r3, r3
    0xe00138b0    0x20    cmp r3, #4
    0xe00138b4    0x24    movne r0, #0
    0xe00138b8    0x28    bne e00138d0 <hasCancelSendRights+0x40>
    0xe00138bc    0x2c    ldr r0, [sp, #4]      ; stack access
    0xe00138c0    0x30    and r3, r0, #3
    0xe00138c4    0x34    cmp r3, #3
    0xe00138c8    0x38    movne r0, #0
    0xe00138cc    0x3c    beq e00138d8 <hasCancelSendRights+0x48>
    0xe00138d0    0x40    add sp, sp, #8
    0xe00138d4    0x44    bx lr
    0xe00138d8    0x48    and r0, r0, #12
    0xe00138dc    0x4c    cmp r0, #12
    0xe00138e0    0x50    movne r0, #0
    0xe00138e4    0x54    moveq r0, #1
    0xe00138e8    0x58    b e00138d0 <hasCancelSendRights+0x40>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `hasCancelSendRights` has 43 nodes.

Section bindNotification (26 of 293)
====================================

Deriving specifications
-----------------------

Section `bindNotification` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `bindNotification`:

    0xe001381c     0x0    ldr r3, [r1, #12]
    0xe0013820     0x4    and r3, r3, #15
    0xe0013824     0x8    bic r2, r0, #15
    0xe0013828     0xc    orr r3, r3, r2
    0xe001382c    0x10    str r3, [r1, #12]
    0xe0013830    0x14    str r1, [r0, #92] 
    0xe0013834    0x18    bx lr

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `bindNotification` has 11 nodes.

Section unbindNotification (27 of 293)
======================================

Deriving specifications
-----------------------

Section `unbindNotification` consists of 8 instructions.


Stack analysis
---------------

No stack accesses found. Code for `unbindNotification`:

    0xe00137fc     0x0    ldr r3, [r0, #92] 
    0xe0013800     0x4    cmp r3, #0
    0xe0013804     0x8    ldrne r2, [r3, #12]
    0xe0013808     0xc    andne r2, r2, #15
    0xe001380c    0x10    strne r2, [r3, #12]
    0xe0013810    0x14    movne r3, #0
    0xe0013814    0x18    strne r3, [r0, #92] 
    0xe0013818    0x1c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unbindNotification` has 23 nodes.

Section unbindMaybeNotification (28 of 293)
===========================================

Deriving specifications
-----------------------

Section `unbindMaybeNotification` consists of 7 instructions.
 BICS (imm)...++


Stack analysis
---------------

No stack accesses found. Code for `unbindMaybeNotification`:

    0xe00137e0     0x0    ldr r3, [r0, #12]
    0xe00137e4     0x4    bics r2, r3, #15
    0xe00137e8     0x8    andne r3, r3, #15
    0xe00137ec     0xc    strne r3, [r0, #12]
    0xe00137f0    0x10    movne r3, #0
    0xe00137f4    0x14    strne r3, [r2, #92] 
    0xe00137f8    0x18    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unbindMaybeNotification` has 19 nodes.

Section setIRQState (29 of 293)
===============================

Deriving specifications
-----------------------

Section `setIRQState` consists of 15 instructions.
 MOV (reg-shift).....+++++
 MOVWEQ..++
 MOVWNE..++
 STR (-imm,pre)...++


Stack analysis
---------------

No stack accesses found. Code for `setIRQState`:

    0xe0013648     0x0    movw r3, #36936 
    0xe001364c     0x4    movt r3, #57346 
    0xe0013650     0x8    str r0, [r3, r1, lsl #2]
    0xe0013654     0xc    cmp r0, #0
    0xe0013658    0x10    lsr r2, r1, #5
    0xe001365c    0x14    and r1, r1, #31
    0xe0013660    0x18    mov r3, #1
    0xe0013664    0x1c    lsl r1, r3, r1
    0xe0013668    0x20    lsl r2, r2, #2
    0xe001366c    0x24    movweq r3, #4735 
    0xe0013670    0x28    movwne r3, #4607 
    0xe0013674    0x2c    movt r3, #65520 
    0xe0013678    0x30    add r3, r2, r3
    0xe001367c    0x34    str r1, [r3, #-255] 
    0xe0013680    0x38    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setIRQState` has 22 nodes.

Section isIRQActive (30 of 293)
===============================

Deriving specifications
-----------------------

Section `isIRQActive` consists of 6 instructions.
 ADDS (imm)...++


Stack analysis
---------------

No stack accesses found. Code for `isIRQActive`:

    0xe0013630     0x0    movw r3, #36936 
    0xe0013634     0x4    movt r3, #57346 
    0xe0013638     0x8    ldr r0, [r3, r0, lsl #2]
    0xe001363c     0xc    adds r0, r0, #0
    0xe0013640    0x10    movne r0, #1
    0xe0013644    0x14    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isIRQActive` has 10 nodes.

Section invokeIRQHandler_AckIRQ (31 of 293)
===========================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_AckIRQ` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `invokeIRQHandler_AckIRQ`:

    0xe0013608     0x0    lsr r2, r0, #5
    0xe001360c     0x4    and r0, r0, #31
    0xe0013610     0x8    mov r3, #1
    0xe0013614     0xc    lsl r0, r3, r0
    0xe0013618    0x10    lsl r2, r2, #2
    0xe001361c    0x14    movw r3, #4607 
    0xe0013620    0x18    movt r3, #65520 
    0xe0013624    0x1c    add r3, r2, r3
    0xe0013628    0x20    str r0, [r3, #-255] 
    0xe001362c    0x24    bx lr

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_AckIRQ` has 12 nodes.

Section replyFromKernel_success_empty (32 of 293)
=================================================

Deriving specifications
-----------------------

Section `replyFromKernel_success_empty` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `replyFromKernel_success_empty`:

    0xe00135f8    0x0    mov r3, #0
    0xe00135fc    0x4    str r3, [r0]
    0xe0013600    0x8    str r3, [r0, #4]
    0xe0013604    0xc    bx lr

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `replyFromKernel_success_empty` has 7 nodes.

Section loadCapTransfer (33 of 293)
===================================

Deriving specifications
-----------------------

Section `loadCapTransfer` consists of 7 instructions.


Stack analysis
---------------

Section `loadCapTransfer` expects pointer to stack in r0.
3 stack accesses found. Annotated code for `loadCapTransfer`:

    0xe00135dc     0x0    ldr ip, [r1, #504] 
    0xe00135e0     0x4    ldr r2, [r1, #508] 
    0xe00135e4     0x8    ldr r1, [r1, #500] 
    0xe00135e8     0xc    str r1, [r0]          ; stack access
    0xe00135ec    0x10    str ip, [r0, #4]      ; stack access
    0xe00135f0    0x14    str r2, [r0, #8]      ; stack access
    0xe00135f4    0x18    bx lr

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `loadCapTransfer` has 14 nodes.

Section ensureEmptySlot (34 of 293)
===================================

Deriving specifications
-----------------------

Section `ensureEmptySlot` consists of 13 instructions.
 MOVTNE..++


Stack analysis
---------------

No stack accesses found. Code for `ensureEmptySlot`:

    0xe0013508     0x0    ldr r3, [r0]
    0xe001350c     0x4    and r2, r3, #14
    0xe0013510     0x8    cmp r2, #14
    0xe0013514     0xc    andne r3, r3, #15
    0xe0013518    0x10    uxtbeq r3, r3
    0xe001351c    0x14    cmp r3, #0
    0xe0013520    0x18    movwne r3, #36896 
    0xe0013524    0x1c    movtne r3, #57346 
    0xe0013528    0x20    movne r2, #8
    0xe001352c    0x24    strne r2, [r3, #24]
    0xe0013530    0x28    movne r0, #3
    0xe0013534    0x2c    moveq r0, #0
    0xe0013538    0x30    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `ensureEmptySlot` has 32 nodes.

Section setupReplyMaster (35 of 293)
====================================

Deriving specifications
-----------------------

Section `setupReplyMaster` consists of 19 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setupReplyMaster`:

    0xe00134bc     0x0    bic r3, r0, #508 
    0xe00134c0     0x4    bic r3, r3, #3
    0xe00134c4     0x8    add r1, r3, #32
    0xe00134c8     0xc    ldr r2, [r3, #32]
    0xe00134cc    0x10    and ip, r2, #14
    0xe00134d0    0x14    cmp ip, #14
    0xe00134d4    0x18    andne r2, r2, #15
    0xe00134d8    0x1c    uxtbeq r2, r2
    0xe00134dc    0x20    cmp r2, #0
    0xe00134e0    0x24    bxne lr
    0xe00134e4    0x28    bic r0, r0, #63 
    0xe00134e8    0x2c    orr r0, r0, #56 
    0xe00134ec    0x30    str r0, [r3, #32]
    0xe00134f0    0x34    mov r3, #0
    0xe00134f4    0x38    str r3, [r1, #4]
    0xe00134f8    0x3c    str r3, [r1, #8]
    0xe00134fc    0x40    mov r3, #3
    0xe0013500    0x44    str r3, [r1, #12]
    0xe0013504    0x48    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setupReplyMaster` has 32 nodes.

Section insertNewCap (36 of 293)
================================

Deriving specifications
-----------------------

Section `insertNewCap` consists of 27 instructions.
 STMIA;3,2...+
 LDMIA;1,0...++
 STMIA;3,0...+
 BICNE (imm)....+++
 ORRNE (reg)...........++++++


Stack analysis
---------------

4 stack accesses found. Annotated code for `insertNewCap`:

    0xe0013450     0x0    push {lr}             ; stack access
    0xe0013454     0x4    sub sp, sp, #12
    0xe0013458     0x8    mov lr, r0
    0xe001345c     0xc    mov ip, r1
    0xe0013460    0x10    mov r1, sp
    0xe0013464    0x14    stm r1, {r2, r3}      ; stack access
    0xe0013468    0x18    ldr r2, [r0, #12]
    0xe001346c    0x1c    bic r2, r2, #7
    0xe0013470    0x20    ldm r1, {r0, r1}      ; stack access
    0xe0013474    0x24    stm ip, {r0, r3}
    0xe0013478    0x28    bic r3, lr, #7
    0xe001347c    0x2c    str r3, [ip, #8]
    0xe0013480    0x30    orr r3, r2, #3
    0xe0013484    0x34    str r3, [ip, #12]
    0xe0013488    0x38    cmp r2, #0
    0xe001348c    0x3c    ldrne r3, [r2, #8]
    0xe0013490    0x40    andne r3, r3, #7
    0xe0013494    0x44    bicne r1, ip, #7
    0xe0013498    0x48    orrne r3, r3, r1
    0xe001349c    0x4c    strne r3, [r2, #8]
    0xe00134a0    0x50    ldr r3, [lr, #12]
    0xe00134a4    0x54    and r3, r3, #7
    0xe00134a8    0x58    bic ip, ip, #7
    0xe00134ac    0x5c    orr ip, r3, ip
    0xe00134b0    0x60    str ip, [lr, #12]
    0xe00134b4    0x64    add sp, sp, #12
    0xe00134b8    0x68    pop {pc}              ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `insertNewCap` has 49 nodes.

Section cteSwap (37 of 293)
===========================

Deriving specifications
-----------------------

Section `cteSwap` consists of 48 instructions.
 STMIA;1,0...+
 LDMIA (wb);14,4.+


Stack analysis
---------------

7 stack accesses found. Annotated code for `cteSwap`:

    0xe00132c4     0x0    sub sp, sp, #8
    0xe00132c8     0x4    push {r4, lr}         ; stack access
    0xe00132cc     0x8    sub sp, sp, #8
    0xe00132d0     0xc    mov ip, sp
    0xe00132d4    0x10    stm ip, {r0, r1}      ; stack access
    0xe00132d8    0x14    str r3, [sp, #20]     ; stack access
    0xe00132dc    0x18    ldr r3, [sp, #28]     ; stack access
    0xe00132e0    0x1c    add r1, sp, #20
    0xe00132e4    0x20    ldm r1, {r0, r1}      ; stack access
    0xe00132e8    0x24    stm r2, {r0, r1}
    0xe00132ec    0x28    ldm ip, {r0, r1}      ; stack access
    0xe00132f0    0x2c    stm r3, {r0, r1}
    0xe00132f4    0x30    ldr lr, [r2, #8]
    0xe00132f8    0x34    ldr ip, [r2, #12]
    0xe00132fc    0x38    bics r0, lr, #7
    0xe0013300    0x3c    ldrne r1, [r0, #12]
    0xe0013304    0x40    andne r1, r1, #7
    0xe0013308    0x44    bicne r4, r3, #7
    0xe001330c    0x48    orrne r1, r1, r4
    0xe0013310    0x4c    strne r1, [r0, #12]
    0xe0013314    0x50    bics r0, ip, #7
    0xe0013318    0x54    ldrne r1, [r0, #8]
    0xe001331c    0x58    andne r1, r1, #7
    0xe0013320    0x5c    bicne r4, r3, #7
    0xe0013324    0x60    orrne r1, r1, r4
    0xe0013328    0x64    strne r1, [r0, #8]
    0xe001332c    0x68    ldr r0, [r3, #8]
    0xe0013330    0x6c    ldr r1, [r3, #12]
    0xe0013334    0x70    str r0, [r2, #8]
    0xe0013338    0x74    str r1, [r2, #12]
    0xe001333c    0x78    str lr, [r3, #8]
    0xe0013340    0x7c    str ip, [r3, #12]
    0xe0013344    0x80    bics r0, r0, #7
    0xe0013348    0x84    ldrne r3, [r0, #12]
    0xe001334c    0x88    andne r3, r3, #7
    0xe0013350    0x8c    bicne ip, r2, #7
    0xe0013354    0x90    orrne r3, r3, ip
    0xe0013358    0x94    strne r3, [r0, #12]
    0xe001335c    0x98    bics r1, r1, #7
    0xe0013360    0x9c    ldrne r3, [r1, #8]
    0xe0013364    0xa0    andne r3, r3, #7
    0xe0013368    0xa4    bicne r2, r2, #7
    0xe001336c    0xa8    orrne r2, r3, r2
    0xe0013370    0xac    strne r2, [r1, #8]
    0xe0013374    0xb0    add sp, sp, #8
    0xe0013378    0xb4    pop {r4, lr}          ; stack access
    0xe001337c    0xb8    add sp, sp, #8
    0xe0013380    0xbc    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
48 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteSwap` has 114 nodes.

Section cteMove (38 of 293)
===========================

Deriving specifications
-----------------------

Section `cteMove` consists of 29 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `cteMove`:

    0xe00131b0     0x0    push {r4, lr}         ; stack access
    0xe00131b4     0x4    sub sp, sp, #8
    0xe00131b8     0x8    mov r4, sp
    0xe00131bc     0xc    stm r4, {r0, r1}      ; stack access
    0xe00131c0    0x10    ldr lr, [r2, #8]
    0xe00131c4    0x14    ldr ip, [r2, #12]
    0xe00131c8    0x18    ldm r4, {r0, r1}      ; stack access
    0xe00131cc    0x1c    stm r3, {r0, r1}
    0xe00131d0    0x20    mov r1, #0
    0xe00131d4    0x24    str r1, [r2]
    0xe00131d8    0x28    str r1, [r2, #4]
    0xe00131dc    0x2c    str lr, [r3, #8]
    0xe00131e0    0x30    str ip, [r3, #12]
    0xe00131e4    0x34    str r1, [r2, #8]
    0xe00131e8    0x38    str r1, [r2, #12]
    0xe00131ec    0x3c    bics lr, lr, #7
    0xe00131f0    0x40    ldrne r2, [lr, #12]
    0xe00131f4    0x44    andne r2, r2, #7
    0xe00131f8    0x48    bicne r1, r3, #7
    0xe00131fc    0x4c    orrne r2, r2, r1
    0xe0013200    0x50    strne r2, [lr, #12]
    0xe0013204    0x54    bics ip, ip, #7
    0xe0013208    0x58    ldrne r2, [ip, #8]
    0xe001320c    0x5c    andne r2, r2, #7
    0xe0013210    0x60    bicne r3, r3, #7
    0xe0013214    0x64    orrne r3, r2, r3
    0xe0013218    0x68    strne r3, [ip, #8]
    0xe001321c    0x6c    add sp, sp, #8
    0xe0013220    0x70    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
29 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteMove` has 66 nodes.

Section cteInsert (39 of 293)
=============================

Deriving specifications
-----------------------

Section `cteInsert` consists of 121 instructions.
 STMDB (wb);14,8,7,6,5,4..+
Switch found.
 LDRLS (+reg,pre)...... LDRLS (+reg,pre,pc)... LDRLS (pc,+reg,pre)... LDRLS (pc,+reg,pre,pc)..++++++++++++++
 LDMDB;1,0...++
 LDMIA (wb);15,8,7,6,5,4.+


Stack analysis
---------------

6 stack accesses found. Annotated code for `cteInsert`:

    0xe0012fa8      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0012fac      0x4    sub sp, sp, #8
    0xe0012fb0      0x8    add ip, sp, #8
    0xe0012fb4      0xc    stmdb ip, {r0, r1}    ; stack access
    0xe0012fb8     0x10    ldr lr, [r2, #8]
    0xe0012fbc     0x14    ldr ip, [r2, #12]
    0xe0012fc0     0x18    ldr r4, [r2]
    0xe0012fc4     0x1c    ldr r7, [r2, #4]
    0xe0012fc8     0x20    ldr r0, [sp]          ; stack access
    0xe0012fcc     0x24    ldr r6, [sp, #4]      ; stack access
    0xe0012fd0     0x28    and r5, r0, #14
    0xe0012fd4     0x2c    cmp r5, #14
    0xe0012fd8     0x30    andne r1, r0, #15
    0xe0012fdc     0x34    uxtbeq r1, r0
    0xe0012fe0     0x38    tst r1, #1
    0xe0012fe4     0x3c    movne r1, #0
    0xe0012fe8     0x40    bne e00130c4 <cteInsert+0x11c>
    0xe0012fec     0x44    sub r1, r1, #2
    0xe0012ff0     0x48    cmp r1, #28
    0xe0012ff4     0x4c    ldrls pc, [pc, r1, lsl #2]
    0xe0012ff8     0x50    b e0013070 <cteInsert+0xc8>
    0xe0012ffc     0x54    .word 0xe00130c0
    0xe0013000     0x58    .word 0xe0013070
    0xe0013004     0x5c    .word 0xe0013078
    0xe0013008     0x60    .word 0xe0013070
    0xe001300c     0x64    .word 0xe001308c
    0xe0013010     0x68    .word 0xe0013070
    0xe0013014     0x6c    .word 0xe0013070
    0xe0013018     0x70    .word 0xe0013070
    0xe001301c     0x74    .word 0xe0013070
    0xe0013020     0x78    .word 0xe0013070
    0xe0013024     0x7c    .word 0xe0013070
    0xe0013028     0x80    .word 0xe0013070
    0xe001302c     0x84    .word 0xe0013070
    0xe0013030     0x88    .word 0xe0013070
    0xe0013034     0x8c    .word 0xe0013070
    0xe0013038     0x90    .word 0xe0013070
    0xe001303c     0x94    .word 0xe0013070
    0xe0013040     0x98    .word 0xe0013070
    0xe0013044     0x9c    .word 0xe0013070
    0xe0013048     0xa0    .word 0xe0013070
    0xe001304c     0xa4    .word 0xe0013070
    0xe0013050     0xa8    .word 0xe0013070
    0xe0013054     0xac    .word 0xe0013070
    0xe0013058     0xb0    .word 0xe0013070
    0xe001305c     0xb4    .word 0xe0013070
    0xe0013060     0xb8    .word 0xe0013070
    0xe0013064     0xbc    .word 0xe0013070
    0xe0013068     0xc0    .word 0xe0013070
    0xe001306c     0xc4    .word 0xe00130a0
    0xe0013070     0xc8    mov r1, #0
    0xe0013074     0xcc    b e00130c4 <cteInsert+0x11c>
    0xe0013078     0xd0    lsr r1, r4, #4
    0xe001307c     0xd4    cmp r1, r0, lsr #4
    0xe0013080     0xd8    movne r1, #1
    0xe0013084     0xdc    moveq r1, #0
    0xe0013088     0xe0    b e00130c4 <cteInsert+0x11c>
    0xe001308c     0xe4    lsr r1, r7, #4
    0xe0013090     0xe8    cmp r1, r6, lsr #4
    0xe0013094     0xec    movne r1, #1
    0xe0013098     0xf0    moveq r1, #0
    0xe001309c     0xf4    b e00130c4 <cteInsert+0x11c>
    0xe00130a0     0xf8    and r1, r4, #14
    0xe00130a4     0xfc    cmp r1, #14
    0xe00130a8    0x100    andne r1, r4, #15
    0xe00130ac    0x104    uxtbeq r1, r4
    0xe00130b0    0x108    cmp r1, #14
    0xe00130b4    0x10c    movne r1, #0
    0xe00130b8    0x110    moveq r1, #1
    0xe00130bc    0x114    b e00130c4 <cteInsert+0x11c>
    0xe00130c0    0x118    mov r1, #1
    0xe00130c4    0x11c    and lr, lr, #7
    0xe00130c8    0x120    bic r8, r2, #7
    0xe00130cc    0x124    orr lr, lr, r8
    0xe00130d0    0x128    bic ip, ip, #2
    0xe00130d4    0x12c    orr ip, ip, r1, lsl #1
    0xe00130d8    0x130    bic ip, ip, #1
    0xe00130dc    0x134    orr ip, ip, r1
    0xe00130e0    0x138    and r1, r4, #14
    0xe00130e4    0x13c    cmp r1, #14
    0xe00130e8    0x140    andne r1, r4, #15
    0xe00130ec    0x144    uxtbeq r1, r4
    0xe00130f0    0x148    cmp r1, #2
    0xe00130f4    0x14c    beq e001313c <cteInsert+0x194>
    0xe00130f8    0x150    add r1, sp, #8
    0xe00130fc    0x154    ldmdb r1, {r0, r1}    ; stack access
    0xe0013100    0x158    stm r3, {r0, r1}
    0xe0013104    0x15c    str lr, [r3, #8]
    0xe0013108    0x160    str ip, [r3, #12]
    0xe001310c    0x164    bic r3, r3, #7
    0xe0013110    0x168    ldr r1, [r2, #12]
    0xe0013114    0x16c    and r1, r1, #7
    0xe0013118    0x170    orr r1, r1, r3
    0xe001311c    0x174    str r1, [r2, #12]
    0xe0013120    0x178    bics ip, ip, #7
    0xe0013124    0x17c    ldrne r2, [ip, #8]
    0xe0013128    0x180    andne r2, r2, #7
    0xe001312c    0x184    orrne r3, r2, r3
    0xe0013130    0x188    strne r3, [ip, #8]
    0xe0013134    0x18c    add sp, sp, #8
    0xe0013138    0x190    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe001313c    0x194    cmp r5, #14
    0xe0013140    0x198    andne r1, r0, #15
    0xe0013144    0x19c    uxtbeq r1, r0
    0xe0013148    0x1a0    cmp r1, #2
    0xe001314c    0x1a4    bne e00130f8 <cteInsert+0x150>
    0xe0013150    0x1a8    bic r4, r4, #15
    0xe0013154    0x1ac    bic r0, r0, #15
    0xe0013158    0x1b0    cmp r4, r0
    0xe001315c    0x1b4    bne e00130f8 <cteInsert+0x150>
    0xe0013160    0x1b8    and r6, r6, #31
    0xe0013164    0x1bc    and r7, r7, #31
    0xe0013168    0x1c0    cmp r6, r7
    0xe001316c    0x1c4    bne e00130f8 <cteInsert+0x150>
    0xe0013170    0x1c8    sub r6, r6, #4
    0xe0013174    0x1cc    ldr r1, [r2, #4]
    0xe0013178    0x1d0    and r1, r1, #63 
    0xe001317c    0x1d4    mov r0, #64 
    0xe0013180    0x1d8    orr r6, r1, r0, lsl r6
    0xe0013184    0x1dc    str r6, [r2, #4]
    0xe0013188    0x1e0    b e00130f8 <cteInsert+0x150>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
92 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteInsert` has 248 nodes.

Section preemptionPoint (40 of 293)
===================================

Deriving specifications
-----------------------

Section `preemptionPoint` consists of 23 instructions.
 LDR (-imm,pre)..++
 MOVCC (imm)..++
 MOVCS (reg)....+++


Stack analysis
---------------

No stack accesses found. Code for `preemptionPoint`:

    0xe0012f4c     0x0    movw r3, #12804 
    0xe0012f50     0x4    movt r3, #57347 
    0xe0012f54     0x8    ldr r3, [r3]
    0xe0012f58     0xc    add r3, r3, #1
    0xe0012f5c    0x10    cmp r3, #99 
    0xe0012f60    0x14    bls e0012f94 <preemptionPoint+0x48>
    0xe0012f64    0x18    movw r3, #12804 
    0xe0012f68    0x1c    movt r3, #57347 
    0xe0012f6c    0x20    mov r2, #0
    0xe0012f70    0x24    str r2, [r3]
    0xe0012f74    0x28    movw r3, #8703 
    0xe0012f78    0x2c    movt r3, #65520 
    0xe0012f7c    0x30    ldr r3, [r3, #-231] 
    0xe0012f80    0x34    ubfx r3, r3, #0, #10
    0xe0012f84    0x38    cmp r3, #1020 
    0xe0012f88    0x3c    movcc r0, #4
    0xe0012f8c    0x40    movcs r0, r2
    0xe0012f90    0x44    bx lr
    0xe0012f94    0x48    movw r2, #12804 
    0xe0012f98    0x4c    movt r2, #57347 
    0xe0012f9c    0x50    str r3, [r2]
    0xe0012fa0    0x54    mov r0, #0
    0xe0012fa4    0x58    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `preemptionPoint` has 35 nodes.

Section setMCPriority (41 of 293)
=================================

Deriving specifications
-----------------------

Section `setMCPriority` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setMCPriority`:

    0xe0012f44    0x0    str r1, [r0, #116] 
    0xe0012f48    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMCPriority` has 4 nodes.

Section doNBRecvFailedTransfer (42 of 293)
==========================================

Deriving specifications
-----------------------

Section `doNBRecvFailedTransfer` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `doNBRecvFailedTransfer`:

    0xe0012f14    0x0    mov r3, #0
    0xe0012f18    0x4    str r3, [r0]
    0xe0012f1c    0x8    bx lr

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doNBRecvFailedTransfer` has 5 nodes.

Section resolveAddressBits (43 of 293)
======================================

Deriving specifications
-----------------------

Section `resolveAddressBits` consists of 97 instructions.
 STMDB;2,1...+
 MVNEQ (imm)..++
 MVN (reg-shift).....+++++
 AND (reg-shift)...............+++++++++++++++
 CMPCS (reg)......+++
 BCC..++


Stack analysis
---------------

Section `resolveAddressBits` expects pointer to stack in r0.
24 stack accesses found. Annotated code for `resolveAddressBits`:

    0xe0012a44      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0012a48      0x4    sub sp, sp, #8
    0xe0012a4c      0x8    add ip, sp, #8
    0xe0012a50      0xc    stmdb ip, {r1, r2}    ; stack access
    0xe0012a54     0x10    ldr r1, [sp]          ; stack access
    0xe0012a58     0x14    ldr r4, [sp, #4]      ; stack access
    0xe0012a5c     0x18    and r2, r1, #14
    0xe0012a60     0x1c    cmp r2, #14
    0xe0012a64     0x20    andne r2, r1, #15
    0xe0012a68     0x24    uxtbeq r2, r1
    0xe0012a6c     0x28    cmp r2, #10
    0xe0012a70     0x2c    ldreq r2, [sp, #32]   ; stack access
    0xe0012a74     0x30    mvneq r7, #0
    0xe0012a78     0x34    bne e0012ae4 <resolveAddressBits+0xa0>
    0xe0012a7c     0x38    ubfx r8, r4, #18, #5
    0xe0012a80     0x3c    ubfx ip, r4, #23, #5
    0xe0012a84     0x40    add lr, ip, r8
    0xe0012a88     0x44    ubfx r4, r4, #0, #18
    0xe0012a8c     0x48    sub r5, r2, ip
    0xe0012a90     0x4c    and r6, r5, #31
    0xe0012a94     0x50    mvn r5, r7, lsl ip
    0xe0012a98     0x54    and r5, r5, r3, lsr r6
    0xe0012a9c     0x58    cmp r2, ip
    0xe0012aa0     0x5c    cmpcs r5, r4
    0xe0012aa4     0x60    bne e0012b10 <resolveAddressBits+0xcc>
    0xe0012aa8     0x64    cmp r2, lr
    0xe0012aac     0x68    bcc e0012b50 <resolveAddressBits+0x10c>
    0xe0012ab0     0x6c    sub r5, r2, lr
    0xe0012ab4     0x70    lsr ip, r3, r5
    0xe0012ab8     0x74    bic ip, ip, r7, lsl r8
    0xe0012abc     0x78    bic r1, r1, #31
    0xe0012ac0     0x7c    add r6, r1, ip, lsl #4
    0xe0012ac4     0x80    cmp r2, lr
    0xe0012ac8     0x84    bhi e0012b90 <resolveAddressBits+0x14c>
    0xe0012acc     0x88    mov r3, #0
    0xe0012ad0     0x8c    str r3, [r0]          ; stack access
    0xe0012ad4     0x90    str r6, [r0, #4]      ; stack access
    0xe0012ad8     0x94    str r3, [r0, #8]      ; stack access
    0xe0012adc     0x98    add sp, sp, #8
    0xe0012ae0     0x9c    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0012ae4     0xa0    movw r3, #36884 
    0xe0012ae8     0xa4    movt r3, #57346 
    0xe0012aec     0xa8    mov r2, #0
    0xe0012af0     0xac    str r2, [r3]
    0xe0012af4     0xb0    str r2, [r3, #4]
    0xe0012af8     0xb4    mov r3, #2
    0xe0012afc     0xb8    str r3, [r0]          ; stack access
    0xe0012b00     0xbc    str r2, [r0, #4]      ; stack access
    0xe0012b04     0xc0    ldr r3, [sp, #32]     ; stack access
    0xe0012b08     0xc4    str r3, [r0, #8]      ; stack access
    0xe0012b0c     0xc8    b e0012adc <resolveAddressBits+0x98>
    0xe0012b10     0xcc    movw r3, #36884 
    0xe0012b14     0xd0    movt r3, #57346 
    0xe0012b18     0xd4    lsl ip, ip, #2
    0xe0012b1c     0xd8    orr ip, ip, #3
    0xe0012b20     0xdc    lsl r2, r2, #8
    0xe0012b24     0xe0    and r2, r2, #16128 
    0xe0012b28     0xe4    orr r2, ip, r2
    0xe0012b2c     0xe8    str r2, [r3]
    0xe0012b30     0xec    str r4, [r3, #4]
    0xe0012b34     0xf0    mov r3, #2
    0xe0012b38     0xf4    str r3, [r0]          ; stack access
    0xe0012b3c     0xf8    mov r3, #0
    0xe0012b40     0xfc    str r3, [r0, #4]      ; stack access
    0xe0012b44    0x100    ldr r3, [sp, #32]     ; stack access
    0xe0012b48    0x104    str r3, [r0, #8]      ; stack access
    0xe0012b4c    0x108    b e0012adc <resolveAddressBits+0x98>
    0xe0012b50    0x10c    movw r3, #36884 
    0xe0012b54    0x110    movt r3, #57346 
    0xe0012b58    0x114    lsl lr, lr, #8
    0xe0012b5c    0x118    orr lr, lr, #2
    0xe0012b60    0x11c    lsl r2, r2, #2
    0xe0012b64    0x120    uxtb r2, r2
    0xe0012b68    0x124    orr r2, lr, r2
    0xe0012b6c    0x128    str r2, [r3]
    0xe0012b70    0x12c    mov r2, #0
    0xe0012b74    0x130    str r2, [r3, #4]
    0xe0012b78    0x134    mov r3, #2
    0xe0012b7c    0x138    str r3, [r0]          ; stack access
    0xe0012b80    0x13c    str r2, [r0, #4]      ; stack access
    0xe0012b84    0x140    ldr r3, [sp, #32]     ; stack access
    0xe0012b88    0x144    str r3, [r0, #8]      ; stack access
    0xe0012b8c    0x148    b e0012adc <resolveAddressBits+0x98>
    0xe0012b90    0x14c    ldr r1, [r1, ip, lsl #4]
    0xe0012b94    0x150    ldr r4, [r6, #4]
    0xe0012b98    0x154    and r2, r1, #14
    0xe0012b9c    0x158    cmp r2, #14
    0xe0012ba0    0x15c    andne ip, r1, #15
    0xe0012ba4    0x160    uxtbeq ip, r1
    0xe0012ba8    0x164    mov r2, r5
    0xe0012bac    0x168    cmp ip, #10
    0xe0012bb0    0x16c    beq e0012a7c <resolveAddressBits+0x38>
    0xe0012bb4    0x170    mov r3, #0
    0xe0012bb8    0x174    str r3, [r0]          ; stack access
    0xe0012bbc    0x178    str r6, [r0, #4]      ; stack access
    0xe0012bc0    0x17c    str r5, [r0, #8]      ; stack access
    0xe0012bc4    0x180    b e0012adc <resolveAddressBits+0x98>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
97 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `resolveAddressBits` has 153 nodes.

Section Arch_performTransfer (44 of 293)
========================================

Deriving specifications
-----------------------

Section `Arch_performTransfer` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_performTransfer`:

    0xe0012a3c    0x0    mov r0, #0
    0xe0012a40    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_performTransfer` has 3 nodes.

Section Arch_decodeTransfer (45 of 293)
=======================================

Deriving specifications
-----------------------

Section `Arch_decodeTransfer` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_decodeTransfer`:

    0xe0012a34    0x0    mov r0, #0
    0xe0012a38    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeTransfer` has 3 nodes.

Section plat_cleanCache (46 of 293)
===================================

Deriving specifications
-----------------------

Section `plat_cleanCache` consists of 21 instructions.
 SXT{A}H,UXT{A}H.......+++++++
Skipping f57ff05f dmb sy


Stack analysis
---------------

No stack accesses found. Code for `plat_cleanCache`:

    0xe00129e0     0x0    movw r3, #12543 
    0xe00129e4     0x4    movt r3, #65520 
    0xe00129e8     0x8    movw r2, #65535 
    0xe00129ec     0xc    str r2, [r3, #1725] 
    0xe00129f0    0x10    movw r2, #12543 
    0xe00129f4    0x14    movt r2, #65520 
    0xe00129f8    0x18    ldr r3, [r2, #1725] 
    0xe00129fc    0x1c    uxth r3, r3
    0xe0012a00    0x20    cmp r3, #0
    0xe0012a04    0x24    bne e00129f8 <plat_cleanCache+0x18>
    0xe0012a08    0x28    dmb sy
    0xe0012a0c    0x2c    movw r3, #12543 
    0xe0012a10    0x30    movt r3, #65520 
    0xe0012a14    0x34    mov r2, #0
    0xe0012a18    0x38    str r2, [r3, #1585] 
    0xe0012a1c    0x3c    movw r2, #12543 
    0xe0012a20    0x40    movt r2, #65520 
    0xe0012a24    0x44    ldr r3, [r2, #1585] 
    0xe0012a28    0x48    tst r3, #1
    0xe0012a2c    0x4c    bne e0012a24 <plat_cleanCache+0x44>
    0xe0012a30    0x50    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `plat_cleanCache` has 31 nodes.

Section setNextPC (47 of 293)
=============================

Deriving specifications
-----------------------

Section `setNextPC` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setNextPC`:

    0xe00129d8    0x0    str r1, [r0, #60] 
    0xe00129dc    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setNextPC` has 4 nodes.

Section getRestartPC (48 of 293)
================================

Deriving specifications
-----------------------

Section `getRestartPC` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `getRestartPC`:

    0xe00129d0    0x0    ldr r0, [r0, #68] 
    0xe00129d4    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getRestartPC` has 4 nodes.

Section setIRQTrigger (49 of 293)
=================================

Deriving specifications
-----------------------

Section `setIRQTrigger` consists of 13 instructions.
 ORRNE (reg-shift)................++++++++++++++++
 BICEQ (reg-shift)................++++++++++++++++


Stack analysis
---------------

No stack accesses found. Code for `setIRQTrigger`:

    0xe001299c     0x0    lsr r3, r0, #4
    0xe00129a0     0x4    and r0, r0, #15
    0xe00129a4     0x8    lsl r0, r0, #1
    0xe00129a8     0xc    cmp r1, #0
    0xe00129ac    0x10    lsl r3, r3, #2
    0xe00129b0    0x14    sub r3, r3, #1044480 
    0xe00129b4    0x18    ldr r2, [r3, #3072] 
    0xe00129b8    0x1c    add r0, r0, #1
    0xe00129bc    0x20    mov r1, #1
    0xe00129c0    0x24    orrne r0, r2, r1, lsl r0
    0xe00129c4    0x28    biceq r0, r2, r1, lsl r0
    0xe00129c8    0x2c    str r0, [r3, #3072] 
    0xe00129cc    0x30    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setIRQTrigger` has 20 nodes.

Section branchFlushRange (50 of 293)
====================================

Deriving specifications
-----------------------

Section `branchFlushRange` consists of 12 instructions.
 BXCS..++
Skipping ee073ff5 mcr 15, 0, r3, cr7, cr5, {7}


Stack analysis
---------------

No stack accesses found. Code for `branchFlushRange`:

    0xe0012524     0x0    lsr r0, r0, #5
    0xe0012528     0x4    lsr r1, r1, #5
    0xe001252c     0x8    add r1, r1, #1
    0xe0012530     0xc    cmp r0, r1
    0xe0012534    0x10    bxcs lr
    0xe0012538    0x14    lsl r3, r0, #5
    0xe001253c    0x18    mcr 15, 0, r3, cr7, cr5, {7}
    0xe0012540    0x1c    add r0, r0, #1
    0xe0012544    0x20    add r3, r3, #32
    0xe0012548    0x24    cmp r0, r1
    0xe001254c    0x28    bne e001253c <branchFlushRange+0x18>
    0xe0012550    0x2c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `branchFlushRange` has 19 nodes.

Section invalidateCacheRange_I (51 of 293)
==========================================

Deriving specifications
-----------------------

Section `invalidateCacheRange_I` consists of 13 instructions.
Skipping ee073f35 mcr 15, 0, r3, cr7, cr5, {1}
Skipping f57ff06f isb sy


Stack analysis
---------------

No stack accesses found. Code for `invalidateCacheRange_I`:

    0xe00124f0     0x0    lsr r0, r0, #5
    0xe00124f4     0x4    lsr r1, r1, #5
    0xe00124f8     0x8    add r1, r1, #1
    0xe00124fc     0xc    cmp r0, r1
    0xe0012500    0x10    bxcs lr
    0xe0012504    0x14    lsl r3, r0, #5
    0xe0012508    0x18    mcr 15, 0, r3, cr7, cr5, {1}
    0xe001250c    0x1c    isb sy
    0xe0012510    0x20    add r0, r0, #1
    0xe0012514    0x24    add r3, r3, #32
    0xe0012518    0x28    cmp r0, r1
    0xe001251c    0x2c    bne e0012508 <invalidateCacheRange_I+0x18>
    0xe0012520    0x30    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invalidateCacheRange_I` has 21 nodes.

Section cleanCacheRange_PoU (52 of 293)
=======================================

Deriving specifications
-----------------------

Section `cleanCacheRange_PoU` consists of 13 instructions.
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy


Stack analysis
---------------

No stack accesses found. Code for `cleanCacheRange_PoU`:

    0xe00120c8     0x0    lsr r0, r0, #5
    0xe00120cc     0x4    lsr r1, r1, #5
    0xe00120d0     0x8    add r1, r1, #1
    0xe00120d4     0xc    cmp r0, r1
    0xe00120d8    0x10    bxcs lr
    0xe00120dc    0x14    lsl r3, r0, #5
    0xe00120e0    0x18    mcr 15, 0, r3, cr7, cr11, {1}
    0xe00120e4    0x1c    dmb sy
    0xe00120e8    0x20    add r0, r0, #1
    0xe00120ec    0x24    add r3, r3, #32
    0xe00120f0    0x28    cmp r0, r1
    0xe00120f4    0x2c    bne e00120e0 <cleanCacheRange_PoU+0x18>
    0xe00120f8    0x30    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanCacheRange_PoU` has 21 nodes.

Section cleanCacheRange_RAM (53 of 293)
=======================================

Deriving specifications
-----------------------

Section `cleanCacheRange_RAM` consists of 38 instructions.
 BCS..++
Skipping ee07cf3a mcr 15, 0, ip, cr7, cr10, {1}
Skipping f57ff05f dmb sy
Skipping f57ff04f dsb sy
Skipping f57ff05f dmb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `cleanCacheRange_RAM`:

    0xe0012030     0x0    push {lr}             ; stack access
    0xe0012034     0x4    lsr r3, r0, #5
    0xe0012038     0x8    lsr lr, r1, #5
    0xe001203c     0xc    add lr, lr, #1
    0xe0012040    0x10    cmp r3, lr
    0xe0012044    0x14    bcs e0012064 <cleanCacheRange_RAM+0x34>
    0xe0012048    0x18    lsl ip, r3, #5
    0xe001204c    0x1c    mcr 15, 0, ip, cr7, cr10, {1}
    0xe0012050    0x20    dmb sy
    0xe0012054    0x24    add r3, r3, #1
    0xe0012058    0x28    add ip, ip, #32
    0xe001205c    0x2c    cmp r3, lr
    0xe0012060    0x30    bne e001204c <cleanCacheRange_RAM+0x1c>
    0xe0012064    0x34    dsb sy
    0xe0012068    0x38    bic r3, r2, #31
    0xe001206c    0x3c    add r2, r2, #32
    0xe0012070    0x40    add r1, r2, r1
    0xe0012074    0x44    sub r0, r1, r0
    0xe0012078    0x48    bic r0, r0, #31
    0xe001207c    0x4c    cmp r3, r0
    0xe0012080    0x50    beq e001209c <cleanCacheRange_RAM+0x6c>
    0xe0012084    0x54    movw r2, #12543 
    0xe0012088    0x58    movt r2, #65520 
    0xe001208c    0x5c    str r3, [r2, #1713] 
    0xe0012090    0x60    add r3, r3, #32
    0xe0012094    0x64    cmp r3, r0
    0xe0012098    0x68    bne e001208c <cleanCacheRange_RAM+0x5c>
    0xe001209c    0x6c    dmb sy
    0xe00120a0    0x70    movw r3, #12543 
    0xe00120a4    0x74    movt r3, #65520 
    0xe00120a8    0x78    mov r2, #0
    0xe00120ac    0x7c    str r2, [r3, #1585] 
    0xe00120b0    0x80    movw r2, #12543 
    0xe00120b4    0x84    movt r2, #65520 
    0xe00120b8    0x88    ldr r3, [r2, #1585] 
    0xe00120bc    0x8c    tst r3, #1
    0xe00120c0    0x90    bne e00120b8 <cleanCacheRange_RAM+0x88>
    0xe00120c4    0x94    pop {pc}              ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanCacheRange_RAM` has 57 nodes.

Section cleanInvalidateCacheRange_RAM (54 of 293)
=================================================

Deriving specifications
-----------------------

Section `cleanInvalidateCacheRange_RAM` consists of 51 instructions.
Skipping ee07ef3a mcr 15, 0, lr, cr7, cr10, {1}
Skipping f57ff05f dmb sy
Skipping f57ff04f dsb sy
Skipping f57ff05f dmb sy
Skipping f57ff05f dmb sy
Skipping ee073f3e mcr 15, 0, r3, cr7, cr14, {1}
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `cleanInvalidateCacheRange_RAM`:

    0xe0011f64     0x0    push {r4, lr}         ; stack access
    0xe0011f68     0x4    lsr ip, r0, #5
    0xe0011f6c     0x8    lsr r4, r1, #5
    0xe0011f70     0xc    add r4, r4, #1
    0xe0011f74    0x10    cmp ip, r4
    0xe0011f78    0x14    bcs e0011f9c <cleanInvalidateCacheRange_RAM+0x38>
    0xe0011f7c    0x18    lsl lr, ip, #5
    0xe0011f80    0x1c    mov r3, ip
    0xe0011f84    0x20    mcr 15, 0, lr, cr7, cr10, {1}
    0xe0011f88    0x24    dmb sy
    0xe0011f8c    0x28    add r3, r3, #1
    0xe0011f90    0x2c    add lr, lr, #32
    0xe0011f94    0x30    cmp r3, r4
    0xe0011f98    0x34    bne e0011f84 <cleanInvalidateCacheRange_RAM+0x20>
    0xe0011f9c    0x38    dsb sy
    0xe0011fa0    0x3c    bic r3, r2, #31
    0xe0011fa4    0x40    add r2, r2, #32
    0xe0011fa8    0x44    add r1, r2, r1
    0xe0011fac    0x48    sub r0, r1, r0
    0xe0011fb0    0x4c    bic r0, r0, #31
    0xe0011fb4    0x50    cmp r3, r0
    0xe0011fb8    0x54    beq e0011fdc <cleanInvalidateCacheRange_RAM+0x78>
    0xe0011fbc    0x58    movw r2, #12543 
    0xe0011fc0    0x5c    movt r2, #65520 
    0xe0011fc4    0x60    str r3, [r2, #1713] 
    0xe0011fc8    0x64    dmb sy
    0xe0011fcc    0x68    str r3, [r2, #1649] 
    0xe0011fd0    0x6c    add r3, r3, #32
    0xe0011fd4    0x70    cmp r3, r0
    0xe0011fd8    0x74    bne e0011fc4 <cleanInvalidateCacheRange_RAM+0x60>
    0xe0011fdc    0x78    dmb sy
    0xe0011fe0    0x7c    movw r3, #12543 
    0xe0011fe4    0x80    movt r3, #65520 
    0xe0011fe8    0x84    mov r2, #0
    0xe0011fec    0x88    str r2, [r3, #1585] 
    0xe0011ff0    0x8c    movw r2, #12543 
    0xe0011ff4    0x90    movt r2, #65520 
    0xe0011ff8    0x94    ldr r3, [r2, #1585] 
    0xe0011ffc    0x98    tst r3, #1
    0xe0012000    0x9c    bne e0011ff8 <cleanInvalidateCacheRange_RAM+0x94>
    0xe0012004    0xa0    cmp ip, r4
    0xe0012008    0xa4    bcs e0012028 <cleanInvalidateCacheRange_RAM+0xc4>
    0xe001200c    0xa8    lsl r3, ip, #5
    0xe0012010    0xac    mcr 15, 0, r3, cr7, cr14, {1}
    0xe0012014    0xb0    dsb sy
    0xe0012018    0xb4    add ip, ip, #1
    0xe001201c    0xb8    add r3, r3, #32
    0xe0012020    0xbc    cmp ip, r4
    0xe0012024    0xc0    bne e0012010 <cleanInvalidateCacheRange_RAM+0xac>
    0xe0012028    0xc4    dsb sy
    0xe001202c    0xc8    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
51 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanInvalidateCacheRange_RAM` has 79 nodes.

Section Arch_postModifyRegisters (55 of 293)
============================================

Deriving specifications
-----------------------

Section `Arch_postModifyRegisters` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_postModifyRegisters`:

    0xe0011f60    0x0    bx lr

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_postModifyRegisters` has 2 nodes.

Section armv_init_user_access (56 of 293)
=========================================

Deriving specifications
-----------------------

Section `armv_init_user_access` consists of 7 instructions.
Skipping ee103f51 mrc 15, 0, r3, cr0, cr1, {2}
Skipping ee103f31 mrc 15, 0, r3, cr0, cr1, {1}
Skipping ee0e3f11 mcr 15, 0, r3, cr14, cr1, {0}


Stack analysis
---------------

No stack accesses found. Code for `armv_init_user_access`:

    0xe0011f44     0x0    mrc 15, 0, r3, cr0, cr1, {2}
    0xe0011f48     0x4    mrc 15, 0, r3, cr0, cr1, {1}
    0xe0011f4c     0x8    tst r3, #65536 
    0xe0011f50     0xc    bxeq lr
    0xe0011f54    0x10    mov r3, #0
    0xe0011f58    0x14    mcr 15, 0, r3, cr14, cr1, {0}
    0xe0011f5c    0x18    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `armv_init_user_access` has 14 nodes.

Section cleanInvalidate_L1D (57 of 293)
=======================================

Deriving specifications
-----------------------

Section `cleanInvalidate_L1D` consists of 35 instructions.
 STMDB (wb);14,7,6,5,4..+
Skipping ee503f10 mrc 15, 2, r3, cr0, cr0, {0}
Skipping ee402f10 mcr 15, 2, r2, cr0, cr0, {0}
Skipping ee300f10 mrc 15, 1, r0, cr0, cr0, {0}
Skipping ee403f10 mcr 15, 2, r3, cr0, cr0, {0}
 CLZ..++
Skipping ee071f5e mcr 15, 0, r1, cr7, cr14, {2}
 LDMIAEQ (wb);15,7,6,5,4..++
 MOVGT (reg)....+++
 MOVGT (imm)..++
 BGT..++


Stack analysis
---------------

2 stack accesses found. Annotated code for `cleanInvalidate_L1D`:

    0xe0011e8c     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0011e90     0x4    mrc 15, 2, r3, cr0, cr0, {0}
    0xe0011e94     0x8    mov r2, #0
    0xe0011e98     0xc    mcr 15, 2, r2, cr0, cr0, {0}
    0xe0011e9c    0x10    mrc 15, 1, r0, cr0, cr0, {0}
    0xe0011ea0    0x14    mcr 15, 2, r3, cr0, cr0, {0}
    0xe0011ea4    0x18    and lr, r0, #7
    0xe0011ea8    0x1c    add r3, lr, #4
    0xe0011eac    0x20    ubfx r6, r0, #3, #10
    0xe0011eb0    0x24    clz r7, r6
    0xe0011eb4    0x28    ubfx r0, r0, #13, #15
    0xe0011eb8    0x2c    add r0, r0, #1
    0xe0011ebc    0x30    add r6, r6, #1
    0xe0011ec0    0x34    mov lr, #1
    0xe0011ec4    0x38    lsl r7, lr, r7
    0xe0011ec8    0x3c    lsl lr, lr, r3
    0xe0011ecc    0x40    mov r4, r2
    0xe0011ed0    0x44    mov r5, r2
    0xe0011ed4    0x48    b e0011f00 <cleanInvalidate_L1D+0x74>
    0xe0011ed8    0x4c    orr r1, r3, ip
    0xe0011edc    0x50    mcr 15, 0, r1, cr7, cr14, {2}
    0xe0011ee0    0x54    add r2, r2, #1
    0xe0011ee4    0x58    add r3, r3, lr
    0xe0011ee8    0x5c    cmp r0, r2
    0xe0011eec    0x60    bne e0011ed8 <cleanInvalidate_L1D+0x4c>
    0xe0011ef0    0x64    add r5, r5, #1
    0xe0011ef4    0x68    add r4, r4, r7
    0xe0011ef8    0x6c    cmp r6, r5
    0xe0011efc    0x70    popeq {r4, r5, r6, r7, pc}  ; stack access
    0xe0011f00    0x74    cmp r0, #0
    0xe0011f04    0x78    movgt ip, r4
    0xe0011f08    0x7c    movgt r3, #0
    0xe0011f0c    0x80    movgt r2, r3
    0xe0011f10    0x84    bgt e0011ed8 <cleanInvalidate_L1D+0x4c>
    0xe0011f14    0x88    b e0011ef0 <cleanInvalidate_L1D+0x64>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanInvalidate_L1D` has 54 nodes.

Section cleanInvalidate_D_PoC (58 of 293)
=========================================

Deriving specifications
-----------------------

Section `cleanInvalidate_D_PoC` consists of 56 instructions.
 STMDB (wb);14,11,10,9,8,7,6,5,4..+
Skipping ee30bf30 mrc 15, 1, fp, cr0, cr0, {1}
 BLE..++
Skipping ee071f5e mcr 15, 0, r1, cr7, cr14, {2}
 ORRGT (reg)...........++++++
Skipping ee503f10 mrc 15, 2, r3, cr0, cr0, {0}
Skipping ee409f10 mcr 15, 2, r9, cr0, cr0, {0}
Skipping ee300f10 mrc 15, 1, r0, cr0, cr0, {0}
Skipping ee403f10 mcr 15, 2, r3, cr0, cr0, {0}
 LDMIA (wb);15,11,10,9,8,7,6,5,4.+


Stack analysis
---------------

4 stack accesses found. Annotated code for `cleanInvalidate_D_PoC`:

    0xe0011dac     0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0011db0     0x4    sub sp, sp, #12
    0xe0011db4     0x8    mrc 15, 1, fp, cr0, cr0, {1}
    0xe0011db8     0xc    str fp, [sp, #4]      ; stack access
    0xe0011dbc    0x10    ubfx fp, fp, #24, #3
    0xe0011dc0    0x14    cmp fp, #0
    0xe0011dc4    0x18    ble e0011e84 <cleanInvalidate_D_PoC+0xd8>
    0xe0011dc8    0x1c    add fp, fp, fp, lsl #1
    0xe0011dcc    0x20    mov r9, #0
    0xe0011dd0    0x24    mov r7, r9
    0xe0011dd4    0x28    b e0011e28 <cleanInvalidate_D_PoC+0x7c>
    0xe0011dd8    0x2c    orr r1, r3, lr
    0xe0011ddc    0x30    mcr 15, 0, r1, cr7, cr14, {2}
    0xe0011de0    0x34    add r2, r2, #1
    0xe0011de4    0x38    add r3, r3, ip
    0xe0011de8    0x3c    cmp r0, r2
    0xe0011dec    0x40    bne e0011dd8 <cleanInvalidate_D_PoC+0x2c>
    0xe0011df0    0x44    add r5, r5, #1
    0xe0011df4    0x48    add r4, r4, r8
    0xe0011df8    0x4c    cmp r6, r5
    0xe0011dfc    0x50    beq e0011e18 <cleanInvalidate_D_PoC+0x6c>
    0xe0011e00    0x54    cmp r0, #0
    0xe0011e04    0x58    orrgt lr, r4, sl
    0xe0011e08    0x5c    movgt r3, #0
    0xe0011e0c    0x60    movgt r2, r3
    0xe0011e10    0x64    bgt e0011dd8 <cleanInvalidate_D_PoC+0x2c>
    0xe0011e14    0x68    b e0011df0 <cleanInvalidate_D_PoC+0x44>
    0xe0011e18    0x6c    add r7, r7, #3
    0xe0011e1c    0x70    add r9, r9, #2
    0xe0011e20    0x74    cmp r7, fp
    0xe0011e24    0x78    beq e0011e84 <cleanInvalidate_D_PoC+0xd8>
    0xe0011e28    0x7c    ldr r3, [sp, #4]      ; stack access
    0xe0011e2c    0x80    asr r3, r3, r7
    0xe0011e30    0x84    and r3, r3, #7
    0xe0011e34    0x88    cmp r3, #1
    0xe0011e38    0x8c    bls e0011e18 <cleanInvalidate_D_PoC+0x6c>
    0xe0011e3c    0x90    mrc 15, 2, r3, cr0, cr0, {0}
    0xe0011e40    0x94    mov sl, r9
    0xe0011e44    0x98    mcr 15, 2, r9, cr0, cr0, {0}
    0xe0011e48    0x9c    mrc 15, 1, r0, cr0, cr0, {0}
    0xe0011e4c    0xa0    mcr 15, 2, r3, cr0, cr0, {0}
    0xe0011e50    0xa4    and ip, r0, #7
    0xe0011e54    0xa8    add ip, ip, #4
    0xe0011e58    0xac    ubfx r6, r0, #3, #10
    0xe0011e5c    0xb0    clz r8, r6
    0xe0011e60    0xb4    ubfx r0, r0, #13, #15
    0xe0011e64    0xb8    add r0, r0, #1
    0xe0011e68    0xbc    add r6, r6, #1
    0xe0011e6c    0xc0    mov r3, #1
    0xe0011e70    0xc4    lsl r8, r3, r8
    0xe0011e74    0xc8    lsl ip, r3, ip
    0xe0011e78    0xcc    mov r4, #0
    0xe0011e7c    0xd0    mov r5, r4
    0xe0011e80    0xd4    b e0011e00 <cleanInvalidate_D_PoC+0x54>
    0xe0011e84    0xd8    add sp, sp, #12
    0xe0011e88    0xdc    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
56 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanInvalidate_D_PoC` has 85 nodes.

Section clean_D_PoU (59 of 293)
===============================

Deriving specifications
-----------------------

Section `clean_D_PoU` consists of 56 instructions.
Skipping ee30bf30 mrc 15, 1, fp, cr0, cr0, {1}
Skipping ee071f5a mcr 15, 0, r1, cr7, cr10, {2}
Skipping ee503f10 mrc 15, 2, r3, cr0, cr0, {0}
Skipping ee409f10 mcr 15, 2, r9, cr0, cr0, {0}
Skipping ee300f10 mrc 15, 1, r0, cr0, cr0, {0}
Skipping ee403f10 mcr 15, 2, r3, cr0, cr0, {0}


Stack analysis
---------------

4 stack accesses found. Annotated code for `clean_D_PoU`:

    0xe0011ccc     0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0011cd0     0x4    sub sp, sp, #12
    0xe0011cd4     0x8    mrc 15, 1, fp, cr0, cr0, {1}
    0xe0011cd8     0xc    str fp, [sp, #4]      ; stack access
    0xe0011cdc    0x10    ubfx fp, fp, #27, #3
    0xe0011ce0    0x14    cmp fp, #0
    0xe0011ce4    0x18    ble e0011da4 <clean_D_PoU+0xd8>
    0xe0011ce8    0x1c    add fp, fp, fp, lsl #1
    0xe0011cec    0x20    mov r9, #0
    0xe0011cf0    0x24    mov r7, r9
    0xe0011cf4    0x28    b e0011d48 <clean_D_PoU+0x7c>
    0xe0011cf8    0x2c    orr r1, r3, lr
    0xe0011cfc    0x30    mcr 15, 0, r1, cr7, cr10, {2}
    0xe0011d00    0x34    add r2, r2, #1
    0xe0011d04    0x38    add r3, r3, ip
    0xe0011d08    0x3c    cmp r0, r2
    0xe0011d0c    0x40    bne e0011cf8 <clean_D_PoU+0x2c>
    0xe0011d10    0x44    add r5, r5, #1
    0xe0011d14    0x48    add r4, r4, r8
    0xe0011d18    0x4c    cmp r6, r5
    0xe0011d1c    0x50    beq e0011d38 <clean_D_PoU+0x6c>
    0xe0011d20    0x54    cmp r0, #0
    0xe0011d24    0x58    orrgt lr, r4, sl
    0xe0011d28    0x5c    movgt r3, #0
    0xe0011d2c    0x60    movgt r2, r3
    0xe0011d30    0x64    bgt e0011cf8 <clean_D_PoU+0x2c>
    0xe0011d34    0x68    b e0011d10 <clean_D_PoU+0x44>
    0xe0011d38    0x6c    add r7, r7, #3
    0xe0011d3c    0x70    add r9, r9, #2
    0xe0011d40    0x74    cmp r7, fp
    0xe0011d44    0x78    beq e0011da4 <clean_D_PoU+0xd8>
    0xe0011d48    0x7c    ldr r3, [sp, #4]      ; stack access
    0xe0011d4c    0x80    asr r3, r3, r7
    0xe0011d50    0x84    and r3, r3, #7
    0xe0011d54    0x88    cmp r3, #1
    0xe0011d58    0x8c    bls e0011d38 <clean_D_PoU+0x6c>
    0xe0011d5c    0x90    mrc 15, 2, r3, cr0, cr0, {0}
    0xe0011d60    0x94    mov sl, r9
    0xe0011d64    0x98    mcr 15, 2, r9, cr0, cr0, {0}
    0xe0011d68    0x9c    mrc 15, 1, r0, cr0, cr0, {0}
    0xe0011d6c    0xa0    mcr 15, 2, r3, cr0, cr0, {0}
    0xe0011d70    0xa4    and ip, r0, #7
    0xe0011d74    0xa8    add ip, ip, #4
    0xe0011d78    0xac    ubfx r6, r0, #3, #10
    0xe0011d7c    0xb0    clz r8, r6
    0xe0011d80    0xb4    ubfx r0, r0, #13, #15
    0xe0011d84    0xb8    add r0, r0, #1
    0xe0011d88    0xbc    add r6, r6, #1
    0xe0011d8c    0xc0    mov r3, #1
    0xe0011d90    0xc4    lsl r8, r3, r8
    0xe0011d94    0xc8    lsl ip, r3, ip
    0xe0011d98    0xcc    mov r4, #0
    0xe0011d9c    0xd0    mov r5, r4
    0xe0011da0    0xd4    b e0011d20 <clean_D_PoU+0x54>
    0xe0011da4    0xd8    add sp, sp, #12
    0xe0011da8    0xdc    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
56 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `clean_D_PoU` has 85 nodes.

Section Arch_prepareThreadDelete (60 of 293)
============================================

Deriving specifications
-----------------------

Section `Arch_prepareThreadDelete` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_prepareThreadDelete`:

    0xe0011ac8    0x0    bx lr

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_prepareThreadDelete` has 2 nodes.

Section Arch_updateCapData (61 of 293)
======================================

Deriving specifications
-----------------------

Section `Arch_updateCapData` consists of 9 instructions.


Stack analysis
---------------

Section `Arch_updateCapData` expects pointer to stack in r0.
3 stack accesses found. Annotated code for `Arch_updateCapData`:

    0xe0011564     0x0    sub sp, sp, #8
    0xe0011568     0x4    mov ip, r0
    0xe001156c     0x8    sub r2, sp, #4
    0xe0011570     0xc    str r3, [r2, #8]!     ; stack access
    0xe0011574    0x10    ldm r2, {r0, r1}      ; stack access
    0xe0011578    0x14    stm ip, {r0, r1}      ; stack access
    0xe001157c    0x18    mov r0, ip
    0xe0011580    0x1c    add sp, sp, #8
    0xe0011584    0x20    bx lr

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_updateCapData` has 13 nodes.

Section Arch_isFrameType (62 of 293)
====================================

Deriving specifications
-----------------------

Section `Arch_isFrameType` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_isFrameType`:

    0xe001142c     0x0    sub r0, r0, #5
    0xe0011430     0x4    cmp r0, #3
    0xe0011434     0x8    movhi r0, #0
    0xe0011438     0xc    movls r0, #1
    0xe001143c    0x10    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_isFrameType` has 10 nodes.

Section copyGlobalMappings (63 of 293)
======================================

Deriving specifications
-----------------------

Section `copyGlobalMappings` consists of 14 instructions.


Stack analysis
---------------

No stack accesses found. Code for `copyGlobalMappings`:

    0xe0011268     0x0    movw r2, #3585 
    0xe001126c     0x4    mov r3, #3584 
    0xe0011270     0x8    movw ip, #16384 
    0xe0011274     0xc    movt ip, #57346 
    0xe0011278    0x10    b e0011284 <copyGlobalMappings+0x1c>
    0xe001127c    0x14    add r3, r3, #1
    0xe0011280    0x18    add r2, r2, #1
    0xe0011284    0x1c    cmp r3, #4080 
    0xe0011288    0x20    beq e001127c <copyGlobalMappings+0x14>
    0xe001128c    0x24    ldr r1, [ip, r3, lsl #2]
    0xe0011290    0x28    str r1, [r0, r3, lsl #2]
    0xe0011294    0x2c    cmp r2, #4096 
    0xe0011298    0x30    bcc e001127c <copyGlobalMappings+0x14>
    0xe001129c    0x34    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `copyGlobalMappings` has 21 nodes.

Section findFreeHWASID (64 of 293)
==================================

Deriving specifications
-----------------------

Section `findFreeHWASID` consists of 42 instructions.
Skipping f57ff04f dsb sy
Skipping ee080f57 mcr 15, 0, r0, cr8, cr7, {2}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy
 STRB (+imm,pre)..++


Stack analysis
---------------

No stack accesses found. Code for `findFreeHWASID`:

    0xe0010fb8     0x0    movw r3, #13896 
    0xe0010fbc     0x4    movt r3, #57347 
    0xe0010fc0     0x8    ldrb ip, [r3]
    0xe0010fc4     0xc    movw r3, #12872 
    0xe0010fc8    0x10    movt r3, #57347 
    0xe0010fcc    0x14    ldr r1, [r3, ip, lsl #2]
    0xe0010fd0    0x18    cmp r1, #0
    0xe0010fd4    0x1c    beq e0011058 <findFreeHWASID+0xa0>
    0xe0010fd8    0x20    add r0, ip, #1
    0xe0010fdc    0x24    uxtb r0, r0
    0xe0010fe0    0x28    mov r2, r3
    0xe0010fe4    0x2c    ldr r3, [r2, r0, lsl #2]
    0xe0010fe8    0x30    cmp r3, #0
    0xe0010fec    0x34    bxeq lr
    0xe0010ff0    0x38    add r0, r0, #1
    0xe0010ff4    0x3c    uxtb r0, r0
    0xe0010ff8    0x40    cmp r0, ip
    0xe0010ffc    0x44    bne e0010fe4 <findFreeHWASID+0x2c>
    0xe0011000    0x48    movw r3, #37576 
    0xe0011004    0x4c    movt r3, #57346 
    0xe0011008    0x50    lsr r2, r1, #10
    0xe001100c    0x54    ldr r3, [r3, r2, lsl #2]
    0xe0011010    0x58    ubfx r1, r1, #0, #10
    0xe0011014    0x5c    ldr r3, [r3, r1, lsl #2]
    0xe0011018    0x60    add r3, r3, #12288 
    0xe001101c    0x64    mov r2, #0
    0xe0011020    0x68    str r2, [r3, #4032] 
    0xe0011024    0x6c    dsb sy
    0xe0011028    0x70    mcr 15, 0, r0, cr8, cr7, {2}
    0xe001102c    0x74    dsb sy
    0xe0011030    0x78    isb sy
    0xe0011034    0x7c    movw r3, #12872 
    0xe0011038    0x80    movt r3, #57347 
    0xe001103c    0x84    str r2, [r3, ip, lsl #2]
    0xe0011040    0x88    movw r3, #13896 
    0xe0011044    0x8c    movt r3, #57347 
    0xe0011048    0x90    ldrb r2, [r3]
    0xe001104c    0x94    add r2, r2, #1
    0xe0011050    0x98    strb r2, [r3]
    0xe0011054    0x9c    bx lr
    0xe0011058    0xa0    mov r0, ip
    0xe001105c    0xa4    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
42 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `findFreeHWASID` has 64 nodes.

Section isIOSpaceFrameCap (65 of 293)
=====================================

Deriving specifications
-----------------------

Section `isIOSpaceFrameCap` consists of 6 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `isIOSpaceFrameCap`:

    0xe0010f34     0x0    sub sp, sp, #8
    0xe0010f38     0x4    add r3, sp, #8
    0xe0010f3c     0x8    stmdb r3, {r0, r1}    ; stack access
    0xe0010f40     0xc    mov r0, #0
    0xe0010f44    0x10    add sp, sp, #8
    0xe0010f48    0x14    bx lr

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isIOSpaceFrameCap` has 8 nodes.

Section isValidVTableRoot (66 of 293)
=====================================

Deriving specifications
-----------------------

Section `isValidVTableRoot` consists of 13 instructions.
 SBFX,UBFXEQ...+++


Stack analysis
---------------

2 stack accesses found. Annotated code for `isValidVTableRoot`:

    0xe0010f00     0x0    sub sp, sp, #8
    0xe0010f04     0x4    add r3, sp, #8
    0xe0010f08     0x8    stmdb r3, {r0, r1}    ; stack access
    0xe0010f0c     0xc    ldr r0, [sp]          ; stack access
    0xe0010f10    0x10    and r3, r0, #14
    0xe0010f14    0x14    cmp r3, #14
    0xe0010f18    0x18    andne r3, r0, #15
    0xe0010f1c    0x1c    uxtbeq r3, r0
    0xe0010f20    0x20    cmp r3, #9
    0xe0010f24    0x24    ubfxeq r0, r0, #4, #1
    0xe0010f28    0x28    movne r0, #0
    0xe0010f2c    0x2c    add sp, sp, #8
    0xe0010f30    0x30    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isValidVTableRoot` has 24 nodes.

Section lookupPTSlot (67 of 293)
================================

Deriving specifications
-----------------------

Section `lookupPTSlot` consists of 24 instructions.


Stack analysis
---------------

Section `lookupPTSlot` expects pointer to stack in r0.
4 stack accesses found. Annotated code for `lookupPTSlot`:

    0xe0010ea0     0x0    lsr r3, r2, #20
    0xe0010ea4     0x4    ldr r3, [r1, r3, lsl #2]
    0xe0010ea8     0x8    and r1, r3, #3
    0xe0010eac     0xc    cmp r1, #1
    0xe0010eb0    0x10    bne e0010ed8 <lookupPTSlot+0x38>
    0xe0010eb4    0x14    mov r1, #0
    0xe0010eb8    0x18    str r1, [r0]          ; stack access
    0xe0010ebc    0x1c    bic r3, r3, #1020 
    0xe0010ec0    0x20    bic r3, r3, #3
    0xe0010ec4    0x24    add r3, r3, #-805306368 
    0xe0010ec8    0x28    ubfx r2, r2, #12, #8
    0xe0010ecc    0x2c    add r3, r3, r2, lsl #2
    0xe0010ed0    0x30    str r3, [r0, #4]      ; stack access
    0xe0010ed4    0x34    bx lr
    0xe0010ed8    0x38    movw r3, #36884 
    0xe0010edc    0x3c    movt r3, #57346 
    0xe0010ee0    0x40    mov r2, #81 
    0xe0010ee4    0x44    str r2, [r3]
    0xe0010ee8    0x48    mov r2, #0
    0xe0010eec    0x4c    str r2, [r3, #4]
    0xe0010ef0    0x50    mov r3, #2
    0xe0010ef4    0x54    str r3, [r0]          ; stack access
    0xe0010ef8    0x58    str r2, [r0, #4]      ; stack access
    0xe0010efc    0x5c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
24 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupPTSlot` has 35 nodes.

Section lookupPDSlot (68 of 293)
================================

Deriving specifications
-----------------------

Section `lookupPDSlot` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookupPDSlot`:

    0xe0010e94    0x0    lsr r1, r1, #20
    0xe0010e98    0x4    add r0, r0, r1, lsl #2
    0xe0010e9c    0x8    bx lr

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupPDSlot` has 4 nodes.

Section checkValidIPCBuffer (69 of 293)
=======================================

Deriving specifications
-----------------------

Section `checkValidIPCBuffer` consists of 35 instructions.
 SBFX,UBFXNE...+++


Stack analysis
---------------

2 stack accesses found. Annotated code for `checkValidIPCBuffer`:

    0xe0010e08     0x0    sub sp, sp, #8
    0xe0010e0c     0x4    add r3, sp, #8
    0xe0010e10     0x8    stmdb r3, {r1, r2}    ; stack access
    0xe0010e14     0xc    ldr r3, [sp]          ; stack access
    0xe0010e18    0x10    and r2, r3, #14
    0xe0010e1c    0x14    cmp r2, #14
    0xe0010e20    0x18    andne r2, r3, #15
    0xe0010e24    0x1c    uxtbeq r2, r3
    0xe0010e28    0x20    bic r1, r2, #2
    0xe0010e2c    0x24    cmp r1, #1
    0xe0010e30    0x28    movwne r3, #36896 
    0xe0010e34    0x2c    movtne r3, #57346 
    0xe0010e38    0x30    movne r0, #3
    0xe0010e3c    0x34    strne r0, [r3, #24]
    0xe0010e40    0x38    bne e0010e8c <checkValidIPCBuffer+0x84>
    0xe0010e44    0x3c    uxtb r2, r2
    0xe0010e48    0x40    cmp r2, #1
    0xe0010e4c    0x44    lsreq r3, r3, #31
    0xe0010e50    0x48    ubfxne r3, r3, #29, #1
    0xe0010e54    0x4c    cmp r3, #0
    0xe0010e58    0x50    movwne r3, #36896 
    0xe0010e5c    0x54    movtne r3, #57346 
    0xe0010e60    0x58    movne r0, #3
    0xe0010e64    0x5c    strne r0, [r3, #24]
    0xe0010e68    0x60    bne e0010e8c <checkValidIPCBuffer+0x84>
    0xe0010e6c    0x64    ubfx r0, r0, #0, #9
    0xe0010e70    0x68    cmp r0, #0
    0xe0010e74    0x6c    movwne r3, #36896 
    0xe0010e78    0x70    movtne r3, #57346 
    0xe0010e7c    0x74    movne r2, #5
    0xe0010e80    0x78    strne r2, [r3, #24]
    0xe0010e84    0x7c    movne r0, #3
    0xe0010e88    0x80    moveq r0, #0
    0xe0010e8c    0x84    add sp, sp, #8
    0xe0010e90    0x88    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `checkValidIPCBuffer` has 81 nodes.

Section findPDForASID (70 of 293)
=================================

Deriving specifications
-----------------------

Section `findPDForASID` consists of 32 instructions.


Stack analysis
---------------

Section `findPDForASID` expects pointer to stack in r0.
6 stack accesses found. Annotated code for `findPDForASID`:

    0xe0010a84     0x0    movw r3, #37576 
    0xe0010a88     0x4    movt r3, #57346 
    0xe0010a8c     0x8    lsr r2, r1, #10
    0xe0010a90     0xc    ldr r3, [r3, r2, lsl #2]
    0xe0010a94    0x10    cmp r3, #0
    0xe0010a98    0x14    beq e0010abc <findPDForASID+0x38>
    0xe0010a9c    0x18    ubfx r1, r1, #0, #10
    0xe0010aa0    0x1c    ldr r3, [r3, r1, lsl #2]
    0xe0010aa4    0x20    cmp r3, #0
    0xe0010aa8    0x24    beq e0010ae0 <findPDForASID+0x5c>
    0xe0010aac    0x28    mov r2, #0
    0xe0010ab0    0x2c    str r2, [r0]          ; stack access
    0xe0010ab4    0x30    str r3, [r0, #4]      ; stack access
    0xe0010ab8    0x34    bx lr
    0xe0010abc    0x38    movw r3, #36884 
    0xe0010ac0    0x3c    movt r3, #57346 
    0xe0010ac4    0x40    mov r2, #0
    0xe0010ac8    0x44    str r2, [r3]
    0xe0010acc    0x48    str r2, [r3, #4]
    0xe0010ad0    0x4c    mov r3, #2
    0xe0010ad4    0x50    str r3, [r0]          ; stack access
    0xe0010ad8    0x54    str r2, [r0, #4]      ; stack access
    0xe0010adc    0x58    bx lr
    0xe0010ae0    0x5c    movw r3, #36884 
    0xe0010ae4    0x60    movt r3, #57346 
    0xe0010ae8    0x64    mov r2, #0
    0xe0010aec    0x68    str r2, [r3]
    0xe0010af0    0x6c    str r2, [r3, #4]
    0xe0010af4    0x70    mov r3, #2
    0xe0010af8    0x74    str r3, [r0]          ; stack access
    0xe0010afc    0x78    str r2, [r0, #4]      ; stack access
    0xe0010b00    0x7c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `findPDForASID` has 51 nodes.

Section maskVMRights (71 of 293)
================================

Deriving specifications
-----------------------

Section `maskVMRights` consists of 20 instructions.


Stack analysis
---------------

No stack accesses found. Code for `maskVMRights`:

    0xe0010a34     0x0    cmp r0, #0
    0xe0010a38     0x4    bxeq lr
    0xe0010a3c     0x8    cmp r0, #2
    0xe0010a40     0xc    beq e0010a54 <maskVMRights+0x20>
    0xe0010a44    0x10    cmp r0, #3
    0xe0010a48    0x14    beq e0010a64 <maskVMRights+0x30>
    0xe0010a4c    0x18    mov r0, #1
    0xe0010a50    0x1c    bx lr
    0xe0010a54    0x20    ubfx r1, r1, #1, #1
    0xe0010a58    0x24    cmp r1, #0
    0xe0010a5c    0x28    moveq r0, #1
    0xe0010a60    0x2c    bx lr
    0xe0010a64    0x30    tst r1, #2
    0xe0010a68    0x34    beq e0010a7c <maskVMRights+0x48>
    0xe0010a6c    0x38    and r1, r1, #1
    0xe0010a70    0x3c    cmp r1, #0
    0xe0010a74    0x40    moveq r0, #2
    0xe0010a78    0x44    bx lr
    0xe0010a7c    0x48    mov r0, #1
    0xe0010a80    0x4c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maskVMRights` has 37 nodes.

Section Arch_activateIdleThread (72 of 293)
===========================================

Deriving specifications
-----------------------

Section `Arch_activateIdleThread` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_activateIdleThread`:

    0xe0010a30    0x0    bx lr

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_activateIdleThread` has 2 nodes.

Section loadHWASID (73 of 293)
==============================

Deriving specifications
-----------------------

Section `loadHWASID` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `loadHWASID`:

    0xe0010868     0x0    movw r3, #37576 
    0xe001086c     0x4    movt r3, #57346 
    0xe0010870     0x8    lsr r2, r0, #10
    0xe0010874     0xc    ldr r3, [r3, r2, lsl #2]
    0xe0010878    0x10    ubfx r0, r0, #0, #10
    0xe001087c    0x14    ldr r3, [r3, r0, lsl #2]
    0xe0010880    0x18    add r3, r3, #12288 
    0xe0010884    0x1c    ldr r0, [r3, #4032] 
    0xe0010888    0x20    bx lr

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `loadHWASID` has 13 nodes.

Section idle_thread (74 of 293)
===============================

Deriving specifications
-----------------------

Section `idle_thread` consists of 2 instructions.
 MSR (cpsr, imm).+Skipping e320f003 wfi


Stack analysis
---------------

No stack accesses found. Code for `idle_thread`:

    0xe0010860    0x0    wfi
    0xe0010864    0x4    b e0010860 <idle_thread>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `idle_thread` has 3 nodes.

Section lockTLBEntryCritical (75 of 293)
========================================

Deriving specifications
-----------------------

Section `lockTLBEntryCritical` consists of 8 instructions.
Skipping ee080f37 mcr 15, 0, r0, cr8, cr7, {1}
Skipping ee0a1f30 mcr 15, 0, r1, cr10, cr0, {1}
Skipping ee0a0f31 mcr 15, 0, r0, cr10, cr1, {1}
Skipping ee0a2f30 mcr 15, 0, r2, cr10, cr0, {1}
Skipping ee0a1f10 mcr 15, 0, r1, cr10, cr0, {0}
Skipping ee0a0f11 mcr 15, 0, r0, cr10, cr1, {0}
Skipping ee0a2f10 mcr 15, 0, r2, cr10, cr0, {0}


Stack analysis
---------------

No stack accesses found. Code for `lockTLBEntryCritical`:

    0xe0010840     0x0    mcr 15, 0, r0, cr8, cr7, {1}
    0xe0010844     0x4    mcr 15, 0, r1, cr10, cr0, {1}
    0xe0010848     0x8    mcr 15, 0, r0, cr10, cr1, {1}
    0xe001084c     0xc    mcr 15, 0, r2, cr10, cr0, {1}
    0xe0010850    0x10    mcr 15, 0, r1, cr10, cr0, {0}
    0xe0010854    0x14    mcr 15, 0, r0, cr10, cr1, {0}
    0xe0010858    0x18    mcr 15, 0, r2, cr10, cr0, {0}
    0xe001085c    0x1c    bx lr

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lockTLBEntryCritical` has 16 nodes.

Section kernel_data_fault (76 of 293)
=====================================

Deriving specifications
-----------------------

Section `kernel_data_fault` consists of 3 instructions.
Skipping ee159f10 mrc 15, 0, r9, cr5, cr0, {0}
Skipping ee16af10 mrc 15, 0, sl, cr6, cr0, {0}


Stack analysis
---------------

No stack accesses found. Code for `kernel_data_fault`:

    0xe00100e0    0x0    mrc 15, 0, r9, cr5, cr0, {0}
    0xe00100e4    0x4    mrc 15, 0, sl, cr6, cr0, {0}
    0xe00100e8    0x8    b e00100e8 <kernel_data_fault+0x8>

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `kernel_data_fault` has 5 nodes.

Section kernel_prefetch_fault (77 of 293)
=========================================

Deriving specifications
-----------------------

Section `kernel_prefetch_fault` consists of 2 instructions.
Skipping ee159f30 mrc 15, 0, r9, cr5, cr0, {1}


Stack analysis
---------------

No stack accesses found. Code for `kernel_prefetch_fault`:

    0xe00100b0    0x0    mrc 15, 0, r9, cr5, cr0, {1}
    0xe00100b4    0x4    b e00100b4 <kernel_prefetch_fault+0x4>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `kernel_prefetch_fault` has 3 nodes.

Section bi_finalise (78 of 293)
===============================

Deriving specifications
-----------------------

Section `bi_finalise` consists of 8 instructions.


Stack analysis
---------------

No stack accesses found. Code for `bi_finalise`:

    0xe0002334     0x0    movw r3, #47104 
    0xe0002338     0x4    movt r3, #57345 
    0xe000233c     0x8    ldr r1, [r3, #128] 
    0xe0002340     0xc    ldr r2, [r3, #132] 
    0xe0002344    0x10    ldr r3, [r3, #124] 
    0xe0002348    0x14    str r1, [r3, #20]
    0xe000234c    0x18    str r2, [r3, #24]
    0xe0002350    0x1c    bx lr

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `bi_finalise` has 14 nodes.

Section init_core_state (79 of 293)
===================================

Deriving specifications
-----------------------

Section `init_core_state` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `init_core_state`:

    0xe0002058     0x0    movw r3, #36892 
    0xe000205c     0x4    movt r3, #57346 
    0xe0002060     0x8    str r0, [r3]
    0xe0002064     0xc    movw r3, #13900 
    0xe0002068    0x10    movt r3, #57347 
    0xe000206c    0x14    movw r2, #36880 
    0xe0002070    0x18    movt r2, #57346 
    0xe0002074    0x1c    ldr r2, [r2]
    0xe0002078    0x20    str r2, [r3]
    0xe000207c    0x24    bx lr

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_core_state` has 14 nodes.

Section create_it_asid_pool (80 of 293)
=======================================

Deriving specifications
-----------------------

Section `create_it_asid_pool` consists of 360 instructions.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.


Stack analysis
---------------

Section `create_it_asid_pool` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `create_it_asid_pool`:

    0xe0001ab8      0x0    push {r4, lr}         ; stack access
    0xe0001abc      0x4    sub sp, sp, #8
    0xe0001ac0      0x8    add r3, sp, #8
    0xe0001ac4      0xc    stmdb r3, {r1, r2}    ; stack access
    0xe0001ac8     0x10    movw r3, #47104 
    0xe0001acc     0x14    movt r3, #57345 
    0xe0001ad0     0x18    ldr r2, [r3, #144] 
    0xe0001ad4     0x1c    bic r2, r2, #15
    0xe0001ad8     0x20    orr r2, r2, #5
    0xe0001adc     0x24    ldr r3, [sp]          ; stack access
    0xe0001ae0     0x28    ldr r4, [sp, #4]      ; stack access
    0xe0001ae4     0x2c    and ip, r3, #14
    0xe0001ae8     0x30    cmp ip, #14
    0xe0001aec     0x34    beq e0001bf8 <create_it_asid_pool+0x140>
    0xe0001af0     0x38    and r1, r3, #15
    0xe0001af4     0x3c    sub lr, r1, #2
    0xe0001af8     0x40    cmp lr, #60 
    0xe0001afc     0x44    ldrls pc, [pc, lr, lsl #2]
    0xe0001b00     0x48    b e0001e74 <create_it_asid_pool+0x3bc>
    0xe0001b04     0x4c    .word 0xe0001d00
    0xe0001b08     0x50    .word 0xe0001e74
    0xe0001b0c     0x54    .word 0xe0001e2c
    0xe0001b10     0x58    .word 0xe0001e74
    0xe0001b14     0x5c    .word 0xe0001e34
    0xe0001b18     0x60    .word 0xe0001e74
    0xe0001b1c     0x64    .word 0xe000201c
    0xe0001b20     0x68    .word 0xe0001e74
    0xe0001b24     0x6c    .word 0xe0001e3c
    0xe0001b28     0x70    .word 0xe0001e74
    0xe0001b2c     0x74    .word 0xe0001e44
    0xe0001b30     0x78    .word 0xe0001e74
    0xe0001b34     0x7c    .word 0xe000201c
    0xe0001b38     0x80    .word 0xe0001e74
    0xe0001b3c     0x84    .word 0xe0001e74
    0xe0001b40     0x88    .word 0xe0001e74
    0xe0001b44     0x8c    .word 0xe0001e74
    0xe0001b48     0x90    .word 0xe0001e74
    0xe0001b4c     0x94    .word 0xe0001e74
    0xe0001b50     0x98    .word 0xe0001e74
    0xe0001b54     0x9c    .word 0xe0001e74
    0xe0001b58     0xa0    .word 0xe0001e74
    0xe0001b5c     0xa4    .word 0xe0001e74
    0xe0001b60     0xa8    .word 0xe0001e74
    0xe0001b64     0xac    .word 0xe0001e74
    0xe0001b68     0xb0    .word 0xe0001e74
    0xe0001b6c     0xb4    .word 0xe0001e74
    0xe0001b70     0xb8    .word 0xe0001e74
    0xe0001b74     0xbc    .word 0xe000201c
    0xe0001b78     0xc0    .word 0xe0001e74
    0xe0001b7c     0xc4    .word 0xe0001e74
    0xe0001b80     0xc8    .word 0xe0001e74
    0xe0001b84     0xcc    .word 0xe0001e74
    0xe0001b88     0xd0    .word 0xe0001e74
    0xe0001b8c     0xd4    .word 0xe0001e74
    0xe0001b90     0xd8    .word 0xe0001e74
    0xe0001b94     0xdc    .word 0xe0001e74
    0xe0001b98     0xe0    .word 0xe0001e74
    0xe0001b9c     0xe4    .word 0xe0001e74
    0xe0001ba0     0xe8    .word 0xe0001e74
    0xe0001ba4     0xec    .word 0xe0001e74
    0xe0001ba8     0xf0    .word 0xe0001e74
    0xe0001bac     0xf4    .word 0xe0001e74
    0xe0001bb0     0xf8    .word 0xe0001e74
    0xe0001bb4     0xfc    .word 0xe0001e50
    0xe0001bb8    0x100    .word 0xe0001e74
    0xe0001bbc    0x104    .word 0xe0001e74
    0xe0001bc0    0x108    .word 0xe0001e74
    0xe0001bc4    0x10c    .word 0xe0001e74
    0xe0001bc8    0x110    .word 0xe0001e74
    0xe0001bcc    0x114    .word 0xe0001e74
    0xe0001bd0    0x118    .word 0xe0001e74
    0xe0001bd4    0x11c    .word 0xe0001e74
    0xe0001bd8    0x120    .word 0xe0001e74
    0xe0001bdc    0x124    .word 0xe0001e74
    0xe0001be0    0x128    .word 0xe0001e74
    0xe0001be4    0x12c    .word 0xe0001e74
    0xe0001be8    0x130    .word 0xe0001e74
    0xe0001bec    0x134    .word 0xe0001e74
    0xe0001bf0    0x138    .word 0xe0001e74
    0xe0001bf4    0x13c    .word 0xe000201c
    0xe0001bf8    0x140    uxtb r1, r3
    0xe0001bfc    0x144    sub lr, r1, #2
    0xe0001c00    0x148    cmp lr, #60 
    0xe0001c04    0x14c    ldrls pc, [pc, lr, lsl #2]
    0xe0001c08    0x150    b e0001e74 <create_it_asid_pool+0x3bc>
    0xe0001c0c    0x154    .word 0xe0001d00
    0xe0001c10    0x158    .word 0xe0001e74
    0xe0001c14    0x15c    .word 0xe0001e2c
    0xe0001c18    0x160    .word 0xe0001e74
    0xe0001c1c    0x164    .word 0xe0001e34
    0xe0001c20    0x168    .word 0xe0001e74
    0xe0001c24    0x16c    .word 0xe0002038
    0xe0001c28    0x170    .word 0xe0001e74
    0xe0001c2c    0x174    .word 0xe0001e3c
    0xe0001c30    0x178    .word 0xe0001e74
    0xe0001c34    0x17c    .word 0xe0001e44
    0xe0001c38    0x180    .word 0xe0001e74
    0xe0001c3c    0x184    .word 0xe0002038
    0xe0001c40    0x188    .word 0xe0001e74
    0xe0001c44    0x18c    .word 0xe0001e74
    0xe0001c48    0x190    .word 0xe0001e74
    0xe0001c4c    0x194    .word 0xe0001e74
    0xe0001c50    0x198    .word 0xe0001e74
    0xe0001c54    0x19c    .word 0xe0001e74
    0xe0001c58    0x1a0    .word 0xe0001e74
    0xe0001c5c    0x1a4    .word 0xe0001e74
    0xe0001c60    0x1a8    .word 0xe0001e74
    0xe0001c64    0x1ac    .word 0xe0001e74
    0xe0001c68    0x1b0    .word 0xe0001e74
    0xe0001c6c    0x1b4    .word 0xe0001e74
    0xe0001c70    0x1b8    .word 0xe0001e74
    0xe0001c74    0x1bc    .word 0xe0001e74
    0xe0001c78    0x1c0    .word 0xe0001e74
    0xe0001c7c    0x1c4    .word 0xe0002038
    0xe0001c80    0x1c8    .word 0xe0001e74
    0xe0001c84    0x1cc    .word 0xe0001e74
    0xe0001c88    0x1d0    .word 0xe0001e74
    0xe0001c8c    0x1d4    .word 0xe0001e74
    0xe0001c90    0x1d8    .word 0xe0001e74
    0xe0001c94    0x1dc    .word 0xe0001e74
    0xe0001c98    0x1e0    .word 0xe0001e74
    0xe0001c9c    0x1e4    .word 0xe0001e74
    0xe0001ca0    0x1e8    .word 0xe0001e74
    0xe0001ca4    0x1ec    .word 0xe0001e74
    0xe0001ca8    0x1f0    .word 0xe0001e74
    0xe0001cac    0x1f4    .word 0xe0001e74
    0xe0001cb0    0x1f8    .word 0xe0001e74
    0xe0001cb4    0x1fc    .word 0xe0001e74
    0xe0001cb8    0x200    .word 0xe0001e74
    0xe0001cbc    0x204    .word 0xe0001e50
    0xe0001cc0    0x208    .word 0xe0001e74
    0xe0001cc4    0x20c    .word 0xe0001e74
    0xe0001cc8    0x210    .word 0xe0001e74
    0xe0001ccc    0x214    .word 0xe0001e74
    0xe0001cd0    0x218    .word 0xe0001e74
    0xe0001cd4    0x21c    .word 0xe0001e74
    0xe0001cd8    0x220    .word 0xe0001e74
    0xe0001cdc    0x224    .word 0xe0001e74
    0xe0001ce0    0x228    .word 0xe0001e74
    0xe0001ce4    0x22c    .word 0xe0001e74
    0xe0001ce8    0x230    .word 0xe0001e74
    0xe0001cec    0x234    .word 0xe0001e74
    0xe0001cf0    0x238    .word 0xe0001e74
    0xe0001cf4    0x23c    .word 0xe0001e74
    0xe0001cf8    0x240    .word 0xe0001e74
    0xe0001cfc    0x244    .word 0xe0002038
    0xe0001d00    0x248    bic r1, r3, #15
    0xe0001d04    0x24c    str r2, [r1, #96] 
    0xe0001d08    0x250    mov lr, #0
    0xe0001d0c    0x254    str lr, [r1, #100] 
    0xe0001d10    0x258    str lr, [r1, #104] 
    0xe0001d14    0x25c    mov lr, #3
    0xe0001d18    0x260    str lr, [r1, #108] 
    0xe0001d1c    0x264    cmp ip, #14
    0xe0001d20    0x268    beq e0002050 <create_it_asid_pool+0x598>
    0xe0001d24    0x26c    and ip, r3, #15
    0xe0001d28    0x270    sub r1, ip, #2
    0xe0001d2c    0x274    cmp r1, #60 
    0xe0001d30    0x278    ldrls pc, [pc, r1, lsl #2]
    0xe0001d34    0x27c    b e0001f58 <create_it_asid_pool+0x4a0>
    0xe0001d38    0x280    .word 0xe0001f08
    0xe0001d3c    0x284    .word 0xe0001f58
    0xe0001d40    0x288    .word 0xe0001f10
    0xe0001d44    0x28c    .word 0xe0001f58
    0xe0001d48    0x290    .word 0xe0001f18
    0xe0001d4c    0x294    .word 0xe0001f58
    0xe0001d50    0x298    .word 0xe0001fe4
    0xe0001d54    0x29c    .word 0xe0001f58
    0xe0001d58    0x2a0    .word 0xe0001f20
    0xe0001d5c    0x2a4    .word 0xe0001f58
    0xe0001d60    0x2a8    .word 0xe0001f28
    0xe0001d64    0x2ac    .word 0xe0001f58
    0xe0001d68    0x2b0    .word 0xe0001fe4
    0xe0001d6c    0x2b4    .word 0xe0001f58
    0xe0001d70    0x2b8    .word 0xe0001f58
    0xe0001d74    0x2bc    .word 0xe0001f58
    0xe0001d78    0x2c0    .word 0xe0001f58
    0xe0001d7c    0x2c4    .word 0xe0001f58
    0xe0001d80    0x2c8    .word 0xe0001f58
    0xe0001d84    0x2cc    .word 0xe0001f58
    0xe0001d88    0x2d0    .word 0xe0001f58
    0xe0001d8c    0x2d4    .word 0xe0001f58
    0xe0001d90    0x2d8    .word 0xe0001f58
    0xe0001d94    0x2dc    .word 0xe0001f58
    0xe0001d98    0x2e0    .word 0xe0001f58
    0xe0001d9c    0x2e4    .word 0xe0001f58
    0xe0001da0    0x2e8    .word 0xe0001f58
    0xe0001da4    0x2ec    .word 0xe0001f58
    0xe0001da8    0x2f0    .word 0xe0001fe4
    0xe0001dac    0x2f4    .word 0xe0001f58
    0xe0001db0    0x2f8    .word 0xe0001f58
    0xe0001db4    0x2fc    .word 0xe0001f58
    0xe0001db8    0x300    .word 0xe0001f58
    0xe0001dbc    0x304    .word 0xe0001f58
    0xe0001dc0    0x308    .word 0xe0001f58
    0xe0001dc4    0x30c    .word 0xe0001f58
    0xe0001dc8    0x310    .word 0xe0001f58
    0xe0001dcc    0x314    .word 0xe0001f58
    0xe0001dd0    0x318    .word 0xe0001f58
    0xe0001dd4    0x31c    .word 0xe0001f58
    0xe0001dd8    0x320    .word 0xe0001f58
    0xe0001ddc    0x324    .word 0xe0001f58
    0xe0001de0    0x328    .word 0xe0001f58
    0xe0001de4    0x32c    .word 0xe0001f58
    0xe0001de8    0x330    .word 0xe0001f34
    0xe0001dec    0x334    .word 0xe0001f58
    0xe0001df0    0x338    .word 0xe0001f58
    0xe0001df4    0x33c    .word 0xe0001f58
    0xe0001df8    0x340    .word 0xe0001f58
    0xe0001dfc    0x344    .word 0xe0001f58
    0xe0001e00    0x348    .word 0xe0001f58
    0xe0001e04    0x34c    .word 0xe0001f58
    0xe0001e08    0x350    .word 0xe0001f58
    0xe0001e0c    0x354    .word 0xe0001f58
    0xe0001e10    0x358    .word 0xe0001f58
    0xe0001e14    0x35c    .word 0xe0001f58
    0xe0001e18    0x360    .word 0xe0001f58
    0xe0001e1c    0x364    .word 0xe0001f58
    0xe0001e20    0x368    .word 0xe0001f58
    0xe0001e24    0x36c    .word 0xe0001f58
    0xe0001e28    0x370    .word 0xe0001fe4
    0xe0001e2c    0x374    bic r1, r4, #15
    0xe0001e30    0x378    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001e34    0x37c    bic r1, r3, #15
    0xe0001e38    0x380    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001e3c    0x384    bic r1, r3, #31
    0xe0001e40    0x388    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001e44    0x38c    bic r1, r3, #508 
    0xe0001e48    0x390    bic r1, r1, #3
    0xe0001e4c    0x394    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001e50    0x398    lsr r1, r3, #8
    0xe0001e54    0x39c    and lr, r1, #63 
    0xe0001e58    0x3a0    cmp lr, #32
    0xe0001e5c    0x3a4    andne r1, r1, #31
    0xe0001e60    0x3a8    moveq r1, #4
    0xe0001e64    0x3ac    add lr, r1, #1
    0xe0001e68    0x3b0    mvn r1, #0
    0xe0001e6c    0x3b4    and r1, r4, r1, lsl lr
    0xe0001e70    0x3b8    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001e74    0x3bc    sub lr, r1, #1
    0xe0001e78    0x3c0    cmp lr, #8
    0xe0001e7c    0x3c4    ldrls pc, [pc, lr, lsl #2]
    0xe0001e80    0x3c8    b e0001f00 <create_it_asid_pool+0x448>
    0xe0001e84    0x3cc    .word 0xe0001ea8
    0xe0001e88    0x3d0    .word 0xe0001f00
    0xe0001e8c    0x3d4    .word 0xe0001ea8
    0xe0001e90    0x3d8    .word 0xe0001f00
    0xe0001e94    0x3dc    .word 0xe0001ef8
    0xe0001e98    0x3e0    .word 0xe0001f00
    0xe0001e9c    0x3e4    .word 0xe0001ee0
    0xe0001ea0    0x3e8    .word 0xe0001f00
    0xe0001ea4    0x3ec    .word 0xe0001eec
    0xe0001ea8    0x3f0    cmp r1, #1
    0xe0001eac    0x3f4    beq e0001ec0 <create_it_asid_pool+0x408>
    0xe0001eb0    0x3f8    cmp r1, #3
    0xe0001eb4    0x3fc    beq e0001ed0 <create_it_asid_pool+0x418>
    0xe0001eb8    0x400    mov r1, #0
    0xe0001ebc    0x404    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001ec0    0x408    lsl r1, r3, #8
    0xe0001ec4    0x40c    bic r1, r1, #4080 
    0xe0001ec8    0x410    bic r1, r1, #15
    0xe0001ecc    0x414    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001ed0    0x418    lsl r1, r3, #10
    0xe0001ed4    0x41c    bic r1, r1, #16320 
    0xe0001ed8    0x420    bic r1, r1, #63 
    0xe0001edc    0x424    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001ee0    0x428    bic r1, r3, #1020 
    0xe0001ee4    0x42c    bic r1, r1, #3
    0xe0001ee8    0x430    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001eec    0x434    bic r1, r3, #16320 
    0xe0001ef0    0x438    bic r1, r1, #63 
    0xe0001ef4    0x43c    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001ef8    0x440    bic r1, r3, #15
    0xe0001efc    0x444    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001f00    0x448    mov r1, #0
    0xe0001f04    0x44c    b e0001d04 <create_it_asid_pool+0x24c>
    0xe0001f08    0x450    bic r3, r3, #15
    0xe0001f0c    0x454    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001f10    0x458    bic r3, r4, #15
    0xe0001f14    0x45c    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001f18    0x460    bic r3, r3, #15
    0xe0001f1c    0x464    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001f20    0x468    bic r3, r3, #31
    0xe0001f24    0x46c    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001f28    0x470    bic r3, r3, #508 
    0xe0001f2c    0x474    bic r3, r3, #3
    0xe0001f30    0x478    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001f34    0x47c    lsr r3, r3, #8
    0xe0001f38    0x480    and r1, r3, #63 
    0xe0001f3c    0x484    cmp r1, #32
    0xe0001f40    0x488    andne r3, r3, #31
    0xe0001f44    0x48c    moveq r3, #4
    0xe0001f48    0x490    add r1, r3, #1
    0xe0001f4c    0x494    mvn r3, #0
    0xe0001f50    0x498    and r3, r4, r3, lsl r1
    0xe0001f54    0x49c    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001f58    0x4a0    sub r1, ip, #1
    0xe0001f5c    0x4a4    cmp r1, #8
    0xe0001f60    0x4a8    ldrls pc, [pc, r1, lsl #2]
    0xe0001f64    0x4ac    b e0002014 <create_it_asid_pool+0x55c>
    0xe0001f68    0x4b0    .word 0xe0001f8c
    0xe0001f6c    0x4b4    .word 0xe0002014
    0xe0001f70    0x4b8    .word 0xe0001f8c
    0xe0001f74    0x4bc    .word 0xe0002014
    0xe0001f78    0x4c0    .word 0xe0001fdc
    0xe0001f7c    0x4c4    .word 0xe0002014
    0xe0001f80    0x4c8    .word 0xe0001fc4
    0xe0001f84    0x4cc    .word 0xe0002014
    0xe0001f88    0x4d0    .word 0xe0001fd0
    0xe0001f8c    0x4d4    cmp ip, #1
    0xe0001f90    0x4d8    beq e0001fa4 <create_it_asid_pool+0x4ec>
    0xe0001f94    0x4dc    cmp ip, #3
    0xe0001f98    0x4e0    beq e0001fb4 <create_it_asid_pool+0x4fc>
    0xe0001f9c    0x4e4    mov r3, #0
    0xe0001fa0    0x4e8    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001fa4    0x4ec    lsl r3, r3, #8
    0xe0001fa8    0x4f0    bic r3, r3, #4080 
    0xe0001fac    0x4f4    bic r3, r3, #15
    0xe0001fb0    0x4f8    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001fb4    0x4fc    lsl r3, r3, #10
    0xe0001fb8    0x500    bic r3, r3, #16320 
    0xe0001fbc    0x504    bic r3, r3, #63 
    0xe0001fc0    0x508    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001fc4    0x50c    bic r3, r3, #1020 
    0xe0001fc8    0x510    bic r3, r3, #3
    0xe0001fcc    0x514    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001fd0    0x518    bic r3, r3, #16320 
    0xe0001fd4    0x51c    bic r3, r3, #63 
    0xe0001fd8    0x520    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001fdc    0x524    bic r3, r3, #15
    0xe0001fe0    0x528    b e0001fe8 <create_it_asid_pool+0x530>
    0xe0001fe4    0x52c    mov r3, #0
    0xe0001fe8    0x530    mov r1, #11
    0xe0001fec    0x534    str r1, [r3, #80] 
    0xe0001ff0    0x538    mov r1, #0
    0xe0001ff4    0x53c    str r1, [r3, #84] 
    0xe0001ff8    0x540    str r1, [r3, #88] 
    0xe0001ffc    0x544    mov ip, #3
    0xe0002000    0x548    str ip, [r3, #92] 
    0xe0002004    0x54c    str r2, [r0]          ; stack access
    0xe0002008    0x550    str r1, [r0, #4]      ; stack access
    0xe000200c    0x554    add sp, sp, #8
    0xe0002010    0x558    pop {r4, pc}          ; stack access
    0xe0002014    0x55c    mov r3, #0
    0xe0002018    0x560    b e0001fe8 <create_it_asid_pool+0x530>
    0xe000201c    0x564    mov r1, #0
    0xe0002020    0x568    str r2, [r1, #96] 
    0xe0002024    0x56c    str r1, [r1, #100] 
    0xe0002028    0x570    str r1, [r1, #104] 
    0xe000202c    0x574    mov ip, #3
    0xe0002030    0x578    str ip, [r1, #108] 
    0xe0002034    0x57c    b e0001d24 <create_it_asid_pool+0x26c>
    0xe0002038    0x580    mov r1, #0
    0xe000203c    0x584    str r2, [r1, #96] 
    0xe0002040    0x588    str r1, [r1, #100] 
    0xe0002044    0x58c    str r1, [r1, #104] 
    0xe0002048    0x590    mov ip, #3
    0xe000204c    0x594    str ip, [r1, #108] 
    0xe0002050    0x598    uxtb ip, r3
    0xe0002054    0x59c    b e0001d28 <create_it_asid_pool+0x270>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
159 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_it_asid_pool` has 812 nodes.

Section provide_cap (81 of 293)
===============================

Deriving specifications
-----------------------

Section `provide_cap` consists of 159 instructions.
 MOVCS (imm)..++
Switch found.
Switch found.


Stack analysis
---------------

6 stack accesses found. Annotated code for `provide_cap`:

    0xe00013e4      0x0    sub sp, sp, #16
    0xe00013e8      0x4    add ip, sp, #16
    0xe00013ec      0x8    stmdb ip, {r0, r1}    ; stack access
    0xe00013f0      0xc    mov r1, sp
    0xe00013f4     0x10    stm r1, {r2, r3}      ; stack access
    0xe00013f8     0x14    movw r3, #47104 
    0xe00013fc     0x18    movt r3, #57345 
    0xe0001400     0x1c    ldr r1, [r3, #128] 
    0xe0001404     0x20    ldr r3, [r3, #132] 
    0xe0001408     0x24    cmp r1, r3
    0xe000140c     0x28    movcs r0, #0
    0xe0001410     0x2c    bcc e000141c <provide_cap+0x38>
    0xe0001414     0x30    add sp, sp, #16
    0xe0001418     0x34    bx lr
    0xe000141c     0x38    ldr r3, [sp, #8]      ; stack access
    0xe0001420     0x3c    ldr ip, [sp, #12]     ; stack access
    0xe0001424     0x40    and r2, r3, #14
    0xe0001428     0x44    cmp r2, #14
    0xe000142c     0x48    andne r0, r3, #15
    0xe0001430     0x4c    uxtbeq r0, r3
    0xe0001434     0x50    sub r2, r0, #2
    0xe0001438     0x54    cmp r2, #60 
    0xe000143c     0x58    ldrls pc, [pc, r2, lsl #2]
    0xe0001440     0x5c    b e0001588 <provide_cap+0x1a4>
    0xe0001444     0x60    .word 0xe0001538
    0xe0001448     0x64    .word 0xe0001588
    0xe000144c     0x68    .word 0xe0001540
    0xe0001450     0x6c    .word 0xe0001588
    0xe0001454     0x70    .word 0xe0001548
    0xe0001458     0x74    .word 0xe0001588
    0xe000145c     0x78    .word 0xe0001614
    0xe0001460     0x7c    .word 0xe0001588
    0xe0001464     0x80    .word 0xe0001550
    0xe0001468     0x84    .word 0xe0001588
    0xe000146c     0x88    .word 0xe0001558
    0xe0001470     0x8c    .word 0xe0001588
    0xe0001474     0x90    .word 0xe0001614
    0xe0001478     0x94    .word 0xe0001588
    0xe000147c     0x98    .word 0xe0001588
    0xe0001480     0x9c    .word 0xe0001588
    0xe0001484     0xa0    .word 0xe0001588
    0xe0001488     0xa4    .word 0xe0001588
    0xe000148c     0xa8    .word 0xe0001588
    0xe0001490     0xac    .word 0xe0001588
    0xe0001494     0xb0    .word 0xe0001588
    0xe0001498     0xb4    .word 0xe0001588
    0xe000149c     0xb8    .word 0xe0001588
    0xe00014a0     0xbc    .word 0xe0001588
    0xe00014a4     0xc0    .word 0xe0001588
    0xe00014a8     0xc4    .word 0xe0001588
    0xe00014ac     0xc8    .word 0xe0001588
    0xe00014b0     0xcc    .word 0xe0001588
    0xe00014b4     0xd0    .word 0xe0001614
    0xe00014b8     0xd4    .word 0xe0001588
    0xe00014bc     0xd8    .word 0xe0001588
    0xe00014c0     0xdc    .word 0xe0001588
    0xe00014c4     0xe0    .word 0xe0001588
    0xe00014c8     0xe4    .word 0xe0001588
    0xe00014cc     0xe8    .word 0xe0001588
    0xe00014d0     0xec    .word 0xe0001588
    0xe00014d4     0xf0    .word 0xe0001588
    0xe00014d8     0xf4    .word 0xe0001588
    0xe00014dc     0xf8    .word 0xe0001588
    0xe00014e0     0xfc    .word 0xe0001588
    0xe00014e4    0x100    .word 0xe0001588
    0xe00014e8    0x104    .word 0xe0001588
    0xe00014ec    0x108    .word 0xe0001588
    0xe00014f0    0x10c    .word 0xe0001588
    0xe00014f4    0x110    .word 0xe0001564
    0xe00014f8    0x114    .word 0xe0001588
    0xe00014fc    0x118    .word 0xe0001588
    0xe0001500    0x11c    .word 0xe0001588
    0xe0001504    0x120    .word 0xe0001588
    0xe0001508    0x124    .word 0xe0001588
    0xe000150c    0x128    .word 0xe0001588
    0xe0001510    0x12c    .word 0xe0001588
    0xe0001514    0x130    .word 0xe0001588
    0xe0001518    0x134    .word 0xe0001588
    0xe000151c    0x138    .word 0xe0001588
    0xe0001520    0x13c    .word 0xe0001588
    0xe0001524    0x140    .word 0xe0001588
    0xe0001528    0x144    .word 0xe0001588
    0xe000152c    0x148    .word 0xe0001588
    0xe0001530    0x14c    .word 0xe0001588
    0xe0001534    0x150    .word 0xe0001614
    0xe0001538    0x154    bic r3, r3, #15
    0xe000153c    0x158    b e0001618 <provide_cap+0x234>
    0xe0001540    0x15c    bic r3, ip, #15
    0xe0001544    0x160    b e0001618 <provide_cap+0x234>
    0xe0001548    0x164    bic r3, r3, #15
    0xe000154c    0x168    b e0001618 <provide_cap+0x234>
    0xe0001550    0x16c    bic r3, r3, #31
    0xe0001554    0x170    b e0001618 <provide_cap+0x234>
    0xe0001558    0x174    bic r3, r3, #508 
    0xe000155c    0x178    bic r3, r3, #3
    0xe0001560    0x17c    b e0001618 <provide_cap+0x234>
    0xe0001564    0x180    lsr r2, r3, #8
    0xe0001568    0x184    and r3, r2, #63 
    0xe000156c    0x188    cmp r3, #32
    0xe0001570    0x18c    andne r3, r2, #31
    0xe0001574    0x190    moveq r3, #4
    0xe0001578    0x194    add r2, r3, #1
    0xe000157c    0x198    mvn r3, #0
    0xe0001580    0x19c    and r3, ip, r3, lsl r2
    0xe0001584    0x1a0    b e0001618 <provide_cap+0x234>
    0xe0001588    0x1a4    sub r2, r0, #1
    0xe000158c    0x1a8    cmp r2, #8
    0xe0001590    0x1ac    ldrls pc, [pc, r2, lsl #2]
    0xe0001594    0x1b0    b e0001658 <provide_cap+0x274>
    0xe0001598    0x1b4    .word 0xe00015bc
    0xe000159c    0x1b8    .word 0xe0001658
    0xe00015a0    0x1bc    .word 0xe00015bc
    0xe00015a4    0x1c0    .word 0xe0001658
    0xe00015a8    0x1c4    .word 0xe000160c
    0xe00015ac    0x1c8    .word 0xe0001658
    0xe00015b0    0x1cc    .word 0xe00015f4
    0xe00015b4    0x1d0    .word 0xe0001658
    0xe00015b8    0x1d4    .word 0xe0001600
    0xe00015bc    0x1d8    cmp r0, #1
    0xe00015c0    0x1dc    beq e00015d4 <provide_cap+0x1f0>
    0xe00015c4    0x1e0    cmp r0, #3
    0xe00015c8    0x1e4    beq e00015e4 <provide_cap+0x200>
    0xe00015cc    0x1e8    mov r3, #0
    0xe00015d0    0x1ec    b e0001618 <provide_cap+0x234>
    0xe00015d4    0x1f0    lsl r3, r3, #8
    0xe00015d8    0x1f4    bic r3, r3, #4080 
    0xe00015dc    0x1f8    bic r3, r3, #15
    0xe00015e0    0x1fc    b e0001618 <provide_cap+0x234>
    0xe00015e4    0x200    lsl r3, r3, #10
    0xe00015e8    0x204    bic r3, r3, #16320 
    0xe00015ec    0x208    bic r3, r3, #63 
    0xe00015f0    0x20c    b e0001618 <provide_cap+0x234>
    0xe00015f4    0x210    bic r3, r3, #1020 
    0xe00015f8    0x214    bic r3, r3, #3
    0xe00015fc    0x218    b e0001618 <provide_cap+0x234>
    0xe0001600    0x21c    bic r3, r3, #16320 
    0xe0001604    0x220    bic r3, r3, #63 
    0xe0001608    0x224    b e0001618 <provide_cap+0x234>
    0xe000160c    0x228    bic r3, r3, #15
    0xe0001610    0x22c    b e0001618 <provide_cap+0x234>
    0xe0001614    0x230    mov r3, #0
    0xe0001618    0x234    add r2, r3, r1, lsl #4
    0xe000161c    0x238    ldr r0, [sp]          ; stack access
    0xe0001620    0x23c    str r0, [r3, r1, lsl #4]
    0xe0001624    0x240    ldr r3, [sp, #4]      ; stack access
    0xe0001628    0x244    str r3, [r2, #4]
    0xe000162c    0x248    mov r3, #0
    0xe0001630    0x24c    str r3, [r2, #8]
    0xe0001634    0x250    mov r3, #3
    0xe0001638    0x254    str r3, [r2, #12]
    0xe000163c    0x258    movw r3, #47104 
    0xe0001640    0x25c    movt r3, #57345 
    0xe0001644    0x260    ldr r2, [r3, #128] 
    0xe0001648    0x264    add r2, r2, #1
    0xe000164c    0x268    str r2, [r3, #128] 
    0xe0001650    0x26c    mov r0, #1
    0xe0001654    0x270    b e0001414 <provide_cap+0x30>
    0xe0001658    0x274    mov r3, #0
    0xe000165c    0x278    b e0001618 <provide_cap+0x234>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
89 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `provide_cap` has 333 nodes.

Section calculate_extra_bi_size_bits (82 of 293)
================================================

Deriving specifications
-----------------------

Section `calculate_extra_bi_size_bits` consists of 14 instructions.
 CMP (reg-shift).....+++++
 RSBHI (imm)....+++


Stack analysis
---------------

No stack accesses found. Code for `calculate_extra_bi_size_bits`:

    0xe00013ac     0x0    subs r2, r0, #0
    0xe00013b0     0x4    beq e00013dc <calculate_extra_bi_size_bits+0x30>
    0xe00013b4     0x8    sub r3, r2, #1
    0xe00013b8     0xc    bic r3, r3, #4080 
    0xe00013bc    0x10    bic r3, r3, #15
    0xe00013c0    0x14    add r3, r3, #4096 
    0xe00013c4    0x18    clz r3, r3
    0xe00013c8    0x1c    rsb r0, r3, #31
    0xe00013cc    0x20    mov r1, #1
    0xe00013d0    0x24    cmp r2, r1, lsl r0
    0xe00013d4    0x28    rsbhi r0, r3, #32
    0xe00013d8    0x2c    bx lr
    0xe00013dc    0x30    mov r0, r2
    0xe00013e0    0x34    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `calculate_extra_bi_size_bits` has 20 nodes.

Section create_domain_cap (83 of 293)
=====================================

Deriving specifications
-----------------------

Section `create_domain_cap` consists of 141 instructions.
Switch found.
Switch found.


Stack analysis
---------------

3 stack accesses found. Annotated code for `create_domain_cap`:

    0xe0000f00      0x0    sub sp, sp, #8
    0xe0000f04      0x4    add r3, sp, #8
    0xe0000f08      0x8    stmdb r3, {r0, r1}    ; stack access
    0xe0000f0c      0xc    ldr r3, [sp]          ; stack access
    0xe0000f10     0x10    ldr r0, [sp, #4]      ; stack access
    0xe0000f14     0x14    and r2, r3, #14
    0xe0000f18     0x18    cmp r2, #14
    0xe0000f1c     0x1c    andne r1, r3, #15
    0xe0000f20     0x20    uxtbeq r1, r3
    0xe0000f24     0x24    sub r2, r1, #2
    0xe0000f28     0x28    cmp r2, #60 
    0xe0000f2c     0x2c    ldrls pc, [pc, r2, lsl #2]
    0xe0000f30     0x30    b e0001078 <create_domain_cap+0x178>
    0xe0000f34     0x34    .word 0xe0001028
    0xe0000f38     0x38    .word 0xe0001078
    0xe0000f3c     0x3c    .word 0xe0001030
    0xe0000f40     0x40    .word 0xe0001078
    0xe0000f44     0x44    .word 0xe0001038
    0xe0000f48     0x48    .word 0xe0001078
    0xe0000f4c     0x4c    .word 0xe0001104
    0xe0000f50     0x50    .word 0xe0001078
    0xe0000f54     0x54    .word 0xe0001040
    0xe0000f58     0x58    .word 0xe0001078
    0xe0000f5c     0x5c    .word 0xe0001048
    0xe0000f60     0x60    .word 0xe0001078
    0xe0000f64     0x64    .word 0xe0001104
    0xe0000f68     0x68    .word 0xe0001078
    0xe0000f6c     0x6c    .word 0xe0001078
    0xe0000f70     0x70    .word 0xe0001078
    0xe0000f74     0x74    .word 0xe0001078
    0xe0000f78     0x78    .word 0xe0001078
    0xe0000f7c     0x7c    .word 0xe0001078
    0xe0000f80     0x80    .word 0xe0001078
    0xe0000f84     0x84    .word 0xe0001078
    0xe0000f88     0x88    .word 0xe0001078
    0xe0000f8c     0x8c    .word 0xe0001078
    0xe0000f90     0x90    .word 0xe0001078
    0xe0000f94     0x94    .word 0xe0001078
    0xe0000f98     0x98    .word 0xe0001078
    0xe0000f9c     0x9c    .word 0xe0001078
    0xe0000fa0     0xa0    .word 0xe0001078
    0xe0000fa4     0xa4    .word 0xe0001104
    0xe0000fa8     0xa8    .word 0xe0001078
    0xe0000fac     0xac    .word 0xe0001078
    0xe0000fb0     0xb0    .word 0xe0001078
    0xe0000fb4     0xb4    .word 0xe0001078
    0xe0000fb8     0xb8    .word 0xe0001078
    0xe0000fbc     0xbc    .word 0xe0001078
    0xe0000fc0     0xc0    .word 0xe0001078
    0xe0000fc4     0xc4    .word 0xe0001078
    0xe0000fc8     0xc8    .word 0xe0001078
    0xe0000fcc     0xcc    .word 0xe0001078
    0xe0000fd0     0xd0    .word 0xe0001078
    0xe0000fd4     0xd4    .word 0xe0001078
    0xe0000fd8     0xd8    .word 0xe0001078
    0xe0000fdc     0xdc    .word 0xe0001078
    0xe0000fe0     0xe0    .word 0xe0001078
    0xe0000fe4     0xe4    .word 0xe0001054
    0xe0000fe8     0xe8    .word 0xe0001078
    0xe0000fec     0xec    .word 0xe0001078
    0xe0000ff0     0xf0    .word 0xe0001078
    0xe0000ff4     0xf4    .word 0xe0001078
    0xe0000ff8     0xf8    .word 0xe0001078
    0xe0000ffc     0xfc    .word 0xe0001078
    0xe0001000    0x100    .word 0xe0001078
    0xe0001004    0x104    .word 0xe0001078
    0xe0001008    0x108    .word 0xe0001078
    0xe000100c    0x10c    .word 0xe0001078
    0xe0001010    0x110    .word 0xe0001078
    0xe0001014    0x114    .word 0xe0001078
    0xe0001018    0x118    .word 0xe0001078
    0xe000101c    0x11c    .word 0xe0001078
    0xe0001020    0x120    .word 0xe0001078
    0xe0001024    0x124    .word 0xe0001104
    0xe0001028    0x128    bic r3, r3, #15
    0xe000102c    0x12c    b e0001108 <create_domain_cap+0x208>
    0xe0001030    0x130    bic r3, r0, #15
    0xe0001034    0x134    b e0001108 <create_domain_cap+0x208>
    0xe0001038    0x138    bic r3, r3, #15
    0xe000103c    0x13c    b e0001108 <create_domain_cap+0x208>
    0xe0001040    0x140    bic r3, r3, #31
    0xe0001044    0x144    b e0001108 <create_domain_cap+0x208>
    0xe0001048    0x148    bic r3, r3, #508 
    0xe000104c    0x14c    bic r3, r3, #3
    0xe0001050    0x150    b e0001108 <create_domain_cap+0x208>
    0xe0001054    0x154    lsr r3, r3, #8
    0xe0001058    0x158    and r2, r3, #63 
    0xe000105c    0x15c    cmp r2, #32
    0xe0001060    0x160    andne r3, r3, #31
    0xe0001064    0x164    moveq r3, #4
    0xe0001068    0x168    add r2, r3, #1
    0xe000106c    0x16c    mvn r3, #0
    0xe0001070    0x170    and r3, r0, r3, lsl r2
    0xe0001074    0x174    b e0001108 <create_domain_cap+0x208>
    0xe0001078    0x178    sub r2, r1, #1
    0xe000107c    0x17c    cmp r2, #8
    0xe0001080    0x180    ldrls pc, [pc, r2, lsl #2]
    0xe0001084    0x184    b e000112c <create_domain_cap+0x22c>
    0xe0001088    0x188    .word 0xe00010ac
    0xe000108c    0x18c    .word 0xe000112c
    0xe0001090    0x190    .word 0xe00010ac
    0xe0001094    0x194    .word 0xe000112c
    0xe0001098    0x198    .word 0xe00010fc
    0xe000109c    0x19c    .word 0xe000112c
    0xe00010a0    0x1a0    .word 0xe00010e4
    0xe00010a4    0x1a4    .word 0xe000112c
    0xe00010a8    0x1a8    .word 0xe00010f0
    0xe00010ac    0x1ac    cmp r1, #1
    0xe00010b0    0x1b0    beq e00010c4 <create_domain_cap+0x1c4>
    0xe00010b4    0x1b4    cmp r1, #3
    0xe00010b8    0x1b8    beq e00010d4 <create_domain_cap+0x1d4>
    0xe00010bc    0x1bc    mov r3, #0
    0xe00010c0    0x1c0    b e0001108 <create_domain_cap+0x208>
    0xe00010c4    0x1c4    lsl r3, r3, #8
    0xe00010c8    0x1c8    bic r3, r3, #4080 
    0xe00010cc    0x1cc    bic r3, r3, #15
    0xe00010d0    0x1d0    b e0001108 <create_domain_cap+0x208>
    0xe00010d4    0x1d4    lsl r3, r3, #10
    0xe00010d8    0x1d8    bic r3, r3, #16320 
    0xe00010dc    0x1dc    bic r3, r3, #63 
    0xe00010e0    0x1e0    b e0001108 <create_domain_cap+0x208>
    0xe00010e4    0x1e4    bic r3, r3, #1020 
    0xe00010e8    0x1e8    bic r3, r3, #3
    0xe00010ec    0x1ec    b e0001108 <create_domain_cap+0x208>
    0xe00010f0    0x1f0    bic r3, r3, #16320 
    0xe00010f4    0x1f4    bic r3, r3, #63 
    0xe00010f8    0x1f8    b e0001108 <create_domain_cap+0x208>
    0xe00010fc    0x1fc    bic r3, r3, #15
    0xe0001100    0x200    b e0001108 <create_domain_cap+0x208>
    0xe0001104    0x204    mov r3, #0
    0xe0001108    0x208    mov r2, #62 
    0xe000110c    0x20c    str r2, [r3, #176] 
    0xe0001110    0x210    mov r2, #0
    0xe0001114    0x214    str r2, [r3, #180] 
    0xe0001118    0x218    str r2, [r3, #184] 
    0xe000111c    0x21c    mov r2, #3
    0xe0001120    0x220    str r2, [r3, #188] 
    0xe0001124    0x224    add sp, sp, #8
    0xe0001128    0x228    bx lr
    0xe000112c    0x22c    mov r3, #0
    0xe0001130    0x230    b e0001108 <create_domain_cap+0x208>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
71 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_domain_cap` has 304 nodes.

Section create_root_cnode (84 of 293)
=====================================

Deriving specifications
-----------------------

Section `create_root_cnode` consists of 19 instructions.


Stack analysis
---------------

Section `create_root_cnode` expects pointer to stack in r0.
4 stack accesses found. Annotated code for `create_root_cnode`:

    0xe0000eb4     0x0    push {lr}             ; stack access
    0xe0000eb8     0x4    movw r3, #47104 
    0xe0000ebc     0x8    movt r3, #57345 
    0xe0000ec0     0xc    mov r2, #4096 
    0xe0000ec4    0x10    str r2, [r3, #132] 
    0xe0000ec8    0x14    ldr r1, [r3, #136] 
    0xe0000ecc    0x18    bic r3, r1, #31
    0xe0000ed0    0x1c    orr r3, r3, #10
    0xe0000ed4    0x20    add r2, r1, #32
    0xe0000ed8    0x24    str r3, [r1, #32]
    0xe0000edc    0x28    mov r1, #170917888 
    0xe0000ee0    0x2c    str r1, [r2, #4]
    0xe0000ee4    0x30    mov lr, #0
    0xe0000ee8    0x34    str lr, [r2, #8]
    0xe0000eec    0x38    mov lr, #3
    0xe0000ef0    0x3c    str lr, [r2, #12]
    0xe0000ef4    0x40    str r3, [r0]          ; stack access
    0xe0000ef8    0x44    str r1, [r0, #4]      ; stack access
    0xe0000efc    0x48    pop {pc}              ; stack access

Proving inst theorems
---------------------

19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_root_cnode` has 29 nodes.

Section write_slot (85 of 293)
==============================

Deriving specifications
-----------------------

Section `write_slot` consists of 12 instructions.
 STMIA;2,1...+
+
 STMIA;2,0...+


Stack analysis
---------------

2 stack accesses found. Annotated code for `write_slot`:

    0xe0000e84     0x0    sub sp, sp, #8
    0xe0000e88     0x4    mov r3, r0
    0xe0000e8c     0x8    mov r0, sp
    0xe0000e90     0xc    stm r0, {r1, r2}      ; stack access
    0xe0000e94    0x10    ldm r0, {r0, r1}      ; stack access
    0xe0000e98    0x14    stm r3, {r0, r2}
    0xe0000e9c    0x18    mov r2, #0
    0xe0000ea0    0x1c    str r2, [r3, #8]
    0xe0000ea4    0x20    mov r2, #3
    0xe0000ea8    0x24    str r2, [r3, #12]
    0xe0000eac    0x28    add sp, sp, #8
    0xe0000eb0    0x2c    bx lr

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `write_slot` has 18 nodes.

Section initTimer (86 of 293)
=============================

Deriving specifications
-----------------------

Section `initTimer` consists of 15 instructions.


Stack analysis
---------------

No stack accesses found. Code for `initTimer`:

    0xe0000b40     0x0    movw r3, #9983 
    0xe0000b44     0x4    movt r3, #65520 
    0xe0000b48     0x8    mov r2, #0
    0xe0000b4c     0xc    str r2, [r3, #-247] 
    0xe0000b50    0x10    str r2, [r3, #-243] 
    0xe0000b54    0x14    movw r2, #12960 
    0xe0000b58    0x18    movt r2, #15
    0xe0000b5c    0x1c    str r2, [r3, #-255] 
    0xe0000b60    0x20    ldr r2, [r3, #-247] 
    0xe0000b64    0x24    orr r2, r2, #6
    0xe0000b68    0x28    str r2, [r3, #-247] 
    0xe0000b6c    0x2c    ldr r2, [r3, #-247] 
    0xe0000b70    0x30    orr r2, r2, #1
    0xe0000b74    0x34    str r2, [r3, #-247] 
    0xe0000b78    0x38    bx lr

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initTimer` has 23 nodes.

Section initL2Cache (87 of 293)
===============================

Deriving specifications
-----------------------

Section `initL2Cache` consists of 66 instructions.
 MOVTEQ..++
 STREQ (+imm,pre)....+++


Stack analysis
---------------

No stack accesses found. Code for `initL2Cache`:

    0xe0000a38      0x0    movw r3, #12543 
    0xe0000a3c      0x4    movt r3, #65520 
    0xe0000a40      0x8    ldr r2, [r3, #1]
    0xe0000a44      0xc    bic r2, r2, #1
    0xe0000a48     0x10    str r2, [r3, #1]
    0xe0000a4c     0x14    mov r2, #0
    0xe0000a50     0x18    movt r2, #15367 
    0xe0000a54     0x1c    str r2, [r3, #5]
    0xe0000a58     0x20    movw r2, #289 
    0xe0000a5c     0x24    str r2, [r3, #9]
    0xe0000a60     0x28    str r2, [r3, #13]
    0xe0000a64     0x2c    mov r2, #805306368 
    0xe0000a68     0x30    str r2, [r3, #3681] 
    0xe0000a6c     0x34    movw r2, #65535 
    0xe0000a70     0x38    str r2, [r3, #1661] 
    0xe0000a74     0x3c    movw r2, #12543 
    0xe0000a78     0x40    movt r2, #65520 
    0xe0000a7c     0x44    ldr r3, [r2, #1661] 
    0xe0000a80     0x48    uxth r3, r3
    0xe0000a84     0x4c    cmp r3, #0
    0xe0000a88     0x50    bne e0000a7c <initL2Cache+0x44>
    0xe0000a8c     0x54    movw r3, #12543 
    0xe0000a90     0x58    movt r3, #65520 
    0xe0000a94     0x5c    ldr r3, [r3, #-251] 
    0xe0000a98     0x60    and r3, r3, #503316480 
    0xe0000a9c     0x64    cmp r3, #469762048 
    0xe0000aa0     0x68    beq e0000af0 <initL2Cache+0xb8>
    0xe0000aa4     0x6c    movw r3, #12543 
    0xe0000aa8     0x70    movt r3, #65520 
    0xe0000aac     0x74    ldr r3, [r3, #-251] 
    0xe0000ab0     0x78    and r3, r3, #503316480 
    0xe0000ab4     0x7c    cmp r3, #503316480 
    0xe0000ab8     0x80    movweq r3, #12543 
    0xe0000abc     0x84    movteq r3, #65520 
    0xe0000ac0     0x88    moveq r2, #0
    0xe0000ac4     0x8c    streq r2, [r3, #2129] 
    0xe0000ac8     0x90    movw r3, #12543 
    0xe0000acc     0x94    movt r3, #65520 
    0xe0000ad0     0x98    mov r2, #0
    0xe0000ad4     0x9c    str r2, [r3, #277] 
    0xe0000ad8     0xa0    movw r2, #511 
    0xe0000adc     0xa4    str r2, [r3, #289] 
    0xe0000ae0     0xa8    ldr r2, [r3, #1]
    0xe0000ae4     0xac    orr r2, r2, #1
    0xe0000ae8     0xb0    str r2, [r3, #1]
    0xe0000aec     0xb4    bx lr
    0xe0000af0     0xb8    movw r3, #12543 
    0xe0000af4     0xbc    movt r3, #65520 
    0xe0000af8     0xc0    mov r2, #0
    0xe0000afc     0xc4    str r2, [r3, #2049] 
    0xe0000b00     0xc8    str r2, [r3, #2053] 
    0xe0000b04     0xcc    str r2, [r3, #2057] 
    0xe0000b08     0xd0    str r2, [r3, #2061] 
    0xe0000b0c     0xd4    str r2, [r3, #2065] 
    0xe0000b10     0xd8    str r2, [r3, #2069] 
    0xe0000b14     0xdc    str r2, [r3, #2073] 
    0xe0000b18     0xe0    str r2, [r3, #2077] 
    0xe0000b1c     0xe4    str r2, [r3, #2081] 
    0xe0000b20     0xe8    str r2, [r3, #2085] 
    0xe0000b24     0xec    str r2, [r3, #2089] 
    0xe0000b28     0xf0    str r2, [r3, #2093] 
    0xe0000b2c     0xf4    str r2, [r3, #2097] 
    0xe0000b30     0xf8    str r2, [r3, #2101] 
    0xe0000b34     0xfc    str r2, [r3, #2105] 
    0xe0000b38    0x100    str r2, [r3, #2109] 
    0xe0000b3c    0x104    b e0000aa4 <initL2Cache+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
66 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initL2Cache` has 110 nodes.

Section get_avail_p_regs (88 of 293)
====================================

Deriving specifications
-----------------------

Section `get_avail_p_regs` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `get_avail_p_regs`:

    0xe0000a2c    0x0    movw r0, #17216 
    0xe0000a30    0x4    movt r0, #57344 
    0xe0000a34    0x8    bx lr

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `get_avail_p_regs` has 4 nodes.

Section get_num_avail_p_regs (89 of 293)
========================================

Deriving specifications
-----------------------

Section `get_num_avail_p_regs` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `get_num_avail_p_regs`:

    0xe0000a24    0x0    mov r0, #1
    0xe0000a28    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `get_num_avail_p_regs` has 3 nodes.

Section arm_errata (90 of 293)
==============================

Deriving specifications
-----------------------

Section `arm_errata` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `arm_errata`:

    0xe0000a08    0x0    bx lr

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_errata` has 2 nodes.

Section fpsimd_HWCapTest (91 of 293)
====================================

Deriving specifications
-----------------------

Section `fpsimd_HWCapTest` consists of 16 instructions.
Skipping ee113f50 mrc 15, 0, r3, cr1, cr0, {2}
Skipping ee013f50 mcr 15, 0, r3, cr1, cr0, {2}
Skipping f57ff06f isb sy
Skipping eef83a10 vmrs r3, fpexc
Skipping eee83a10 vmsr fpexc, r3
Skipping eef83a10 vmrs r3, fpexc


Stack analysis
---------------

No stack accesses found. Code for `fpsimd_HWCapTest`:

    0xe000097c     0x0    mrc 15, 0, r3, cr1, cr0, {2}
    0xe0000980     0x4    orr r3, r3, #15728640 
    0xe0000984     0x8    mcr 15, 0, r3, cr1, cr0, {2}
    0xe0000988     0xc    isb sy
    0xe000098c    0x10    .word 0xeef00a10
    0xe0000990    0x14    mov r3, r0
    0xe0000994    0x18    tst r3, #8388608 
    0xe0000998    0x1c    bne e00009b4 <fpsimd_HWCapTest+0x38>
    0xe000099c    0x20    vmrs r3, fpexc
    0xe00009a0    0x24    orr r3, r3, #-2147483648 
    0xe00009a4    0x28    vmsr fpexc, r3
    0xe00009a8    0x2c    vmrs r3, fpexc
    0xe00009ac    0x30    mov r0, #1
    0xe00009b0    0x34    bx lr
    0xe00009b4    0x38    mov r0, #0
    0xe00009b8    0x3c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `fpsimd_HWCapTest` has 25 nodes.

Section write_it_asid_pool (92 of 293)
======================================

Deriving specifications
-----------------------

Section `write_it_asid_pool` consists of 270 instructions.
Switch found.
Switch found.
Switch found.
Switch found.


Stack analysis
---------------

6 stack accesses found. Annotated code for `write_it_asid_pool`:

    0xe0000544      0x0    sub sp, sp, #16
    0xe0000548      0x4    add ip, sp, #16
    0xe000054c      0x8    stmdb ip, {r0, r1}    ; stack access
    0xe0000550      0xc    mov r1, sp
    0xe0000554     0x10    stm r1, {r2, r3}      ; stack access
    0xe0000558     0x14    ldr r3, [sp, #8]      ; stack access
    0xe000055c     0x18    ldr r1, [sp, #12]     ; stack access
    0xe0000560     0x1c    and r2, r3, #14
    0xe0000564     0x20    cmp r2, #14
    0xe0000568     0x24    andne r0, r3, #15
    0xe000056c     0x28    uxtbeq r0, r3
    0xe0000570     0x2c    sub r2, r0, #2
    0xe0000574     0x30    cmp r2, #60 
    0xe0000578     0x34    ldrls pc, [pc, r2, lsl #2]
    0xe000057c     0x38    b e00006c4 <write_it_asid_pool+0x180>
    0xe0000580     0x3c    .word 0xe0000674
    0xe0000584     0x40    .word 0xe00006c4
    0xe0000588     0x44    .word 0xe000067c
    0xe000058c     0x48    .word 0xe00006c4
    0xe0000590     0x4c    .word 0xe0000684
    0xe0000594     0x50    .word 0xe00006c4
    0xe0000598     0x54    .word 0xe0000754
    0xe000059c     0x58    .word 0xe00006c4
    0xe00005a0     0x5c    .word 0xe000068c
    0xe00005a4     0x60    .word 0xe00006c4
    0xe00005a8     0x64    .word 0xe0000694
    0xe00005ac     0x68    .word 0xe00006c4
    0xe00005b0     0x6c    .word 0xe0000754
    0xe00005b4     0x70    .word 0xe00006c4
    0xe00005b8     0x74    .word 0xe00006c4
    0xe00005bc     0x78    .word 0xe00006c4
    0xe00005c0     0x7c    .word 0xe00006c4
    0xe00005c4     0x80    .word 0xe00006c4
    0xe00005c8     0x84    .word 0xe00006c4
    0xe00005cc     0x88    .word 0xe00006c4
    0xe00005d0     0x8c    .word 0xe00006c4
    0xe00005d4     0x90    .word 0xe00006c4
    0xe00005d8     0x94    .word 0xe00006c4
    0xe00005dc     0x98    .word 0xe00006c4
    0xe00005e0     0x9c    .word 0xe00006c4
    0xe00005e4     0xa0    .word 0xe00006c4
    0xe00005e8     0xa4    .word 0xe00006c4
    0xe00005ec     0xa8    .word 0xe00006c4
    0xe00005f0     0xac    .word 0xe0000754
    0xe00005f4     0xb0    .word 0xe00006c4
    0xe00005f8     0xb4    .word 0xe00006c4
    0xe00005fc     0xb8    .word 0xe00006c4
    0xe0000600     0xbc    .word 0xe00006c4
    0xe0000604     0xc0    .word 0xe00006c4
    0xe0000608     0xc4    .word 0xe00006c4
    0xe000060c     0xc8    .word 0xe00006c4
    0xe0000610     0xcc    .word 0xe00006c4
    0xe0000614     0xd0    .word 0xe00006c4
    0xe0000618     0xd4    .word 0xe00006c4
    0xe000061c     0xd8    .word 0xe00006c4
    0xe0000620     0xdc    .word 0xe00006c4
    0xe0000624     0xe0    .word 0xe00006c4
    0xe0000628     0xe4    .word 0xe00006c4
    0xe000062c     0xe8    .word 0xe00006c4
    0xe0000630     0xec    .word 0xe00006a0
    0xe0000634     0xf0    .word 0xe00006c4
    0xe0000638     0xf4    .word 0xe00006c4
    0xe000063c     0xf8    .word 0xe00006c4
    0xe0000640     0xfc    .word 0xe00006c4
    0xe0000644    0x100    .word 0xe00006c4
    0xe0000648    0x104    .word 0xe00006c4
    0xe000064c    0x108    .word 0xe00006c4
    0xe0000650    0x10c    .word 0xe00006c4
    0xe0000654    0x110    .word 0xe00006c4
    0xe0000658    0x114    .word 0xe00006c4
    0xe000065c    0x118    .word 0xe00006c4
    0xe0000660    0x11c    .word 0xe00006c4
    0xe0000664    0x120    .word 0xe00006c4
    0xe0000668    0x124    .word 0xe00006c4
    0xe000066c    0x128    .word 0xe00006c4
    0xe0000670    0x12c    .word 0xe0000754
    0xe0000674    0x130    bic r1, r3, #15
    0xe0000678    0x134    b e0000758 <write_it_asid_pool+0x214>
    0xe000067c    0x138    bic r1, r1, #15
    0xe0000680    0x13c    b e0000758 <write_it_asid_pool+0x214>
    0xe0000684    0x140    bic r1, r3, #15
    0xe0000688    0x144    b e0000758 <write_it_asid_pool+0x214>
    0xe000068c    0x148    bic r1, r3, #31
    0xe0000690    0x14c    b e0000758 <write_it_asid_pool+0x214>
    0xe0000694    0x150    bic r1, r3, #508 
    0xe0000698    0x154    bic r1, r1, #3
    0xe000069c    0x158    b e0000758 <write_it_asid_pool+0x214>
    0xe00006a0    0x15c    lsr r3, r3, #8
    0xe00006a4    0x160    and r2, r3, #63 
    0xe00006a8    0x164    cmp r2, #32
    0xe00006ac    0x168    andne r3, r3, #31
    0xe00006b0    0x16c    moveq r3, #4
    0xe00006b4    0x170    add r3, r3, #1
    0xe00006b8    0x174    mvn r2, #0
    0xe00006bc    0x178    and r1, r1, r2, lsl r3
    0xe00006c0    0x17c    b e0000758 <write_it_asid_pool+0x214>
    0xe00006c4    0x180    sub r2, r0, #1
    0xe00006c8    0x184    cmp r2, #8
    0xe00006cc    0x188    ldrls pc, [pc, r2, lsl #2]
    0xe00006d0    0x18c    b e0000874 <write_it_asid_pool+0x330>
    0xe00006d4    0x190    .word 0xe00006f8
    0xe00006d8    0x194    .word 0xe0000874
    0xe00006dc    0x198    .word 0xe00006f8
    0xe00006e0    0x19c    .word 0xe0000874
    0xe00006e4    0x1a0    .word 0xe000074c
    0xe00006e8    0x1a4    .word 0xe0000874
    0xe00006ec    0x1a8    .word 0xe0000734
    0xe00006f0    0x1ac    .word 0xe0000874
    0xe00006f4    0x1b0    .word 0xe0000740
    0xe00006f8    0x1b4    cmp r0, #1
    0xe00006fc    0x1b8    beq e0000710 <write_it_asid_pool+0x1cc>
    0xe0000700    0x1bc    cmp r0, #3
    0xe0000704    0x1c0    beq e0000724 <write_it_asid_pool+0x1e0>
    0xe0000708    0x1c4    mov r3, #0
    0xe000070c    0x1c8    b e000071c <write_it_asid_pool+0x1d8>
    0xe0000710    0x1cc    lsl r3, r3, #8
    0xe0000714    0x1d0    bic r3, r3, #4080 
    0xe0000718    0x1d4    bic r3, r3, #15
    0xe000071c    0x1d8    mov r1, r3
    0xe0000720    0x1dc    b e0000758 <write_it_asid_pool+0x214>
    0xe0000724    0x1e0    lsl r3, r3, #10
    0xe0000728    0x1e4    bic r3, r3, #16320 
    0xe000072c    0x1e8    bic r3, r3, #63 
    0xe0000730    0x1ec    b e000071c <write_it_asid_pool+0x1d8>
    0xe0000734    0x1f0    bic r1, r3, #1020 
    0xe0000738    0x1f4    bic r1, r1, #3
    0xe000073c    0x1f8    b e0000758 <write_it_asid_pool+0x214>
    0xe0000740    0x1fc    bic r1, r3, #16320 
    0xe0000744    0x200    bic r1, r1, #63 
    0xe0000748    0x204    b e0000758 <write_it_asid_pool+0x214>
    0xe000074c    0x208    bic r1, r3, #15
    0xe0000750    0x20c    b e0000758 <write_it_asid_pool+0x214>
    0xe0000754    0x210    mov r1, #0
    0xe0000758    0x214    ldr r3, [sp]          ; stack access
    0xe000075c    0x218    ldr ip, [sp, #4]      ; stack access
    0xe0000760    0x21c    and r2, r3, #14
    0xe0000764    0x220    cmp r2, #14
    0xe0000768    0x224    andne r0, r3, #15
    0xe000076c    0x228    uxtbeq r0, r3
    0xe0000770    0x22c    sub r2, r0, #2
    0xe0000774    0x230    cmp r2, #60 
    0xe0000778    0x234    ldrls pc, [pc, r2, lsl #2]
    0xe000077c    0x238    b e00008cc <write_it_asid_pool+0x388>
    0xe0000780    0x23c    .word 0xe000087c
    0xe0000784    0x240    .word 0xe00008cc
    0xe0000788    0x244    .word 0xe0000884
    0xe000078c    0x248    .word 0xe00008cc
    0xe0000790    0x24c    .word 0xe000088c
    0xe0000794    0x250    .word 0xe00008cc
    0xe0000798    0x254    .word 0xe0000958
    0xe000079c    0x258    .word 0xe00008cc
    0xe00007a0    0x25c    .word 0xe0000894
    0xe00007a4    0x260    .word 0xe00008cc
    0xe00007a8    0x264    .word 0xe000089c
    0xe00007ac    0x268    .word 0xe00008cc
    0xe00007b0    0x26c    .word 0xe0000958
    0xe00007b4    0x270    .word 0xe00008cc
    0xe00007b8    0x274    .word 0xe00008cc
    0xe00007bc    0x278    .word 0xe00008cc
    0xe00007c0    0x27c    .word 0xe00008cc
    0xe00007c4    0x280    .word 0xe00008cc
    0xe00007c8    0x284    .word 0xe00008cc
    0xe00007cc    0x288    .word 0xe00008cc
    0xe00007d0    0x28c    .word 0xe00008cc
    0xe00007d4    0x290    .word 0xe00008cc
    0xe00007d8    0x294    .word 0xe00008cc
    0xe00007dc    0x298    .word 0xe00008cc
    0xe00007e0    0x29c    .word 0xe00008cc
    0xe00007e4    0x2a0    .word 0xe00008cc
    0xe00007e8    0x2a4    .word 0xe00008cc
    0xe00007ec    0x2a8    .word 0xe00008cc
    0xe00007f0    0x2ac    .word 0xe0000958
    0xe00007f4    0x2b0    .word 0xe00008cc
    0xe00007f8    0x2b4    .word 0xe00008cc
    0xe00007fc    0x2b8    .word 0xe00008cc
    0xe0000800    0x2bc    .word 0xe00008cc
    0xe0000804    0x2c0    .word 0xe00008cc
    0xe0000808    0x2c4    .word 0xe00008cc
    0xe000080c    0x2c8    .word 0xe00008cc
    0xe0000810    0x2cc    .word 0xe00008cc
    0xe0000814    0x2d0    .word 0xe00008cc
    0xe0000818    0x2d4    .word 0xe00008cc
    0xe000081c    0x2d8    .word 0xe00008cc
    0xe0000820    0x2dc    .word 0xe00008cc
    0xe0000824    0x2e0    .word 0xe00008cc
    0xe0000828    0x2e4    .word 0xe00008cc
    0xe000082c    0x2e8    .word 0xe00008cc
    0xe0000830    0x2ec    .word 0xe00008a8
    0xe0000834    0x2f0    .word 0xe00008cc
    0xe0000838    0x2f4    .word 0xe00008cc
    0xe000083c    0x2f8    .word 0xe00008cc
    0xe0000840    0x2fc    .word 0xe00008cc
    0xe0000844    0x300    .word 0xe00008cc
    0xe0000848    0x304    .word 0xe00008cc
    0xe000084c    0x308    .word 0xe00008cc
    0xe0000850    0x30c    .word 0xe00008cc
    0xe0000854    0x310    .word 0xe00008cc
    0xe0000858    0x314    .word 0xe00008cc
    0xe000085c    0x318    .word 0xe00008cc
    0xe0000860    0x31c    .word 0xe00008cc
    0xe0000864    0x320    .word 0xe00008cc
    0xe0000868    0x324    .word 0xe00008cc
    0xe000086c    0x328    .word 0xe00008cc
    0xe0000870    0x32c    .word 0xe0000958
    0xe0000874    0x330    mov r1, #0
    0xe0000878    0x334    b e0000758 <write_it_asid_pool+0x214>
    0xe000087c    0x338    bic r3, r3, #15
    0xe0000880    0x33c    b e000095c <write_it_asid_pool+0x418>
    0xe0000884    0x340    bic r3, ip, #15
    0xe0000888    0x344    b e000095c <write_it_asid_pool+0x418>
    0xe000088c    0x348    bic r3, r3, #15
    0xe0000890    0x34c    b e000095c <write_it_asid_pool+0x418>
    0xe0000894    0x350    bic r3, r3, #31
    0xe0000898    0x354    b e000095c <write_it_asid_pool+0x418>
    0xe000089c    0x358    bic r3, r3, #508 
    0xe00008a0    0x35c    bic r3, r3, #3
    0xe00008a4    0x360    b e000095c <write_it_asid_pool+0x418>
    0xe00008a8    0x364    lsr r2, r3, #8
    0xe00008ac    0x368    and r3, r2, #63 
    0xe00008b0    0x36c    cmp r3, #32
    0xe00008b4    0x370    andne r3, r2, #31
    0xe00008b8    0x374    moveq r3, #4
    0xe00008bc    0x378    add r2, r3, #1
    0xe00008c0    0x37c    mvn r3, #0
    0xe00008c4    0x380    and r3, ip, r3, lsl r2
    0xe00008c8    0x384    b e000095c <write_it_asid_pool+0x418>
    0xe00008cc    0x388    sub r2, r0, #1
    0xe00008d0    0x38c    cmp r2, #8
    0xe00008d4    0x390    ldrls pc, [pc, r2, lsl #2]
    0xe00008d8    0x394    b e0000974 <write_it_asid_pool+0x430>
    0xe00008dc    0x398    .word 0xe0000900
    0xe00008e0    0x39c    .word 0xe0000974
    0xe00008e4    0x3a0    .word 0xe0000900
    0xe00008e8    0x3a4    .word 0xe0000974
    0xe00008ec    0x3a8    .word 0xe0000950
    0xe00008f0    0x3ac    .word 0xe0000974
    0xe00008f4    0x3b0    .word 0xe0000938
    0xe00008f8    0x3b4    .word 0xe0000974
    0xe00008fc    0x3b8    .word 0xe0000944
    0xe0000900    0x3bc    cmp r0, #1
    0xe0000904    0x3c0    beq e0000918 <write_it_asid_pool+0x3d4>
    0xe0000908    0x3c4    cmp r0, #3
    0xe000090c    0x3c8    beq e0000928 <write_it_asid_pool+0x3e4>
    0xe0000910    0x3cc    mov r3, #0
    0xe0000914    0x3d0    b e000095c <write_it_asid_pool+0x418>
    0xe0000918    0x3d4    lsl r3, r3, #8
    0xe000091c    0x3d8    bic r3, r3, #4080 
    0xe0000920    0x3dc    bic r3, r3, #15
    0xe0000924    0x3e0    b e000095c <write_it_asid_pool+0x418>
    0xe0000928    0x3e4    lsl r3, r3, #10
    0xe000092c    0x3e8    bic r3, r3, #16320 
    0xe0000930    0x3ec    bic r3, r3, #63 
    0xe0000934    0x3f0    b e000095c <write_it_asid_pool+0x418>
    0xe0000938    0x3f4    bic r3, r3, #1020 
    0xe000093c    0x3f8    bic r3, r3, #3
    0xe0000940    0x3fc    b e000095c <write_it_asid_pool+0x418>
    0xe0000944    0x400    bic r3, r3, #16320 
    0xe0000948    0x404    bic r3, r3, #63 
    0xe000094c    0x408    b e000095c <write_it_asid_pool+0x418>
    0xe0000950    0x40c    bic r3, r3, #15
    0xe0000954    0x410    b e000095c <write_it_asid_pool+0x418>
    0xe0000958    0x414    mov r3, #0
    0xe000095c    0x418    str r3, [r1, #4]
    0xe0000960    0x41c    movw r3, #37576 
    0xe0000964    0x420    movt r3, #57346 
    0xe0000968    0x424    str r1, [r3]
    0xe000096c    0x428    add sp, sp, #16
    0xe0000970    0x42c    bx lr
    0xe0000974    0x430    mov r3, #0
    0xe0000978    0x434    b e000095c <write_it_asid_pool+0x418>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
130 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `write_it_asid_pool` has 589 nodes.

Section create_unmapped_it_frame_cap (93 of 293)
================================================

Deriving specifications
-----------------------

Section `create_unmapped_it_frame_cap` consists of 18 instructions.


Stack analysis
---------------

Section `create_unmapped_it_frame_cap` expects pointer to stack in r0.
4 stack accesses found. Annotated code for `create_unmapped_it_frame_cap`:

    0xe00003c0     0x0    cmp r2, #0
    0xe00003c4     0x4    bne e00003e4 <create_unmapped_it_frame_cap+0x24>
    0xe00003c8     0x8    lsr r1, r1, #8
    0xe00003cc     0xc    bic r1, r1, #15
    0xe00003d0    0x10    orr r1, r1, #1
    0xe00003d4    0x14    str r1, [r0]          ; stack access
    0xe00003d8    0x18    mov r3, #3145728 
    0xe00003dc    0x1c    str r3, [r0, #4]      ; stack access
    0xe00003e0    0x20    bx lr
    0xe00003e4    0x24    lsr r1, r1, #10
    0xe00003e8    0x28    bic r1, r1, #-268435441 
    0xe00003ec    0x2c    bic r1, r1, #264241152 
    0xe00003f0    0x30    orr r1, r1, #3
    0xe00003f4    0x34    str r1, [r0]          ; stack access
    0xe00003f8    0x38    mov r3, #0
    0xe00003fc    0x3c    movt r3, #32780 
    0xe0000400    0x40    str r3, [r0, #4]      ; stack access
    0xe0000404    0x44    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_unmapped_it_frame_cap` has 26 nodes.

Section arch_get_n_paging (94 of 293)
=====================================

Deriving specifications
-----------------------

Section `arch_get_n_paging` consists of 15 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `arch_get_n_paging`:

    0xe0000384     0x0    sub sp, sp, #8
    0xe0000388     0x4    add r3, sp, #8
    0xe000038c     0x8    stmdb r3, {r0, r1}    ; stack access
    0xe0000390     0xc    ldr r0, [sp, #4]      ; stack access
    0xe0000394    0x10    sub r0, r0, #1
    0xe0000398    0x14    lsr r0, r0, #20
    0xe000039c    0x18    lsl r0, r0, #20
    0xe00003a0    0x1c    add r0, r0, #1048576 
    0xe00003a4    0x20    ldr r3, [sp]          ; stack access
    0xe00003a8    0x24    lsr r3, r3, #20
    0xe00003ac    0x28    lsl r3, r3, #20
    0xe00003b0    0x2c    sub r0, r0, r3
    0xe00003b4    0x30    lsr r0, r0, #20
    0xe00003b8    0x34    add sp, sp, #8
    0xe00003bc    0x38    bx lr

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arch_get_n_paging` has 19 nodes.

Section Arch_configureIdleThread (95 of 293)
============================================

Deriving specifications
-----------------------

Section `Arch_configureIdleThread` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_configureIdleThread`:

    0xe000031c     0x0    movw r3, #351 
    0xe0000320     0x4    str r3, [r0, #64] 
    0xe0000324     0x8    movw r3, #2144 
    0xe0000328     0xc    movt r3, #57345 
    0xe000032c    0x10    str r3, [r0, #60] 
    0xe0000330    0x14    bx lr

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_configureIdleThread` has 9 nodes.

Section merge_regions (96 of 293)
=================================

Deriving specifications
-----------------------

Section `merge_regions` consists of 35 instructions.
 STMDB (wb);14,5,4..+
 LDMIALS (wb);15,5,4..++
 ADDNE (imm)....+++


Stack analysis
---------------

2 stack accesses found. Annotated code for `merge_regions`:

    0xe0000290     0x0    push {r4, r5, lr}     ; stack access
    0xe0000294     0x4    mov r3, #1
    0xe0000298     0x8    movw r2, #47104 
    0xe000029c     0xc    movt r2, #57345 
    0xe00002a0    0x10    b e00002ac <merge_regions+0x1c>
    0xe00002a4    0x14    sub r4, r4, #1
    0xe00002a8    0x18    str r4, [r2, #88] 
    0xe00002ac    0x1c    ldr r4, [r2, #88] 
    0xe00002b0    0x20    cmp r4, r3
    0xe00002b4    0x24    popls {r4, r5, pc}    ; stack access
    0xe00002b8    0x28    sub r1, r3, #1
    0xe00002bc    0x2c    add r0, r2, r1, lsl #3
    0xe00002c0    0x30    ldr ip, [r0, #4]
    0xe00002c4    0x34    ldr r0, [r2, r3, lsl #3]
    0xe00002c8    0x38    cmp ip, r0
    0xe00002cc    0x3c    addne r3, r3, #1
    0xe00002d0    0x40    bne e00002ac <merge_regions+0x1c>
    0xe00002d4    0x44    add r0, r2, r3, lsl #3
    0xe00002d8    0x48    ldr r0, [r0, #4]
    0xe00002dc    0x4c    add r1, r2, r1, lsl #3
    0xe00002e0    0x50    str r0, [r1, #4]
    0xe00002e4    0x54    add r1, r3, #1
    0xe00002e8    0x58    cmp r4, r1
    0xe00002ec    0x5c    bls e00002a4 <merge_regions+0x14>
    0xe00002f0    0x60    lsl ip, r3, #3
    0xe00002f4    0x64    sub r5, r4, #-536870911 
    0xe00002f8    0x68    lsl r5, r5, #3
    0xe00002fc    0x6c    add lr, r2, ip
    0xe0000300    0x70    add r1, lr, #8
    0xe0000304    0x74    ldm r1, {r0, r1}
    0xe0000308    0x78    stm lr, {r0, r1}
    0xe000030c    0x7c    add ip, ip, #8
    0xe0000310    0x80    cmp ip, r5
    0xe0000314    0x84    bne e00002fc <merge_regions+0x6c>
    0xe0000318    0x88    b e00002a4 <merge_regions+0x14>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `merge_regions` has 55 nodes.

Section cpu_iface_init (97 of 293)
==================================

Deriving specifications
-----------------------

Section `cpu_iface_init` consists of 37 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cpu_iface_init`:

    0xe00001fc     0x0    movw r3, #4351 
    0xe0000200     0x4    movt r3, #65520 
    0xe0000204     0x8    mvn r2, #0
    0xe0000208     0xc    str r2, [r3, #129] 
    0xe000020c    0x10    str r2, [r3, #385] 
    0xe0000210    0x14    mov r1, #0
    0xe0000214    0x18    str r1, [r3, #-127] 
    0xe0000218    0x1c    str r1, [r3, #769] 
    0xe000021c    0x20    str r2, [r3, #3601] 
    0xe0000220    0x24    str r2, [r3, #3605] 
    0xe0000224    0x28    str r2, [r3, #3609] 
    0xe0000228    0x2c    str r2, [r3, #3613] 
    0xe000022c    0x30    movw r3, #8703 
    0xe0000230    0x34    movt r3, #65520 
    0xe0000234    0x38    str r1, [r3, #-255] 
    0xe0000238    0x3c    mov r2, #240 
    0xe000023c    0x40    str r2, [r3, #-251] 
    0xe0000240    0x44    mov r2, #3
    0xe0000244    0x48    str r2, [r3, #-247] 
    0xe0000248    0x4c    ldr r3, [r3, #-243] 
    0xe000024c    0x50    ubfx r1, r3, #0, #10
    0xe0000250    0x54    movw r2, #1023 
    0xe0000254    0x58    cmp r1, r2
    0xe0000258    0x5c    beq e000027c <cpu_iface_init+0x80>
    0xe000025c    0x60    movw r2, #8703 
    0xe0000260    0x64    movt r2, #65520 
    0xe0000264    0x68    movw r0, #1023 
    0xe0000268    0x6c    str r3, [r2, #-239] 
    0xe000026c    0x70    ldr r3, [r2, #-243] 
    0xe0000270    0x74    ubfx r1, r3, #0, #10
    0xe0000274    0x78    cmp r1, r0
    0xe0000278    0x7c    bne e0000268 <cpu_iface_init+0x6c>
    0xe000027c    0x80    movw r3, #8703 
    0xe0000280    0x84    movt r3, #65520 
    0xe0000284    0x88    mov r2, #1
    0xe0000288    0x8c    str r2, [r3, #-255] 
    0xe000028c    0x90    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
37 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cpu_iface_init` has 57 nodes.

Section dist_init (98 of 293)
=============================

Deriving specifications
-----------------------

Section `dist_init` consists of 103 instructions.
 ORRS (reg)..........+++++
 MOVWHI..++
 MOVTHI..++
 BFC...++


Stack analysis
---------------

No stack accesses found. Code for `dist_init`:

    0xe0000060      0x0    movw r3, #4351 
    0xe0000064      0x4    movt r3, #65520 
    0xe0000068      0x8    ldr r2, [r3, #-251] 
    0xe000006c      0xc    and r2, r2, #31
    0xe0000070     0x10    add r2, r2, #1
    0xe0000074     0x14    mov r1, #0
    0xe0000078     0x18    str r1, [r3, #-255] 
    0xe000007c     0x1c    lsls r2, r2, #5
    0xe0000080     0x20    beq e00001ec <dist_init+0x18c>
    0xe0000084     0x24    mvn r0, #0
    0xe0000088     0x28    lsr r3, r1, #5
    0xe000008c     0x2c    lsl r3, r3, #2
    0xe0000090     0x30    sub r3, r3, #1044480 
    0xe0000094     0x34    str r0, [r3, #384] 
    0xe0000098     0x38    str r0, [r3, #640] 
    0xe000009c     0x3c    add r1, r1, #32
    0xe00000a0     0x40    cmp r2, r1
    0xe00000a4     0x44    bhi e0000088 <dist_init+0x28>
    0xe00000a8     0x48    cmp r2, #32
    0xe00000ac     0x4c    bls e00000dc <dist_init+0x7c>
    0xe00000b0     0x50    mov r1, #32
    0xe00000b4     0x54    movw r0, #4351 
    0xe00000b8     0x58    movt r0, #65520 
    0xe00000bc     0x5c    mov ip, #0
    0xe00000c0     0x60    bic r3, r1, #3
    0xe00000c4     0x64    add r3, r3, #1024 
    0xe00000c8     0x68    add r3, r0, r3
    0xe00000cc     0x6c    str ip, [r3, #-255] 
    0xe00000d0     0x70    add r1, r1, #4
    0xe00000d4     0x74    cmp r2, r1
    0xe00000d8     0x78    bhi e00000c0 <dist_init+0x60>
    0xe00000dc     0x7c    movw r3, #4351 
    0xe00000e0     0x80    movt r3, #65520 
    0xe00000e4     0x84    ldr r3, [r3, #1793] 
    0xe00000e8     0x88    orr r3, r3, r3, lsr #16
    0xe00000ec     0x8c    orrs r3, r3, r3, lsr #8
    0xe00000f0     0x90    bne e0000130 <dist_init+0xd0>
    0xe00000f4     0x94    mov r1, #0
    0xe00000f8     0x98    movw r0, #4351 
    0xe00000fc     0x9c    movt r0, #65520 
    0xe0000100     0xa0    add r1, r1, #4
    0xe0000104     0xa4    cmp r2, r1
    0xe0000108     0xa8    bls e000012c <dist_init+0xcc>
    0xe000010c     0xac    bic r3, r1, #3
    0xe0000110     0xb0    add r3, r3, #2048 
    0xe0000114     0xb4    add r3, r0, r3
    0xe0000118     0xb8    ldr r3, [r3, #-255] 
    0xe000011c     0xbc    orr r3, r3, r3, lsr #16
    0xe0000120     0xc0    orrs r3, r3, r3, lsr #8
    0xe0000124     0xc4    beq e0000100 <dist_init+0xa0>
    0xe0000128     0xc8    b e0000130 <dist_init+0xd0>
    0xe000012c     0xcc    mov r3, #1
    0xe0000130     0xd0    uxtb r3, r3
    0xe0000134     0xd4    lsl r1, r3, #16
    0xe0000138     0xd8    orr r1, r1, r3, lsl #8
    0xe000013c     0xdc    orr r1, r1, r3
    0xe0000140     0xe0    orr r3, r1, r3, lsl #24
    0xe0000144     0xe4    mov r0, #0
    0xe0000148     0xe8    movw ip, #4351 
    0xe000014c     0xec    movt ip, #65520 
    0xe0000150     0xf0    bic r1, r0, #3
    0xe0000154     0xf4    add r1, r1, #2048 
    0xe0000158     0xf8    add r1, ip, r1
    0xe000015c     0xfc    str r3, [r1, #-255] 
    0xe0000160    0x100    add r0, r0, #4
    0xe0000164    0x104    cmp r2, r0
    0xe0000168    0x108    bhi e0000150 <dist_init+0xf0>
    0xe000016c    0x10c    cmp r2, #64 
    0xe0000170    0x110    movhi r1, #64 
    0xe0000174    0x114    movwhi ip, #4351 
    0xe0000178    0x118    movthi ip, #65520 
    0xe000017c    0x11c    bls e00001ac <dist_init+0x14c>
    0xe0000180    0x120    lsr r3, r1, #5
    0xe0000184    0x124    add r3, r3, #768 
    0xe0000188    0x128    add r3, ip, r3, lsl #2
    0xe000018c    0x12c    movw r0, #21845 
    0xe0000190    0x130    bfi r0, r0, #16, #16
    0xe0000194    0x134    str r0, [r3, #-255] 
    0xe0000198    0x138    add r1, r1, #32
    0xe000019c    0x13c    cmp r2, r1
    0xe00001a0    0x140    bhi e0000180 <dist_init+0x120>
    0xe00001a4    0x144    cmp r2, #0
    0xe00001a8    0x148    beq e00001d8 <dist_init+0x178>
    0xe00001ac    0x14c    mov r1, #0
    0xe00001b0    0x150    movw r0, #4351 
    0xe00001b4    0x154    movt r0, #65520 
    0xe00001b8    0x158    mov ip, r1
    0xe00001bc    0x15c    lsr r3, r1, #5
    0xe00001c0    0x160    add r3, r3, #32
    0xe00001c4    0x164    add r3, r0, r3, lsl #2
    0xe00001c8    0x168    str ip, [r3, #-255] 
    0xe00001cc    0x16c    add r1, r1, #32
    0xe00001d0    0x170    cmp r2, r1
    0xe00001d4    0x174    bhi e00001bc <dist_init+0x15c>
    0xe00001d8    0x178    movw r3, #4351 
    0xe00001dc    0x17c    movt r3, #65520 
    0xe00001e0    0x180    mov r2, #1
    0xe00001e4    0x184    str r2, [r3, #-255] 
    0xe00001e8    0x188    bx lr
    0xe00001ec    0x18c    cmp r2, #0
    0xe00001f0    0x190    beq e00001d8 <dist_init+0x178>
    0xe00001f4    0x194    mov r3, #1
    0xe00001f8    0x198    b e0000130 <dist_init+0xd0>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
103 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `dist_init` has 148 nodes.

Section arm_reset_exception (99 of 293)
=======================================

Deriving specifications
-----------------------

Section `arm_reset_exception` consists of 1 instructions.
 BL.+


Stack analysis
---------------

No stack accesses found. Code for `arm_reset_exception`:

    0xe0010110    0x0    bl e0010904 <halt>

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_reset_exception` has 2 nodes.

Section str_to_long (100 of 293)
================================

Deriving specifications
-----------------------

Section `str_to_long` consists of 32 instructions.
 CMN (imm)..+
 CMPNE (reg)......+++
 MLA...............+++++++++++++++
 ADDEQ (imm)....+++


Stack analysis
---------------

2 stack accesses found. Annotated code for `str_to_long`:

    0xe001b44c     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe001b450     0x4    mov r4, r0
    0xe001b454     0x8    ldrb r0, [r0]
    0xe001b458     0xc    cmp r0, #48 
    0xe001b45c    0x10    movne r6, #10
    0xe001b460    0x14    beq e001b498 <str_to_long+0x4c>
    0xe001b464    0x18    ldrb r0, [r4]
    0xe001b468    0x1c    cmp r0, #0
    0xe001b46c    0x20    beq e001b4b8 <str_to_long+0x6c>
    0xe001b470    0x24    mov r5, #0
    0xe001b474    0x28    bl e001b404 <char_to_long>
    0xe001b478    0x2c    cmn r0, #1
    0xe001b47c    0x30    cmpne r0, r6
    0xe001b480    0x34    bcs e001b4c0 <str_to_long+0x74>
    0xe001b484    0x38    mla r5, r6, r5, r0
    0xe001b488    0x3c    ldrb r0, [r4, #1]!
    0xe001b48c    0x40    cmp r0, #0
    0xe001b490    0x44    bne e001b474 <str_to_long+0x28>
    0xe001b494    0x48    b e001b4c4 <str_to_long+0x78>
    0xe001b498    0x4c    ldrb r3, [r4, #1]
    0xe001b49c    0x50    and r3, r3, #223 
    0xe001b4a0    0x54    cmp r3, #88 
    0xe001b4a4    0x58    addeq r4, r4, #2
    0xe001b4a8    0x5c    moveq r6, #16
    0xe001b4ac    0x60    beq e001b464 <str_to_long+0x18>
    0xe001b4b0    0x64    mov r6, #10
    0xe001b4b4    0x68    b e001b470 <str_to_long+0x24>
    0xe001b4b8    0x6c    mvn r5, #0
    0xe001b4bc    0x70    b e001b4c4 <str_to_long+0x78>
    0xe001b4c0    0x74    mvn r5, #0
    0xe001b4c4    0x78    mov r0, r5
    0xe001b4c8    0x7c    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `str_to_long` has 58 nodes.

Section memset (101 of 293)
===========================

Deriving specifications
-----------------------

Section `memset` consists of 19 instructions.
 ADDNE (reg)...........++++++
 MOVNE (reg)....+++


Stack analysis
---------------

2 stack accesses found. Annotated code for `memset`:

    0xe001b310     0x0    push {r4, lr}         ; stack access
    0xe001b314     0x4    mov r4, r0
    0xe001b318     0x8    cmp r1, #0
    0xe001b31c     0xc    bne e001b33c <memset+0x2c>
    0xe001b320    0x10    orr r3, r0, r2
    0xe001b324    0x14    tst r3, #3
    0xe001b328    0x18    bne e001b33c <memset+0x2c>
    0xe001b32c    0x1c    mov r1, r2
    0xe001b330    0x20    bl e0019244 <memzero>
    0xe001b334    0x24    mov r0, r4
    0xe001b338    0x28    pop {r4, pc}          ; stack access
    0xe001b33c    0x2c    cmp r2, #0
    0xe001b340    0x30    addne r2, r4, r2
    0xe001b344    0x34    movne r3, r4
    0xe001b348    0x38    beq e001b334 <memset+0x24>
    0xe001b34c    0x3c    strb r1, [r3], #1
    0xe001b350    0x40    cmp r2, r3
    0xe001b354    0x44    bne e001b34c <memset+0x3c>
    0xe001b358    0x48    b e001b334 <memset+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memset` has 35 nodes.

Section Arch_decodeInvocation (102 of 293)
==========================================

Deriving specifications
-----------------------

Section `Arch_decodeInvocation` consists of 20 instructions.
 LDMIA;2,1,0....++
 STMIA;2,1,0....+
 LDMIB;1,0...+
 LDMIA (wb);15,5,4.+


Stack analysis
---------------

8 stack accesses found. Annotated code for `Arch_decodeInvocation`:

    0xe001ab5c     0x0    push {r4, r5, lr}     ; stack access
    0xe001ab60     0x4    sub sp, sp, #28
    0xe001ab64     0x8    mov lr, r0
    0xe001ab68     0xc    mov r4, r1
    0xe001ab6c    0x10    mov r5, r2
    0xe001ab70    0x14    ldr r2, [sp, #64]     ; stack access
    0xe001ab74    0x18    str r2, [sp, #20]     ; stack access
    0xe001ab78    0x1c    add ip, sp, #8
    0xe001ab7c    0x20    add r2, sp, #48 
    0xe001ab80    0x24    ldm r2, {r0, r1, r2}  ; stack access
    0xe001ab84    0x28    stm ip, {r0, r1, r2}  ; stack access
    0xe001ab88    0x2c    add r2, sp, #36 
    0xe001ab8c    0x30    ldmib r2, {r0, r1}    ; stack access
    0xe001ab90    0x34    stm sp, {r0, r1}      ; stack access
    0xe001ab94    0x38    mov r2, r5
    0xe001ab98    0x3c    mov r1, r4
    0xe001ab9c    0x40    mov r0, lr
    0xe001aba0    0x44    bl e001978c <decodeARMMMUInvocation>
    0xe001aba4    0x48    add sp, sp, #28
    0xe001aba8    0x4c    pop {r4, r5, pc}      ; stack access

Proving inst theorems
---------------------

20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeInvocation` has 29 nodes.

Section setMRs_syscall_error (103 of 293)
=========================================

Deriving specifications
-----------------------

Section `setMRs_syscall_error` consists of 91 instructions.
Switch found.
Switch found.


Stack analysis
---------------

11 stack accesses found. Annotated code for `setMRs_syscall_error`:

    0xe0018f34      0x0    push {r4, lr}         ; stack access
    0xe0018f38      0x4    movw r3, #36896 
    0xe0018f3c      0x8    movt r3, #57346 
    0xe0018f40      0xc    ldr r3, [r3, #24]
    0xe0018f44     0x10    sub r3, r3, #1
    0xe0018f48     0x14    cmp r3, #9
    0xe0018f4c     0x18    ldrls pc, [pc, r3, lsl #2]
    0xe0018f50     0x1c    b e0019084 <setMRs_syscall_error+0x150>
    0xe0018f54     0x20    .word 0xe0018f7c
    0xe0018f58     0x24    .word 0xe0018f94
    0xe0018f5c     0x28    .word 0xe0019088
    0xe0018f60     0x2c    .word 0xe0018fac
    0xe0018f64     0x30    .word 0xe0019088
    0xe0018f68     0x34    .word 0xe0018fcc
    0xe0018f6c     0x38    .word 0xe0019088
    0xe0018f70     0x3c    .word 0xe0019088
    0xe0018f74     0x40    .word 0xe0019088
    0xe0018f78     0x44    .word 0xe001906c
    0xe0018f7c     0x48    movw r3, #36896 
    0xe0018f80     0x4c    movt r3, #57346 
    0xe0018f84     0x50    ldr r3, [r3]
    0xe0018f88     0x54    str r3, [r0, #8]
    0xe0018f8c     0x58    mov r0, #1
    0xe0018f90     0x5c    pop {r4, pc}          ; stack access
    0xe0018f94     0x60    movw r3, #36896 
    0xe0018f98     0x64    movt r3, #57346 
    0xe0018f9c     0x68    ldr r3, [r3, #4]
    0xe0018fa0     0x6c    str r3, [r0, #8]
    0xe0018fa4     0x70    mov r0, #1
    0xe0018fa8     0x74    pop {r4, pc}          ; stack access
    0xe0018fac     0x78    movw r3, #36896 
    0xe0018fb0     0x7c    movt r3, #57346 
    0xe0018fb4     0x80    ldr r2, [r3, #8]
    0xe0018fb8     0x84    str r2, [r0, #8]
    0xe0018fbc     0x88    ldr r3, [r3, #12]
    0xe0018fc0     0x8c    str r3, [r0, #12]
    0xe0018fc4     0x90    mov r0, #2
    0xe0018fc8     0x94    pop {r4, pc}          ; stack access
    0xe0018fcc     0x98    movw r3, #36896 
    0xe0018fd0     0x9c    movt r3, #57346 
    0xe0018fd4     0xa0    ldr r3, [r3, #20]
    0xe0018fd8     0xa4    adds r3, r3, #0
    0xe0018fdc     0xa8    movne r3, #1
    0xe0018fe0     0xac    str r3, [r0, #8]
    0xe0018fe4     0xb0    movw r3, #36884 
    0xe0018fe8     0xb4    movt r3, #57346 
    0xe0018fec     0xb8    ldr r2, [r3]
    0xe0018ff0     0xbc    ldr lr, [r3, #4]
    0xe0018ff4     0xc0    and r3, r2, #3
    0xe0018ff8     0xc4    add ip, r3, #1
    0xe0018ffc     0xc8    str ip, [r0, #12]
    0xe0019000     0xcc    cmp r3, #3
    0xe0019004     0xd0    ldrls pc, [pc, r3, lsl #2]
    0xe0019008     0xd4    b e0019068 <setMRs_syscall_error+0x134>
    0xe001900c     0xd8    .word 0xe0019090
    0xe0019010     0xdc    .word 0xe001901c
    0xe0019014     0xe0    .word 0xe001902c
    0xe0019018     0xe4    .word 0xe0019044
    0xe001901c     0xe8    ubfx r2, r2, #2, #6
    0xe0019020     0xec    str r2, [r0, #16]
    0xe0019024     0xf0    mov r0, #3
    0xe0019028     0xf4    pop {r4, pc}          ; stack access
    0xe001902c     0xf8    ubfx r3, r2, #2, #6
    0xe0019030     0xfc    str r3, [r0, #16]
    0xe0019034    0x100    ubfx r2, r2, #8, #6
    0xe0019038    0x104    str r2, [r0, #20]
    0xe001903c    0x108    mov r0, #4
    0xe0019040    0x10c    pop {r4, pc}          ; stack access
    0xe0019044    0x110    ubfx r3, r2, #8, #6
    0xe0019048    0x114    str r3, [r0, #16]
    0xe001904c    0x118    str lr, [r0, #20]
    0xe0019050    0x11c    cmp r1, #0
    0xe0019054    0x120    beq e0019098 <setMRs_syscall_error+0x164>
    0xe0019058    0x124    ubfx r2, r2, #2, #6
    0xe001905c    0x128    str r2, [r1, #20]
    0xe0019060    0x12c    mov r0, #5
    0xe0019064    0x130    pop {r4, pc}          ; stack access
    0xe0019068    0x134    bl e0010904 <halt>
    0xe001906c    0x138    movw r3, #36896 
    0xe0019070    0x13c    movt r3, #57346 
    0xe0019074    0x140    ldr r3, [r3, #16]
    0xe0019078    0x144    str r3, [r0, #8]
    0xe001907c    0x148    mov r0, #1
    0xe0019080    0x14c    pop {r4, pc}          ; stack access
    0xe0019084    0x150    bl e0010904 <halt>
    0xe0019088    0x154    mov r0, #0
    0xe001908c    0x158    pop {r4, pc}          ; stack access
    0xe0019090    0x15c    mov r0, #2
    0xe0019094    0x160    pop {r4, pc}          ; stack access
    0xe0019098    0x164    mov r0, #4
    0xe001909c    0x168    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
77 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMRs_syscall_error` has 160 nodes.

Section invokeTCB_Resume (104 of 293)
=====================================

Deriving specifications
-----------------------

Section `invokeTCB_Resume` consists of 4 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_Resume`:

    0xe0017914    0x0    push {r4, lr}         ; stack access
    0xe0017918    0x4    bl e0016718 <restart>
    0xe001791c    0x8    mov r0, #0
    0xe0017920    0xc    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_Resume` has 7 nodes.

Section invokeTCB_Suspend (105 of 293)
======================================

Deriving specifications
-----------------------

Section `invokeTCB_Suspend` consists of 4 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_Suspend`:

    0xe0017904    0x0    push {r4, lr}         ; stack access
    0xe0017908    0x4    bl e001584c <suspend>
    0xe001790c    0x8    mov r0, #0
    0xe0017910    0xc    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_Suspend` has 7 nodes.

Section performInvocation_Endpoint (106 of 293)
===============================================

Deriving specifications
-----------------------

Section `performInvocation_Endpoint` consists of 16 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `performInvocation_Endpoint`:

    0xe0017428     0x0    push {lr}             ; stack access
    0xe001742c     0x4    sub sp, sp, #20
    0xe0017430     0x8    str r0, [sp, #8]      ; stack access
    0xe0017434     0xc    movw r0, #13900 
    0xe0017438    0x10    movt r0, #57347 
    0xe001743c    0x14    ldr r0, [r0]
    0xe0017440    0x18    str r0, [sp, #4]      ; stack access
    0xe0017444    0x1c    str r3, [sp]          ; stack access
    0xe0017448    0x20    mov r3, r2
    0xe001744c    0x24    mov r2, r1
    0xe0017450    0x28    ldr r1, [sp, #28]     ; stack access
    0xe0017454    0x2c    ldr r0, [sp, #24]     ; stack access
    0xe0017458    0x30    bl e0017070 <sendIPC>
    0xe001745c    0x34    mov r0, #0
    0xe0017460    0x38    add sp, sp, #20
    0xe0017464    0x3c    pop {pc}              ; stack access

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Endpoint` has 25 nodes.

Section performInvocation_Reply (107 of 293)
============================================

Deriving specifications
-----------------------

Section `performInvocation_Reply` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `performInvocation_Reply`:

    0xe0017048     0x0    push {r4, lr}         ; stack access
    0xe001704c     0x4    movw ip, #13900 
    0xe0017050     0x8    movt ip, #57347 
    0xe0017054     0xc    mov r3, r2
    0xe0017058    0x10    mov r2, r1
    0xe001705c    0x14    mov r1, r0
    0xe0017060    0x18    ldr r0, [ip]
    0xe0017064    0x1c    bl e0016f48 <doReplyTransfer>
    0xe0017068    0x20    mov r0, #0
    0xe001706c    0x24    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Reply` has 14 nodes.

Section lookupExtraCaps (108 of 293)
====================================

Deriving specifications
-----------------------

Section `lookupExtraCaps` consists of 46 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `lookupExtraCaps`:

    0xe0016b74     0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe0016b78     0x4    sub sp, sp, #12
    0xe0016b7c     0x8    subs r5, r1, #0
    0xe0016b80     0xc    beq e0016bf4 <lookupExtraCaps+0x80>
    0xe0016b84    0x10    ubfx r7, r2, #7, #2
    0xe0016b88    0x14    cmp r7, #0
    0xe0016b8c    0x18    beq e0016c24 <lookupExtraCaps+0xb0>
    0xe0016b90    0x1c    mov r8, r0
    0xe0016b94    0x20    add r5, r5, #484 
    0xe0016b98    0x24    mov r4, #0
    0xe0016b9c    0x28    movw r9, #36924 
    0xe0016ba0    0x2c    movt r9, #57346 
    0xe0016ba4    0x30    ldr r6, [r5, #4]!
    0xe0016ba8    0x34    mov r2, r6
    0xe0016bac    0x38    mov r1, r8
    0xe0016bb0    0x3c    mov r0, sp
    0xe0016bb4    0x40    bl e0012bc8 <lookupSlot>
    0xe0016bb8    0x44    ldr r0, [sp]          ; stack access
    0xe0016bbc    0x48    cmp r0, #0
    0xe0016bc0    0x4c    bne e0016c08 <lookupExtraCaps+0x94>
    0xe0016bc4    0x50    ldr r3, [sp, #4]      ; stack access
    0xe0016bc8    0x54    str r3, [r9, r4, lsl #2]
    0xe0016bcc    0x58    add r4, r4, #1
    0xe0016bd0    0x5c    cmp r4, r7
    0xe0016bd4    0x60    bne e0016ba4 <lookupExtraCaps+0x30>
    0xe0016bd8    0x64    cmp r4, #2
    0xe0016bdc    0x68    bhi e0016c1c <lookupExtraCaps+0xa8>
    0xe0016be0    0x6c    movw r3, #36924 
    0xe0016be4    0x70    movt r3, #57346 
    0xe0016be8    0x74    mov r0, #0
    0xe0016bec    0x78    str r0, [r3, r4, lsl #2]
    0xe0016bf0    0x7c    b e0016c1c <lookupExtraCaps+0xa8>
    0xe0016bf4    0x80    movw r3, #36924 
    0xe0016bf8    0x84    movt r3, #57346 
    0xe0016bfc    0x88    mov r0, #0
    0xe0016c00    0x8c    str r0, [r3]
    0xe0016c04    0x90    b e0016c1c <lookupExtraCaps+0xa8>
    0xe0016c08    0x94    movw r3, #32768 
    0xe0016c0c    0x98    movt r3, #57346 
    0xe0016c10    0x9c    mov r2, #1
    0xe0016c14    0xa0    str r2, [r3]
    0xe0016c18    0xa4    str r6, [r3, #4]
    0xe0016c1c    0xa8    add sp, sp, #12
    0xe0016c20    0xac    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0016c24    0xb0    mov r4, r7
    0xe0016c28    0xb4    b e0016be0 <lookupExtraCaps+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
46 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupExtraCaps` has 67 nodes.

Section deleteCallerCap (109 of 293)
====================================

Deriving specifications
-----------------------

Section `deleteCallerCap` consists of 6 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deleteCallerCap`:

    0xe0016b5c     0x0    push {r4, lr}         ; stack access
    0xe0016b60     0x4    bic r0, r0, #508 
    0xe0016b64     0x8    bic r0, r0, #3
    0xe0016b68     0xc    add r0, r0, #48 
    0xe0016b6c    0x10    bl e00164f8 <cteDeleteOne>
    0xe0016b70    0x14    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteCallerCap` has 9 nodes.

Section performInvocation_Notification (110 of 293)
===================================================

Deriving specifications
-----------------------

Section `performInvocation_Notification` consists of 4 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `performInvocation_Notification`:

    0xe0016acc    0x0    push {r4, lr}         ; stack access
    0xe0016ad0    0x4    bl e0016764 <sendSignal>
    0xe0016ad4    0x8    mov r0, #0
    0xe0016ad8    0xc    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Notification` has 7 nodes.

Section deletingIRQHandler (111 of 293)
=======================================

Deriving specifications
-----------------------

Section `deletingIRQHandler` consists of 6 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deletingIRQHandler`:

    0xe0016700     0x0    push {r4, lr}         ; stack access
    0xe0016704     0x4    movw r3, #8192 
    0xe0016708     0x8    movt r3, #57347 
    0xe001670c     0xc    add r0, r3, r0, lsl #4
    0xe0016710    0x10    bl e00164f8 <cteDeleteOne>
    0xe0016714    0x14    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deletingIRQHandler` has 9 nodes.

Section invokeIRQHandler_ClearIRQHandler (112 of 293)
=====================================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_ClearIRQHandler` consists of 6 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeIRQHandler_ClearIRQHandler`:

    0xe00165a0     0x0    push {r4, lr}         ; stack access
    0xe00165a4     0x4    movw r3, #8192 
    0xe00165a8     0x8    movt r3, #57347 
    0xe00165ac     0xc    add r0, r3, r0, lsl #4
    0xe00165b0    0x10    bl e00164f8 <cteDeleteOne>
    0xe00165b4    0x14    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_ClearIRQHandler` has 9 nodes.

Section invokeCNodeRevoke (113 of 293)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeRevoke` consists of 3 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeCNodeRevoke`:

    0xe0015dcc    0x0    push {r4, lr}         ; stack access
    0xe0015dd0    0x4    bl e0015d68 <cteRevoke>
    0xe0015dd4    0x8    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeRevoke` has 6 nodes.

Section invokeCNodeDelete (114 of 293)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeDelete` consists of 4 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeCNodeDelete`:

    0xe0015d58    0x0    push {r4, lr}         ; stack access
    0xe0015d5c    0x4    mov r1, #1
    0xe0015d60    0x8    bl e0015b14 <cteDelete>
    0xe0015d64    0xc    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeDelete` has 7 nodes.

Section invokeCNodeCancelBadgedSends (115 of 293)
=================================================

Deriving specifications
-----------------------

Section `invokeCNodeCancelBadgedSends` consists of 14 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `invokeCNodeCancelBadgedSends`:

    0xe0015690     0x0    push {lr}             ; stack access
    0xe0015694     0x4    sub sp, sp, #12
    0xe0015698     0x8    add r3, sp, #8
    0xe001569c     0xc    stmdb r3, {r0, r1}    ; stack access
    0xe00156a0    0x10    ldr r1, [sp]          ; stack access
    0xe00156a4    0x14    lsrs r1, r1, #4
    0xe00156a8    0x18    bne e00156b8 <invokeCNodeCancelBadgedSends+0x28>
    0xe00156ac    0x1c    mov r0, #0
    0xe00156b0    0x20    add sp, sp, #12
    0xe00156b4    0x24    pop {pc}              ; stack access
    0xe00156b8    0x28    ldr r0, [sp, #4]      ; stack access
    0xe00156bc    0x2c    bic r0, r0, #15
    0xe00156c0    0x30    bl e0015588 <cancelBadgedSends>
    0xe00156c4    0x34    b e00156ac <invokeCNodeCancelBadgedSends+0x1c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeCancelBadgedSends` has 22 nodes.

Section scheduleChooseNewThread (116 of 293)
============================================

Deriving specifications
-----------------------

Section `scheduleChooseNewThread` consists of 39 instructions.
 MOVWLS..++
 MOVTLS..++
 STRLS (+imm,pre)....+++


Stack analysis
---------------

2 stack accesses found. Annotated code for `scheduleChooseNewThread`:

    0xe001525c     0x0    push {r4, lr}         ; stack access
    0xe0015260     0x4    movw r3, #5324 
    0xe0015264     0x8    movt r3, #57347 
    0xe0015268     0xc    ldr r3, [r3]
    0xe001526c    0x10    cmp r3, #0
    0xe0015270    0x14    beq e001527c <scheduleChooseNewThread+0x20>
    0xe0015274    0x18    bl e00151f0 <chooseThread>
    0xe0015278    0x1c    pop {r4, pc}          ; stack access
    0xe001527c    0x20    movw r3, #13904 
    0xe0015280    0x24    movt r3, #57347 
    0xe0015284    0x28    ldr r3, [r3]
    0xe0015288    0x2c    add r3, r3, #1
    0xe001528c    0x30    cmp r3, #2
    0xe0015290    0x34    movwls r2, #13904 
    0xe0015294    0x38    movtls r2, #57347 
    0xe0015298    0x3c    strls r3, [r2]
    0xe001529c    0x40    movwhi r3, #13904 
    0xe00152a0    0x44    movthi r3, #57347 
    0xe00152a4    0x48    movhi r2, #0
    0xe00152a8    0x4c    strhi r2, [r3]
    0xe00152ac    0x50    movw r3, #12804 
    0xe00152b0    0x54    movt r3, #57347 
    0xe00152b4    0x58    mov r2, #0
    0xe00152b8    0x5c    str r2, [r3]
    0xe00152bc    0x60    movw r3, #13904 
    0xe00152c0    0x64    movt r3, #57347 
    0xe00152c4    0x68    ldr r1, [r3]
    0xe00152c8    0x6c    movw r2, #12288 
    0xe00152cc    0x70    movt r2, #57347 
    0xe00152d0    0x74    movw r3, #46284 
    0xe00152d4    0x78    movt r3, #57345 
    0xe00152d8    0x7c    add r3, r3, r1, lsl #3
    0xe00152dc    0x80    ldr r1, [r3, #112] 
    0xe00152e0    0x84    str r1, [r2]
    0xe00152e4    0x88    movw r2, #5324 
    0xe00152e8    0x8c    movt r2, #57347 
    0xe00152ec    0x90    ldr r3, [r3, #116] 
    0xe00152f0    0x94    str r3, [r2]
    0xe00152f4    0x98    b e0015274 <scheduleChooseNewThread+0x18>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `scheduleChooseNewThread` has 68 nodes.

Section receiveSignal (117 of 293)
==================================

Deriving specifications
-----------------------

Section `receiveSignal` consists of 49 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `receiveSignal`:

    0xe0014e10     0x0    push {r4, r5, lr}     ; stack access
    0xe0014e14     0x4    sub sp, sp, #12
    0xe0014e18     0x8    add ip, sp, #8
    0xe0014e1c     0xc    stmdb ip, {r1, r2}    ; stack access
    0xe0014e20    0x10    ldr r4, [sp]          ; stack access
    0xe0014e24    0x14    bic r4, r4, #15
    0xe0014e28    0x18    ldr r2, [r4]
    0xe0014e2c    0x1c    and r2, r2, #3
    0xe0014e30    0x20    cmp r2, #1
    0xe0014e34    0x24    bls e0014e48 <receiveSignal+0x38>
    0xe0014e38    0x28    cmp r2, #2
    0xe0014e3c    0x2c    beq e0014ebc <receiveSignal+0xac>
    0xe0014e40    0x30    add sp, sp, #12
    0xe0014e44    0x34    pop {r4, r5, pc}      ; stack access
    0xe0014e48    0x38    cmp r3, #0
    0xe0014e4c    0x3c    moveq r3, #0
    0xe0014e50    0x40    streq r3, [r0]
    0xe0014e54    0x44    beq e0014e40 <receiveSignal+0x30>
    0xe0014e58    0x48    mov r5, r0
    0xe0014e5c    0x4c    orr r3, r4, #6
    0xe0014e60    0x50    str r3, [r0, #80] 
    0xe0014e64    0x54    bl e0014a90 <scheduleTCB>
    0xe0014e68    0x58    ldr r3, [r4, #4]
    0xe0014e6c    0x5c    ldr r2, [r4]
    0xe0014e70    0x60    bic r2, r2, #15
    0xe0014e74    0x64    bics r3, r3, #15
    0xe0014e78    0x68    strne r5, [r2, #144] 
    0xe0014e7c    0x6c    moveq r3, r5
    0xe0014e80    0x70    str r2, [r5, #148] 
    0xe0014e84    0x74    mov r2, #0
    0xe0014e88    0x78    str r2, [r5, #144] 
    0xe0014e8c    0x7c    ldr r0, [r4]
    0xe0014e90    0x80    ldr r2, [r4, #4]
    0xe0014e94    0x84    and r2, r2, #15
    0xe0014e98    0x88    bic r3, r3, #15
    0xe0014e9c    0x8c    orr r3, r2, r3
    0xe0014ea0    0x90    str r3, [r4, #4]
    0xe0014ea4    0x94    and r0, r0, #12
    0xe0014ea8    0x98    orr r3, r0, #1
    0xe0014eac    0x9c    bic r0, r5, #15
    0xe0014eb0    0xa0    orr r0, r3, r0
    0xe0014eb4    0xa4    str r0, [r4]
    0xe0014eb8    0xa8    b e0014e40 <receiveSignal+0x30>
    0xe0014ebc    0xac    ldr r3, [r4, #8]
    0xe0014ec0    0xb0    str r3, [r0]
    0xe0014ec4    0xb4    ldr r3, [r4]
    0xe0014ec8    0xb8    bic r3, r3, #3
    0xe0014ecc    0xbc    str r3, [r4]
    0xe0014ed0    0xc0    b e0014e40 <receiveSignal+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
49 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `receiveSignal` has 84 nodes.

Section handleDoubleFault (118 of 293)
======================================

Deriving specifications
-----------------------

Section `handleDoubleFault` consists of 8 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `handleDoubleFault`:

    0xe0014c4c     0x0    push {lr}             ; stack access
    0xe0014c50     0x4    sub sp, sp, #12
    0xe0014c54     0x8    add r3, sp, #8
    0xe0014c58     0xc    stmdb r3, {r1, r2}    ; stack access
    0xe0014c5c    0x10    mov r1, #0
    0xe0014c60    0x14    bl e0014ad8 <setThreadState>
    0xe0014c64    0x18    add sp, sp, #12
    0xe0014c68    0x1c    pop {pc}              ; stack access

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleDoubleFault` has 12 nodes.

Section setThreadState (119 of 293)
===================================

Deriving specifications
-----------------------

Section `setThreadState` consists of 8 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `setThreadState`:

    0xe0014ad8     0x0    push {r4, lr}         ; stack access
    0xe0014adc     0x4    ldr r3, [r0, #80] 
    0xe0014ae0     0x8    bic r3, r3, #15
    0xe0014ae4     0xc    and r1, r1, #15
    0xe0014ae8    0x10    orr r3, r3, r1
    0xe0014aec    0x14    str r3, [r0, #80] 
    0xe0014af0    0x18    bl e0014a90 <scheduleTCB>
    0xe0014af4    0x1c    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setThreadState` has 13 nodes.

Section scheduleTCB (120 of 293)
================================

Deriving specifications
-----------------------

Section `scheduleTCB` consists of 18 instructions.
 BXLS..++


Stack analysis
---------------

2 stack accesses found. Annotated code for `scheduleTCB`:

    0xe0014a90     0x0    movw r3, #13900 
    0xe0014a94     0x4    movt r3, #57347 
    0xe0014a98     0x8    ldr r3, [r3]
    0xe0014a9c     0xc    cmp r3, r0
    0xe0014aa0    0x10    bxne lr
    0xe0014aa4    0x14    movw r2, #36892 
    0xe0014aa8    0x18    movt r2, #57346 
    0xe0014aac    0x1c    ldr r2, [r2]
    0xe0014ab0    0x20    cmp r2, #0
    0xe0014ab4    0x24    bxne lr
    0xe0014ab8    0x28    ldr r3, [r3, #80] 
    0xe0014abc    0x2c    and r3, r3, #15
    0xe0014ac0    0x30    sub r3, r3, #1
    0xe0014ac4    0x34    cmp r3, #1
    0xe0014ac8    0x38    bxls lr
    0xe0014acc    0x3c    push {r4, lr}         ; stack access
    0xe0014ad0    0x40    bl e0014a4c <rescheduleRequired>
    0xe0014ad4    0x44    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `scheduleTCB` has 33 nodes.

Section rescheduleRequired (121 of 293)
=======================================

Deriving specifications
-----------------------

Section `rescheduleRequired` consists of 17 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `rescheduleRequired`:

    0xe0014a4c     0x0    movw r3, #36892 
    0xe0014a50     0x4    movt r3, #57346 
    0xe0014a54     0x8    ldr r0, [r3]
    0xe0014a58     0xc    cmp r0, #1
    0xe0014a5c    0x10    bhi e0014a74 <rescheduleRequired+0x28>
    0xe0014a60    0x14    movw r3, #36892 
    0xe0014a64    0x18    movt r3, #57346 
    0xe0014a68    0x1c    mov r2, #1
    0xe0014a6c    0x20    str r2, [r3]
    0xe0014a70    0x24    bx lr
    0xe0014a74    0x28    push {r4, lr}         ; stack access
    0xe0014a78    0x2c    bl e00149a8 <tcbSchedEnqueue>
    0xe0014a7c    0x30    movw r3, #36892 
    0xe0014a80    0x34    movt r3, #57346 
    0xe0014a84    0x38    mov r2, #1
    0xe0014a88    0x3c    str r2, [r3]
    0xe0014a8c    0x40    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `rescheduleRequired` has 26 nodes.

Section slotCapLongRunningDelete (122 of 293)
=============================================

Deriving specifications
-----------------------

Section `slotCapLongRunningDelete` consists of 23 instructions.
 LDMIAEQ (wb);15,4..++


Stack analysis
---------------

5 stack accesses found. Annotated code for `slotCapLongRunningDelete`:

    0xe00144a4     0x0    push {r4, lr}         ; stack access
    0xe00144a8     0x4    ldr r3, [r0]
    0xe00144ac     0x8    and r2, r3, #14
    0xe00144b0     0xc    cmp r2, #14
    0xe00144b4    0x10    andne r4, r3, #15
    0xe00144b8    0x14    uxtbeq r4, r3
    0xe00144bc    0x18    cmp r4, #0
    0xe00144c0    0x1c    beq e00144f0 <slotCapLongRunningDelete+0x4c>
    0xe00144c4    0x20    bl e0014448 <isFinalCapability>
    0xe00144c8    0x24    cmp r0, #0
    0xe00144cc    0x28    popeq {r4, pc}        ; stack access
    0xe00144d0    0x2c    cmp r4, #12
    0xe00144d4    0x30    beq e00144f8 <slotCapLongRunningDelete+0x54>
    0xe00144d8    0x34    cmp r4, #46 
    0xe00144dc    0x38    beq e00144f8 <slotCapLongRunningDelete+0x54>
    0xe00144e0    0x3c    cmp r4, #10
    0xe00144e4    0x40    beq e00144f8 <slotCapLongRunningDelete+0x54>
    0xe00144e8    0x44    mov r0, #0
    0xe00144ec    0x48    pop {r4, pc}          ; stack access
    0xe00144f0    0x4c    mov r0, #0
    0xe00144f4    0x50    pop {r4, pc}          ; stack access
    0xe00144f8    0x54    mov r0, #1
    0xe00144fc    0x58    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `slotCapLongRunningDelete` has 44 nodes.

Section isFinalCapability (123 of 293)
======================================

Deriving specifications
-----------------------

Section `isFinalCapability` consists of 23 instructions.
 LDMIA;3,2...+
+


Stack analysis
---------------

4 stack accesses found. Annotated code for `isFinalCapability`:

    0xe0014448     0x0    push {r4, lr}         ; stack access
    0xe001444c     0x4    mov r4, r0
    0xe0014450     0x8    ldr r3, [r0, #8]
    0xe0014454     0xc    bics r1, r3, #7
    0xe0014458    0x10    beq e0014470 <isFinalCapability+0x28>
    0xe001445c    0x14    ldm r0, {r2, r3}
    0xe0014460    0x18    ldm r1, {r0, r1}
    0xe0014464    0x1c    bl e0014394 <sameObjectAs>
    0xe0014468    0x20    cmp r0, #0
    0xe001446c    0x24    bne e0014494 <isFinalCapability+0x4c>
    0xe0014470    0x28    ldr r3, [r4, #12]
    0xe0014474    0x2c    bics r3, r3, #7
    0xe0014478    0x30    beq e001449c <isFinalCapability+0x54>
    0xe001447c    0x34    ldm r3, {r2, r3}
    0xe0014480    0x38    ldm r4, {r0, r1}
    0xe0014484    0x3c    bl e0014394 <sameObjectAs>
    0xe0014488    0x40    clz r0, r0
    0xe001448c    0x44    lsr r0, r0, #5
    0xe0014490    0x48    pop {r4, pc}          ; stack access
    0xe0014494    0x4c    mov r0, #0
    0xe0014498    0x50    pop {r4, pc}          ; stack access
    0xe001449c    0x54    mov r0, #1
    0xe00144a0    0x58    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isFinalCapability` has 41 nodes.

Section ensureNoChildren (124 of 293)
=====================================

Deriving specifications
-----------------------

Section `ensureNoChildren` consists of 17 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `ensureNoChildren`:

    0xe00142a0     0x0    ldr r1, [r0, #12]
    0xe00142a4     0x4    bics r1, r1, #7
    0xe00142a8     0x8    beq e00142dc <ensureNoChildren+0x3c>
    0xe00142ac     0xc    push {r4, lr}         ; stack access
    0xe00142b0    0x10    bl e00141e4 <isMDBParentOf>
    0xe00142b4    0x14    cmp r0, #0
    0xe00142b8    0x18    bne e00142c4 <ensureNoChildren+0x24>
    0xe00142bc    0x1c    mov r0, #0
    0xe00142c0    0x20    pop {r4, pc}          ; stack access
    0xe00142c4    0x24    movw r3, #36896 
    0xe00142c8    0x28    movt r3, #57346 
    0xe00142cc    0x2c    mov r2, #9
    0xe00142d0    0x30    str r2, [r3, #24]
    0xe00142d4    0x34    mov r0, #3
    0xe00142d8    0x38    pop {r4, pc}          ; stack access
    0xe00142dc    0x3c    mov r0, #0
    0xe00142e0    0x40    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `ensureNoChildren` has 28 nodes.

Section isMDBParentOf (125 of 293)
==================================

Deriving specifications
-----------------------

Section `isMDBParentOf` consists of 47 instructions.
 EOREQ (imm)....+++
 ANDEQ (imm)....+++


Stack analysis
---------------

7 stack accesses found. Annotated code for `isMDBParentOf`:

    0xe00141e4     0x0    ldr r3, [r0, #12]
    0xe00141e8     0x4    tst r3, #2
    0xe00141ec     0x8    beq e0014288 <isMDBParentOf+0xa4>
    0xe00141f0     0xc    push {r4, r5, r6, lr}  ; stack access
    0xe00141f4    0x10    mov r5, r1
    0xe00141f8    0x14    mov r4, r0
    0xe00141fc    0x18    ldm r1, {r2, r3}
    0xe0014200    0x1c    ldm r0, {r0, r1}
    0xe0014204    0x20    bl e00138ec <sameRegionAs>
    0xe0014208    0x24    cmp r0, #0
    0xe001420c    0x28    popeq {r4, r5, r6, pc}  ; stack access
    0xe0014210    0x2c    ldr r3, [r4]
    0xe0014214    0x30    and r2, r3, #14
    0xe0014218    0x34    cmp r2, #14
    0xe001421c    0x38    andne r2, r3, #15
    0xe0014220    0x3c    uxtbeq r2, r3
    0xe0014224    0x40    cmp r2, #4
    0xe0014228    0x44    beq e001423c <isMDBParentOf+0x58>
    0xe001422c    0x48    cmp r2, #6
    0xe0014230    0x4c    beq e0014260 <isMDBParentOf+0x7c>
    0xe0014234    0x50    mov r0, #1
    0xe0014238    0x54    pop {r4, r5, r6, pc}  ; stack access
    0xe001423c    0x58    lsrs r3, r3, #4
    0xe0014240    0x5c    beq e0014290 <isMDBParentOf+0xac>
    0xe0014244    0x60    ldr r2, [r5]
    0xe0014248    0x64    cmp r3, r2, lsr #4
    0xe001424c    0x68    ldreq r0, [r5, #12]
    0xe0014250    0x6c    eoreq r0, r0, #1
    0xe0014254    0x70    andeq r0, r0, #1
    0xe0014258    0x74    movne r0, #0
    0xe001425c    0x78    pop {r4, r5, r6, pc}  ; stack access
    0xe0014260    0x7c    ldr r3, [r4, #4]
    0xe0014264    0x80    lsrs r3, r3, #4
    0xe0014268    0x84    beq e0014298 <isMDBParentOf+0xb4>
    0xe001426c    0x88    ldr r2, [r5, #4]
    0xe0014270    0x8c    cmp r3, r2, lsr #4
    0xe0014274    0x90    ldreq r0, [r5, #12]
    0xe0014278    0x94    eoreq r0, r0, #1
    0xe001427c    0x98    andeq r0, r0, #1
    0xe0014280    0x9c    movne r0, #0
    0xe0014284    0xa0    pop {r4, r5, r6, pc}  ; stack access
    0xe0014288    0xa4    mov r0, #0
    0xe001428c    0xa8    bx lr
    0xe0014290    0xac    mov r0, #1
    0xe0014294    0xb0    pop {r4, r5, r6, pc}  ; stack access
    0xe0014298    0xb4    mov r0, #1
    0xe001429c    0xb8    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
47 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isMDBParentOf` has 97 nodes.

Section completeSignal (126 of 293)
===================================

Deriving specifications
-----------------------

Section `completeSignal` consists of 14 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `completeSignal`:

    0xe00137a8     0x0    cmp r1, #0
    0xe00137ac     0x4    beq e00137d8 <completeSignal+0x30>
    0xe00137b0     0x8    ldr r3, [r0]
    0xe00137b4     0xc    and r3, r3, #3
    0xe00137b8    0x10    cmp r3, #2
    0xe00137bc    0x14    bne e00137d8 <completeSignal+0x30>
    0xe00137c0    0x18    ldr r3, [r0, #8]
    0xe00137c4    0x1c    str r3, [r1]
    0xe00137c8    0x20    ldr r3, [r0]
    0xe00137cc    0x24    bic r3, r3, #3
    0xe00137d0    0x28    str r3, [r0]
    0xe00137d4    0x2c    bx lr
    0xe00137d8    0x30    push {r4, lr}         ; stack access
    0xe00137dc    0x34    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `completeSignal` has 26 nodes.

Section emptySlot (127 of 293)
==============================

Deriving specifications
-----------------------

Section `emptySlot` consists of 48 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `emptySlot`:

    0xe00136e8     0x0    push {lr}             ; stack access
    0xe00136ec     0x4    sub sp, sp, #12
    0xe00136f0     0x8    add r3, sp, #8
    0xe00136f4     0xc    stmdb r3, {r1, r2}    ; stack access
    0xe00136f8    0x10    ldr r3, [r0]
    0xe00136fc    0x14    and r2, r3, #14
    0xe0013700    0x18    cmp r2, #14
    0xe0013704    0x1c    andne r3, r3, #15
    0xe0013708    0x20    uxtbeq r3, r3
    0xe001370c    0x24    cmp r3, #0
    0xe0013710    0x28    beq e0013794 <emptySlot+0xac>
    0xe0013714    0x2c    ldr r3, [r0, #12]
    0xe0013718    0x30    ldr r2, [r0, #8]
    0xe001371c    0x34    bic r1, r3, #7
    0xe0013720    0x38    bics r2, r2, #7
    0xe0013724    0x3c    ldrne ip, [r2, #12]
    0xe0013728    0x40    andne ip, ip, #7
    0xe001372c    0x44    orrne ip, ip, r1
    0xe0013730    0x48    strne ip, [r2, #12]
    0xe0013734    0x4c    cmp r1, #0
    0xe0013738    0x50    beq e0013764 <emptySlot+0x7c>
    0xe001373c    0x54    ldr ip, [r1, #8]
    0xe0013740    0x58    and ip, ip, #7
    0xe0013744    0x5c    orr r2, ip, r2
    0xe0013748    0x60    str r2, [r1, #8]
    0xe001374c    0x64    ldr r2, [r1, #12]
    0xe0013750    0x68    orr r3, r3, r2
    0xe0013754    0x6c    and r3, r3, #1
    0xe0013758    0x70    bic r2, r2, #1
    0xe001375c    0x74    orr r3, r3, r2
    0xe0013760    0x78    str r3, [r1, #12]
    0xe0013764    0x7c    mov r3, #0
    0xe0013768    0x80    str r3, [r0]
    0xe001376c    0x84    str r3, [r0, #4]
    0xe0013770    0x88    str r3, [r0, #8]
    0xe0013774    0x8c    str r3, [r0, #12]
    0xe0013778    0x90    ldr r3, [sp]          ; stack access
    0xe001377c    0x94    and r2, r3, #14
    0xe0013780    0x98    cmp r2, #14
    0xe0013784    0x9c    andne r3, r3, #15
    0xe0013788    0xa0    uxtbeq r3, r3
    0xe001378c    0xa4    cmp r3, #30
    0xe0013790    0xa8    beq e001379c <emptySlot+0xb4>
    0xe0013794    0xac    add sp, sp, #12
    0xe0013798    0xb0    pop {pc}              ; stack access
    0xe001379c    0xb4    ldrb r0, [sp, #4]     ; stack access
    0xe00137a0    0xb8    bl e00136d4 <deletedIRQHandler>
    0xe00137a4    0xbc    b e0013794 <emptySlot+0xac>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
48 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `emptySlot` has 89 nodes.

Section deletedIRQHandler (128 of 293)
======================================

Deriving specifications
-----------------------

Section `deletedIRQHandler` consists of 5 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deletedIRQHandler`:

    0xe00136d4     0x0    push {r4, lr}         ; stack access
    0xe00136d8     0x4    mov r1, r0
    0xe00136dc     0x8    mov r0, #0
    0xe00136e0     0xc    bl e0013648 <setIRQState>
    0xe00136e4    0x10    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deletedIRQHandler` has 8 nodes.

Section capSwapForDelete (129 of 293)
=====================================

Deriving specifications
-----------------------

Section `capSwapForDelete` consists of 20 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `capSwapForDelete`:

    0xe0013400     0x0    cmp r0, r1
    0xe0013404     0x4    bxeq lr
    0xe0013408     0x8    push {lr}             ; stack access
    0xe001340c     0xc    sub sp, sp, #28
    0xe0013410    0x10    mov r3, r1
    0xe0013414    0x14    mov r2, r0
    0xe0013418    0x18    add ip, sp, #16
    0xe001341c    0x1c    ldm r0, {r0, r1}
    0xe0013420    0x20    stm ip, {r0, r1}      ; stack access
    0xe0013424    0x24    add lr, sp, #8
    0xe0013428    0x28    ldm r3, {r0, r1}
    0xe001342c    0x2c    stm lr, {r0, r1}      ; stack access
    0xe0013430    0x30    str r3, [sp, #4]      ; stack access
    0xe0013434    0x34    ldr r3, [sp, #12]     ; stack access
    0xe0013438    0x38    str r3, [sp]          ; stack access
    0xe001343c    0x3c    mov r3, r0
    0xe0013440    0x40    ldm ip, {r0, r1}      ; stack access
    0xe0013444    0x44    bl e00132c4 <cteSwap>
    0xe0013448    0x48    add sp, sp, #28
    0xe001344c    0x4c    pop {pc}              ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `capSwapForDelete` has 34 nodes.

Section invokeCNodeMove (130 of 293)
====================================

Deriving specifications
-----------------------

Section `invokeCNodeMove` consists of 9 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `invokeCNodeMove`:

    0xe0013224     0x0    push {lr}             ; stack access
    0xe0013228     0x4    sub sp, sp, #12
    0xe001322c     0x8    mov ip, sp
    0xe0013230     0xc    stm ip, {r0, r1}      ; stack access
    0xe0013234    0x10    ldm ip, {r0, r1}      ; stack access
    0xe0013238    0x14    bl e00131b0 <cteMove>
    0xe001323c    0x18    mov r0, #0
    0xe0013240    0x1c    add sp, sp, #12
    0xe0013244    0x20    pop {pc}              ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeMove` has 14 nodes.

Section invokeCNodeInsert (131 of 293)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeInsert` consists of 9 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `invokeCNodeInsert`:

    0xe001318c     0x0    push {lr}             ; stack access
    0xe0013190     0x4    sub sp, sp, #12
    0xe0013194     0x8    mov ip, sp
    0xe0013198     0xc    stm ip, {r0, r1}      ; stack access
    0xe001319c    0x10    ldm ip, {r0, r1}      ; stack access
    0xe00131a0    0x14    bl e0012fa8 <cteInsert>
    0xe00131a4    0x18    mov r0, #0
    0xe00131a8    0x1c    add sp, sp, #12
    0xe00131ac    0x20    pop {pc}              ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeInsert` has 14 nodes.

Section switchToIdleThread (132 of 293)
=======================================

Deriving specifications
-----------------------

Section `switchToIdleThread` consists of 9 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `switchToIdleThread`:

    0xe0012f20     0x0    push {r4, lr}         ; stack access
    0xe0012f24     0x4    bl e00111b0 <Arch_switchToIdleThread>
    0xe0012f28     0x8    movw r3, #13900 
    0xe0012f2c     0xc    movt r3, #57347 
    0xe0012f30    0x10    movw r2, #36880 
    0xe0012f34    0x14    movt r2, #57346 
    0xe0012f38    0x18    ldr r2, [r2]
    0xe0012f3c    0x1c    str r2, [r3]
    0xe0012f40    0x20    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `switchToIdleThread` has 14 nodes.

Section doFaultTransfer (133 of 293)
====================================

Deriving specifications
-----------------------

Section `doFaultTransfer` consists of 16 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `doFaultTransfer`:

    0xe0012ed4     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0012ed8     0x4    mov r6, r0
    0xe0012edc     0x8    mov r5, r1
    0xe0012ee0     0xc    mov r4, r2
    0xe0012ee4    0x10    mov r2, r3
    0xe0012ee8    0x14    mov r1, r4
    0xe0012eec    0x18    mov r0, r5
    0xe0012ef0    0x1c    bl e0011b24 <setMRs_fault>
    0xe0012ef4    0x20    ldr r3, [r5, #96] 
    0xe0012ef8    0x24    lsl r3, r3, #12
    0xe0012efc    0x28    uxth r3, r3
    0xe0012f00    0x2c    and r0, r0, #127 
    0xe0012f04    0x30    orr r3, r3, r0
    0xe0012f08    0x34    str r3, [r4, #4]
    0xe0012f0c    0x38    str r6, [r4]
    0xe0012f10    0x3c    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doFaultTransfer` has 22 nodes.

Section lookupPivotSlot (134 of 293)
====================================

Deriving specifications
-----------------------

Section `lookupPivotSlot` consists of 14 instructions.


Stack analysis
---------------

Section `lookupPivotSlot` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `lookupPivotSlot`:

    0xe0012e9c     0x0    push {r4, lr}         ; stack access
    0xe0012ea0     0x4    sub sp, sp, #16
    0xe0012ea4     0x8    mov r4, r0
    0xe0012ea8     0xc    add ip, sp, #8
    0xe0012eac    0x10    stm ip, {r1, r2}      ; stack access
    0xe0012eb0    0x14    ldr r2, [sp, #24]     ; stack access
    0xe0012eb4    0x18    str r2, [sp, #4]      ; stack access
    0xe0012eb8    0x1c    str r3, [sp]          ; stack access
    0xe0012ebc    0x20    ldm ip, {r2, r3}      ; stack access
    0xe0012ec0    0x24    mov r1, #1
    0xe0012ec4    0x28    bl e0012cc4 <lookupSlotForCNodeOp>
    0xe0012ec8    0x2c    mov r0, r4
    0xe0012ecc    0x30    add sp, sp, #16
    0xe0012ed0    0x34    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupPivotSlot` has 22 nodes.

Section lookupTargetSlot (135 of 293)
=====================================

Deriving specifications
-----------------------

Section `lookupTargetSlot` consists of 14 instructions.


Stack analysis
---------------

Section `lookupTargetSlot` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `lookupTargetSlot`:

    0xe0012e64     0x0    push {r4, lr}         ; stack access
    0xe0012e68     0x4    sub sp, sp, #16
    0xe0012e6c     0x8    mov r4, r0
    0xe0012e70     0xc    add ip, sp, #8
    0xe0012e74    0x10    stm ip, {r1, r2}      ; stack access
    0xe0012e78    0x14    ldr r2, [sp, #24]     ; stack access
    0xe0012e7c    0x18    str r2, [sp, #4]      ; stack access
    0xe0012e80    0x1c    str r3, [sp]          ; stack access
    0xe0012e84    0x20    ldm ip, {r2, r3}      ; stack access
    0xe0012e88    0x24    mov r1, #0
    0xe0012e8c    0x28    bl e0012cc4 <lookupSlotForCNodeOp>
    0xe0012e90    0x2c    mov r0, r4
    0xe0012e94    0x30    add sp, sp, #16
    0xe0012e98    0x34    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupTargetSlot` has 22 nodes.

Section lookupSourceSlot (136 of 293)
=====================================

Deriving specifications
-----------------------

Section `lookupSourceSlot` consists of 14 instructions.


Stack analysis
---------------

Section `lookupSourceSlot` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `lookupSourceSlot`:

    0xe0012e2c     0x0    push {r4, lr}         ; stack access
    0xe0012e30     0x4    sub sp, sp, #16
    0xe0012e34     0x8    mov r4, r0
    0xe0012e38     0xc    add ip, sp, #8
    0xe0012e3c    0x10    stm ip, {r1, r2}      ; stack access
    0xe0012e40    0x14    ldr r2, [sp, #24]     ; stack access
    0xe0012e44    0x18    str r2, [sp, #4]      ; stack access
    0xe0012e48    0x1c    str r3, [sp]          ; stack access
    0xe0012e4c    0x20    ldm ip, {r2, r3}      ; stack access
    0xe0012e50    0x24    mov r1, #1
    0xe0012e54    0x28    bl e0012cc4 <lookupSlotForCNodeOp>
    0xe0012e58    0x2c    mov r0, r4
    0xe0012e5c    0x30    add sp, sp, #16
    0xe0012e60    0x34    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSourceSlot` has 22 nodes.

Section lookupSlotForCNodeOp (137 of 293)
=========================================

Deriving specifications
-----------------------

Section `lookupSlotForCNodeOp` consists of 90 instructions.
 LDMIA;2,1...++


Stack analysis
---------------

Section `lookupSlotForCNodeOp` expects pointer to stack in r0.
21 stack accesses found. Annotated code for `lookupSlotForCNodeOp`:

    0xe0012cc4      0x0    push {r4, r5, lr}     ; stack access
    0xe0012cc8      0x4    sub sp, sp, #36 
    0xe0012ccc      0x8    mov r4, r0
    0xe0012cd0      0xc    mov r5, r1
    0xe0012cd4     0x10    add r1, sp, #8
    0xe0012cd8     0x14    stm r1, {r2, r3}      ; stack access
    0xe0012cdc     0x18    ldr r2, [sp, #52]     ; stack access
    0xe0012ce0     0x1c    ldr r3, [sp, #8]      ; stack access
    0xe0012ce4     0x20    and r1, r3, #14
    0xe0012ce8     0x24    cmp r1, #14
    0xe0012cec     0x28    andne r3, r3, #15
    0xe0012cf0     0x2c    uxtbeq r3, r3
    0xe0012cf4     0x30    cmp r3, #10
    0xe0012cf8     0x34    bne e0012d54 <lookupSlotForCNodeOp+0x90>
    0xe0012cfc     0x38    sub r3, r2, #1
    0xe0012d00     0x3c    cmp r3, #31
    0xe0012d04     0x40    bhi e0012d8c <lookupSlotForCNodeOp+0xc8>
    0xe0012d08     0x44    str r2, [sp]          ; stack access
    0xe0012d0c     0x48    ldr r3, [sp, #48]     ; stack access
    0xe0012d10     0x4c    add r2, sp, #8
    0xe0012d14     0x50    ldm r2, {r1, r2}      ; stack access
    0xe0012d18     0x54    add r0, sp, #20
    0xe0012d1c     0x58    bl e0012a44 <resolveAddressBits>
    0xe0012d20     0x5c    ldr r3, [sp, #28]     ; stack access
    0xe0012d24     0x60    ldr r2, [sp, #20]     ; stack access
    0xe0012d28     0x64    cmp r2, #0
    0xe0012d2c     0x68    bne e0012dc0 <lookupSlotForCNodeOp+0xfc>
    0xe0012d30     0x6c    cmp r3, #0
    0xe0012d34     0x70    bne e0012de8 <lookupSlotForCNodeOp+0x124>
    0xe0012d38     0x74    mov r3, #0
    0xe0012d3c     0x78    str r3, [r4]          ; stack access
    0xe0012d40     0x7c    ldr r3, [sp, #24]     ; stack access
    0xe0012d44     0x80    str r3, [r4, #4]      ; stack access
    0xe0012d48     0x84    mov r0, r4
    0xe0012d4c     0x88    add sp, sp, #36 
    0xe0012d50     0x8c    pop {r4, r5, pc}      ; stack access
    0xe0012d54     0x90    movw r3, #36896 
    0xe0012d58     0x94    movt r3, #57346 
    0xe0012d5c     0x98    mov r2, #6
    0xe0012d60     0x9c    str r2, [r3, #24]
    0xe0012d64     0xa0    str r5, [r3, #20]
    0xe0012d68     0xa4    movw r3, #36884 
    0xe0012d6c     0xa8    movt r3, #57346 
    0xe0012d70     0xac    mov r2, #0
    0xe0012d74     0xb0    str r2, [r3]
    0xe0012d78     0xb4    str r2, [r3, #4]
    0xe0012d7c     0xb8    mov r3, #3
    0xe0012d80     0xbc    str r3, [r0]          ; stack access
    0xe0012d84     0xc0    str r2, [r0, #4]      ; stack access
    0xe0012d88     0xc4    b e0012d48 <lookupSlotForCNodeOp+0x84>
    0xe0012d8c     0xc8    movw r3, #36896 
    0xe0012d90     0xcc    movt r3, #57346 
    0xe0012d94     0xd0    mov r2, #4
    0xe0012d98     0xd4    str r2, [r3, #24]
    0xe0012d9c     0xd8    mov r2, #1
    0xe0012da0     0xdc    str r2, [r3, #8]
    0xe0012da4     0xe0    mov r2, #32
    0xe0012da8     0xe4    str r2, [r3, #12]
    0xe0012dac     0xe8    mov r3, #3
    0xe0012db0     0xec    str r3, [r0]          ; stack access
    0xe0012db4     0xf0    mov r3, #0
    0xe0012db8     0xf4    str r3, [r0, #4]      ; stack access
    0xe0012dbc     0xf8    b e0012d48 <lookupSlotForCNodeOp+0x84>
    0xe0012dc0     0xfc    movw r3, #36896 
    0xe0012dc4    0x100    movt r3, #57346 
    0xe0012dc8    0x104    mov r2, #6
    0xe0012dcc    0x108    str r2, [r3, #24]
    0xe0012dd0    0x10c    str r5, [r3, #20]
    0xe0012dd4    0x110    mov r3, #3
    0xe0012dd8    0x114    str r3, [r4]          ; stack access
    0xe0012ddc    0x118    mov r3, #0
    0xe0012de0    0x11c    str r3, [r4, #4]      ; stack access
    0xe0012de4    0x120    b e0012d48 <lookupSlotForCNodeOp+0x84>
    0xe0012de8    0x124    movw r2, #36896 
    0xe0012dec    0x128    movt r2, #57346 
    0xe0012df0    0x12c    mov r1, #6
    0xe0012df4    0x130    str r1, [r2, #24]
    0xe0012df8    0x134    str r5, [r2, #20]
    0xe0012dfc    0x138    movw r2, #36884 
    0xe0012e00    0x13c    movt r2, #57346 
    0xe0012e04    0x140    lsl r3, r3, #2
    0xe0012e08    0x144    uxtb r3, r3
    0xe0012e0c    0x148    orr r3, r3, #2
    0xe0012e10    0x14c    str r3, [r2]
    0xe0012e14    0x150    mov r3, #0
    0xe0012e18    0x154    str r3, [r2, #4]
    0xe0012e1c    0x158    mov r2, #3
    0xe0012e20    0x15c    str r2, [r4]          ; stack access
    0xe0012e24    0x160    str r3, [r4, #4]      ; stack access
    0xe0012e28    0x164    b e0012d48 <lookupSlotForCNodeOp+0x84>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
90 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSlotForCNodeOp` has 137 nodes.

Section lookupCapAndSlot (138 of 293)
=====================================

Deriving specifications
-----------------------

Section `lookupCapAndSlot` consists of 22 instructions.


Stack analysis
---------------

Section `lookupCapAndSlot` expects pointer to stack in r0.
11 stack accesses found. Annotated code for `lookupCapAndSlot`:

    0xe0012c6c     0x0    push {r4, lr}         ; stack access
    0xe0012c70     0x4    sub sp, sp, #8
    0xe0012c74     0x8    mov r4, r0
    0xe0012c78     0xc    mov r0, sp
    0xe0012c7c    0x10    bl e0012bc8 <lookupSlot>
    0xe0012c80    0x14    ldr r2, [sp]          ; stack access
    0xe0012c84    0x18    ldr r3, [sp, #4]      ; stack access
    0xe0012c88    0x1c    cmp r2, #0
    0xe0012c8c    0x20    strne r2, [r4]        ; stack access
    0xe0012c90    0x24    movne r3, #0
    0xe0012c94    0x28    strne r3, [r4, #4]    ; stack access
    0xe0012c98    0x2c    strne r3, [r4, #8]    ; stack access
    0xe0012c9c    0x30    ldreq r1, [r3]
    0xe0012ca0    0x34    ldreq r2, [r3, #4]
    0xe0012ca4    0x38    moveq r0, #0
    0xe0012ca8    0x3c    streq r0, [r4]        ; stack access
    0xe0012cac    0x40    streq r1, [r4, #4]    ; stack access
    0xe0012cb0    0x44    streq r2, [r4, #8]    ; stack access
    0xe0012cb4    0x48    str r3, [r4, #12]     ; stack access
    0xe0012cb8    0x4c    mov r0, r4
    0xe0012cbc    0x50    add sp, sp, #8
    0xe0012cc0    0x54    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupCapAndSlot` has 56 nodes.

Section lookupCap (139 of 293)
==============================

Deriving specifications
-----------------------

Section `lookupCap` consists of 20 instructions.


Stack analysis
---------------

Section `lookupCap` expects pointer to stack in r0.
9 stack accesses found. Annotated code for `lookupCap`:

    0xe0012c1c     0x0    push {r4, lr}         ; stack access
    0xe0012c20     0x4    sub sp, sp, #8
    0xe0012c24     0x8    mov r4, r0
    0xe0012c28     0xc    mov r0, sp
    0xe0012c2c    0x10    bl e0012bc8 <lookupSlot>
    0xe0012c30    0x14    ldr r3, [sp]          ; stack access
    0xe0012c34    0x18    cmp r3, #0
    0xe0012c38    0x1c    strne r3, [r4]        ; stack access
    0xe0012c3c    0x20    movne r3, #0
    0xe0012c40    0x24    strne r3, [r4, #4]    ; stack access
    0xe0012c44    0x28    ldreq r3, [sp, #4]    ; stack access
    0xe0012c48    0x2c    ldreq r2, [r3]
    0xe0012c4c    0x30    ldreq r3, [r3, #4]
    0xe0012c50    0x34    moveq r1, #0
    0xe0012c54    0x38    streq r1, [r4]        ; stack access
    0xe0012c58    0x3c    streq r2, [r4, #4]    ; stack access
    0xe0012c5c    0x40    str r3, [r4, #8]      ; stack access
    0xe0012c60    0x44    mov r0, r4
    0xe0012c64    0x48    add sp, sp, #8
    0xe0012c68    0x4c    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupCap` has 50 nodes.

Section lookupSlot (140 of 293)
===============================

Deriving specifications
-----------------------

Section `lookupSlot` consists of 21 instructions.


Stack analysis
---------------

Section `lookupSlot` expects pointer to stack in r0.
9 stack accesses found. Annotated code for `lookupSlot`:

    0xe0012bc8     0x0    push {r4, lr}         ; stack access
    0xe0012bcc     0x4    sub sp, sp, #32
    0xe0012bd0     0x8    mov r4, r0
    0xe0012bd4     0xc    bic r1, r1, #508 
    0xe0012bd8    0x10    bic r1, r1, #3
    0xe0012bdc    0x14    add ip, sp, #24
    0xe0012be0    0x18    ldm r1, {r0, r1}
    0xe0012be4    0x1c    stm ip, {r0, r1}      ; stack access
    0xe0012be8    0x20    mov r3, #32
    0xe0012bec    0x24    str r3, [sp]          ; stack access
    0xe0012bf0    0x28    mov r3, r2
    0xe0012bf4    0x2c    ldm ip, {r1, r2}      ; stack access
    0xe0012bf8    0x30    add r0, sp, #12
    0xe0012bfc    0x34    bl e0012a44 <resolveAddressBits>
    0xe0012c00    0x38    ldr r3, [sp, #12]     ; stack access
    0xe0012c04    0x3c    str r3, [r4]          ; stack access
    0xe0012c08    0x40    ldr r3, [sp, #16]     ; stack access
    0xe0012c0c    0x44    str r3, [r4, #4]      ; stack access
    0xe0012c10    0x48    mov r0, r4
    0xe0012c14    0x4c    add sp, sp, #32
    0xe0012c18    0x50    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSlot` has 32 nodes.

Section arch_clean_invalidate_L1_caches (141 of 293)
====================================================

Deriving specifications
-----------------------

Section `arch_clean_invalidate_L1_caches` consists of 16 instructions.
Skipping f57ff04f dsb sy
Skipping ee073f15 mcr 15, 0, r3, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy


Stack analysis
---------------

3 stack accesses found. Annotated code for `arch_clean_invalidate_L1_caches`:

    0xe001295c     0x0    push {r4, lr}         ; stack access
    0xe0012960     0x4    mov r4, r0
    0xe0012964     0x8    dsb sy
    0xe0012968     0xc    tst r0, #2
    0xe001296c    0x10    bne e0012990 <arch_clean_invalidate_L1_caches+0x34>
    0xe0012970    0x14    tst r4, #1
    0xe0012974    0x18    popeq {r4, pc}        ; stack access
    0xe0012978    0x1c    mov r3, #0
    0xe001297c    0x20    mcr 15, 0, r3, cr7, cr5, {0}
    0xe0012980    0x24    isb sy
    0xe0012984    0x28    dsb sy
    0xe0012988    0x2c    isb sy
    0xe001298c    0x30    pop {r4, pc}          ; stack access
    0xe0012990    0x34    bl e0011e8c <cleanInvalidate_L1D>
    0xe0012994    0x38    dsb sy
    0xe0012998    0x3c    b e0012970 <arch_clean_invalidate_L1_caches+0x14>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arch_clean_invalidate_L1_caches` has 30 nodes.

Section cleanInvalidateL1Caches (142 of 293)
============================================

Deriving specifications
-----------------------

Section `cleanInvalidateL1Caches` consists of 9 instructions.
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee073f15 mcr 15, 0, r3, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `cleanInvalidateL1Caches`:

    0xe001288c     0x0    push {r4, lr}         ; stack access
    0xe0012890     0x4    dsb sy
    0xe0012894     0x8    bl e0011dac <cleanInvalidate_D_PoC>
    0xe0012898     0xc    dsb sy
    0xe001289c    0x10    mov r3, #0
    0xe00128a0    0x14    mcr 15, 0, r3, cr7, cr5, {0}
    0xe00128a4    0x18    isb sy
    0xe00128a8    0x1c    dsb sy
    0xe00128ac    0x20    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanInvalidateL1Caches` has 17 nodes.

Section cleanCaches_PoU (143 of 293)
====================================

Deriving specifications
-----------------------

Section `cleanCaches_PoU` consists of 9 instructions.
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee073f15 mcr 15, 0, r3, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `cleanCaches_PoU`:

    0xe0012620     0x0    push {r4, lr}         ; stack access
    0xe0012624     0x4    dsb sy
    0xe0012628     0x8    bl e0011ccc <clean_D_PoU>
    0xe001262c     0xc    dsb sy
    0xe0012630    0x10    mov r3, #0
    0xe0012634    0x14    mcr 15, 0, r3, cr7, cr5, {0}
    0xe0012638    0x18    isb sy
    0xe001263c    0x1c    dsb sy
    0xe0012640    0x20    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanCaches_PoU` has 17 nodes.

Section invalidateCacheRange_RAM (144 of 293)
=============================================

Deriving specifications
-----------------------

Section `invalidateCacheRange_RAM` consists of 55 instructions.
Skipping f57ff05f dmb sy
Skipping ee073f36 mcr 15, 0, r3, cr7, cr6, {1}
Skipping f57ff05f dmb sy
Skipping f57ff04f dsb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `invalidateCacheRange_RAM`:

    0xe0012414     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0012418     0x4    mov r4, r0
    0xe001241c     0x8    mov r5, r1
    0xe0012420     0xc    mov r6, r2
    0xe0012424    0x10    tst r0, #31
    0xe0012428    0x14    bne e00124cc <invalidateCacheRange_RAM+0xb8>
    0xe001242c    0x18    add r3, r5, #1
    0xe0012430    0x1c    tst r3, #31
    0xe0012434    0x20    bne e00124d8 <invalidateCacheRange_RAM+0xc4>
    0xe0012438    0x24    bic r3, r6, #31
    0xe001243c    0x28    add r2, r5, #32
    0xe0012440    0x2c    add r2, r2, r6
    0xe0012444    0x30    sub r2, r2, r4
    0xe0012448    0x34    bic r2, r2, #31
    0xe001244c    0x38    cmp r3, r2
    0xe0012450    0x3c    beq e001246c <invalidateCacheRange_RAM+0x58>
    0xe0012454    0x40    movw r1, #12543 
    0xe0012458    0x44    movt r1, #65520 
    0xe001245c    0x48    str r3, [r1, #1649] 
    0xe0012460    0x4c    add r3, r3, #32
    0xe0012464    0x50    cmp r3, r2
    0xe0012468    0x54    bne e001245c <invalidateCacheRange_RAM+0x48>
    0xe001246c    0x58    dmb sy
    0xe0012470    0x5c    movw r3, #12543 
    0xe0012474    0x60    movt r3, #65520 
    0xe0012478    0x64    mov r2, #0
    0xe001247c    0x68    str r2, [r3, #1585] 
    0xe0012480    0x6c    movw r2, #12543 
    0xe0012484    0x70    movt r2, #65520 
    0xe0012488    0x74    ldr r3, [r2, #1585] 
    0xe001248c    0x78    tst r3, #1
    0xe0012490    0x7c    bne e0012488 <invalidateCacheRange_RAM+0x74>
    0xe0012494    0x80    lsr r0, r4, #5
    0xe0012498    0x84    lsr r1, r5, #5
    0xe001249c    0x88    add r1, r1, #1
    0xe00124a0    0x8c    cmp r0, r1
    0xe00124a4    0x90    bcs e00124c4 <invalidateCacheRange_RAM+0xb0>
    0xe00124a8    0x94    lsl r3, r0, #5
    0xe00124ac    0x98    mcr 15, 0, r3, cr7, cr6, {1}
    0xe00124b0    0x9c    dmb sy
    0xe00124b4    0xa0    add r0, r0, #1
    0xe00124b8    0xa4    add r3, r3, #32
    0xe00124bc    0xa8    cmp r0, r1
    0xe00124c0    0xac    bne e00124ac <invalidateCacheRange_RAM+0x98>
    0xe00124c4    0xb0    dsb sy
    0xe00124c8    0xb4    pop {r4, r5, r6, pc}  ; stack access
    0xe00124cc    0xb8    mov r1, r0
    0xe00124d0    0xbc    bl e0012030 <cleanCacheRange_RAM>
    0xe00124d4    0xc0    b e001242c <invalidateCacheRange_RAM+0x18>
    0xe00124d8    0xc4    bic r0, r5, #31
    0xe00124dc    0xc8    add r2, r6, r0
    0xe00124e0    0xcc    sub r2, r2, r4
    0xe00124e4    0xd0    mov r1, r0
    0xe00124e8    0xd4    bl e0012030 <cleanCacheRange_RAM>
    0xe00124ec    0xd8    b e0012438 <invalidateCacheRange_RAM+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
55 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invalidateCacheRange_RAM` has 80 nodes.

Section lockTLBEntry (145 of 293)
=================================

Deriving specifications
-----------------------

Section `lockTLBEntry` consists of 11 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `lockTLBEntry`:

    0xe0011f18     0x0    push {r4, lr}         ; stack access
    0xe0011f1c     0x4    movw r3, #47284 
    0xe0011f20     0x8    movt r3, #57345 
    0xe0011f24     0xc    ldr r1, [r3]
    0xe0011f28    0x10    add r2, r1, #1
    0xe0011f2c    0x14    str r2, [r3]
    0xe0011f30    0x18    lsl r1, r1, #28
    0xe0011f34    0x1c    lsl r2, r2, #28
    0xe0011f38    0x20    orr r1, r1, #1
    0xe0011f3c    0x24    bl e0010840 <lockTLBEntryCritical>
    0xe0011f40    0x28    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lockTLBEntry` has 16 nodes.

Section Arch_setMRs_fault (146 of 293)
======================================

Deriving specifications
-----------------------

Section `Arch_setMRs_fault` consists of 16 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_setMRs_fault`:

    0xe0011ae4     0x0    cmp r3, #5
    0xe0011ae8     0x4    bne e0011b1c <Arch_setMRs_fault+0x38>
    0xe0011aec     0x8    ldr r3, [r0, #68] 
    0xe0011af0     0xc    str r3, [r1, #8]
    0xe0011af4    0x10    ldr r3, [r0, #100] 
    0xe0011af8    0x14    str r3, [r1, #12]
    0xe0011afc    0x18    ldr r3, [r0, #96] 
    0xe0011b00    0x1c    ubfx r3, r3, #17, #1
    0xe0011b04    0x20    str r3, [r1, #16]
    0xe0011b08    0x24    ldr r3, [r0, #96] 
    0xe0011b0c    0x28    lsr r3, r3, #18
    0xe0011b10    0x2c    str r3, [r1, #20]
    0xe0011b14    0x30    mov r0, #4
    0xe0011b18    0x34    bx lr
    0xe0011b1c    0x38    push {r4, lr}         ; stack access
    0xe0011b20    0x3c    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_setMRs_fault` has 29 nodes.

Section Arch_handleFaultReply (147 of 293)
==========================================

Deriving specifications
-----------------------

Section `Arch_handleFaultReply` consists of 6 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_handleFaultReply`:

    0xe0011acc     0x0    cmp r2, #5
    0xe0011ad0     0x4    bne e0011adc <Arch_handleFaultReply+0x10>
    0xe0011ad4     0x8    mov r0, #1
    0xe0011ad8     0xc    bx lr
    0xe0011adc    0x10    push {r4, lr}         ; stack access
    0xe0011ae0    0x14    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_handleFaultReply` has 11 nodes.

Section Arch_getObjectSize (148 of 293)
=======================================

Deriving specifications
-----------------------

Section `Arch_getObjectSize` consists of 24 instructions.
Switch found.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_getObjectSize`:

    0xe0011a68     0x0    sub r0, r0, #5
    0xe0011a6c     0x4    cmp r0, #5
    0xe0011a70     0x8    ldrls pc, [pc, r0, lsl #2]
    0xe0011a74     0xc    b e0011ab0 <Arch_getObjectSize+0x48>
    0xe0011a78    0x10    .word 0xe0011ab8
    0xe0011a7c    0x14    .word 0xe0011a90
    0xe0011a80    0x18    .word 0xe0011ac0
    0xe0011a84    0x1c    .word 0xe0011a98
    0xe0011a88    0x20    .word 0xe0011aa0
    0xe0011a8c    0x24    .word 0xe0011aa8
    0xe0011a90    0x28    mov r0, #16
    0xe0011a94    0x2c    bx lr
    0xe0011a98    0x30    mov r0, #24
    0xe0011a9c    0x34    bx lr
    0xe0011aa0    0x38    mov r0, #10
    0xe0011aa4    0x3c    bx lr
    0xe0011aa8    0x40    mov r0, #14
    0xe0011aac    0x44    bx lr
    0xe0011ab0    0x48    push {r4, lr}         ; stack access
    0xe0011ab4    0x4c    bl e0010904 <halt>
    0xe0011ab8    0x50    mov r0, #12
    0xe0011abc    0x54    bx lr
    0xe0011ac0    0x58    mov r0, #20
    0xe0011ac4    0x5c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_getObjectSize` has 45 nodes.

Section Arch_sameObjectAs (149 of 293)
======================================

Deriving specifications
-----------------------

Section `Arch_sameObjectAs` consists of 79 instructions.
 MVN (reg)...++
 EOR (imm)...++


Stack analysis
---------------

9 stack accesses found. Annotated code for `Arch_sameObjectAs`:

    0xe001192c      0x0    push {lr}             ; stack access
    0xe0011930      0x4    sub sp, sp, #20
    0xe0011934      0x8    add ip, sp, #16
    0xe0011938      0xc    stmdb ip, {r0, r1}    ; stack access
    0xe001193c     0x10    mov r1, sp
    0xe0011940     0x14    stm r1, {r2, r3}      ; stack access
    0xe0011944     0x18    mov r1, r2
    0xe0011948     0x1c    ldr r3, [sp, #8]      ; stack access
    0xe001194c     0x20    and r2, r3, #14
    0xe0011950     0x24    cmp r2, #14
    0xe0011954     0x28    andne r2, r3, #15
    0xe0011958     0x2c    uxtbeq r2, r3
    0xe001195c     0x30    cmp r2, #1
    0xe0011960     0x34    beq e0011988 <Arch_sameObjectAs+0x5c>
    0xe0011964     0x38    cmp r2, #3
    0xe0011968     0x3c    beq e00119ec <Arch_sameObjectAs+0xc0>
    0xe001196c     0x40    mov r3, sp
    0xe0011970     0x44    ldm r3, {r2, r3}      ; stack access
    0xe0011974     0x48    add r1, sp, #16
    0xe0011978     0x4c    ldmdb r1, {r0, r1}    ; stack access
    0xe001197c     0x50    bl e0011624 <Arch_sameRegionAs>
    0xe0011980     0x54    add sp, sp, #20
    0xe0011984     0x58    pop {pc}              ; stack access
    0xe0011988     0x5c    and r2, r1, #14
    0xe001198c     0x60    cmp r2, #14
    0xe0011990     0x64    andne r2, r1, #15
    0xe0011994     0x68    uxtbeq r2, r1
    0xe0011998     0x6c    cmp r2, #1
    0xe001199c     0x70    beq e00119b0 <Arch_sameObjectAs+0x84>
    0xe00119a0     0x74    cmp r2, #3
    0xe00119a4     0x78    bne e001196c <Arch_sameObjectAs+0x40>
    0xe00119a8     0x7c    mov r0, #0
    0xe00119ac     0x80    b e0011980 <Arch_sameObjectAs+0x54>
    0xe00119b0     0x84    lsl r0, r1, #8
    0xe00119b4     0x88    bic r0, r0, #4080 
    0xe00119b8     0x8c    bic r0, r0, #15
    0xe00119bc     0x90    lsl r2, r3, #8
    0xe00119c0     0x94    bic r2, r2, #4080 
    0xe00119c4     0x98    bic r2, r2, #15
    0xe00119c8     0x9c    cmp r0, r2
    0xe00119cc     0xa0    movne r0, #0
    0xe00119d0     0xa4    bne e0011980 <Arch_sameObjectAs+0x54>
    0xe00119d4     0xa8    mvn r1, r1
    0xe00119d8     0xac    lsr r1, r1, #31
    0xe00119dc     0xb0    cmp r1, r3, lsr #31
    0xe00119e0     0xb4    movne r0, #1
    0xe00119e4     0xb8    moveq r0, #0
    0xe00119e8     0xbc    b e0011980 <Arch_sameObjectAs+0x54>
    0xe00119ec     0xc0    and r2, r1, #14
    0xe00119f0     0xc4    cmp r2, #14
    0xe00119f4     0xc8    andne r2, r1, #15
    0xe00119f8     0xcc    uxtbeq r2, r1
    0xe00119fc     0xd0    cmp r2, #3
    0xe0011a00     0xd4    beq e0011a14 <Arch_sameObjectAs+0xe8>
    0xe0011a04     0xd8    cmp r2, #1
    0xe0011a08     0xdc    moveq r0, #0
    0xe0011a0c     0xe0    bne e001196c <Arch_sameObjectAs+0x40>
    0xe0011a10     0xe4    b e0011980 <Arch_sameObjectAs+0x54>
    0xe0011a14     0xe8    lsl r0, r1, #10
    0xe0011a18     0xec    bic r0, r0, #16320 
    0xe0011a1c     0xf0    bic r0, r0, #63 
    0xe0011a20     0xf4    lsl r2, r3, #10
    0xe0011a24     0xf8    bic r2, r2, #16320 
    0xe0011a28     0xfc    bic r2, r2, #63 
    0xe0011a2c    0x100    cmp r0, r2
    0xe0011a30    0x104    movne r0, #0
    0xe0011a34    0x108    bne e0011980 <Arch_sameObjectAs+0x54>
    0xe0011a38    0x10c    ldr r2, [sp, #12]     ; stack access
    0xe0011a3c    0x110    lsr r2, r2, #30
    0xe0011a40    0x114    ldr r0, [sp, #4]      ; stack access
    0xe0011a44    0x118    cmp r2, r0, lsr #30
    0xe0011a48    0x11c    movne r0, #0
    0xe0011a4c    0x120    bne e0011980 <Arch_sameObjectAs+0x54>
    0xe0011a50    0x124    eor r1, r1, #536870912 
    0xe0011a54    0x128    ubfx r0, r3, #29, #1
    0xe0011a58    0x12c    ubfx r3, r1, #29, #1
    0xe0011a5c    0x130    subs r0, r0, r3
    0xe0011a60    0x134    movne r0, #1
    0xe0011a64    0x138    b e0011980 <Arch_sameObjectAs+0x54>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
79 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_sameObjectAs` has 133 nodes.

Section Arch_sameRegionAs (150 of 293)
======================================

Deriving specifications
-----------------------

Section `Arch_sameRegionAs` consists of 194 instructions.
Switch found.
Switch found.
Switch found.
 ADD (reg-shift)...............+++++++++++++++
 ANDCS (imm)....+++


Stack analysis
---------------

10 stack accesses found. Annotated code for `Arch_sameRegionAs`:

    0xe0011624      0x0    push {r4, lr}         ; stack access
    0xe0011628      0x4    sub sp, sp, #16
    0xe001162c      0x8    add ip, sp, #16
    0xe0011630      0xc    stmdb ip, {r0, r1}    ; stack access
    0xe0011634     0x10    mov r1, sp
    0xe0011638     0x14    stm r1, {r2, r3}      ; stack access
    0xe001163c     0x18    mov r3, r2
    0xe0011640     0x1c    ldr r0, [sp, #8]      ; stack access
    0xe0011644     0x20    and r2, r0, #14
    0xe0011648     0x24    cmp r2, #14
    0xe001164c     0x28    andne r1, r0, #15
    0xe0011650     0x2c    uxtbeq r1, r0
    0xe0011654     0x30    sub r2, r1, #1
    0xe0011658     0x34    cmp r2, #10
    0xe001165c     0x38    ldrls pc, [pc, r2, lsl #2]
    0xe0011660     0x3c    b e001190c <Arch_sameRegionAs+0x2e8>
    0xe0011664     0x40    .word 0xe0011690
    0xe0011668     0x44    .word 0xe001190c
    0xe001166c     0x48    .word 0xe0011690
    0xe0011670     0x4c    .word 0xe001190c
    0xe0011674     0x50    .word 0xe00118d8
    0xe0011678     0x54    .word 0xe001190c
    0xe001167c     0x58    .word 0xe001183c
    0xe0011680     0x5c    .word 0xe001190c
    0xe0011684     0x60    .word 0xe0011878
    0xe0011688     0x64    .word 0xe001190c
    0xe001168c     0x68    .word 0xe00118b4
    0xe0011690     0x6c    and r2, r3, #14
    0xe0011694     0x70    cmp r2, #14
    0xe0011698     0x74    andne ip, r3, #15
    0xe001169c     0x78    uxtbeq ip, r3
    0xe00116a0     0x7c    bic r2, ip, #2
    0xe00116a4     0x80    cmp r2, #1
    0xe00116a8     0x84    bne e0011914 <Arch_sameRegionAs+0x2f0>
    0xe00116ac     0x88    cmp r1, #1
    0xe00116b0     0x8c    beq e00116e0 <Arch_sameRegionAs+0xbc>
    0xe00116b4     0x90    cmp r1, #3
    0xe00116b8     0x94    beq e0011708 <Arch_sameRegionAs+0xe4>
    0xe00116bc     0x98    cmp ip, #1
    0xe00116c0     0x9c    beq e001174c <Arch_sameRegionAs+0x128>
    0xe00116c4     0xa0    cmp ip, #3
    0xe00116c8     0xa4    moveq r0, #0
    0xe00116cc     0xa8    bne e00117a0 <Arch_sameRegionAs+0x17c>
    0xe00116d0     0xac    lsl r3, r3, #10
    0xe00116d4     0xb0    bic r3, r3, #16320 
    0xe00116d8     0xb4    bic r3, r3, #63 
    0xe00116dc     0xb8    b e001175c <Arch_sameRegionAs+0x138>
    0xe00116e0     0xbc    lsl r0, r0, #8
    0xe00116e4     0xc0    bic r0, r0, #4080 
    0xe00116e8     0xc4    bic r0, r0, #15
    0xe00116ec     0xc8    cmp ip, #1
    0xe00116f0     0xcc    beq e0011750 <Arch_sameRegionAs+0x12c>
    0xe00116f4     0xd0    cmp ip, #3
    0xe00116f8     0xd4    movne r3, #0
    0xe00116fc     0xd8    movne r2, r3
    0xe0011700     0xdc    bne e0011730 <Arch_sameRegionAs+0x10c>
    0xe0011704     0xe0    b e00116d0 <Arch_sameRegionAs+0xac>
    0xe0011708     0xe4    lsl r0, r0, #10
    0xe001170c     0xe8    bic r0, r0, #16320 
    0xe0011710     0xec    bic r0, r0, #63 
    0xe0011714     0xf0    cmp ip, #1
    0xe0011718     0xf4    beq e0011750 <Arch_sameRegionAs+0x12c>
    0xe001171c     0xf8    cmp ip, #3
    0xe0011720     0xfc    ldrne r2, [sp, #12]   ; stack access
    0xe0011724    0x100    movne r3, #0
    0xe0011728    0x104    beq e00116d0 <Arch_sameRegionAs+0xac>
    0xe001172c    0x108    lsr r2, r2, #30
    0xe0011730    0x10c    cmp r2, #3
    0xe0011734    0x110    ldrls pc, [pc, r2, lsl #2]
    0xe0011738    0x114    b e00117e8 <Arch_sameRegionAs+0x1c4>
    0xe001173c    0x118    .word 0xe0011768
    0xe0011740    0x11c    .word 0xe001191c
    0xe0011744    0x120    .word 0xe00117c4
    0xe0011748    0x124    .word 0xe0011924
    0xe001174c    0x128    mov r0, #0
    0xe0011750    0x12c    lsl r3, r3, #8
    0xe0011754    0x130    bic r3, r3, #4080 
    0xe0011758    0x134    bic r3, r3, #15
    0xe001175c    0x138    ldr r2, [sp, #12]     ; stack access
    0xe0011760    0x13c    cmp r1, #3
    0xe0011764    0x140    beq e001172c <Arch_sameRegionAs+0x108>
    0xe0011768    0x144    add r4, r0, #4080 
    0xe001176c    0x148    add r4, r4, #15
    0xe0011770    0x14c    ldr r1, [sp, #4]      ; stack access
    0xe0011774    0x150    cmp ip, #3
    0xe0011778    0x154    movne r1, #0
    0xe001177c    0x158    bne e0011784 <Arch_sameRegionAs+0x160>
    0xe0011780    0x15c    lsr r1, r1, #30
    0xe0011784    0x160    cmp r1, #3
    0xe0011788    0x164    ldrls pc, [pc, r1, lsl #2]
    0xe001178c    0x168    b e0011828 <Arch_sameRegionAs+0x204>
    0xe0011790    0x16c    .word 0xe001182c
    0xe0011794    0x170    .word 0xe00117ec
    0xe0011798    0x174    .word 0xe0011834
    0xe001179c    0x178    .word 0xe0011820
    0xe00117a0    0x17c    ldr r2, [sp, #12]     ; stack access
    0xe00117a4    0x180    cmp r1, #3
    0xe00117a8    0x184    moveq r0, #0
    0xe00117ac    0x188    moveq r3, r0
    0xe00117b0    0x18c    beq e001172c <Arch_sameRegionAs+0x108>
    0xe00117b4    0x190    mov r0, #0
    0xe00117b8    0x194    mov r3, r0
    0xe00117bc    0x198    mov r2, r0
    0xe00117c0    0x19c    b e0011730 <Arch_sameRegionAs+0x10c>
    0xe00117c4    0x1a0    mov lr, #20
    0xe00117c8    0x1a4    sub r2, r0, #1
    0xe00117cc    0x1a8    mov r1, #1
    0xe00117d0    0x1ac    add r4, r2, r1, lsl lr
    0xe00117d4    0x1b0    ldr r1, [sp, #4]      ; stack access
    0xe00117d8    0x1b4    cmp ip, #3
    0xe00117dc    0x1b8    beq e0011780 <Arch_sameRegionAs+0x15c>
    0xe00117e0    0x1bc    mov lr, #12
    0xe00117e4    0x1c0    b e00117f0 <Arch_sameRegionAs+0x1cc>
    0xe00117e8    0x1c4    bl e0010904 <halt>
    0xe00117ec    0x1c8    mov lr, #16
    0xe00117f0    0x1cc    sub r1, r3, #1
    0xe00117f4    0x1d0    mov ip, #1
    0xe00117f8    0x1d4    add r1, r1, ip, lsl lr
    0xe00117fc    0x1d8    cmp r1, r4
    0xe0011800    0x1dc    movhi r2, #0
    0xe0011804    0x1e0    movls r2, #1
    0xe0011808    0x1e4    cmp r1, r3
    0xe001180c    0x1e8    movcc r2, #0
    0xe0011810    0x1ec    cmp r3, r0
    0xe0011814    0x1f0    movcc r0, #0
    0xe0011818    0x1f4    andcs r0, r2, #1
    0xe001181c    0x1f8    b e00118d0 <Arch_sameRegionAs+0x2ac>
    0xe0011820    0x1fc    mov lr, #24
    0xe0011824    0x200    b e00117f0 <Arch_sameRegionAs+0x1cc>
    0xe0011828    0x204    bl e0010904 <halt>
    0xe001182c    0x208    mov lr, #12
    0xe0011830    0x20c    b e00117f0 <Arch_sameRegionAs+0x1cc>
    0xe0011834    0x210    mov lr, #20
    0xe0011838    0x214    b e00117f0 <Arch_sameRegionAs+0x1cc>
    0xe001183c    0x218    and r2, r3, #14
    0xe0011840    0x21c    cmp r2, #14
    0xe0011844    0x220    andne r2, r3, #15
    0xe0011848    0x224    uxtbeq r2, r3
    0xe001184c    0x228    cmp r2, #7
    0xe0011850    0x22c    movne r0, #0
    0xe0011854    0x230    bne e00118d0 <Arch_sameRegionAs+0x2ac>
    0xe0011858    0x234    bic r3, r3, #1020 
    0xe001185c    0x238    bic r3, r3, #3
    0xe0011860    0x23c    bic r0, r0, #1020 
    0xe0011864    0x240    bic r0, r0, #3
    0xe0011868    0x244    cmp r3, r0
    0xe001186c    0x248    movne r0, #0
    0xe0011870    0x24c    moveq r0, #1
    0xe0011874    0x250    b e00118d0 <Arch_sameRegionAs+0x2ac>
    0xe0011878    0x254    and r2, r3, #14
    0xe001187c    0x258    cmp r2, #14
    0xe0011880    0x25c    andne r2, r3, #15
    0xe0011884    0x260    uxtbeq r2, r3
    0xe0011888    0x264    cmp r2, #9
    0xe001188c    0x268    movne r0, #0
    0xe0011890    0x26c    bne e00118d0 <Arch_sameRegionAs+0x2ac>
    0xe0011894    0x270    bic r3, r3, #16320 
    0xe0011898    0x274    bic r3, r3, #63 
    0xe001189c    0x278    bic r0, r0, #16320 
    0xe00118a0    0x27c    bic r0, r0, #63 
    0xe00118a4    0x280    cmp r3, r0
    0xe00118a8    0x284    movne r0, #0
    0xe00118ac    0x288    moveq r0, #1
    0xe00118b0    0x28c    b e00118d0 <Arch_sameRegionAs+0x2ac>
    0xe00118b4    0x290    and r2, r3, #14
    0xe00118b8    0x294    cmp r2, #14
    0xe00118bc    0x298    andne r3, r3, #15
    0xe00118c0    0x29c    uxtbeq r3, r3
    0xe00118c4    0x2a0    cmp r3, #11
    0xe00118c8    0x2a4    movne r0, #0
    0xe00118cc    0x2a8    moveq r0, #1
    0xe00118d0    0x2ac    add sp, sp, #16
    0xe00118d4    0x2b0    pop {r4, pc}          ; stack access
    0xe00118d8    0x2b4    and r2, r3, #14
    0xe00118dc    0x2b8    cmp r2, #14
    0xe00118e0    0x2bc    andne r2, r3, #15
    0xe00118e4    0x2c0    uxtbeq r2, r3
    0xe00118e8    0x2c4    cmp r2, #5
    0xe00118ec    0x2c8    movne r0, #0
    0xe00118f0    0x2cc    bne e00118d0 <Arch_sameRegionAs+0x2ac>
    0xe00118f4    0x2d0    bic r3, r3, #15
    0xe00118f8    0x2d4    bic r0, r0, #15
    0xe00118fc    0x2d8    cmp r3, r0
    0xe0011900    0x2dc    movne r0, #0
    0xe0011904    0x2e0    moveq r0, #1
    0xe0011908    0x2e4    b e00118d0 <Arch_sameRegionAs+0x2ac>
    0xe001190c    0x2e8    mov r0, #0
    0xe0011910    0x2ec    b e00118d0 <Arch_sameRegionAs+0x2ac>
    0xe0011914    0x2f0    mov r0, #0
    0xe0011918    0x2f4    b e00118d0 <Arch_sameRegionAs+0x2ac>
    0xe001191c    0x2f8    mov lr, #16
    0xe0011920    0x2fc    b e00117c8 <Arch_sameRegionAs+0x1a4>
    0xe0011924    0x300    mov lr, #24
    0xe0011928    0x304    b e00117c8 <Arch_sameRegionAs+0x1a4>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
175 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_sameRegionAs` has 352 nodes.

Section Arch_maskCapRights (151 of 293)
=======================================

Deriving specifications
-----------------------

Section `Arch_maskCapRights` consists of 39 instructions.


Stack analysis
---------------

Section `Arch_maskCapRights` expects pointer to stack in r0.
11 stack accesses found. Annotated code for `Arch_maskCapRights`:

    0xe0011588     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe001158c     0x4    sub sp, sp, #8
    0xe0011590     0x8    mov r4, r0
    0xe0011594     0xc    add r0, sp, #8
    0xe0011598    0x10    stmdb r0, {r2, r3}    ; stack access
    0xe001159c    0x14    ldr r6, [sp, #4]      ; stack access
    0xe00115a0    0x18    ldr r5, [sp]          ; stack access
    0xe00115a4    0x1c    and r3, r5, #14
    0xe00115a8    0x20    cmp r3, #14
    0xe00115ac    0x24    andne r3, r5, #15
    0xe00115b0    0x28    uxtbeq r3, r5
    0xe00115b4    0x2c    cmp r3, #1
    0xe00115b8    0x30    beq e00115dc <Arch_maskCapRights+0x54>
    0xe00115bc    0x34    cmp r3, #3
    0xe00115c0    0x38    beq e0011600 <Arch_maskCapRights+0x78>
    0xe00115c4    0x3c    add r3, sp, #8
    0xe00115c8    0x40    ldmdb r3, {r0, r1}    ; stack access
    0xe00115cc    0x44    stm r4, {r0, r1}      ; stack access
    0xe00115d0    0x48    mov r0, r4
    0xe00115d4    0x4c    add sp, sp, #8
    0xe00115d8    0x50    pop {r4, r5, r6, pc}  ; stack access
    0xe00115dc    0x54    ubfx r0, r6, #20, #2
    0xe00115e0    0x58    bl e0010a34 <maskVMRights>
    0xe00115e4    0x5c    str r5, [r4]          ; stack access
    0xe00115e8    0x60    lsl r0, r0, #20
    0xe00115ec    0x64    and r0, r0, #3145728 
    0xe00115f0    0x68    bic r6, r6, #3145728 
    0xe00115f4    0x6c    orr r6, r0, r6
    0xe00115f8    0x70    str r6, [r4, #4]      ; stack access
    0xe00115fc    0x74    b e00115d0 <Arch_maskCapRights+0x48>
    0xe0011600    0x78    ubfx r0, r6, #18, #2
    0xe0011604    0x7c    bl e0010a34 <maskVMRights>
    0xe0011608    0x80    str r5, [r4]          ; stack access
    0xe001160c    0x84    lsl r0, r0, #18
    0xe0011610    0x88    and r0, r0, #786432 
    0xe0011614    0x8c    bic r6, r6, #786432 
    0xe0011618    0x90    orr r6, r0, r6
    0xe001161c    0x94    str r6, [r4, #4]      ; stack access
    0xe0011620    0x98    b e00115d0 <Arch_maskCapRights+0x48>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_maskCapRights` has 60 nodes.

Section Arch_deriveCap (152 of 293)
===================================

Deriving specifications
-----------------------

Section `Arch_deriveCap` consists of 73 instructions.
Switch found.


Stack analysis
---------------

Section `Arch_deriveCap` expects pointer to stack in r0.
20 stack accesses found. Annotated code for `Arch_deriveCap`:

    0xe0011440      0x0    push {lr}             ; stack access
    0xe0011444      0x4    sub sp, sp, #12
    0xe0011448      0x8    add r1, sp, #8
    0xe001144c      0xc    stmdb r1, {r2, r3}    ; stack access
    0xe0011450     0x10    ldr ip, [sp, #4]      ; stack access
    0xe0011454     0x14    ldr r3, [sp]          ; stack access
    0xe0011458     0x18    and r2, r3, #14
    0xe001145c     0x1c    cmp r2, #14
    0xe0011460     0x20    andne r2, r3, #15
    0xe0011464     0x24    uxtbeq r2, r3
    0xe0011468     0x28    sub r2, r2, #1
    0xe001146c     0x2c    cmp r2, #10
    0xe0011470     0x30    ldrls pc, [pc, r2, lsl #2]
    0xe0011474     0x34    b e0011560 <Arch_deriveCap+0x120>
    0xe0011478     0x38    .word 0xe0011510
    0xe001147c     0x3c    .word 0xe0011560
    0xe0011480     0x40    .word 0xe001152c
    0xe0011484     0x44    .word 0xe0011560
    0xe0011488     0x48    .word 0xe001154c
    0xe001148c     0x4c    .word 0xe0011560
    0xe0011490     0x50    .word 0xe00114a4
    0xe0011494     0x54    .word 0xe0011560
    0xe0011498     0x58    .word 0xe00114dc
    0xe001149c     0x5c    .word 0xe0011560
    0xe00114a0     0x60    .word 0xe001154c
    0xe00114a4     0x64    ubfx r1, ip, #29, #1
    0xe00114a8     0x68    cmp r1, #0
    0xe00114ac     0x6c    movweq r3, #36896 
    0xe00114b0     0x70    movteq r3, #57346 
    0xe00114b4     0x74    moveq r2, #3
    0xe00114b8     0x78    streq r2, [r3, #24]
    0xe00114bc     0x7c    moveq ip, r1
    0xe00114c0     0x80    moveq r3, #0
    0xe00114c4     0x84    movne r2, #0
    0xe00114c8     0x88    str r2, [r0]          ; stack access
    0xe00114cc     0x8c    str r3, [r0, #4]      ; stack access
    0xe00114d0     0x90    str ip, [r0, #8]      ; stack access
    0xe00114d4     0x94    add sp, sp, #12
    0xe00114d8     0x98    pop {pc}              ; stack access
    0xe00114dc     0x9c    ubfx r1, r3, #4, #1
    0xe00114e0     0xa0    cmp r1, #0
    0xe00114e4     0xa4    movweq r3, #36896 
    0xe00114e8     0xa8    movteq r3, #57346 
    0xe00114ec     0xac    moveq r2, #3
    0xe00114f0     0xb0    streq r2, [r3, #24]
    0xe00114f4     0xb4    moveq ip, r1
    0xe00114f8     0xb8    moveq r3, #0
    0xe00114fc     0xbc    movne r2, #0
    0xe0011500     0xc0    str r2, [r0]          ; stack access
    0xe0011504     0xc4    str r3, [r0, #4]      ; stack access
    0xe0011508     0xc8    str ip, [r0, #8]      ; stack access
    0xe001150c     0xcc    b e00114d4 <Arch_deriveCap+0x94>
    0xe0011510     0xd0    mov r2, #0
    0xe0011514     0xd4    str r2, [r0]          ; stack access
    0xe0011518     0xd8    bic r3, r3, #2130706432 
    0xe001151c     0xdc    str r3, [r0, #4]      ; stack access
    0xe0011520     0xe0    ubfx r3, ip, #0, #22
    0xe0011524     0xe4    str r3, [r0, #8]      ; stack access
    0xe0011528     0xe8    b e00114d4 <Arch_deriveCap+0x94>
    0xe001152c     0xec    mov r2, #0
    0xe0011530     0xf0    str r2, [r0]          ; stack access
    0xe0011534     0xf4    bic r3, r3, #532676608 
    0xe0011538     0xf8    str r3, [r0, #4]      ; stack access
    0xe001153c     0xfc    bic r3, ip, #1069547520 
    0xe0011540    0x100    bic r3, r3, #3145728 
    0xe0011544    0x104    str r3, [r0, #8]      ; stack access
    0xe0011548    0x108    b e00114d4 <Arch_deriveCap+0x94>
    0xe001154c    0x10c    mov r2, #0
    0xe0011550    0x110    str r2, [r0]          ; stack access
    0xe0011554    0x114    str r3, [r0, #4]      ; stack access
    0xe0011558    0x118    str ip, [r0, #8]      ; stack access
    0xe001155c    0x11c    b e00114d4 <Arch_deriveCap+0x94>
    0xe0011560    0x120    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
62 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_deriveCap` has 151 nodes.

Section invalidateTLBByASID (153 of 293)
========================================

Deriving specifications
-----------------------

Section `invalidateTLBByASID` consists of 10 instructions.
Skipping f57ff04f dsb sy
Skipping ee080f57 mcr 15, 0, r0, cr8, cr7, {2}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

3 stack accesses found. Annotated code for `invalidateTLBByASID`:

    0xe0011404     0x0    push {r4, lr}         ; stack access
    0xe0011408     0x4    bl e0010868 <loadHWASID>
    0xe001140c     0x8    tst r0, #8388608 
    0xe0011410     0xc    popeq {r4, pc}        ; stack access
    0xe0011414    0x10    dsb sy
    0xe0011418    0x14    lsr r0, r0, #24
    0xe001141c    0x18    mcr 15, 0, r0, cr8, cr7, {2}
    0xe0011420    0x1c    dsb sy
    0xe0011424    0x20    isb sy
    0xe0011428    0x24    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invalidateTLBByASID` has 20 nodes.

Section handleVMFault (154 of 293)
==================================

Deriving specifications
-----------------------

Section `handleVMFault` consists of 26 instructions.
Skipping ee153f30 mrc 15, 0, r3, cr5, cr0, {1}
Skipping ee161f10 mrc 15, 0, r1, cr6, cr0, {0}
Skipping ee153f10 mrc 15, 0, r3, cr5, cr0, {0}


Stack analysis
---------------

1 stack accesses found. Annotated code for `handleVMFault`:

    0xe00112a0     0x0    cmp r1, #0
    0xe00112a4     0x4    beq e00112e0 <handleVMFault+0x40>
    0xe00112a8     0x8    cmp r1, #1
    0xe00112ac     0xc    bne e00112d8 <handleVMFault+0x38>
    0xe00112b0    0x10    ldr r1, [r0, #68] 
    0xe00112b4    0x14    mrc 15, 0, r3, cr5, cr0, {1}
    0xe00112b8    0x18    movw r2, #32768 
    0xe00112bc    0x1c    movt r2, #57346 
    0xe00112c0    0x20    lsl r3, r3, #18
    0xe00112c4    0x24    orr r3, r3, #131072 
    0xe00112c8    0x28    orr r3, r3, #5
    0xe00112cc    0x2c    str r3, [r2]
    0xe00112d0    0x30    str r1, [r2, #4]
    0xe00112d4    0x34    b e0011300 <handleVMFault+0x60>
    0xe00112d8    0x38    push {r4, lr}         ; stack access
    0xe00112dc    0x3c    bl e0010904 <halt>
    0xe00112e0    0x40    mrc 15, 0, r1, cr6, cr0, {0}
    0xe00112e4    0x44    mrc 15, 0, r3, cr5, cr0, {0}
    0xe00112e8    0x48    movw r2, #32768 
    0xe00112ec    0x4c    movt r2, #57346 
    0xe00112f0    0x50    lsl r3, r3, #18
    0xe00112f4    0x54    orr r3, r3, #5
    0xe00112f8    0x58    str r3, [r2]
    0xe00112fc    0x5c    str r1, [r2, #4]
    0xe0011300    0x60    mov r0, #1
    0xe0011304    0x64    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleVMFault` has 41 nodes.

Section setVMRootForFlush (155 of 293)
======================================

Deriving specifications
-----------------------

Section `setVMRootForFlush` consists of 40 instructions.
Skipping f57ff04f dsb sy
Skipping ee023f10 mcr 15, 0, r3, cr2, cr0, {0}
Skipping f57ff06f isb sy
Skipping ee0d0f30 mcr 15, 0, r0, cr13, cr0, {1}
Skipping f57ff06f isb sy
Skipping ee020f10 mcr 15, 0, r0, cr2, cr0, {0}
Skipping f57ff06f isb sy


Stack analysis
---------------

3 stack accesses found. Annotated code for `setVMRootForFlush`:

    0xe00111c8     0x0    push {r4, lr}         ; stack access
    0xe00111cc     0x4    mov r4, r0
    0xe00111d0     0x8    movw r2, #13900 
    0xe00111d4     0xc    movt r2, #57347 
    0xe00111d8    0x10    ldr r2, [r2]
    0xe00111dc    0x14    bic r2, r2, #508 
    0xe00111e0    0x18    bic r2, r2, #3
    0xe00111e4    0x1c    ldr r2, [r2, #16]
    0xe00111e8    0x20    and r0, r2, #14
    0xe00111ec    0x24    cmp r0, #14
    0xe00111f0    0x28    andne r0, r2, #15
    0xe00111f4    0x2c    uxtbeq r0, r2
    0xe00111f8    0x30    cmp r0, #9
    0xe00111fc    0x34    bne e0011218 <setVMRootForFlush+0x50>
    0xe0011200    0x38    tst r2, #16
    0xe0011204    0x3c    beq e0011218 <setVMRootForFlush+0x50>
    0xe0011208    0x40    bic r2, r2, #16320 
    0xe001120c    0x44    bic r2, r2, #63 
    0xe0011210    0x48    cmp r4, r2
    0xe0011214    0x4c    beq e001125c <setVMRootForFlush+0x94>
    0xe0011218    0x50    mov r0, r1
    0xe001121c    0x54    bl e0011060 <getHWASID>
    0xe0011220    0x58    dsb sy
    0xe0011224    0x5c    ldr r3, [pc, #56] 
    0xe0011228    0x60    orr r3, r3, #24
    0xe001122c    0x64    mcr 15, 0, r3, cr2, cr0, {0}
    0xe0011230    0x68    isb sy
    0xe0011234    0x6c    mcr 15, 0, r0, cr13, cr0, {1}
    0xe0011238    0x70    isb sy
    0xe001123c    0x74    add r0, r4, #805306368 
    0xe0011240    0x78    bic r0, r0, #8128 
    0xe0011244    0x7c    bic r0, r0, #63 
    0xe0011248    0x80    orr r0, r0, #24
    0xe001124c    0x84    mcr 15, 0, r0, cr2, cr0, {0}
    0xe0011250    0x88    isb sy
    0xe0011254    0x8c    mov r0, #1
    0xe0011258    0x90    pop {r4, pc}          ; stack access
    0xe001125c    0x94    mov r0, #0
    0xe0011260    0x98    pop {r4, pc}          ; stack access
    0xe0011264    0x9c    .word 0x10024000

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setVMRootForFlush` has 62 nodes.

Section Arch_switchToIdleThread (156 of 293)
============================================

Deriving specifications
-----------------------

Section `Arch_switchToIdleThread` consists of 6 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `Arch_switchToIdleThread`:

    0xe00111b0     0x0    push {r4, lr}         ; stack access
    0xe00111b4     0x4    movw r3, #36880 
    0xe00111b8     0x8    movt r3, #57346 
    0xe00111bc     0xc    ldr r0, [r3]
    0xe00111c0    0x10    bl e00110b8 <setVMRoot>
    0xe00111c4    0x14    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_switchToIdleThread` has 10 nodes.

Section Arch_switchToThread (157 of 293)
========================================

Deriving specifications
-----------------------

Section `Arch_switchToThread` consists of 7 instructions.
Skipping e1830f91 strex r0, r1, [r3]


Stack analysis
---------------

2 stack accesses found. Annotated code for `Arch_switchToThread`:

    0xe0011194     0x0    push {lr}             ; stack access
    0xe0011198     0x4    sub sp, sp, #12
    0xe001119c     0x8    bl e00110b8 <setVMRoot>
    0xe00111a0     0xc    add r3, sp, #4
    0xe00111a4    0x10    strex r0, r1, [r3]
    0xe00111a8    0x14    add sp, sp, #12
    0xe00111ac    0x18    pop {pc}              ; stack access

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_switchToThread` has 11 nodes.

Section pageTableMapped (158 of 293)
====================================

Deriving specifications
-----------------------

Section `pageTableMapped` consists of 27 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `pageTableMapped`:

    0xe0010f4c     0x0    push {r4, r5, lr}     ; stack access
    0xe0010f50     0x4    sub sp, sp, #12
    0xe0010f54     0x8    mov r4, r1
    0xe0010f58     0xc    mov r5, r2
    0xe0010f5c    0x10    mov r1, r0
    0xe0010f60    0x14    mov r0, sp
    0xe0010f64    0x18    bl e0010a84 <findPDForASID>
    0xe0010f68    0x1c    ldr r0, [sp, #4]      ; stack access
    0xe0010f6c    0x20    ldr r3, [sp]          ; stack access
    0xe0010f70    0x24    cmp r3, #0
    0xe0010f74    0x28    bne e0010fa8 <pageTableMapped+0x5c>
    0xe0010f78    0x2c    lsr r4, r4, #20
    0xe0010f7c    0x30    ldr r3, [r0, r4, lsl #2]
    0xe0010f80    0x34    and r2, r3, #3
    0xe0010f84    0x38    cmp r2, #1
    0xe0010f88    0x3c    bne e0010fb0 <pageTableMapped+0x64>
    0xe0010f8c    0x40    bic r3, r3, #1020 
    0xe0010f90    0x44    bic r3, r3, #3
    0xe0010f94    0x48    add r3, r3, #-805306368 
    0xe0010f98    0x4c    cmp r5, r3
    0xe0010f9c    0x50    movne r0, #0
    0xe0010fa0    0x54    add sp, sp, #12
    0xe0010fa4    0x58    pop {r4, r5, pc}      ; stack access
    0xe0010fa8    0x5c    mov r0, #0
    0xe0010fac    0x60    b e0010fa0 <pageTableMapped+0x54>
    0xe0010fb0    0x64    mov r0, #0
    0xe0010fb4    0x68    b e0010fa0 <pageTableMapped+0x54>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `pageTableMapped` has 39 nodes.

Section lookupIPCBuffer (159 of 293)
====================================

Deriving specifications
-----------------------

Section `lookupIPCBuffer` consists of 73 instructions.
Switch found.
 CMPEQ (imm)...++


Stack analysis
---------------

7 stack accesses found. Annotated code for `lookupIPCBuffer`:

    0xe0010b04      0x0    push {r4, lr}         ; stack access
    0xe0010b08      0x4    bic r3, r1, #508 
    0xe0010b0c      0x8    bic r3, r3, #3
    0xe0010b10      0xc    add lr, r3, #64 
    0xe0010b14     0x10    ldr r3, [r3, #64] 
    0xe0010b18     0x14    and r2, r3, #14
    0xe0010b1c     0x18    cmp r2, #14
    0xe0010b20     0x1c    andne r2, r3, #15
    0xe0010b24     0x20    uxtbeq r2, r3
    0xe0010b28     0x24    bic ip, r2, #2
    0xe0010b2c     0x28    cmp ip, #1
    0xe0010b30     0x2c    bne e0010bf0 <lookupIPCBuffer+0xec>
    0xe0010b34     0x30    uxtb ip, r2
    0xe0010b38     0x34    cmp ip, #1
    0xe0010b3c     0x38    lsreq ip, r3, #31
    0xe0010b40     0x3c    ubfxne ip, r3, #29, #1
    0xe0010b44     0x40    cmp ip, #0
    0xe0010b48     0x44    bne e0010bf8 <lookupIPCBuffer+0xf4>
    0xe0010b4c     0x48    ldr ip, [lr, #4]
    0xe0010b50     0x4c    cmp r2, #1
    0xe0010b54     0x50    beq e0010b68 <lookupIPCBuffer+0x64>
    0xe0010b58     0x54    cmp r2, #3
    0xe0010b5c     0x58    beq e0010b8c <lookupIPCBuffer+0x88>
    0xe0010b60     0x5c    mov r0, #0
    0xe0010b64     0x60    pop {r4, pc}          ; stack access
    0xe0010b68     0x64    ubfx ip, ip, #20, #2
    0xe0010b6c     0x68    cmp ip, #3
    0xe0010b70     0x6c    bne e0010c00 <lookupIPCBuffer+0xfc>
    0xe0010b74     0x70    lsl r3, r3, #8
    0xe0010b78     0x74    bic r3, r3, #4080 
    0xe0010b7c     0x78    bic r3, r3, #15
    0xe0010b80     0x7c    ldr r0, [r1, #132] 
    0xe0010b84     0x80    mov r1, #12
    0xe0010b88     0x84    b e0010bd4 <lookupIPCBuffer+0xd0>
    0xe0010b8c     0x88    ubfx r2, ip, #18, #2
    0xe0010b90     0x8c    cmp r2, #3
    0xe0010b94     0x90    bne e0010c14 <lookupIPCBuffer+0x110>
    0xe0010b98     0x94    lsl r3, r3, #10
    0xe0010b9c     0x98    bic r3, r3, #16320 
    0xe0010ba0     0x9c    bic r3, r3, #63 
    0xe0010ba4     0xa0    ldr r0, [r1, #132] 
    0xe0010ba8     0xa4    lsr ip, ip, #30
    0xe0010bac     0xa8    cmp ip, #3
    0xe0010bb0     0xac    ldrls pc, [pc, ip, lsl #2]
    0xe0010bb4     0xb0    b e0010be4 <lookupIPCBuffer+0xe0>
    0xe0010bb8     0xb4    .word 0xe0010b84
    0xe0010bbc     0xb8    .word 0xe0010bc8
    0xe0010bc0     0xbc    .word 0xe0010be8
    0xe0010bc4     0xc0    .word 0xe0010bd0
    0xe0010bc8     0xc4    mov r1, #16
    0xe0010bcc     0xc8    b e0010bd4 <lookupIPCBuffer+0xd0>
    0xe0010bd0     0xcc    mov r1, #24
    0xe0010bd4     0xd0    mvn r2, #0
    0xe0010bd8     0xd4    bic r0, r0, r2, lsl r1
    0xe0010bdc     0xd8    add r0, r0, r3
    0xe0010be0     0xdc    pop {r4, pc}          ; stack access
    0xe0010be4     0xe0    bl e0010904 <halt>
    0xe0010be8     0xe4    mov r1, #20
    0xe0010bec     0xe8    b e0010bd4 <lookupIPCBuffer+0xd0>
    0xe0010bf0     0xec    mov r0, #0
    0xe0010bf4     0xf0    pop {r4, pc}          ; stack access
    0xe0010bf8     0xf4    mov r0, #0
    0xe0010bfc     0xf8    pop {r4, pc}          ; stack access
    0xe0010c00     0xfc    cmp ip, #2
    0xe0010c04    0x100    cmpeq r0, #0
    0xe0010c08    0x104    beq e0010b74 <lookupIPCBuffer+0x70>
    0xe0010c0c    0x108    mov r0, #0
    0xe0010c10    0x10c    pop {r4, pc}          ; stack access
    0xe0010c14    0x110    cmp r2, #2
    0xe0010c18    0x114    cmpeq r0, #0
    0xe0010c1c    0x118    beq e0010b98 <lookupIPCBuffer+0x94>
    0xe0010c20    0x11c    mov r0, #0
    0xe0010c24    0x120    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
69 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupIPCBuffer` has 123 nodes.

Section APFromVMRights (160 of 293)
===================================

Deriving specifications
-----------------------

Section `APFromVMRights` consists of 17 instructions.
Switch found.


Stack analysis
---------------

1 stack accesses found. Annotated code for `APFromVMRights`:

    0xe0010910     0x0    cmp r0, #3
    0xe0010914     0x4    ldrls pc, [pc, r0, lsl #2]
    0xe0010918     0x8    b e001093c <APFromVMRights+0x2c>
    0xe001091c     0xc    .word 0xe0010944
    0xe0010920    0x10    .word 0xe001092c
    0xe0010924    0x14    .word 0xe001094c
    0xe0010928    0x18    .word 0xe0010934
    0xe001092c    0x1c    mov r0, #1
    0xe0010930    0x20    bx lr
    0xe0010934    0x24    mov r0, #3
    0xe0010938    0x28    bx lr
    0xe001093c    0x2c    push {r4, lr}         ; stack access
    0xe0010940    0x30    bl e0010904 <halt>
    0xe0010944    0x34    mov r0, #0
    0xe0010948    0x38    bx lr
    0xe001094c    0x3c    mov r0, #2
    0xe0010950    0x40    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `APFromVMRights` has 32 nodes.

Section halt (161 of 293)
=========================

Deriving specifications
-----------------------

Section `halt` consists of 3 instructions.
Skipping f10c01c0 cpsid aif


Stack analysis
---------------

1 stack accesses found. Annotated code for `halt`:

    0xe0010904    0x0    push {r4, lr}         ; stack access
    0xe0010908    0x4    cpsid aif
    0xe001090c    0x8    bl e0010860 <idle_thread>

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `halt` has 6 nodes.

Section invalidateASIDEntry (162 of 293)
========================================

Deriving specifications
-----------------------

Section `invalidateASIDEntry` consists of 19 instructions.
 STRNE (+reg,pre)........++++++


Stack analysis
---------------

2 stack accesses found. Annotated code for `invalidateASIDEntry`:

    0xe001088c     0x0    push {r4, lr}         ; stack access
    0xe0010890     0x4    mov r4, r0
    0xe0010894     0x8    bl e0010868 <loadHWASID>
    0xe0010898     0xc    tst r0, #8388608 
    0xe001089c    0x10    movwne r3, #12872 
    0xe00108a0    0x14    movtne r3, #57347 
    0xe00108a4    0x18    lsrne r0, r0, #24
    0xe00108a8    0x1c    movne r2, #0
    0xe00108ac    0x20    strne r2, [r3, r0, lsl #2]
    0xe00108b0    0x24    movw r3, #37576 
    0xe00108b4    0x28    movt r3, #57346 
    0xe00108b8    0x2c    lsr r2, r4, #10
    0xe00108bc    0x30    ldr r3, [r3, r2, lsl #2]
    0xe00108c0    0x34    ubfx r4, r4, #0, #10
    0xe00108c4    0x38    ldr r3, [r3, r4, lsl #2]
    0xe00108c8    0x3c    add r3, r3, #12288 
    0xe00108cc    0x40    mov r2, #0
    0xe00108d0    0x44    str r2, [r3, #4032] 
    0xe00108d4    0x48    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invalidateASIDEntry` has 36 nodes.

Section c_handle_syscall (163 of 293)
=====================================

Deriving specifications
-----------------------

Section `c_handle_syscall` consists of 12 instructions.
Skipping ee1d1f50 mrc 15, 0, r1, cr13, cr0, {2}
Skipping ee1d1f70 mrc 15, 0, r1, cr13, cr0, {3}
 ANDEQ (reg)...........++++++


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_syscall`:

    0xe0010810     0x0    push {r4, lr}         ; stack access
    0xe0010814     0x4    movw r3, #13900 
    0xe0010818     0x8    movt r3, #57347 
    0xe001081c     0xc    ldr r3, [r3]
    0xe0010820    0x10    mrc 15, 0, r1, cr13, cr0, {2}
    0xe0010824    0x14    str r1, [r3, #72] 
    0xe0010828    0x18    mrc 15, 0, r1, cr13, cr0, {3}
    0xe001082c    0x1c    str r1, [r3, #76] 
    0xe0010830    0x20    mov r0, r2
    0xe0010834    0x24    bl e001b2f4 <slowpath>
    0xe0010838    0x28    andeq r0, r0, r0
    0xe001083c    0x2c    andeq r0, r0, r0

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_syscall` has 23 nodes.

Section arm_fiq_exception (164 of 293)
======================================

Deriving specifications
-----------------------

Section `arm_fiq_exception` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `arm_fiq_exception`:

    0xe0010114    0x0    bl e0010904 <halt>
    0xe0010118    0x4    andeq r0, r0, r0
    0xe001011c    0x8    andeq r0, r0, r0

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_fiq_exception` has 8 nodes.

Section arm_irq_exception (165 of 293)
======================================

Deriving specifications
-----------------------

Section `arm_irq_exception` consists of 9 instructions.
Skipping f8cd0513 srsia sp, #19
Skipping f1020013 cps #19
Skipping e94d7fff stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
Skipping ee1ddf90 mrc 15, 0, sp, cr13, cr0, {4}


Stack analysis
---------------

3 stack accesses found. Annotated code for `arm_irq_exception`:

    0xe00100ec     0x0    srsia sp, #19
    0xe00100f0     0x4    cps #19
    0xe00100f4     0x8    stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    0xe00100f8     0xc    ldr r8, [sp]          ; stack access
    0xe00100fc    0x10    sub r8, r8, #4
    0xe0010100    0x14    str r8, [sp]          ; stack access
    0xe0010104    0x18    str r8, [sp, #8]      ; stack access
    0xe0010108    0x1c    mrc 15, 0, sp, cr13, cr0, {4}
    0xe001010c    0x20    b e0010120 <c_handle_interrupt>

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_irq_exception` has 17 nodes.

Section arm_undefined_inst_exception (166 of 293)
=================================================

Deriving specifications
-----------------------

Section `arm_undefined_inst_exception` consists of 8 instructions.
Skipping f8cd0513 srsia sp, #19
Skipping f1020013 cps #19
Skipping e94d7fff stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
Skipping ee1ddf90 mrc 15, 0, sp, cr13, cr0, {4}


Stack analysis
---------------

2 stack accesses found. Annotated code for `arm_undefined_inst_exception`:

    0xe001003c     0x0    srsia sp, #19
    0xe0010040     0x4    cps #19
    0xe0010044     0x8    stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    0xe0010048     0xc    ldr r8, [sp]          ; stack access
    0xe001004c    0x10    sub r8, r8, #4
    0xe0010050    0x14    str r8, [sp, #8]      ; stack access
    0xe0010054    0x18    mrc 15, 0, sp, cr13, cr0, {4}
    0xe0010058    0x1c    b e0010148 <c_handle_undefined_instruction>

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_undefined_inst_exception` has 15 nodes.

Section maybe_alloc_extra_bi (167 of 293)
=========================================

Deriving specifications
-----------------------

Section `maybe_alloc_extra_bi` consists of 15 instructions.
 BXCC..++


Stack analysis
---------------

2 stack accesses found. Annotated code for `maybe_alloc_extra_bi`:

    0xe00031b4     0x0    cmp r1, r0
    0xe00031b8     0x4    bxcc lr
    0xe00031bc     0x8    movw r3, #47104 
    0xe00031c0     0xc    movt r3, #57345 
    0xe00031c4    0x10    ldr r3, [r3, #156] 
    0xe00031c8    0x14    cmp r3, #0
    0xe00031cc    0x18    bxne lr
    0xe00031d0    0x1c    push {r4, lr}         ; stack access
    0xe00031d4    0x20    mov r0, r1
    0xe00031d8    0x24    mov r1, #1
    0xe00031dc    0x28    bl e0003188 <alloc_rootserver_obj>
    0xe00031e0    0x2c    movw r3, #47104 
    0xe00031e4    0x30    movt r3, #57345 
    0xe00031e8    0x34    str r0, [r3, #156] 
    0xe00031ec    0x38    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maybe_alloc_extra_bi` has 26 nodes.

Section alloc_rootserver_obj (168 of 293)
=========================================

Deriving specifications
-----------------------

Section `alloc_rootserver_obj` consists of 11 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `alloc_rootserver_obj`:

    0xe0003188     0x0    push {r4, lr}         ; stack access
    0xe000318c     0x4    movw r3, #47104 
    0xe0003190     0x8    movt r3, #57345 
    0xe0003194     0xc    ldr r4, [r3, #172] 
    0xe0003198    0x10    lsl r1, r1, r0
    0xe000319c    0x14    add r2, r1, r4
    0xe00031a0    0x18    str r2, [r3, #172] 
    0xe00031a4    0x1c    mov r0, r4
    0xe00031a8    0x20    bl e0019244 <memzero>
    0xe00031ac    0x24    mov r0, r4
    0xe00031b0    0x28    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `alloc_rootserver_obj` has 16 nodes.

Section create_idle_thread (169 of 293)
=======================================

Deriving specifications
-----------------------

Section `create_idle_thread` consists of 9 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `create_idle_thread`:

    0xe0003008     0x0    push {r4, lr}         ; stack access
    0xe000300c     0x4    ldr r0, [pc, #20] 
    0xe0003010     0x8    movw r3, #36880 
    0xe0003014     0xc    movt r3, #57346 
    0xe0003018    0x10    str r0, [r3]
    0xe000301c    0x14    bl e0002fe4 <configureIdleThread>
    0xe0003020    0x18    mov r0, #1
    0xe0003024    0x1c    pop {r4, pc}          ; stack access
    0xe0003028    0x20    .word 0xe001b700

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_idle_thread` has 12 nodes.

Section configureIdleThread (170 of 293)
========================================

Deriving specifications
-----------------------

Section `configureIdleThread` consists of 9 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `configureIdleThread`:

    0xe0002fe4     0x0    push {r4, lr}         ; stack access
    0xe0002fe8     0x4    movw r3, #351 
    0xe0002fec     0x8    str r3, [r0, #64] 
    0xe0002ff0     0xc    movw r3, #2144 
    0xe0002ff4    0x10    movt r3, #57345 
    0xe0002ff8    0x14    str r3, [r0, #60] 
    0xe0002ffc    0x18    mov r1, #7
    0xe0003000    0x1c    bl e0014ad8 <setThreadState>
    0xe0003004    0x20    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `configureIdleThread` has 14 nodes.

Section create_kernel_untypeds (171 of 293)
===========================================

Deriving specifications
-----------------------

Section `create_kernel_untypeds` consists of 42 instructions.


Stack analysis
---------------

15 stack accesses found. Annotated code for `create_kernel_untypeds`:

    0xe000228c     0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe0002290     0x4    sub sp, sp, #36 
    0xe0002294     0x8    add ip, sp, #16
    0xe0002298     0xc    stm ip, {r0, r1}      ; stack access
    0xe000229c    0x10    add r1, sp, #8
    0xe00022a0    0x14    stm r1, {r2, r3}      ; stack access
    0xe00022a4    0x18    ldr r8, [sp, #64]     ; stack access
    0xe00022a8    0x1c    str r8, [sp, #4]      ; stack access
    0xe00022ac    0x20    ldr r3, [sp, #12]     ; stack access
    0xe00022b0    0x24    str r3, [sp]          ; stack access
    0xe00022b4    0x28    mov r3, r2
    0xe00022b8    0x2c    mov r2, #0
    0xe00022bc    0x30    ldm ip, {r0, r1}      ; stack access
    0xe00022c0    0x34    bl e0002080 <create_untypeds_for_region>
    0xe00022c4    0x38    cmp r0, #0
    0xe00022c8    0x3c    beq e000232c <create_kernel_untypeds+0xa0>
    0xe00022cc    0x40    movw r4, #47104 
    0xe00022d0    0x44    movt r4, #57345 
    0xe00022d4    0x48    add r9, r4, #32
    0xe00022d8    0x4c    add r7, sp, #24
    0xe00022dc    0x50    mov r5, #0
    0xe00022e0    0x54    add r6, sp, #16
    0xe00022e4    0x58    add r3, r4, #92 
    0xe00022e8    0x5c    ldm r3, {r0, r1}
    0xe00022ec    0x60    stm r7, {r0, r1}      ; stack access
    0xe00022f0    0x64    str r5, [r4, #92] 
    0xe00022f4    0x68    str r5, [r4, #96] 
    0xe00022f8    0x6c    str r8, [sp, #4]      ; stack access
    0xe00022fc    0x70    ldr r3, [sp, #28]     ; stack access
    0xe0002300    0x74    str r3, [sp]          ; stack access
    0xe0002304    0x78    ldr r3, [sp, #24]     ; stack access
    0xe0002308    0x7c    mov r2, r5
    0xe000230c    0x80    ldm r6, {r0, r1}      ; stack access
    0xe0002310    0x84    bl e0002080 <create_untypeds_for_region>
    0xe0002314    0x88    cmp r0, #0
    0xe0002318    0x8c    beq e000232c <create_kernel_untypeds+0xa0>
    0xe000231c    0x90    add r4, r4, #8
    0xe0002320    0x94    cmp r4, r9
    0xe0002324    0x98    bne e00022e4 <create_kernel_untypeds+0x58>
    0xe0002328    0x9c    mov r0, #1
    0xe000232c    0xa0    add sp, sp, #36 
    0xe0002330    0xa4    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
42 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_kernel_untypeds` has 68 nodes.

Section create_device_untypeds (172 of 293)
===========================================

Deriving specifications
-----------------------

Section `create_device_untypeds` consists of 54 instructions.


Stack analysis
---------------

9 stack accesses found. Annotated code for `create_device_untypeds`:

    0xe00021b4     0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe00021b8     0x4    sub sp, sp, #28
    0xe00021bc     0x8    add r3, sp, #8
    0xe00021c0     0xc    stm r3, {r0, r1}      ; stack access
    0xe00021c4    0x10    mov r8, r2
    0xe00021c8    0x14    movw r3, #47104 
    0xe00021cc    0x18    movt r3, #57345 
    0xe00021d0    0x1c    ldr r3, [r3, #88] 
    0xe00021d4    0x20    cmp r3, #0
    0xe00021d8    0x24    beq e0002284 <create_device_untypeds+0xd0>
    0xe00021dc    0x28    movw r5, #47104 
    0xe00021e0    0x2c    movt r5, #57345 
    0xe00021e4    0x30    mov r4, #0
    0xe00021e8    0x34    mov r3, r4
    0xe00021ec    0x38    mov r6, r5
    0xe00021f0    0x3c    mov r9, #1
    0xe00021f4    0x40    add r7, sp, #8
    0xe00021f8    0x44    b e0002214 <create_device_untypeds+0x60>
    0xe00021fc    0x48    ldr r3, [r5, #4]
    0xe0002200    0x4c    add r4, r4, #1
    0xe0002204    0x50    add r5, r5, #8
    0xe0002208    0x54    ldr r2, [r6, #88] 
    0xe000220c    0x58    cmp r2, r4
    0xe0002210    0x5c    bls e0002248 <create_device_untypeds+0x94>
    0xe0002214    0x60    ldr r2, [r6, r4, lsl #3]
    0xe0002218    0x64    cmp r2, r3
    0xe000221c    0x68    bls e00021fc <create_device_untypeds+0x48>
    0xe0002220    0x6c    add r2, r2, #-805306368 
    0xe0002224    0x70    str r8, [sp, #4]      ; stack access
    0xe0002228    0x74    str r2, [sp]          ; stack access
    0xe000222c    0x78    add r3, r3, #-805306368 
    0xe0002230    0x7c    mov r2, r9
    0xe0002234    0x80    ldm r7, {r0, r1}      ; stack access
    0xe0002238    0x84    bl e0002080 <create_untypeds_for_region>
    0xe000223c    0x88    cmp r0, #0
    0xe0002240    0x8c    bne e00021fc <create_device_untypeds+0x48>
    0xe0002244    0x90    b e000227c <create_device_untypeds+0xc8>
    0xe0002248    0x94    cmn r3, #1
    0xe000224c    0x98    moveq r0, #1
    0xe0002250    0x9c    beq e000227c <create_device_untypeds+0xc8>
    0xe0002254    0xa0    str r8, [sp, #4]      ; stack access
    0xe0002258    0xa4    mvn r2, #805306368 
    0xe000225c    0xa8    str r2, [sp]          ; stack access
    0xe0002260    0xac    add r3, r3, #-805306368 
    0xe0002264    0xb0    mov r2, #1
    0xe0002268    0xb4    add r1, sp, #8
    0xe000226c    0xb8    ldm r1, {r0, r1}      ; stack access
    0xe0002270    0xbc    bl e0002080 <create_untypeds_for_region>
    0xe0002274    0xc0    cmp r0, #0
    0xe0002278    0xc4    movne r0, #1
    0xe000227c    0xc8    add sp, sp, #28
    0xe0002280    0xcc    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0002284    0xd0    mov r3, #0
    0xe0002288    0xd4    b e0002254 <create_device_untypeds+0xa0>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
54 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_device_untypeds` has 83 nodes.

Section create_untypeds_for_region (173 of 293)
===============================================

Deriving specifications
-----------------------

Section `create_untypeds_for_region` consists of 77 instructions.
 RBITNE...+++
 CLZNE...+++
 LDMDB;3,2...++
 LDMIA (wb);14,11,10,9,8,7,6,5,4.+


Stack analysis
---------------

14 stack accesses found. Annotated code for `create_untypeds_for_region`:

    0xe0002080      0x0    sub sp, sp, #8
    0xe0002084      0x4    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0002088      0x8    sub sp, sp, #36 
    0xe000208c      0xc    add ip, sp, #8
    0xe0002090     0x10    stm ip, {r0, r1}      ; stack access
    0xe0002094     0x14    str r3, [sp, #76]     ; stack access
    0xe0002098     0x18    ldr sl, [sp, #84]     ; stack access
    0xe000209c     0x1c    ldr r6, [sp, #80]     ; stack access
    0xe00020a0     0x20    cmp r6, r3
    0xe00020a4     0x24    beq e00021ac <create_untypeds_for_region+0x12c>
    0xe00020a8     0x28    mov fp, r2
    0xe00020ac     0x2c    mov r5, r3
    0xe00020b0     0x30    lsl r3, r2, #5
    0xe00020b4     0x34    and r3, r3, #32
    0xe00020b8     0x38    str r3, [sp, #4]      ; stack access
    0xe00020bc     0x3c    add r7, sp, #16
    0xe00020c0     0x40    mov r8, ip
    0xe00020c4     0x44    movw r9, #47104 
    0xe00020c8     0x48    movt r9, #57345 
    0xe00020cc     0x4c    b e00020fc <create_untypeds_for_region+0x7c>
    0xe00020d0     0x50    mov r4, #29
    0xe00020d4     0x54    ldm r8, {r0, r1}      ; stack access
    0xe00020d8     0x58    stm r7, {r0, r1}      ; stack access
    0xe00020dc     0x5c    ldr r3, [r9, #128] 
    0xe00020e0     0x60    sub r3, r3, sl
    0xe00020e4     0x64    cmp r3, #229 
    0xe00020e8     0x68    bls e0002134 <create_untypeds_for_region+0xb4>
    0xe00020ec     0x6c    mov r3, #1
    0xe00020f0     0x70    add r5, r5, r3, lsl r4
    0xe00020f4     0x74    cmp r6, r5
    0xe00020f8     0x78    beq e0002198 <create_untypeds_for_region+0x118>
    0xe00020fc     0x7c    sub r4, r6, r5
    0xe0002100     0x80    clz r4, r4
    0xe0002104     0x84    rsb r3, r4, #31
    0xe0002108     0x88    cmp r5, #0
    0xe000210c     0x8c    rbitne r4, r5
    0xe0002110     0x90    clzne r4, r4
    0xe0002114     0x94    moveq r4, r3
    0xe0002118     0x98    cmp r4, r3
    0xe000211c     0x9c    movcs r4, r3
    0xe0002120     0xa0    cmp r4, #29
    0xe0002124     0xa4    bhi e00020d0 <create_untypeds_for_region+0x50>
    0xe0002128     0xa8    cmp r4, #3
    0xe000212c     0xac    bls e00020ec <create_untypeds_for_region+0x6c>
    0xe0002130     0xb0    b e00020d4 <create_untypeds_for_region+0x54>
    0xe0002134     0xb4    ldr r2, [r9, #124] 
    0xe0002138     0xb8    add r3, r2, r3, lsl #3
    0xe000213c     0xbc    mov r1, #0
    0xe0002140     0xc0    str r1, [r3, #88] 
    0xe0002144     0xc4    add r2, r5, #805306368 
    0xe0002148     0xc8    str r2, [r3, #84] 
    0xe000214c     0xcc    strb r4, [r3, #88] 
    0xe0002150     0xd0    strb fp, [r3, #89] 
    0xe0002154     0xd4    bic r3, r5, #15
    0xe0002158     0xd8    orr r3, r3, #2
    0xe000215c     0xdc    str r3, [sp, #24]     ; stack access
    0xe0002160     0xe0    sub r3, r4, #4
    0xe0002164     0xe4    and r2, r4, #31
    0xe0002168     0xe8    ldr r1, [sp, #4]      ; stack access
    0xe000216c     0xec    orr r2, r2, r1
    0xe0002170     0xf0    mov r1, #64 
    0xe0002174     0xf4    orr r3, r2, r1, lsl r3
    0xe0002178     0xf8    str r3, [sp, #28]     ; stack access
    0xe000217c     0xfc    add r3, sp, #32
    0xe0002180    0x100    ldmdb r3, {r2, r3}    ; stack access
    0xe0002184    0x104    ldm r7, {r0, r1}      ; stack access
    0xe0002188    0x108    bl e00013e4 <provide_cap>
    0xe000218c    0x10c    cmp r0, #0
    0xe0002190    0x110    bne e00020ec <create_untypeds_for_region+0x6c>
    0xe0002194    0x114    b e000219c <create_untypeds_for_region+0x11c>
    0xe0002198    0x118    mov r0, r3
    0xe000219c    0x11c    add sp, sp, #36 
    0xe00021a0    0x120    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00021a4    0x124    add sp, sp, #8
    0xe00021a8    0x128    bx lr
    0xe00021ac    0x12c    mov r0, #1
    0xe00021b0    0x130    b e000219c <create_untypeds_for_region+0x11c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
77 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_untypeds_for_region` has 120 nodes.

Section create_bi_frame_cap (174 of 293)
========================================

Deriving specifications
-----------------------

Section `create_bi_frame_cap` consists of 158 instructions.
+
Switch found.
Switch found.


Stack analysis
---------------

14 stack accesses found. Annotated code for `create_bi_frame_cap`:

    0xe0001134      0x0    push {lr}             ; stack access
    0xe0001138      0x4    sub sp, sp, #44 
    0xe000113c      0x8    add ip, sp, #24
    0xe0001140      0xc    stm ip, {r0, r1}      ; stack access
    0xe0001144     0x10    add r1, sp, #16
    0xe0001148     0x14    stm r1, {r2, r3}      ; stack access
    0xe000114c     0x18    movw r3, #47104 
    0xe0001150     0x1c    movt r3, #57345 
    0xe0001154     0x20    ldr r3, [r3, #152] 
    0xe0001158     0x24    mov r2, #0
    0xe000115c     0x28    str r2, [sp, #12]     ; stack access
    0xe0001160     0x2c    str r2, [sp, #8]      ; stack access
    0xe0001164     0x30    mov r2, #1
    0xe0001168     0x34    str r2, [sp, #4]      ; stack access
    0xe000116c     0x38    ldr r2, [sp, #48]     ; stack access
    0xe0001170     0x3c    str r2, [sp]          ; stack access
    0xe0001174     0x40    ldm r1, {r1, r2}      ; stack access
    0xe0001178     0x44    add r0, sp, #32
    0xe000117c     0x48    bl e0000408 <create_mapped_it_frame_cap>
    0xe0001180     0x4c    ldr r3, [sp, #24]     ; stack access
    0xe0001184     0x50    ldr r0, [sp, #28]     ; stack access
    0xe0001188     0x54    and r2, r3, #14
    0xe000118c     0x58    cmp r2, #14
    0xe0001190     0x5c    andne r1, r3, #15
    0xe0001194     0x60    uxtbeq r1, r3
    0xe0001198     0x64    sub r2, r1, #2
    0xe000119c     0x68    cmp r2, #60 
    0xe00011a0     0x6c    ldrls pc, [pc, r2, lsl #2]
    0xe00011a4     0x70    b e00012ec <create_bi_frame_cap+0x1b8>
    0xe00011a8     0x74    .word 0xe000129c
    0xe00011ac     0x78    .word 0xe00012ec
    0xe00011b0     0x7c    .word 0xe00012a4
    0xe00011b4     0x80    .word 0xe00012ec
    0xe00011b8     0x84    .word 0xe00012ac
    0xe00011bc     0x88    .word 0xe00012ec
    0xe00011c0     0x8c    .word 0xe0001378
    0xe00011c4     0x90    .word 0xe00012ec
    0xe00011c8     0x94    .word 0xe00012b4
    0xe00011cc     0x98    .word 0xe00012ec
    0xe00011d0     0x9c    .word 0xe00012bc
    0xe00011d4     0xa0    .word 0xe00012ec
    0xe00011d8     0xa4    .word 0xe0001378
    0xe00011dc     0xa8    .word 0xe00012ec
    0xe00011e0     0xac    .word 0xe00012ec
    0xe00011e4     0xb0    .word 0xe00012ec
    0xe00011e8     0xb4    .word 0xe00012ec
    0xe00011ec     0xb8    .word 0xe00012ec
    0xe00011f0     0xbc    .word 0xe00012ec
    0xe00011f4     0xc0    .word 0xe00012ec
    0xe00011f8     0xc4    .word 0xe00012ec
    0xe00011fc     0xc8    .word 0xe00012ec
    0xe0001200     0xcc    .word 0xe00012ec
    0xe0001204     0xd0    .word 0xe00012ec
    0xe0001208     0xd4    .word 0xe00012ec
    0xe000120c     0xd8    .word 0xe00012ec
    0xe0001210     0xdc    .word 0xe00012ec
    0xe0001214     0xe0    .word 0xe00012ec
    0xe0001218     0xe4    .word 0xe0001378
    0xe000121c     0xe8    .word 0xe00012ec
    0xe0001220     0xec    .word 0xe00012ec
    0xe0001224     0xf0    .word 0xe00012ec
    0xe0001228     0xf4    .word 0xe00012ec
    0xe000122c     0xf8    .word 0xe00012ec
    0xe0001230     0xfc    .word 0xe00012ec
    0xe0001234    0x100    .word 0xe00012ec
    0xe0001238    0x104    .word 0xe00012ec
    0xe000123c    0x108    .word 0xe00012ec
    0xe0001240    0x10c    .word 0xe00012ec
    0xe0001244    0x110    .word 0xe00012ec
    0xe0001248    0x114    .word 0xe00012ec
    0xe000124c    0x118    .word 0xe00012ec
    0xe0001250    0x11c    .word 0xe00012ec
    0xe0001254    0x120    .word 0xe00012ec
    0xe0001258    0x124    .word 0xe00012c8
    0xe000125c    0x128    .word 0xe00012ec
    0xe0001260    0x12c    .word 0xe00012ec
    0xe0001264    0x130    .word 0xe00012ec
    0xe0001268    0x134    .word 0xe00012ec
    0xe000126c    0x138    .word 0xe00012ec
    0xe0001270    0x13c    .word 0xe00012ec
    0xe0001274    0x140    .word 0xe00012ec
    0xe0001278    0x144    .word 0xe00012ec
    0xe000127c    0x148    .word 0xe00012ec
    0xe0001280    0x14c    .word 0xe00012ec
    0xe0001284    0x150    .word 0xe00012ec
    0xe0001288    0x154    .word 0xe00012ec
    0xe000128c    0x158    .word 0xe00012ec
    0xe0001290    0x15c    .word 0xe00012ec
    0xe0001294    0x160    .word 0xe00012ec
    0xe0001298    0x164    .word 0xe0001378
    0xe000129c    0x168    bic r3, r3, #15
    0xe00012a0    0x16c    b e000137c <create_bi_frame_cap+0x248>
    0xe00012a4    0x170    bic r3, r0, #15
    0xe00012a8    0x174    b e000137c <create_bi_frame_cap+0x248>
    0xe00012ac    0x178    bic r3, r3, #15
    0xe00012b0    0x17c    b e000137c <create_bi_frame_cap+0x248>
    0xe00012b4    0x180    bic r3, r3, #31
    0xe00012b8    0x184    b e000137c <create_bi_frame_cap+0x248>
    0xe00012bc    0x188    bic r3, r3, #508 
    0xe00012c0    0x18c    bic r3, r3, #3
    0xe00012c4    0x190    b e000137c <create_bi_frame_cap+0x248>
    0xe00012c8    0x194    lsr r3, r3, #8
    0xe00012cc    0x198    and r2, r3, #63 
    0xe00012d0    0x19c    cmp r2, #32
    0xe00012d4    0x1a0    andne r3, r3, #31
    0xe00012d8    0x1a4    moveq r3, #4
    0xe00012dc    0x1a8    add r3, r3, #1
    0xe00012e0    0x1ac    mvn r2, #0
    0xe00012e4    0x1b0    and r3, r0, r2, lsl r3
    0xe00012e8    0x1b4    b e000137c <create_bi_frame_cap+0x248>
    0xe00012ec    0x1b8    sub r2, r1, #1
    0xe00012f0    0x1bc    cmp r2, #8
    0xe00012f4    0x1c0    ldrls pc, [pc, r2, lsl #2]
    0xe00012f8    0x1c4    b e00013a4 <create_bi_frame_cap+0x270>
    0xe00012fc    0x1c8    .word 0xe0001320
    0xe0001300    0x1cc    .word 0xe00013a4
    0xe0001304    0x1d0    .word 0xe0001320
    0xe0001308    0x1d4    .word 0xe00013a4
    0xe000130c    0x1d8    .word 0xe0001370
    0xe0001310    0x1dc    .word 0xe00013a4
    0xe0001314    0x1e0    .word 0xe0001358
    0xe0001318    0x1e4    .word 0xe00013a4
    0xe000131c    0x1e8    .word 0xe0001364
    0xe0001320    0x1ec    cmp r1, #1
    0xe0001324    0x1f0    beq e0001338 <create_bi_frame_cap+0x204>
    0xe0001328    0x1f4    cmp r1, #3
    0xe000132c    0x1f8    beq e0001348 <create_bi_frame_cap+0x214>
    0xe0001330    0x1fc    mov r3, #0
    0xe0001334    0x200    b e000137c <create_bi_frame_cap+0x248>
    0xe0001338    0x204    lsl r3, r3, #8
    0xe000133c    0x208    bic r3, r3, #4080 
    0xe0001340    0x20c    bic r3, r3, #15
    0xe0001344    0x210    b e000137c <create_bi_frame_cap+0x248>
    0xe0001348    0x214    lsl r3, r3, #10
    0xe000134c    0x218    bic r3, r3, #16320 
    0xe0001350    0x21c    bic r3, r3, #63 
    0xe0001354    0x220    b e000137c <create_bi_frame_cap+0x248>
    0xe0001358    0x224    bic r3, r3, #1020 
    0xe000135c    0x228    bic r3, r3, #3
    0xe0001360    0x22c    b e000137c <create_bi_frame_cap+0x248>
    0xe0001364    0x230    bic r3, r3, #16320 
    0xe0001368    0x234    bic r3, r3, #63 
    0xe000136c    0x238    b e000137c <create_bi_frame_cap+0x248>
    0xe0001370    0x23c    bic r3, r3, #15
    0xe0001374    0x240    b e000137c <create_bi_frame_cap+0x248>
    0xe0001378    0x244    mov r3, #0
    0xe000137c    0x248    ldr r2, [sp, #32]     ; stack access
    0xe0001380    0x24c    str r2, [r3, #144] 
    0xe0001384    0x250    ldr r2, [sp, #36]     ; stack access
    0xe0001388    0x254    str r2, [r3, #148] 
    0xe000138c    0x258    mov r2, #0
    0xe0001390    0x25c    str r2, [r3, #152] 
    0xe0001394    0x260    mov r2, #3
    0xe0001398    0x264    str r2, [r3, #156] 
    0xe000139c    0x268    add sp, sp, #44 
    0xe00013a0    0x26c    pop {pc}              ; stack access
    0xe00013a4    0x270    mov r3, #0
    0xe00013a8    0x274    b e000137c <create_bi_frame_cap+0x248>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
88 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_bi_frame_cap` has 333 nodes.

Section insert_region (175 of 293)
==================================

Deriving specifications
-----------------------

Section `insert_region` consists of 58 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `insert_region`:

    0xe0000d9c     0x0    push {r4, lr}         ; stack access
    0xe0000da0     0x4    sub sp, sp, #16
    0xe0000da4     0x8    mov r3, sp
    0xe0000da8     0xc    stm r3, {r0, r1}      ; stack access
    0xe0000dac    0x10    ldr r2, [sp, #4]      ; stack access
    0xe0000db0    0x14    cmp r0, r2
    0xe0000db4    0x18    moveq r0, #1
    0xe0000db8    0x1c    beq e0000e28 <insert_region+0x8c>
    0xe0000dbc    0x20    mov r1, r0
    0xe0000dc0    0x24    movw r3, #47104 
    0xe0000dc4    0x28    movt r3, #57345 
    0xe0000dc8    0x2c    ldr r0, [r3, #92] 
    0xe0000dcc    0x30    ldr r3, [r3, #96] 
    0xe0000dd0    0x34    cmp r0, r3
    0xe0000dd4    0x38    beq e0000e40 <insert_region+0xa4>
    0xe0000dd8    0x3c    movw r3, #47104 
    0xe0000ddc    0x40    movt r3, #57345 
    0xe0000de0    0x44    ldr r0, [r3, #100] 
    0xe0000de4    0x48    ldr r3, [r3, #104] 
    0xe0000de8    0x4c    cmp r0, r3
    0xe0000dec    0x50    beq e0000e30 <insert_region+0x94>
    0xe0000df0    0x54    movw r3, #47104 
    0xe0000df4    0x58    movt r3, #57345 
    0xe0000df8    0x5c    ldr r0, [r3, #108] 
    0xe0000dfc    0x60    ldr r3, [r3, #112] 
    0xe0000e00    0x64    cmp r0, r3
    0xe0000e04    0x68    beq e0000e38 <insert_region+0x9c>
    0xe0000e08    0x6c    movw r3, #47104 
    0xe0000e0c    0x70    movt r3, #57345 
    0xe0000e10    0x74    ldr r0, [r3, #116] 
    0xe0000e14    0x78    ldr r3, [r3, #120] 
    0xe0000e18    0x7c    cmp r0, r3
    0xe0000e1c    0x80    moveq r4, #3
    0xe0000e20    0x84    beq e0000e44 <insert_region+0xa8>
    0xe0000e24    0x88    mov r0, #0
    0xe0000e28    0x8c    add sp, sp, #16
    0xe0000e2c    0x90    pop {r4, pc}          ; stack access
    0xe0000e30    0x94    mov r4, #1
    0xe0000e34    0x98    b e0000e44 <insert_region+0xa8>
    0xe0000e38    0x9c    mov r4, #2
    0xe0000e3c    0xa0    b e0000e44 <insert_region+0xa8>
    0xe0000e40    0xa4    mov r4, #0
    0xe0000e44    0xa8    add r1, r1, #805306368 
    0xe0000e48    0xac    str r1, [sp, #8]      ; stack access
    0xe0000e4c    0xb0    add r2, r2, #805306368 
    0xe0000e50    0xb4    str r2, [sp, #12]     ; stack access
    0xe0000e54    0xb8    add r3, sp, #16
    0xe0000e58    0xbc    ldmdb r3, {r0, r1}    ; stack access
    0xe0000e5c    0xc0    bl e0000b7c <reserve_region>
    0xe0000e60    0xc4    movw r3, #47104 
    0xe0000e64    0xc8    movt r3, #57345 
    0xe0000e68    0xcc    add r3, r3, r4, lsl #3
    0xe0000e6c    0xd0    add r3, r3, #92 
    0xe0000e70    0xd4    mov r2, sp
    0xe0000e74    0xd8    ldm r2, {r0, r1}      ; stack access
    0xe0000e78    0xdc    stm r3, {r0, r1}
    0xe0000e7c    0xe0    mov r0, #1
    0xe0000e80    0xe4    b e0000e28 <insert_region+0x8c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
58 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `insert_region` has 91 nodes.

Section reserve_region (176 of 293)
===================================

Deriving specifications
-----------------------

Section `reserve_region` consists of 105 instructions.
 MOVWCS..++
 MOVTCS..++


Stack analysis
---------------

5 stack accesses found. Annotated code for `reserve_region`:

    0xe0000b7c      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0000b80      0x4    sub sp, sp, #8
    0xe0000b84      0x8    add r3, sp, #8
    0xe0000b88      0xc    stmdb r3, {r0, r1}    ; stack access
    0xe0000b8c     0x10    ldr r4, [sp]          ; stack access
    0xe0000b90     0x14    ldr ip, [sp, #4]      ; stack access
    0xe0000b94     0x18    cmp r4, ip
    0xe0000b98     0x1c    moveq r0, #1
    0xe0000b9c     0x20    beq e0000c98 <reserve_region+0x11c>
    0xe0000ba0     0x24    movw r3, #47104 
    0xe0000ba4     0x28    movt r3, #57345 
    0xe0000ba8     0x2c    ldr lr, [r3, #88] 
    0xe0000bac     0x30    cmp lr, #0
    0xe0000bb0     0x34    beq e0000d08 <reserve_region+0x18c>
    0xe0000bb4     0x38    movw r3, #47104 
    0xe0000bb8     0x3c    movt r3, #57345 
    0xe0000bbc     0x40    ldr r2, [r3]
    0xe0000bc0     0x44    cmp ip, r2
    0xe0000bc4     0x48    beq e0000c80 <reserve_region+0x104>
    0xe0000bc8     0x4c    movw r3, #47104 
    0xe0000bcc     0x50    movt r3, #57345 
    0xe0000bd0     0x54    ldr r3, [r3, #4]
    0xe0000bd4     0x58    cmp r4, r3
    0xe0000bd8     0x5c    beq e0000ca0 <reserve_region+0x124>
    0xe0000bdc     0x60    cmp ip, r2
    0xe0000be0     0x64    movwcs r3, #47104 
    0xe0000be4     0x68    movtcs r3, #57345 
    0xe0000be8     0x6c    movcs r2, #0
    0xe0000bec     0x70    bcc e0000cc0 <reserve_region+0x144>
    0xe0000bf0     0x74    add r2, r2, #1
    0xe0000bf4     0x78    cmp r2, lr
    0xe0000bf8     0x7c    beq e0000cd8 <reserve_region+0x15c>
    0xe0000bfc     0x80    ldr r1, [r3, #8]
    0xe0000c00     0x84    cmp r1, ip
    0xe0000c04     0x88    beq e0000c84 <reserve_region+0x108>
    0xe0000c08     0x8c    ldr r0, [r3, #12]
    0xe0000c0c     0x90    cmp r0, r4
    0xe0000c10     0x94    beq e0000ca4 <reserve_region+0x128>
    0xe0000c14     0x98    add r3, r3, #8
    0xe0000c18     0x9c    cmp r1, ip
    0xe0000c1c     0xa0    bls e0000bf0 <reserve_region+0x74>
    0xe0000c20     0xa4    add r3, lr, #1
    0xe0000c24     0xa8    cmp r3, #10
    0xe0000c28     0xac    bhi e0000d18 <reserve_region+0x19c>
    0xe0000c2c     0xb0    mov r3, lr
    0xe0000c30     0xb4    movw r6, #47104 
    0xe0000c34     0xb8    movt r6, #57345 
    0xe0000c38     0xbc    sub lr, lr, #1
    0xe0000c3c     0xc0    add r5, r6, r3, lsl #3
    0xe0000c40     0xc4    add r1, r6, lr, lsl #3
    0xe0000c44     0xc8    ldm r1, {r0, r1}
    0xe0000c48     0xcc    stm r5, {r0, r1}
    0xe0000c4c     0xd0    sub r3, r3, #1
    0xe0000c50     0xd4    cmp lr, r2
    0xe0000c54     0xd8    bhi e0000c38 <reserve_region+0xbc>
    0xe0000c58     0xdc    movw r3, #47104 
    0xe0000c5c     0xe0    movt r3, #57345 
    0xe0000c60     0xe4    add r1, r3, r2, lsl #3
    0xe0000c64     0xe8    str r4, [r3, r2, lsl #3]
    0xe0000c68     0xec    str ip, [r1, #4]
    0xe0000c6c     0xf0    ldr r2, [r3, #88] 
    0xe0000c70     0xf4    add r2, r2, #1
    0xe0000c74     0xf8    str r2, [r3, #88] 
    0xe0000c78     0xfc    mov r0, #1
    0xe0000c7c    0x100    b e0000c98 <reserve_region+0x11c>
    0xe0000c80    0x104    mov r2, #0
    0xe0000c84    0x108    movw r3, #47104 
    0xe0000c88    0x10c    movt r3, #57345 
    0xe0000c8c    0x110    str r4, [r3, r2, lsl #3]
    0xe0000c90    0x114    bl e0000290 <merge_regions>
    0xe0000c94    0x118    mov r0, #1
    0xe0000c98    0x11c    add sp, sp, #8
    0xe0000c9c    0x120    pop {r4, r5, r6, pc}  ; stack access
    0xe0000ca0    0x124    mov r2, #0
    0xe0000ca4    0x128    movw r3, #47104 
    0xe0000ca8    0x12c    movt r3, #57345 
    0xe0000cac    0x130    add r2, r3, r2, lsl #3
    0xe0000cb0    0x134    str ip, [r2, #4]
    0xe0000cb4    0x138    bl e0000290 <merge_regions>
    0xe0000cb8    0x13c    mov r0, #1
    0xe0000cbc    0x140    b e0000c98 <reserve_region+0x11c>
    0xe0000cc0    0x144    add r3, lr, #1
    0xe0000cc4    0x148    cmp r3, #10
    0xe0000cc8    0x14c    movhi r0, #0
    0xe0000ccc    0x150    bhi e0000c98 <reserve_region+0x11c>
    0xe0000cd0    0x154    mov r2, #0
    0xe0000cd4    0x158    b e0000c2c <reserve_region+0xb0>
    0xe0000cd8    0x15c    cmp r2, #10
    0xe0000cdc    0x160    beq e0000d10 <reserve_region+0x194>
    0xe0000ce0    0x164    movw r3, #47104 
    0xe0000ce4    0x168    movt r3, #57345 
    0xe0000ce8    0x16c    add r1, r3, r2, lsl #3
    0xe0000cec    0x170    str r4, [r3, r2, lsl #3]
    0xe0000cf0    0x174    str ip, [r1, #4]
    0xe0000cf4    0x178    ldr r2, [r3, #88] 
    0xe0000cf8    0x17c    add r2, r2, #1
    0xe0000cfc    0x180    str r2, [r3, #88] 
    0xe0000d00    0x184    mov r0, #1
    0xe0000d04    0x188    b e0000c98 <reserve_region+0x11c>
    0xe0000d08    0x18c    mov r2, lr
    0xe0000d0c    0x190    b e0000ce0 <reserve_region+0x164>
    0xe0000d10    0x194    mov r0, #0
    0xe0000d14    0x198    b e0000c98 <reserve_region+0x11c>
    0xe0000d18    0x19c    mov r0, #0
    0xe0000d1c    0x1a0    b e0000c98 <reserve_region+0x11c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
105 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `reserve_region` has 165 nodes.

Section cpu_initLocalIRQController (177 of 293)
===============================================

Deriving specifications
-----------------------

Section `cpu_initLocalIRQController` consists of 3 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `cpu_initLocalIRQController`:

    0xe0000a18    0x0    push {r4, lr}         ; stack access
    0xe0000a1c    0x4    bl e00001fc <cpu_iface_init>
    0xe0000a20    0x8    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cpu_initLocalIRQController` has 6 nodes.

Section initIRQController (178 of 293)
======================================

Deriving specifications
-----------------------

Section `initIRQController` consists of 3 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `initIRQController`:

    0xe0000a0c    0x0    push {r4, lr}         ; stack access
    0xe0000a10    0x4    bl e0000060 <dist_init>
    0xe0000a14    0x8    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initIRQController` has 6 nodes.

Section create_mapped_it_frame_cap (179 of 293)
===============================================

Deriving specifications
-----------------------

Section `create_mapped_it_frame_cap` consists of 79 instructions.
 ORREQ (imm)....+++


Stack analysis
---------------

Section `create_mapped_it_frame_cap` expects pointer to stack in r0.
10 stack accesses found. Annotated code for `create_mapped_it_frame_cap`:

    0xe0000408      0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe000040c      0x4    sub sp, sp, #12
    0xe0000410      0x8    mov r8, r0
    0xe0000414      0xc    add r0, sp, #8
    0xe0000418     0x10    stmdb r0, {r1, r2}    ; stack access
    0xe000041c     0x14    ldr r1, [sp, #40]     ; stack access
    0xe0000420     0x18    ldr r2, [sp, #44]     ; stack access
    0xe0000424     0x1c    ldr r0, [sp, #48]     ; stack access
    0xe0000428     0x20    cmp r0, #0
    0xe000042c     0x24    bne e000048c <create_mapped_it_frame_cap+0x84>
    0xe0000430     0x28    lsl r4, r2, #14
    0xe0000434     0x2c    and r4, r4, #2130706432 
    0xe0000438     0x30    orr r4, r4, #1
    0xe000043c     0x34    lsr r3, r3, #8
    0xe0000440     0x38    bic r3, r3, #15
    0xe0000444     0x3c    orr r4, r4, r3
    0xe0000448     0x40    lsl r5, r2, #22
    0xe000044c     0x44    orr r5, r5, #3145728 
    0xe0000450     0x48    orr r5, r5, r1, lsr #12
    0xe0000454     0x4c    ldr r2, [sp]          ; stack access
    0xe0000458     0x50    bic r2, r2, #16320 
    0xe000045c     0x54    bic r2, r2, #63 
    0xe0000460     0x58    and r3, r4, #15
    0xe0000464     0x5c    cmp r3, #1
    0xe0000468     0x60    beq e00004c4 <create_mapped_it_frame_cap+0xbc>
    0xe000046c     0x64    cmp r3, #3
    0xe0000470     0x68    beq e00004d8 <create_mapped_it_frame_cap+0xd0>
    0xe0000474     0x6c    uxtb r3, r3
    0xe0000478     0x70    cmp r3, #1
    0xe000047c     0x74    movne r9, #0
    0xe0000480     0x78    bne e00004e4 <create_mapped_it_frame_cap+0xdc>
    0xe0000484     0x7c    mov r9, #0
    0xe0000488     0x80    b e00004d0 <create_mapped_it_frame_cap+0xc8>
    0xe000048c     0x84    lsl r4, r2, #12
    0xe0000490     0x88    and r4, r4, #532676608 
    0xe0000494     0x8c    orr r4, r4, #3
    0xe0000498     0x90    lsr r3, r3, #10
    0xe000049c     0x94    bic r3, r3, #-268435441 
    0xe00004a0     0x98    bic r3, r3, #264241152 
    0xe00004a4     0x9c    orr r4, r4, r3
    0xe00004a8     0xa0    mov r5, #0
    0xe00004ac     0xa4    movt r5, #16368 
    0xe00004b0     0xa8    and r5, r5, r2, lsl #20
    0xe00004b4     0xac    orr r5, r5, r1, lsr #14
    0xe00004b8     0xb0    orr r5, r5, #-2147483648 
    0xe00004bc     0xb4    orr r5, r5, #786432 
    0xe00004c0     0xb8    b e0000454 <create_mapped_it_frame_cap+0x4c>
    0xe00004c4     0xbc    lsl r9, r4, #8
    0xe00004c8     0xc0    bic r9, r9, #4080 
    0xe00004cc     0xc4    bic r9, r9, #15
    0xe00004d0     0xc8    lsl r7, r5, #12
    0xe00004d4     0xcc    b e00004e8 <create_mapped_it_frame_cap+0xe0>
    0xe00004d8     0xd0    lsl r9, r4, #10
    0xe00004dc     0xd4    bic r9, r9, #16320 
    0xe00004e0     0xd8    bic r9, r9, #63 
    0xe00004e4     0xdc    lsl r7, r5, #14
    0xe00004e8     0xe0    lsr r3, r7, #20
    0xe00004ec     0xe4    ldr r6, [r2, r3, lsl #2]
    0xe00004f0     0xe8    bic r6, r6, #1020 
    0xe00004f4     0xec    bic r6, r6, #3
    0xe00004f8     0xf0    add r6, r6, #-805306368 
    0xe00004fc     0xf4    ubfx r7, r7, #12, #8
    0xe0000500     0xf8    mov r0, #3
    0xe0000504     0xfc    bl e0010910 <APFromVMRights>
    0xe0000508    0x100    ldr r2, [sp, #52]     ; stack access
    0xe000050c    0x104    movw r3, #2374 
    0xe0000510    0x108    cmp r2, #0
    0xe0000514    0x10c    orreq r3, r3, #1
    0xe0000518    0x110    add r9, r9, #805306368 
    0xe000051c    0x114    orr r3, r3, r9
    0xe0000520    0x118    lsl r0, r0, #4
    0xe0000524    0x11c    and r0, r0, #48 
    0xe0000528    0x120    orr r3, r3, r0
    0xe000052c    0x124    str r3, [r6, r7, lsl #2]
    0xe0000530    0x128    str r4, [r8]          ; stack access
    0xe0000534    0x12c    str r5, [r8, #4]      ; stack access
    0xe0000538    0x130    mov r0, r8
    0xe000053c    0x134    add sp, sp, #12
    0xe0000540    0x138    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
79 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_mapped_it_frame_cap` has 104 nodes.

Section map_kernel_frame (180 of 293)
=====================================

Deriving specifications
-----------------------

Section `map_kernel_frame` consists of 20 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `map_kernel_frame`:

    0xe0000334     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0000338     0x4    mov r4, r0
    0xe000033c     0x8    ubfx r5, r1, #12, #8
    0xe0000340     0xc    and r3, r3, #1
    0xe0000344    0x10    cmp r3, #0
    0xe0000348    0x14    movne r6, #5
    0xe000034c    0x18    moveq r6, #0
    0xe0000350    0x1c    mov r0, r2
    0xe0000354    0x20    bl e0010910 <APFromVMRights>
    0xe0000358    0x24    movw r2, #0
    0xe000035c    0x28    movt r2, #57346 
    0xe0000360    0x2c    bic r3, r4, #4080 
    0xe0000364    0x30    bic r3, r3, #15
    0xe0000368    0x34    orr r3, r3, #6
    0xe000036c    0x38    orr r3, r3, r6, lsl #6
    0xe0000370    0x3c    lsl r0, r0, #4
    0xe0000374    0x40    and r0, r0, #48 
    0xe0000378    0x44    orr r3, r3, r0
    0xe000037c    0x48    str r3, [r2, r5, lsl #2]
    0xe0000380    0x4c    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_frame` has 28 nodes.

Section replyFromKernel_error (181 of 293)
==========================================

Deriving specifications
-----------------------

Section `replyFromKernel_error` consists of 17 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `replyFromKernel_error`:

    0xe00190a0     0x0    push {r4, lr}         ; stack access
    0xe00190a4     0x4    mov r4, r0
    0xe00190a8     0x8    mov r1, r0
    0xe00190ac     0xc    mov r0, #1
    0xe00190b0    0x10    bl e0010b04 <lookupIPCBuffer>
    0xe00190b4    0x14    mov r3, #0
    0xe00190b8    0x18    str r3, [r4]
    0xe00190bc    0x1c    mov r1, r0
    0xe00190c0    0x20    mov r0, r4
    0xe00190c4    0x24    bl e0018f34 <setMRs_syscall_error>
    0xe00190c8    0x28    movw r3, #36896 
    0xe00190cc    0x2c    movt r3, #57346 
    0xe00190d0    0x30    ldr r3, [r3, #24]
    0xe00190d4    0x34    and r0, r0, #127 
    0xe00190d8    0x38    orr r0, r0, r3, lsl #12
    0xe00190dc    0x3c    str r0, [r4, #4]
    0xe00190e0    0x40    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `replyFromKernel_error` has 24 nodes.

Section decodeUnbindNotification (182 of 293)
=============================================

Deriving specifications
-----------------------

Section `decodeUnbindNotification` consists of 24 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `decodeUnbindNotification`:

    0xe0018c1c     0x0    push {r4, lr}         ; stack access
    0xe0018c20     0x4    sub sp, sp, #8
    0xe0018c24     0x8    add r3, sp, #8
    0xe0018c28     0xc    stmdb r3, {r0, r1}    ; stack access
    0xe0018c2c    0x10    ldr r4, [sp]          ; stack access
    0xe0018c30    0x14    bic r4, r4, #15
    0xe0018c34    0x18    ldr r3, [r4, #92] 
    0xe0018c38    0x1c    cmp r3, #0
    0xe0018c3c    0x20    beq e0018c68 <decodeUnbindNotification+0x4c>
    0xe0018c40    0x24    movw r3, #13900 
    0xe0018c44    0x28    movt r3, #57347 
    0xe0018c48    0x2c    mov r1, #2
    0xe0018c4c    0x30    ldr r0, [r3]
    0xe0018c50    0x34    bl e0014ad8 <setThreadState>
    0xe0018c54    0x38    mov r1, #0
    0xe0018c58    0x3c    mov r0, r4
    0xe0018c5c    0x40    bl e0018ae4 <invokeTCB_NotificationControl>
    0xe0018c60    0x44    add sp, sp, #8
    0xe0018c64    0x48    pop {r4, pc}          ; stack access
    0xe0018c68    0x4c    movw r3, #36896 
    0xe0018c6c    0x50    movt r3, #57346 
    0xe0018c70    0x54    mov r0, #3
    0xe0018c74    0x58    str r0, [r3, #24]
    0xe0018c78    0x5c    b e0018c60 <decodeUnbindNotification+0x44>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
24 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeUnbindNotification` has 35 nodes.

Section decodeBindNotification (183 of 293)
===========================================

Deriving specifications
-----------------------

Section `decodeBindNotification` consists of 70 instructions.
 STMIB;3,2...+
 LDMIA (wb);14,5,4.+


Stack analysis
---------------

6 stack accesses found. Annotated code for `decodeBindNotification`:

    0xe0018b04      0x0    sub sp, sp, #8
    0xe0018b08      0x4    push {r4, r5, lr}     ; stack access
    0xe0018b0c      0x8    sub sp, sp, #12
    0xe0018b10      0xc    add ip, sp, #8
    0xe0018b14     0x10    stmdb ip, {r0, r1}    ; stack access
    0xe0018b18     0x14    add r1, sp, #20
    0xe0018b1c     0x18    stmib r1, {r2, r3}    ; stack access
    0xe0018b20     0x1c    ldr r3, [sp, #24]     ; stack access
    0xe0018b24     0x20    cmp r3, #0
    0xe0018b28     0x24    beq e0018b60 <decodeBindNotification+0x5c>
    0xe0018b2c     0x28    ldr r4, [sp]          ; stack access
    0xe0018b30     0x2c    bic r4, r4, #15
    0xe0018b34     0x30    ldr r2, [r4, #92] 
    0xe0018b38     0x34    cmp r2, #0
    0xe0018b3c     0x38    beq e0018b78 <decodeBindNotification+0x74>
    0xe0018b40     0x3c    movw r3, #36896 
    0xe0018b44     0x40    movt r3, #57346 
    0xe0018b48     0x44    mov r0, #3
    0xe0018b4c     0x48    str r0, [r3, #24]
    0xe0018b50     0x4c    add sp, sp, #12
    0xe0018b54     0x50    pop {r4, r5, lr}      ; stack access
    0xe0018b58     0x54    add sp, sp, #8
    0xe0018b5c     0x58    bx lr
    0xe0018b60     0x5c    movw r3, #36896 
    0xe0018b64     0x60    movt r3, #57346 
    0xe0018b68     0x64    mov r2, #7
    0xe0018b6c     0x68    str r2, [r3, #24]
    0xe0018b70     0x6c    mov r0, #3
    0xe0018b74     0x70    b e0018b50 <decodeBindNotification+0x4c>
    0xe0018b78     0x74    ldr r1, [r3]
    0xe0018b7c     0x78    and r2, r1, #14
    0xe0018b80     0x7c    cmp r2, #14
    0xe0018b84     0x80    andne r2, r1, #15
    0xe0018b88     0x84    uxtbeq r2, r1
    0xe0018b8c     0x88    cmp r2, #6
    0xe0018b90     0x8c    bne e0018be0 <decodeBindNotification+0xdc>
    0xe0018b94     0x90    ldr r3, [r3, #4]
    0xe0018b98     0x94    tst r3, #2
    0xe0018b9c     0x98    beq e0018bf4 <decodeBindNotification+0xf0>
    0xe0018ba0     0x9c    bic r5, r1, #15
    0xe0018ba4     0xa0    ldr r3, [r5, #4]
    0xe0018ba8     0xa4    bics r3, r3, #15
    0xe0018bac     0xa8    bne e0018c08 <decodeBindNotification+0x104>
    0xe0018bb0     0xac    ldr r3, [r5, #12]
    0xe0018bb4     0xb0    bics r3, r3, #15
    0xe0018bb8     0xb4    bne e0018c08 <decodeBindNotification+0x104>
    0xe0018bbc     0xb8    movw r3, #13900 
    0xe0018bc0     0xbc    movt r3, #57347 
    0xe0018bc4     0xc0    mov r1, #2
    0xe0018bc8     0xc4    ldr r0, [r3]
    0xe0018bcc     0xc8    bl e0014ad8 <setThreadState>
    0xe0018bd0     0xcc    mov r1, r5
    0xe0018bd4     0xd0    mov r0, r4
    0xe0018bd8     0xd4    bl e0018ae4 <invokeTCB_NotificationControl>
    0xe0018bdc     0xd8    b e0018b50 <decodeBindNotification+0x4c>
    0xe0018be0     0xdc    movw r3, #36896 
    0xe0018be4     0xe0    movt r3, #57346 
    0xe0018be8     0xe4    mov r0, #3
    0xe0018bec     0xe8    str r0, [r3, #24]
    0xe0018bf0     0xec    b e0018b50 <decodeBindNotification+0x4c>
    0xe0018bf4     0xf0    movw r3, #36896 
    0xe0018bf8     0xf4    movt r3, #57346 
    0xe0018bfc     0xf8    mov r0, #3
    0xe0018c00     0xfc    str r0, [r3, #24]
    0xe0018c04    0x100    b e0018b50 <decodeBindNotification+0x4c>
    0xe0018c08    0x104    movw r3, #36896 
    0xe0018c0c    0x108    movt r3, #57346 
    0xe0018c10    0x10c    mov r0, #3
    0xe0018c14    0x110    str r0, [r3, #24]
    0xe0018c18    0x114    b e0018b50 <decodeBindNotification+0x4c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
70 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeBindNotification` has 106 nodes.

Section invokeTCB_NotificationControl (184 of 293)
==================================================

Deriving specifications
-----------------------

Section `invokeTCB_NotificationControl` consists of 8 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_NotificationControl`:

    0xe0018ae4     0x0    push {r4, lr}         ; stack access
    0xe0018ae8     0x4    cmp r1, #0
    0xe0018aec     0x8    beq e0018afc <invokeTCB_NotificationControl+0x18>
    0xe0018af0     0xc    bl e001381c <bindNotification>
    0xe0018af4    0x10    mov r0, #0
    0xe0018af8    0x14    pop {r4, pc}          ; stack access
    0xe0018afc    0x18    bl e00137fc <unbindNotification>
    0xe0018b00    0x1c    b e0018af4 <invokeTCB_NotificationControl+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_NotificationControl` has 14 nodes.

Section decodeWriteRegisters (185 of 293)
=========================================

Deriving specifications
-----------------------

Section `decodeWriteRegisters` consists of 46 instructions.
 LDMIA (wb);15,7,6,5,4.+


Stack analysis
---------------

5 stack accesses found. Annotated code for `decodeWriteRegisters`:

    0xe0018a2c     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0018a30     0x4    sub sp, sp, #20
    0xe0018a34     0x8    add ip, sp, #16
    0xe0018a38     0xc    stmdb ip, {r0, r1}    ; stack access
    0xe0018a3c    0x10    cmp r2, #1
    0xe0018a40    0x14    bls e0018aa0 <decodeWriteRegisters+0x74>
    0xe0018a44    0x18    movw r1, #13900 
    0xe0018a48    0x1c    movt r1, #57347 
    0xe0018a4c    0x20    ldr r0, [r1]
    0xe0018a50    0x24    ldr r6, [r0, #12]
    0xe0018a54    0x28    sub r2, r2, #2
    0xe0018a58    0x2c    cmp r2, r6
    0xe0018a5c    0x30    bcc e0018ab8 <decodeWriteRegisters+0x8c>
    0xe0018a60    0x34    ldr r4, [sp, #8]      ; stack access
    0xe0018a64    0x38    bic r4, r4, #15
    0xe0018a68    0x3c    cmp r4, r0
    0xe0018a6c    0x40    beq e0018ad0 <decodeWriteRegisters+0xa4>
    0xe0018a70    0x44    mov r5, r3
    0xe0018a74    0x48    ldr r7, [r0, #8]
    0xe0018a78    0x4c    mov r1, #2
    0xe0018a7c    0x50    bl e0014ad8 <setThreadState>
    0xe0018a80    0x54    str r5, [sp]          ; stack access
    0xe0018a84    0x58    mov r3, #0
    0xe0018a88    0x5c    mov r2, r6
    0xe0018a8c    0x60    and r1, r7, #1
    0xe0018a90    0x64    mov r0, r4
    0xe0018a94    0x68    bl e00188e8 <invokeTCB_WriteRegisters>
    0xe0018a98    0x6c    add sp, sp, #20
    0xe0018a9c    0x70    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0018aa0    0x74    movw r3, #36896 
    0xe0018aa4    0x78    movt r3, #57346 
    0xe0018aa8    0x7c    mov r2, #7
    0xe0018aac    0x80    str r2, [r3, #24]
    0xe0018ab0    0x84    mov r0, #3
    0xe0018ab4    0x88    b e0018a98 <decodeWriteRegisters+0x6c>
    0xe0018ab8    0x8c    movw r3, #36896 
    0xe0018abc    0x90    movt r3, #57346 
    0xe0018ac0    0x94    mov r2, #7
    0xe0018ac4    0x98    str r2, [r3, #24]
    0xe0018ac8    0x9c    mov r0, #3
    0xe0018acc    0xa0    b e0018a98 <decodeWriteRegisters+0x6c>
    0xe0018ad0    0xa4    movw r3, #36896 
    0xe0018ad4    0xa8    movt r3, #57346 
    0xe0018ad8    0xac    mov r0, #3
    0xe0018adc    0xb0    str r0, [r3, #24]
    0xe0018ae0    0xb4    b e0018a98 <decodeWriteRegisters+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
46 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeWriteRegisters` has 65 nodes.

Section invokeTCB_WriteRegisters (186 of 293)
=============================================

Deriving specifications
-----------------------

Section `invokeTCB_WriteRegisters` consists of 81 instructions.
 MOVCC (reg)....+++
 LDRLS (+imm,pre)...+++
 ADDHI (reg)...........++++++
 LDRHI (+imm,pre)...+++


Stack analysis
---------------

3 stack accesses found. Annotated code for `invokeTCB_WriteRegisters`:

    0xe00188e8      0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe00188ec      0x4    mov r4, r0
    0xe00188f0      0x8    ldr ip, [sp, #32]     ; stack access
    0xe00188f4      0xc    cmp r2, #19
    0xe00188f8     0x10    movcc r5, r2
    0xe00188fc     0x14    movcs r5, #19
    0xe0018900     0x18    cmp r2, #0
    0xe0018904     0x1c    beq e00189e8 <invokeTCB_WriteRegisters+0x100>
    0xe0018908     0x20    mov r6, #2
    0xe001890c     0x24    mov r3, #0
    0xe0018910     0x28    movw r0, #46284 
    0xe0018914     0x2c    movt r0, #57345 
    0xe0018918     0x30    add r9, r0, #136 
    0xe001891c     0x34    movw r8, #13900 
    0xe0018920     0x38    movt r8, #57347 
    0xe0018924     0x3c    add lr, r0, #96 
    0xe0018928     0x40    lsl r0, r3, #2
    0xe001892c     0x44    ldr r7, [r9, r3, lsl #2]
    0xe0018930     0x48    cmp r6, #3
    0xe0018934     0x4c    ldrls r0, [r8]
    0xe0018938     0x50    ldrls sl, [lr, r6, lsl #2]
    0xe001893c     0x54    ldrls r0, [r0, sl, lsl #2]
    0xe0018940     0x58    addhi r0, ip, r0
    0xe0018944     0x5c    ldrhi r0, [r0, #12]
    0xe0018948     0x60    cmp r7, #16
    0xe001894c     0x64    andeq r0, r0, #-134217728 
    0xe0018950     0x68    orreq r0, r0, #336 
    0xe0018954     0x6c    str r0, [r4, r7, lsl #2]
    0xe0018958     0x70    add r3, r3, #1
    0xe001895c     0x74    add r6, r6, #1
    0xe0018960     0x78    cmp r3, #9
    0xe0018964     0x7c    movhi r0, #0
    0xe0018968     0x80    movls r0, #1
    0xe001896c     0x84    cmp r5, r3
    0xe0018970     0x88    movls r0, #0
    0xe0018974     0x8c    cmp r0, #0
    0xe0018978     0x90    bne e0018928 <invokeTCB_WriteRegisters+0x40>
    0xe001897c     0x94    cmp r2, #10
    0xe0018980     0x98    bls e00189e8 <invokeTCB_WriteRegisters+0x100>
    0xe0018984     0x9c    ldr lr, [pc, #156] 
    0xe0018988     0xa0    add ip, ip, #52 
    0xe001898c     0xa4    mov r3, #12
    0xe0018990     0xa8    movw r6, #13900 
    0xe0018994     0xac    movt r6, #57347 
    0xe0018998     0xb0    sub r7, lr, #76 
    0xe001899c     0xb4    b e00189a4 <invokeTCB_WriteRegisters+0xbc>
    0xe00189a0     0xb8    mov r3, r2
    0xe00189a4     0xbc    ldr r0, [lr, #4]!
    0xe00189a8     0xc0    cmp r3, #3
    0xe00189ac     0xc4    ldrls r2, [r6]
    0xe00189b0     0xc8    ldrls r8, [r7, r3, lsl #2]
    0xe00189b4     0xcc    ldrls r2, [r2, r8, lsl #2]
    0xe00189b8     0xd0    ldrhi r2, [ip]
    0xe00189bc     0xd4    cmp r0, #16
    0xe00189c0     0xd8    andeq r2, r2, #-134217728 
    0xe00189c4     0xdc    orreq r2, r2, #336 
    0xe00189c8     0xe0    str r2, [r4, r0, lsl #2]
    0xe00189cc     0xe4    cmp r3, #20
    0xe00189d0     0xe8    beq e00189e8 <invokeTCB_WriteRegisters+0x100>
    0xe00189d4     0xec    add r2, r3, #1
    0xe00189d8     0xf0    add ip, ip, #4
    0xe00189dc     0xf4    sub r3, r3, #1
    0xe00189e0     0xf8    cmp r5, r3
    0xe00189e4     0xfc    bhi e00189a0 <invokeTCB_WriteRegisters+0xb8>
    0xe00189e8    0x100    ldr r3, [r4, #68] 
    0xe00189ec    0x104    str r3, [r4, #60] 
    0xe00189f0    0x108    cmp r1, #0
    0xe00189f4    0x10c    bne e0018a14 <invokeTCB_WriteRegisters+0x12c>
    0xe00189f8    0x110    movw r3, #13900 
    0xe00189fc    0x114    movt r3, #57347 
    0xe0018a00    0x118    ldr r3, [r3]
    0xe0018a04    0x11c    cmp r3, r4
    0xe0018a08    0x120    beq e0018a20 <invokeTCB_WriteRegisters+0x138>
    0xe0018a0c    0x124    mov r0, #0
    0xe0018a10    0x128    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe0018a14    0x12c    mov r0, r4
    0xe0018a18    0x130    bl e0016718 <restart>
    0xe0018a1c    0x134    b e00189f8 <invokeTCB_WriteRegisters+0x110>
    0xe0018a20    0x138    bl e0014a4c <rescheduleRequired>
    0xe0018a24    0x13c    b e0018a0c <invokeTCB_WriteRegisters+0x124>
    0xe0018a28    0x140    .word 0xe001b578

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
80 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_WriteRegisters` has 151 nodes.

Section decodeReadRegisters (187 of 293)
========================================

Deriving specifications
-----------------------

Section `decodeReadRegisters` consists of 50 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `decodeReadRegisters`:

    0xe0018820     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0018824     0x4    sub sp, sp, #20
    0xe0018828     0x8    add ip, sp, #16
    0xe001882c     0xc    stmdb ip, {r0, r1}    ; stack access
    0xe0018830    0x10    cmp r2, #1
    0xe0018834    0x14    bls e0018894 <decodeReadRegisters+0x74>
    0xe0018838    0x18    movw r2, #13900 
    0xe001883c    0x1c    movt r2, #57347 
    0xe0018840    0x20    ldr r0, [r2]
    0xe0018844    0x24    ldr r6, [r0, #12]
    0xe0018848    0x28    sub r2, r6, #1
    0xe001884c    0x2c    cmp r2, #18
    0xe0018850    0x30    bhi e00188ac <decodeReadRegisters+0x8c>
    0xe0018854    0x34    ldr r4, [sp, #8]      ; stack access
    0xe0018858    0x38    bic r4, r4, #15
    0xe001885c    0x3c    cmp r4, r0
    0xe0018860    0x40    beq e00188d4 <decodeReadRegisters+0xb4>
    0xe0018864    0x44    mov r5, r3
    0xe0018868    0x48    ldr r7, [r0, #8]
    0xe001886c    0x4c    mov r1, #2
    0xe0018870    0x50    bl e0014ad8 <setThreadState>
    0xe0018874    0x54    str r5, [sp]          ; stack access
    0xe0018878    0x58    mov r3, #0
    0xe001887c    0x5c    mov r2, r6
    0xe0018880    0x60    and r1, r7, #1
    0xe0018884    0x64    mov r0, r4
    0xe0018888    0x68    bl e00186b4 <invokeTCB_ReadRegisters>
    0xe001888c    0x6c    add sp, sp, #20
    0xe0018890    0x70    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0018894    0x74    movw r3, #36896 
    0xe0018898    0x78    movt r3, #57346 
    0xe001889c    0x7c    mov r2, #7
    0xe00188a0    0x80    str r2, [r3, #24]
    0xe00188a4    0x84    mov r0, #3
    0xe00188a8    0x88    b e001888c <decodeReadRegisters+0x6c>
    0xe00188ac    0x8c    movw r3, #36896 
    0xe00188b0    0x90    movt r3, #57346 
    0xe00188b4    0x94    mov r2, #4
    0xe00188b8    0x98    str r2, [r3, #24]
    0xe00188bc    0x9c    mov r2, #1
    0xe00188c0    0xa0    str r2, [r3, #8]
    0xe00188c4    0xa4    mov r2, #19
    0xe00188c8    0xa8    str r2, [r3, #12]
    0xe00188cc    0xac    mov r0, #3
    0xe00188d0    0xb0    b e001888c <decodeReadRegisters+0x6c>
    0xe00188d4    0xb4    movw r3, #36896 
    0xe00188d8    0xb8    movt r3, #57346 
    0xe00188dc    0xbc    mov r0, #3
    0xe00188e0    0xc0    str r0, [r3, #24]
    0xe00188e4    0xc4    b e001888c <decodeReadRegisters+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
50 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeReadRegisters` has 71 nodes.

Section decodeCopyRegisters (188 of 293)
========================================

Deriving specifications
-----------------------

Section `decodeCopyRegisters` consists of 52 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `decodeCopyRegisters`:

    0xe00185e4     0x0    sub sp, sp, #8
    0xe00185e8     0x4    push {r4, r5, lr}     ; stack access
    0xe00185ec     0x8    sub sp, sp, #28
    0xe00185f0     0xc    add ip, sp, #24
    0xe00185f4    0x10    stmdb ip, {r0, r1}    ; stack access
    0xe00185f8    0x14    str r3, [sp, #44]     ; stack access
    0xe00185fc    0x18    cmp r2, #0
    0xe0018600    0x1c    cmpne r3, #0
    0xe0018604    0x20    beq e0018644 <decodeCopyRegisters+0x60>
    0xe0018608    0x24    ldr r4, [r3]
    0xe001860c    0x28    and r3, r4, #14
    0xe0018610    0x2c    cmp r3, #14
    0xe0018614    0x30    andne r3, r4, #15
    0xe0018618    0x34    uxtbeq r3, r4
    0xe001861c    0x38    cmp r3, #12
    0xe0018620    0x3c    beq e0018668 <decodeCopyRegisters+0x84>
    0xe0018624    0x40    movw r3, #36896 
    0xe0018628    0x44    movt r3, #57346 
    0xe001862c    0x48    mov r2, #2
    0xe0018630    0x4c    str r2, [r3, #24]
    0xe0018634    0x50    mov r2, #1
    0xe0018638    0x54    str r2, [r3, #4]
    0xe001863c    0x58    mov r0, #3
    0xe0018640    0x5c    b e0018658 <decodeCopyRegisters+0x74>
    0xe0018644    0x60    movw r3, #36896 
    0xe0018648    0x64    movt r3, #57346 
    0xe001864c    0x68    mov r2, #7
    0xe0018650    0x6c    str r2, [r3, #24]
    0xe0018654    0x70    mov r0, #3
    0xe0018658    0x74    add sp, sp, #28
    0xe001865c    0x78    pop {r4, r5, lr}      ; stack access
    0xe0018660    0x7c    add sp, sp, #8
    0xe0018664    0x80    bx lr
    0xe0018668    0x84    movw r3, #13900 
    0xe001866c    0x88    movt r3, #57347 
    0xe0018670    0x8c    ldr r0, [r3]
    0xe0018674    0x90    ldr r5, [r0, #8]
    0xe0018678    0x94    mov r1, #2
    0xe001867c    0x98    bl e0014ad8 <setThreadState>
    0xe0018680    0x9c    mov r3, #0
    0xe0018684    0xa0    str r3, [sp, #8]      ; stack access
    0xe0018688    0xa4    and r3, r5, #8
    0xe001868c    0xa8    str r3, [sp, #4]      ; stack access
    0xe0018690    0xac    and r3, r5, #4
    0xe0018694    0xb0    str r3, [sp]          ; stack access
    0xe0018698    0xb4    and r3, r5, #2
    0xe001869c    0xb8    and r2, r5, #1
    0xe00186a0    0xbc    bic r1, r4, #15
    0xe00186a4    0xc0    ldr r0, [sp, #16]     ; stack access
    0xe00186a8    0xc4    bic r0, r0, #15
    0xe00186ac    0xc8    bl e0018520 <invokeTCB_CopyRegisters>
    0xe00186b0    0xcc    b e0018658 <decodeCopyRegisters+0x74>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
52 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeCopyRegisters` has 79 nodes.

Section decodeSetSchedParams (189 of 293)
=========================================

Deriving specifications
-----------------------

Section `decodeSetSchedParams` consists of 90 instructions.
 STMIB;1,0...+


Stack analysis
---------------

19 stack accesses found. Annotated code for `decodeSetSchedParams`:

    0xe0018040      0x0    sub sp, sp, #8
    0xe0018044      0x4    push {r4, r5, lr}     ; stack access
    0xe0018048      0x8    sub sp, sp, #68 
    0xe001804c      0xc    add ip, sp, #48 
    0xe0018050     0x10    stm ip, {r0, r1}      ; stack access
    0xe0018054     0x14    str r3, [sp, #84]     ; stack access
    0xe0018058     0x18    cmp r3, #0
    0xe001805c     0x1c    cmpne r2, #1
    0xe0018060     0x20    bls e00180ac <decodeSetSchedParams+0x6c>
    0xe0018064     0x24    ldr r3, [r3]
    0xe0018068     0x28    and r2, r3, #14
    0xe001806c     0x2c    cmp r2, #14
    0xe0018070     0x30    andne r2, r3, #15
    0xe0018074     0x34    uxtbeq r2, r3
    0xe0018078     0x38    cmp r2, #12
    0xe001807c     0x3c    beq e00180c4 <decodeSetSchedParams+0x84>
    0xe0018080     0x40    movw r3, #36896 
    0xe0018084     0x44    movt r3, #57346 
    0xe0018088     0x48    mov r2, #2
    0xe001808c     0x4c    str r2, [r3, #24]
    0xe0018090     0x50    mov r2, #1
    0xe0018094     0x54    str r2, [r3, #4]
    0xe0018098     0x58    mov r0, #3
    0xe001809c     0x5c    add sp, sp, #68 
    0xe00180a0     0x60    pop {r4, r5, lr}      ; stack access
    0xe00180a4     0x64    add sp, sp, #8
    0xe00180a8     0x68    bx lr
    0xe00180ac     0x6c    movw r3, #36896 
    0xe00180b0     0x70    movt r3, #57346 
    0xe00180b4     0x74    mov r2, #7
    0xe00180b8     0x78    str r2, [r3, #24]
    0xe00180bc     0x7c    mov r0, #3
    0xe00180c0     0x80    b e001809c <decodeSetSchedParams+0x5c>
    0xe00180c4     0x84    movw r2, #13900 
    0xe00180c8     0x88    movt r2, #57347 
    0xe00180cc     0x8c    ldr r0, [r2]
    0xe00180d0     0x90    ldr r4, [r0, #8]
    0xe00180d4     0x94    bic r3, r3, #15
    0xe00180d8     0x98    ldr r3, [r3, #116] 
    0xe00180dc     0x9c    cmp r4, r3
    0xe00180e0     0xa0    bhi e0018160 <decodeSetSchedParams+0x120>
    0xe00180e4     0xa4    ldr r5, [r0, #12]
    0xe00180e8     0xa8    cmp r5, r3
    0xe00180ec     0xac    bhi e0018184 <decodeSetSchedParams+0x144>
    0xe00180f0     0xb0    mov r1, #2
    0xe00180f4     0xb4    bl e0014ad8 <setThreadState>
    0xe00180f8     0xb8    mov ip, #0
    0xe00180fc     0xbc    str ip, [sp, #56]     ; stack access
    0xe0018100     0xc0    str ip, [sp, #60]     ; stack access
    0xe0018104     0xc4    mov r3, #9
    0xe0018108     0xc8    str r3, [sp, #44]     ; stack access
    0xe001810c     0xcc    str ip, [sp, #40]     ; stack access
    0xe0018110     0xd0    add r2, sp, #32
    0xe0018114     0xd4    add r3, sp, #56 
    0xe0018118     0xd8    ldm r3, {r0, r1}      ; stack access
    0xe001811c     0xdc    stm r2, {r0, r1}      ; stack access
    0xe0018120     0xe0    str ip, [sp, #28]     ; stack access
    0xe0018124     0xe4    str ip, [sp, #24]     ; stack access
    0xe0018128     0xe8    add r2, sp, #16
    0xe001812c     0xec    ldm r3, {r0, r1}      ; stack access
    0xe0018130     0xf0    stm r2, {r0, r1}      ; stack access
    0xe0018134     0xf4    str ip, [sp, #12]     ; stack access
    0xe0018138     0xf8    ldm r3, {r0, r1}      ; stack access
    0xe001813c     0xfc    stmib sp, {r0, r1}    ; stack access
    0xe0018140    0x100    str r5, [sp]          ; stack access
    0xe0018144    0x104    mov r3, r4
    0xe0018148    0x108    mov r2, ip
    0xe001814c    0x10c    mov r1, ip
    0xe0018150    0x110    ldr r0, [sp, #48]     ; stack access
    0xe0018154    0x114    bic r0, r0, #15
    0xe0018158    0x118    bl e0017924 <invokeTCB_ThreadControl>
    0xe001815c    0x11c    b e001809c <decodeSetSchedParams+0x5c>
    0xe0018160    0x120    movw r2, #36896 
    0xe0018164    0x124    movt r2, #57346 
    0xe0018168    0x128    mov r1, #4
    0xe001816c    0x12c    str r1, [r2, #24]
    0xe0018170    0x130    mov r1, #0
    0xe0018174    0x134    str r1, [r2, #8]
    0xe0018178    0x138    str r3, [r2, #12]
    0xe001817c    0x13c    mov r0, #3
    0xe0018180    0x140    b e001809c <decodeSetSchedParams+0x5c>
    0xe0018184    0x144    movw r2, #36896 
    0xe0018188    0x148    movt r2, #57346 
    0xe001818c    0x14c    mov r1, #4
    0xe0018190    0x150    str r1, [r2, #24]
    0xe0018194    0x154    mov r1, #0
    0xe0018198    0x158    str r1, [r2, #8]
    0xe001819c    0x15c    str r3, [r2, #12]
    0xe00181a0    0x160    mov r0, #3
    0xe00181a4    0x164    b e001809c <decodeSetSchedParams+0x5c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
90 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetSchedParams` has 140 nodes.

Section decodeSetMCPriority (190 of 293)
========================================

Deriving specifications
-----------------------

Section `decodeSetMCPriority` consists of 78 instructions.


Stack analysis
---------------

19 stack accesses found. Annotated code for `decodeSetMCPriority`:

    0xe0017f08      0x0    sub sp, sp, #8
    0xe0017f0c      0x4    push {r4, lr}         ; stack access
    0xe0017f10      0x8    sub sp, sp, #64 
    0xe0017f14      0xc    add ip, sp, #48 
    0xe0017f18     0x10    stm ip, {r0, r1}      ; stack access
    0xe0017f1c     0x14    str r3, [sp, #76]     ; stack access
    0xe0017f20     0x18    cmp r3, #0
    0xe0017f24     0x1c    cmpne r2, #0
    0xe0017f28     0x20    beq e0017f68 <decodeSetMCPriority+0x60>
    0xe0017f2c     0x24    ldr r3, [r3]
    0xe0017f30     0x28    and r2, r3, #14
    0xe0017f34     0x2c    cmp r2, #14
    0xe0017f38     0x30    andne r2, r3, #15
    0xe0017f3c     0x34    uxtbeq r2, r3
    0xe0017f40     0x38    cmp r2, #12
    0xe0017f44     0x3c    beq e0017f8c <decodeSetMCPriority+0x84>
    0xe0017f48     0x40    movw r3, #36896 
    0xe0017f4c     0x44    movt r3, #57346 
    0xe0017f50     0x48    mov r2, #2
    0xe0017f54     0x4c    str r2, [r3, #24]
    0xe0017f58     0x50    mov r2, #1
    0xe0017f5c     0x54    str r2, [r3, #4]
    0xe0017f60     0x58    mov r0, #3
    0xe0017f64     0x5c    b e0017f7c <decodeSetMCPriority+0x74>
    0xe0017f68     0x60    movw r3, #36896 
    0xe0017f6c     0x64    movt r3, #57346 
    0xe0017f70     0x68    mov r2, #7
    0xe0017f74     0x6c    str r2, [r3, #24]
    0xe0017f78     0x70    mov r0, #3
    0xe0017f7c     0x74    add sp, sp, #64 
    0xe0017f80     0x78    pop {r4, lr}          ; stack access
    0xe0017f84     0x7c    add sp, sp, #8
    0xe0017f88     0x80    bx lr
    0xe0017f8c     0x84    movw r2, #13900 
    0xe0017f90     0x88    movt r2, #57347 
    0xe0017f94     0x8c    ldr r0, [r2]
    0xe0017f98     0x90    ldr r4, [r0, #8]
    0xe0017f9c     0x94    bic r3, r3, #15
    0xe0017fa0     0x98    ldr r3, [r3, #116] 
    0xe0017fa4     0x9c    cmp r4, r3
    0xe0017fa8     0xa0    bhi e001801c <decodeSetMCPriority+0x114>
    0xe0017fac     0xa4    mov r1, #2
    0xe0017fb0     0xa8    bl e0014ad8 <setThreadState>
    0xe0017fb4     0xac    mov ip, #0
    0xe0017fb8     0xb0    str ip, [sp, #56]     ; stack access
    0xe0017fbc     0xb4    str ip, [sp, #60]     ; stack access
    0xe0017fc0     0xb8    mov r3, #8
    0xe0017fc4     0xbc    str r3, [sp, #44]     ; stack access
    0xe0017fc8     0xc0    str ip, [sp, #40]     ; stack access
    0xe0017fcc     0xc4    add r2, sp, #32
    0xe0017fd0     0xc8    add r3, sp, #56 
    0xe0017fd4     0xcc    ldm r3, {r0, r1}      ; stack access
    0xe0017fd8     0xd0    stm r2, {r0, r1}      ; stack access
    0xe0017fdc     0xd4    str ip, [sp, #28]     ; stack access
    0xe0017fe0     0xd8    str ip, [sp, #24]     ; stack access
    0xe0017fe4     0xdc    add r2, sp, #16
    0xe0017fe8     0xe0    ldm r3, {r0, r1}      ; stack access
    0xe0017fec     0xe4    stm r2, {r0, r1}      ; stack access
    0xe0017ff0     0xe8    str ip, [sp, #12]     ; stack access
    0xe0017ff4     0xec    ldm r3, {r0, r1}      ; stack access
    0xe0017ff8     0xf0    stmib sp, {r0, r1}    ; stack access
    0xe0017ffc     0xf4    str ip, [sp]          ; stack access
    0xe0018000     0xf8    mov r3, r4
    0xe0018004     0xfc    mov r2, ip
    0xe0018008    0x100    mov r1, ip
    0xe001800c    0x104    ldr r0, [sp, #48]     ; stack access
    0xe0018010    0x108    bic r0, r0, #15
    0xe0018014    0x10c    bl e0017924 <invokeTCB_ThreadControl>
    0xe0018018    0x110    b e0017f7c <decodeSetMCPriority+0x74>
    0xe001801c    0x114    movw r2, #36896 
    0xe0018020    0x118    movt r2, #57346 
    0xe0018024    0x11c    mov r1, #4
    0xe0018028    0x120    str r1, [r2, #24]
    0xe001802c    0x124    mov r1, #0
    0xe0018030    0x128    str r1, [r2, #8]
    0xe0018034    0x12c    str r3, [r2, #12]
    0xe0018038    0x130    mov r0, #3
    0xe001803c    0x134    b e0017f7c <decodeSetMCPriority+0x74>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
78 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetMCPriority` has 122 nodes.

Section decodeSetPriority (191 of 293)
======================================

Deriving specifications
-----------------------

Section `decodeSetPriority` consists of 78 instructions.


Stack analysis
---------------

19 stack accesses found. Annotated code for `decodeSetPriority`:

    0xe0017dd0      0x0    sub sp, sp, #8
    0xe0017dd4      0x4    push {r4, lr}         ; stack access
    0xe0017dd8      0x8    sub sp, sp, #64 
    0xe0017ddc      0xc    add ip, sp, #48 
    0xe0017de0     0x10    stm ip, {r0, r1}      ; stack access
    0xe0017de4     0x14    str r3, [sp, #76]     ; stack access
    0xe0017de8     0x18    cmp r3, #0
    0xe0017dec     0x1c    cmpne r2, #0
    0xe0017df0     0x20    beq e0017e30 <decodeSetPriority+0x60>
    0xe0017df4     0x24    ldr r3, [r3]
    0xe0017df8     0x28    and r2, r3, #14
    0xe0017dfc     0x2c    cmp r2, #14
    0xe0017e00     0x30    andne r2, r3, #15
    0xe0017e04     0x34    uxtbeq r2, r3
    0xe0017e08     0x38    cmp r2, #12
    0xe0017e0c     0x3c    beq e0017e54 <decodeSetPriority+0x84>
    0xe0017e10     0x40    movw r3, #36896 
    0xe0017e14     0x44    movt r3, #57346 
    0xe0017e18     0x48    mov r2, #2
    0xe0017e1c     0x4c    str r2, [r3, #24]
    0xe0017e20     0x50    mov r2, #1
    0xe0017e24     0x54    str r2, [r3, #4]
    0xe0017e28     0x58    mov r0, #3
    0xe0017e2c     0x5c    b e0017e44 <decodeSetPriority+0x74>
    0xe0017e30     0x60    movw r3, #36896 
    0xe0017e34     0x64    movt r3, #57346 
    0xe0017e38     0x68    mov r2, #7
    0xe0017e3c     0x6c    str r2, [r3, #24]
    0xe0017e40     0x70    mov r0, #3
    0xe0017e44     0x74    add sp, sp, #64 
    0xe0017e48     0x78    pop {r4, lr}          ; stack access
    0xe0017e4c     0x7c    add sp, sp, #8
    0xe0017e50     0x80    bx lr
    0xe0017e54     0x84    movw r2, #13900 
    0xe0017e58     0x88    movt r2, #57347 
    0xe0017e5c     0x8c    ldr r0, [r2]
    0xe0017e60     0x90    ldr r4, [r0, #8]
    0xe0017e64     0x94    bic r3, r3, #15
    0xe0017e68     0x98    ldr r3, [r3, #116] 
    0xe0017e6c     0x9c    cmp r4, r3
    0xe0017e70     0xa0    bhi e0017ee4 <decodeSetPriority+0x114>
    0xe0017e74     0xa4    mov r1, #2
    0xe0017e78     0xa8    bl e0014ad8 <setThreadState>
    0xe0017e7c     0xac    mov ip, #0
    0xe0017e80     0xb0    str ip, [sp, #56]     ; stack access
    0xe0017e84     0xb4    str ip, [sp, #60]     ; stack access
    0xe0017e88     0xb8    mov r3, #1
    0xe0017e8c     0xbc    str r3, [sp, #44]     ; stack access
    0xe0017e90     0xc0    str ip, [sp, #40]     ; stack access
    0xe0017e94     0xc4    add r2, sp, #32
    0xe0017e98     0xc8    add r3, sp, #56 
    0xe0017e9c     0xcc    ldm r3, {r0, r1}      ; stack access
    0xe0017ea0     0xd0    stm r2, {r0, r1}      ; stack access
    0xe0017ea4     0xd4    str ip, [sp, #28]     ; stack access
    0xe0017ea8     0xd8    str ip, [sp, #24]     ; stack access
    0xe0017eac     0xdc    add r2, sp, #16
    0xe0017eb0     0xe0    ldm r3, {r0, r1}      ; stack access
    0xe0017eb4     0xe4    stm r2, {r0, r1}      ; stack access
    0xe0017eb8     0xe8    str ip, [sp, #12]     ; stack access
    0xe0017ebc     0xec    ldm r3, {r0, r1}      ; stack access
    0xe0017ec0     0xf0    stmib sp, {r0, r1}    ; stack access
    0xe0017ec4     0xf4    str r4, [sp]          ; stack access
    0xe0017ec8     0xf8    mov r3, ip
    0xe0017ecc     0xfc    mov r2, ip
    0xe0017ed0    0x100    mov r1, ip
    0xe0017ed4    0x104    ldr r0, [sp, #48]     ; stack access
    0xe0017ed8    0x108    bic r0, r0, #15
    0xe0017edc    0x10c    bl e0017924 <invokeTCB_ThreadControl>
    0xe0017ee0    0x110    b e0017e44 <decodeSetPriority+0x74>
    0xe0017ee4    0x114    movw r2, #36896 
    0xe0017ee8    0x118    movt r2, #57346 
    0xe0017eec    0x11c    mov r1, #4
    0xe0017ef0    0x120    str r1, [r2, #24]
    0xe0017ef4    0x124    mov r1, #0
    0xe0017ef8    0x128    str r1, [r2, #8]
    0xe0017efc    0x12c    str r3, [r2, #12]
    0xe0017f00    0x130    mov r0, #3
    0xe0017f04    0x134    b e0017e44 <decodeSetPriority+0x74>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
78 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetPriority` has 122 nodes.

Section decodeDomainInvocation (192 of 293)
===========================================

Deriving specifications
-----------------------

Section `decodeDomainInvocation` consists of 64 instructions.
 LDMIA (wb);14,6,5,4.+


Stack analysis
---------------

4 stack accesses found. Annotated code for `decodeDomainInvocation`:

    0xe0017804     0x0    sub sp, sp, #8
    0xe0017808     0x4    push {r4, r5, r6, lr}  ; stack access
    0xe001780c     0x8    add ip, sp, #12
    0xe0017810     0xc    stmib ip, {r2, r3}    ; stack access
    0xe0017814    0x10    cmp r0, #29
    0xe0017818    0x14    movwne r3, #36896 
    0xe001781c    0x18    movtne r3, #57346 
    0xe0017820    0x1c    movne r0, #3
    0xe0017824    0x20    strne r0, [r3, #24]
    0xe0017828    0x24    bne e001788c <decodeDomainInvocation+0x88>
    0xe001782c    0x28    cmp r1, #0
    0xe0017830    0x2c    beq e0017898 <decodeDomainInvocation+0x94>
    0xe0017834    0x30    movw r3, #13900 
    0xe0017838    0x34    movt r3, #57347 
    0xe001783c    0x38    ldr r0, [r3]
    0xe0017840    0x3c    ldr r4, [r0, #8]
    0xe0017844    0x40    cmp r4, #15
    0xe0017848    0x44    bhi e00178b0 <decodeDomainInvocation+0xac>
    0xe001784c    0x48    ldr r3, [sp, #16]     ; stack access
    0xe0017850    0x4c    cmp r3, #0
    0xe0017854    0x50    beq e00178d0 <decodeDomainInvocation+0xcc>
    0xe0017858    0x54    ldr r5, [r3]
    0xe001785c    0x58    and r3, r5, #14
    0xe0017860    0x5c    cmp r3, #14
    0xe0017864    0x60    andne r3, r5, #15
    0xe0017868    0x64    uxtbeq r3, r5
    0xe001786c    0x68    cmp r3, #12
    0xe0017870    0x6c    bne e00178e8 <decodeDomainInvocation+0xe4>
    0xe0017874    0x70    mov r1, #2
    0xe0017878    0x74    bl e0014ad8 <setThreadState>
    0xe001787c    0x78    mov r1, r4
    0xe0017880    0x7c    bic r0, r5, #15
    0xe0017884    0x80    bl e001545c <setDomain>
    0xe0017888    0x84    mov r0, #0
    0xe001788c    0x88    pop {r4, r5, r6, lr}  ; stack access
    0xe0017890    0x8c    add sp, sp, #8
    0xe0017894    0x90    bx lr
    0xe0017898    0x94    movw r3, #36896 
    0xe001789c    0x98    movt r3, #57346 
    0xe00178a0    0x9c    mov r2, #7
    0xe00178a4    0xa0    str r2, [r3, #24]
    0xe00178a8    0xa4    mov r0, #3
    0xe00178ac    0xa8    b e001788c <decodeDomainInvocation+0x88>
    0xe00178b0    0xac    movw r3, #36896 
    0xe00178b4    0xb0    movt r3, #57346 
    0xe00178b8    0xb4    mov r2, #1
    0xe00178bc    0xb8    str r2, [r3, #24]
    0xe00178c0    0xbc    mov r2, #0
    0xe00178c4    0xc0    str r2, [r3]
    0xe00178c8    0xc4    mov r0, #3
    0xe00178cc    0xc8    b e001788c <decodeDomainInvocation+0x88>
    0xe00178d0    0xcc    movw r3, #36896 
    0xe00178d4    0xd0    movt r3, #57346 
    0xe00178d8    0xd4    mov r2, #7
    0xe00178dc    0xd8    str r2, [r3, #24]
    0xe00178e0    0xdc    mov r0, #3
    0xe00178e4    0xe0    b e001788c <decodeDomainInvocation+0x88>
    0xe00178e8    0xe4    movw r3, #36896 
    0xe00178ec    0xe8    movt r3, #57346 
    0xe00178f0    0xec    mov r2, #1
    0xe00178f4    0xf0    str r2, [r3, #24]
    0xe00178f8    0xf4    str r2, [r3]
    0xe00178fc    0xf8    mov r0, #3
    0xe0017900    0xfc    b e001788c <decodeDomainInvocation+0x88>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
64 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeDomainInvocation` has 103 nodes.

Section handleFault (193 of 293)
================================

Deriving specifications
-----------------------

Section `handleFault` consists of 9 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `handleFault`:

    0xe001734c     0x0    push {r4, lr}         ; stack access
    0xe0017350     0x4    mov r4, r0
    0xe0017354     0x8    bl e0017240 <sendFaultIPC>
    0xe0017358     0xc    cmp r0, #0
    0xe001735c    0x10    popeq {r4, pc}        ; stack access
    0xe0017360    0x14    mov r1, #0
    0xe0017364    0x18    mov r0, r4
    0xe0017368    0x1c    bl e0014ad8 <setThreadState>
    0xe001736c    0x20    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleFault` has 16 nodes.

Section sendFaultIPC (194 of 293)
=================================

Deriving specifications
-----------------------

Section `sendFaultIPC` consists of 67 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `sendFaultIPC`:

    0xe0017240      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0017244      0x4    sub sp, sp, #32
    0xe0017248      0x8    mov r5, r0
    0xe001724c      0xc    movw r3, #36884 
    0xe0017250     0x10    movt r3, #57346 
    0xe0017254     0x14    ldr r7, [r3]
    0xe0017258     0x18    ldr r8, [r3, #4]
    0xe001725c     0x1c    ldr r6, [r0, #128] 
    0xe0017260     0x20    mov r2, r6
    0xe0017264     0x24    mov r1, r0
    0xe0017268     0x28    add r0, sp, #20
    0xe001726c     0x2c    bl e0012c1c <lookupCap>
    0xe0017270     0x30    ldr r4, [sp, #20]     ; stack access
    0xe0017274     0x34    cmp r4, #0
    0xe0017278     0x38    bne e00172cc <sendFaultIPC+0x8c>
    0xe001727c     0x3c    ldr r2, [sp, #24]     ; stack access
    0xe0017280     0x40    and r3, r2, #14
    0xe0017284     0x44    cmp r3, #14
    0xe0017288     0x48    andne r3, r2, #15
    0xe001728c     0x4c    uxtbeq r3, r2
    0xe0017290     0x50    cmp r3, #4
    0xe0017294     0x54    beq e00172e4 <sendFaultIPC+0xa4>
    0xe0017298     0x58    movw r3, #32768 
    0xe001729c     0x5c    movt r3, #57346 
    0xe00172a0     0x60    mov r4, #1
    0xe00172a4     0x64    str r4, [r3]
    0xe00172a8     0x68    str r6, [r3, #4]
    0xe00172ac     0x6c    movw r3, #36884 
    0xe00172b0     0x70    movt r3, #57346 
    0xe00172b4     0x74    str r4, [r3]
    0xe00172b8     0x78    mov r2, #0
    0xe00172bc     0x7c    str r2, [r3, #4]
    0xe00172c0     0x80    mov r0, r4
    0xe00172c4     0x84    add sp, sp, #32
    0xe00172c8     0x88    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe00172cc     0x8c    movw r3, #32768 
    0xe00172d0     0x90    movt r3, #57346 
    0xe00172d4     0x94    mov r4, #1
    0xe00172d8     0x98    str r4, [r3]
    0xe00172dc     0x9c    str r6, [r3, #4]
    0xe00172e0     0xa0    b e00172c0 <sendFaultIPC+0x80>
    0xe00172e4     0xa4    ldr ip, [sp, #28]     ; stack access
    0xe00172e8     0xa8    tst ip, #1
    0xe00172ec     0xac    beq e0017298 <sendFaultIPC+0x58>
    0xe00172f0     0xb0    lsr r3, ip, #2
    0xe00172f4     0xb4    orr r1, r3, ip, lsr #3
    0xe00172f8     0xb8    tst r1, #1
    0xe00172fc     0xbc    beq e0017298 <sendFaultIPC+0x58>
    0xe0017300     0xc0    movw r1, #32768 
    0xe0017304     0xc4    movt r1, #57346 
    0xe0017308     0xc8    add lr, r5, #96 
    0xe001730c     0xcc    ldm r1, {r0, r1}
    0xe0017310     0xd0    stm lr, {r0, r1}
    0xe0017314     0xd4    and r0, r0, #15
    0xe0017318     0xd8    cmp r0, #1
    0xe001731c     0xdc    streq r7, [r5, #104] 
    0xe0017320     0xe0    streq r8, [r5, #108] 
    0xe0017324     0xe4    bic ip, ip, #15
    0xe0017328     0xe8    str ip, [sp, #8]      ; stack access
    0xe001732c     0xec    str r5, [sp, #4]      ; stack access
    0xe0017330     0xf0    mov r0, #1
    0xe0017334     0xf4    str r0, [sp]          ; stack access
    0xe0017338     0xf8    and r3, r3, r0
    0xe001733c     0xfc    lsr r2, r2, #4
    0xe0017340    0x100    mov r1, r0
    0xe0017344    0x104    bl e0017070 <sendIPC>
    0xe0017348    0x108    b e00172c0 <sendFaultIPC+0x80>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
67 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendFaultIPC` has 106 nodes.

Section handleReply (195 of 293)
================================

Deriving specifications
-----------------------

Section `handleReply` consists of 23 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleReply`:

    0xe0016fec     0x0    movw r3, #13900 
    0xe0016ff0     0x4    movt r3, #57347 
    0xe0016ff4     0x8    ldr r0, [r3]
    0xe0016ff8     0xc    bic r3, r0, #508 
    0xe0016ffc    0x10    bic r3, r3, #3
    0xe0017000    0x14    add r2, r3, #48 
    0xe0017004    0x18    ldr r1, [r3, #48] 
    0xe0017008    0x1c    and r3, r1, #14
    0xe001700c    0x20    cmp r3, #14
    0xe0017010    0x24    andne r3, r1, #15
    0xe0017014    0x28    uxtbeq r3, r1
    0xe0017018    0x2c    cmp r3, #0
    0xe001701c    0x30    bxeq lr
    0xe0017020    0x34    push {r4, lr}         ; stack access
    0xe0017024    0x38    cmp r3, #8
    0xe0017028    0x3c    bne e0017044 <handleReply+0x58>
    0xe001702c    0x40    tst r1, #16
    0xe0017030    0x44    bne e0017044 <handleReply+0x58>
    0xe0017034    0x48    ubfx r3, r1, #5, #1
    0xe0017038    0x4c    bic r1, r1, #63 
    0xe001703c    0x50    bl e0016f48 <doReplyTransfer>
    0xe0017040    0x54    pop {r4, pc}          ; stack access
    0xe0017044    0x58    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleReply` has 40 nodes.

Section setupCallerCap (196 of 293)
===================================

Deriving specifications
-----------------------

Section `setupCallerCap` consists of 26 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `setupCallerCap`:

    0xe0016af4     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0016af8     0x4    sub sp, sp, #8
    0xe0016afc     0x8    mov r5, r0
    0xe0016b00     0xc    mov r6, r1
    0xe0016b04    0x10    mov r4, r2
    0xe0016b08    0x14    mov r1, #5
    0xe0016b0c    0x18    bl e0014ad8 <setThreadState>
    0xe0016b10    0x1c    lsl r4, r4, #5
    0xe0016b14    0x20    and r4, r4, #32
    0xe0016b18    0x24    orr r4, r4, #8
    0xe0016b1c    0x28    bic r3, r5, #63 
    0xe0016b20    0x2c    orr r4, r4, r3
    0xe0016b24    0x30    str r4, [sp]          ; stack access
    0xe0016b28    0x34    mov r3, #0
    0xe0016b2c    0x38    str r3, [sp, #4]      ; stack access
    0xe0016b30    0x3c    bic r3, r6, #508 
    0xe0016b34    0x40    bic r3, r3, #3
    0xe0016b38    0x44    bic r2, r5, #508 
    0xe0016b3c    0x48    bic r2, r2, #3
    0xe0016b40    0x4c    add r3, r3, #48 
    0xe0016b44    0x50    add r2, r2, #32
    0xe0016b48    0x54    add r1, sp, #8
    0xe0016b4c    0x58    ldmdb r1, {r0, r1}    ; stack access
    0xe0016b50    0x5c    bl e0012fa8 <cteInsert>
    0xe0016b54    0x60    add sp, sp, #8
    0xe0016b58    0x64    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setupCallerCap` has 33 nodes.

Section invokeIRQHandler_SetIRQHandler (197 of 293)
===================================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_SetIRQHandler` consists of 16 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `invokeIRQHandler_SetIRQHandler`:

    0xe0016560     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0016564     0x4    sub sp, sp, #8
    0xe0016568     0x8    mov r5, sp
    0xe001656c     0xc    stm r5, {r1, r2}      ; stack access
    0xe0016570    0x10    mov r6, r3
    0xe0016574    0x14    movw r3, #8192 
    0xe0016578    0x18    movt r3, #57347 
    0xe001657c    0x1c    add r4, r3, r0, lsl #4
    0xe0016580    0x20    mov r0, r4
    0xe0016584    0x24    bl e00164f8 <cteDeleteOne>
    0xe0016588    0x28    mov r3, r4
    0xe001658c    0x2c    mov r2, r6
    0xe0016590    0x30    ldm r5, {r0, r1}      ; stack access
    0xe0016594    0x34    bl e0012fa8 <cteInsert>
    0xe0016598    0x38    add sp, sp, #8
    0xe001659c    0x3c    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_SetIRQHandler` has 22 nodes.

Section cancelSignal (198 of 293)
=================================

Deriving specifications
-----------------------

Section `cancelSignal` consists of 37 instructions.
 BICEQ (imm)....+++


Stack analysis
---------------

9 stack accesses found. Annotated code for `cancelSignal`:

    0xe00156c8     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe00156cc     0x4    sub sp, sp, #20
    0xe00156d0     0x8    mov r5, r0
    0xe00156d4     0xc    mov r4, r1
    0xe00156d8    0x10    ldr r3, [r1]
    0xe00156dc    0x14    bic r3, r3, #15
    0xe00156e0    0x18    ldr r2, [r1, #4]
    0xe00156e4    0x1c    bic r2, r2, #15
    0xe00156e8    0x20    str r2, [sp, #8]      ; stack access
    0xe00156ec    0x24    str r3, [sp, #12]     ; stack access
    0xe00156f0    0x28    mov r7, sp
    0xe00156f4    0x2c    add r6, sp, #8
    0xe00156f8    0x30    ldm r6, {r2, r3}      ; stack access
    0xe00156fc    0x34    mov r1, r0
    0xe0015700    0x38    mov r0, r7
    0xe0015704    0x3c    bl e0015538 <tcbEPDequeue>
    0xe0015708    0x40    ldm r7, {r0, r1}      ; stack access
    0xe001570c    0x44    stm r6, {r0, r1}      ; stack access
    0xe0015710    0x48    ldr r1, [sp, #8]      ; stack access
    0xe0015714    0x4c    ldr r3, [r4, #4]
    0xe0015718    0x50    and r3, r3, #15
    0xe001571c    0x54    bic r2, r1, #15
    0xe0015720    0x58    orr r3, r3, r2
    0xe0015724    0x5c    str r3, [r4, #4]
    0xe0015728    0x60    ldr r3, [r4]
    0xe001572c    0x64    and r3, r3, #15
    0xe0015730    0x68    ldr r2, [sp, #12]     ; stack access
    0xe0015734    0x6c    bic r2, r2, #15
    0xe0015738    0x70    orr r3, r3, r2
    0xe001573c    0x74    cmp r1, #0
    0xe0015740    0x78    biceq r3, r3, #3
    0xe0015744    0x7c    str r3, [r4]
    0xe0015748    0x80    mov r1, #0
    0xe001574c    0x84    mov r0, r5
    0xe0015750    0x88    bl e0014ad8 <setThreadState>
    0xe0015754    0x8c    add sp, sp, #20
    0xe0015758    0x90    pop {r4, r5, r6, r7, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
37 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelSignal` has 56 nodes.

Section chooseThread (199 of 293)
=================================

Deriving specifications
-----------------------

Section `chooseThread` consists of 27 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `chooseThread`:

    0xe00151f0     0x0    push {r4, lr}         ; stack access
    0xe00151f4     0x4    movw r3, #12288 
    0xe00151f8     0x8    movt r3, #57347 
    0xe00151fc     0xc    ldr r1, [r3]
    0xe0015200    0x10    movw r2, #12808 
    0xe0015204    0x14    movt r2, #57347 
    0xe0015208    0x18    ldr r2, [r2, r1, lsl #2]
    0xe001520c    0x1c    cmp r2, #0
    0xe0015210    0x20    beq e0015254 <chooseThread+0x64>
    0xe0015214    0x24    clz r2, r2
    0xe0015218    0x28    rsb r2, r2, #31
    0xe001521c    0x2c    movw r3, #12292 
    0xe0015220    0x30    movt r3, #57347 
    0xe0015224    0x34    rsb r0, r2, #7
    0xe0015228    0x38    add r0, r0, r1, lsl #3
    0xe001522c    0x3c    ldr r3, [r3, r0, lsl #2]
    0xe0015230    0x40    clz r3, r3
    0xe0015234    0x44    movw r0, #38092 
    0xe0015238    0x48    movt r0, #57346 
    0xe001523c    0x4c    rsb r3, r3, #31
    0xe0015240    0x50    orr r3, r3, r2, lsl #5
    0xe0015244    0x54    add r3, r3, r1, lsl #8
    0xe0015248    0x58    ldr r0, [r0, r3, lsl #3]
    0xe001524c    0x5c    bl e00151cc <switchToThread>
    0xe0015250    0x60    pop {r4, pc}          ; stack access
    0xe0015254    0x64    bl e0012f20 <switchToIdleThread>
    0xe0015258    0x68    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `chooseThread` has 38 nodes.

Section switchToThread (200 of 293)
===================================

Deriving specifications
-----------------------

Section `switchToThread` consists of 9 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `switchToThread`:

    0xe00151cc     0x0    push {r4, lr}         ; stack access
    0xe00151d0     0x4    mov r4, r0
    0xe00151d4     0x8    bl e0011194 <Arch_switchToThread>
    0xe00151d8     0xc    mov r0, r4
    0xe00151dc    0x10    bl e00150f4 <tcbSchedDequeue>
    0xe00151e0    0x14    movw r3, #13900 
    0xe00151e4    0x18    movt r3, #57347 
    0xe00151e8    0x1c    str r4, [r3]
    0xe00151ec    0x20    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `switchToThread` has 14 nodes.

Section timerTick (201 of 293)
==============================

Deriving specifications
-----------------------

Section `timerTick` consists of 27 instructions.
 LDMIANE (wb);15,4..++


Stack analysis
---------------

3 stack accesses found. Annotated code for `timerTick`:

    0xe0015088     0x0    push {r4, lr}         ; stack access
    0xe001508c     0x4    movw r3, #13900 
    0xe0015090     0x8    movt r3, #57347 
    0xe0015094     0xc    ldr r0, [r3]
    0xe0015098    0x10    ldr r3, [r0, #80] 
    0xe001509c    0x14    and r3, r3, #15
    0xe00150a0    0x18    cmp r3, #1
    0xe00150a4    0x1c    bne e00150bc <timerTick+0x34>
    0xe00150a8    0x20    ldr r3, [r0, #124] 
    0xe00150ac    0x24    cmp r3, #1
    0xe00150b0    0x28    bls e00150e0 <timerTick+0x58>
    0xe00150b4    0x2c    sub r3, r3, #1
    0xe00150b8    0x30    str r3, [r0, #124] 
    0xe00150bc    0x34    movw r2, #5324 
    0xe00150c0    0x38    movt r2, #57347 
    0xe00150c4    0x3c    ldr r3, [r2]
    0xe00150c8    0x40    sub r3, r3, #1
    0xe00150cc    0x44    str r3, [r2]
    0xe00150d0    0x48    cmp r3, #0
    0xe00150d4    0x4c    popne {r4, pc}        ; stack access
    0xe00150d8    0x50    bl e0014a4c <rescheduleRequired>
    0xe00150dc    0x54    pop {r4, pc}          ; stack access
    0xe00150e0    0x58    mov r3, #5
    0xe00150e4    0x5c    str r3, [r0, #124] 
    0xe00150e8    0x60    bl e0014fe4 <tcbSchedAppend>
    0xe00150ec    0x64    bl e0014a4c <rescheduleRequired>
    0xe00150f0    0x68    b e00150bc <timerTick+0x34>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `timerTick` has 46 nodes.

Section possibleSwitchTo (202 of 293)
=====================================

Deriving specifications
-----------------------

Section `possibleSwitchTo` consists of 23 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `possibleSwitchTo`:

    0xe0014ed4     0x0    push {r4, lr}         ; stack access
    0xe0014ed8     0x4    mov r4, r0
    0xe0014edc     0x8    movw r3, #12288 
    0xe0014ee0     0xc    movt r3, #57347 
    0xe0014ee4    0x10    ldr r2, [r0, #112] 
    0xe0014ee8    0x14    ldr r3, [r3]
    0xe0014eec    0x18    cmp r2, r3
    0xe0014ef0    0x1c    bne e0014f18 <possibleSwitchTo+0x44>
    0xe0014ef4    0x20    movw r3, #36892 
    0xe0014ef8    0x24    movt r3, #57346 
    0xe0014efc    0x28    ldr r3, [r3]
    0xe0014f00    0x2c    cmp r3, #0
    0xe0014f04    0x30    bne e0014f20 <possibleSwitchTo+0x4c>
    0xe0014f08    0x34    movw r3, #36892 
    0xe0014f0c    0x38    movt r3, #57346 
    0xe0014f10    0x3c    str r0, [r3]
    0xe0014f14    0x40    pop {r4, pc}          ; stack access
    0xe0014f18    0x44    bl e00149a8 <tcbSchedEnqueue>
    0xe0014f1c    0x48    pop {r4, pc}          ; stack access
    0xe0014f20    0x4c    bl e0014a4c <rescheduleRequired>
    0xe0014f24    0x50    mov r0, r4
    0xe0014f28    0x54    bl e00149a8 <tcbSchedEnqueue>
    0xe0014f2c    0x58    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `possibleSwitchTo` has 38 nodes.

Section activateThread (203 of 293)
===================================

Deriving specifications
-----------------------

Section `activateThread` consists of 18 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `activateThread`:

    0xe0014c6c     0x0    push {r4, lr}         ; stack access
    0xe0014c70     0x4    movw r3, #13900 
    0xe0014c74     0x8    movt r3, #57347 
    0xe0014c78     0xc    ldr r0, [r3]
    0xe0014c7c    0x10    ldr r3, [r0, #80] 
    0xe0014c80    0x14    and r3, r3, #15
    0xe0014c84    0x18    cmp r3, #2
    0xe0014c88    0x1c    beq e0014ca0 <activateThread+0x34>
    0xe0014c8c    0x20    cmp r3, #7
    0xe0014c90    0x24    popeq {r4, pc}        ; stack access
    0xe0014c94    0x28    cmp r3, #1
    0xe0014c98    0x2c    popeq {r4, pc}        ; stack access
    0xe0014c9c    0x30    bl e0010904 <halt>
    0xe0014ca0    0x34    ldr r3, [r0, #68] 
    0xe0014ca4    0x38    str r3, [r0, #60] 
    0xe0014ca8    0x3c    mov r1, #1
    0xe0014cac    0x40    bl e0014ad8 <setThreadState>
    0xe0014cb0    0x44    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `activateThread` has 34 nodes.

Section createObject (204 of 293)
=================================

Deriving specifications
-----------------------

Section `createObject` consists of 64 instructions.
Switch found.


Stack analysis
---------------

Section `createObject` expects pointer to stack in r0.
15 stack accesses found. Annotated code for `createObject`:

    0xe001480c     0x0    push {r4, lr}         ; stack access
    0xe0014810     0x4    sub sp, sp, #8
    0xe0014814     0x8    mov r4, r0
    0xe0014818     0xc    cmp r1, #4
    0xe001481c    0x10    bhi e0014840 <createObject+0x34>
    0xe0014820    0x14    cmp r1, #4
    0xe0014824    0x18    ldrls pc, [pc, r1, lsl #2]
    0xe0014828    0x1c    b e0014908 <createObject+0xfc>
    0xe001482c    0x20    .word 0xe00148e0
    0xe0014830    0x24    .word 0xe001485c
    0xe0014834    0x28    .word 0xe0014898
    0xe0014838    0x2c    .word 0xe00148ac
    0xe001483c    0x30    .word 0xe00148c4
    0xe0014840    0x34    ldr r0, [sp, #16]     ; stack access
    0xe0014844    0x38    str r0, [sp]          ; stack access
    0xe0014848    0x3c    mov r0, r4
    0xe001484c    0x40    bl e00122bc <Arch_createObject>
    0xe0014850    0x44    mov r0, r4
    0xe0014854    0x48    add sp, sp, #8
    0xe0014858    0x4c    pop {r4, pc}          ; stack access
    0xe001485c    0x50    mov r3, #336 
    0xe0014860    0x54    str r3, [r2, #320] 
    0xe0014864    0x58    mov r3, #5
    0xe0014868    0x5c    str r3, [r2, #380] 
    0xe001486c    0x60    movw r3, #12288 
    0xe0014870    0x64    movt r3, #57347 
    0xe0014874    0x68    ldr r3, [r3]
    0xe0014878    0x6c    str r3, [r2, #368] 
    0xe001487c    0x70    add r2, r2, #256 
    0xe0014880    0x74    bic r2, r2, #15
    0xe0014884    0x78    orr r2, r2, #12
    0xe0014888    0x7c    str r2, [r0]          ; stack access
    0xe001488c    0x80    mov r3, #0
    0xe0014890    0x84    str r3, [r0, #4]      ; stack access
    0xe0014894    0x88    b e0014850 <createObject+0x44>
    0xe0014898    0x8c    mov r3, #4
    0xe001489c    0x90    str r3, [r0]          ; stack access
    0xe00148a0    0x94    orr r2, r2, #15
    0xe00148a4    0x98    str r2, [r0, #4]      ; stack access
    0xe00148a8    0x9c    b e0014850 <createObject+0x44>
    0xe00148ac    0xa0    bic r2, r2, #15
    0xe00148b0    0xa4    orr r2, r2, #6
    0xe00148b4    0xa8    str r2, [r0]          ; stack access
    0xe00148b8    0xac    mov r3, #3
    0xe00148bc    0xb0    str r3, [r0, #4]      ; stack access
    0xe00148c0    0xb4    b e0014850 <createObject+0x44>
    0xe00148c4    0xb8    bic r2, r2, #31
    0xe00148c8    0xbc    orr r2, r2, #10
    0xe00148cc    0xc0    str r2, [r0]          ; stack access
    0xe00148d0    0xc4    lsl r3, r3, #18
    0xe00148d4    0xc8    and r3, r3, #8126464 
    0xe00148d8    0xcc    str r3, [r0, #4]      ; stack access
    0xe00148dc    0xd0    b e0014850 <createObject+0x44>
    0xe00148e0    0xd4    bic r2, r2, #15
    0xe00148e4    0xd8    orr r2, r2, #2
    0xe00148e8    0xdc    str r2, [r0]          ; stack access
    0xe00148ec    0xe0    ldr r2, [sp, #16]     ; stack access
    0xe00148f0    0xe4    adds r2, r2, #0
    0xe00148f4    0xe8    movne r2, #1
    0xe00148f8    0xec    and r3, r3, #31
    0xe00148fc    0xf0    orr r3, r3, r2, lsl #5
    0xe0014900    0xf4    str r3, [r0, #4]      ; stack access
    0xe0014904    0xf8    b e0014850 <createObject+0x44>
    0xe0014908    0xfc    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
59 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `createObject` has 100 nodes.

Section maskCapRights (205 of 293)
==================================

Deriving specifications
-----------------------

Section `maskCapRights` consists of 127 instructions.
Switch found.


Stack analysis
---------------

Section `maskCapRights` expects pointer to stack in r0.
14 stack accesses found. Annotated code for `maskCapRights`:

    0xe0014610      0x0    push {r4, lr}         ; stack access
    0xe0014614      0x4    sub sp, sp, #8
    0xe0014618      0x8    mov r4, r0
    0xe001461c      0xc    add r0, sp, #8
    0xe0014620     0x10    stmdb r0, {r2, r3}    ; stack access
    0xe0014624     0x14    ldr r3, [sp]          ; stack access
    0xe0014628     0x18    and r2, r3, #14
    0xe001462c     0x1c    cmp r2, #14
    0xe0014630     0x20    andne r2, r3, #15
    0xe0014634     0x24    uxtbeq r2, r3
    0xe0014638     0x28    tst r2, #1
    0xe001463c     0x2c    bne e001474c <maskCapRights+0x13c>
    0xe0014640     0x30    ldr r0, [sp, #4]      ; stack access
    0xe0014644     0x34    cmp r2, #62 
    0xe0014648     0x38    ldrls pc, [pc, r2, lsl #2]
    0xe001464c     0x3c    b e0014808 <maskCapRights+0x1f8>
    0xe0014650     0x40    .word 0xe0014768
    0xe0014654     0x44    .word 0xe0014808
    0xe0014658     0x48    .word 0xe0014768
    0xe001465c     0x4c    .word 0xe0014808
    0xe0014660     0x50    .word 0xe0014778
    0xe0014664     0x54    .word 0xe0014808
    0xe0014668     0x58    .word 0xe00147bc
    0xe001466c     0x5c    .word 0xe0014808
    0xe0014670     0x60    .word 0xe00147e4
    0xe0014674     0x64    .word 0xe0014808
    0xe0014678     0x68    .word 0xe0014768
    0xe001467c     0x6c    .word 0xe0014808
    0xe0014680     0x70    .word 0xe0014768
    0xe0014684     0x74    .word 0xe0014808
    0xe0014688     0x78    .word 0xe0014768
    0xe001468c     0x7c    .word 0xe0014808
    0xe0014690     0x80    .word 0xe0014808
    0xe0014694     0x84    .word 0xe0014808
    0xe0014698     0x88    .word 0xe0014808
    0xe001469c     0x8c    .word 0xe0014808
    0xe00146a0     0x90    .word 0xe0014808
    0xe00146a4     0x94    .word 0xe0014808
    0xe00146a8     0x98    .word 0xe0014808
    0xe00146ac     0x9c    .word 0xe0014808
    0xe00146b0     0xa0    .word 0xe0014808
    0xe00146b4     0xa4    .word 0xe0014808
    0xe00146b8     0xa8    .word 0xe0014808
    0xe00146bc     0xac    .word 0xe0014808
    0xe00146c0     0xb0    .word 0xe0014808
    0xe00146c4     0xb4    .word 0xe0014808
    0xe00146c8     0xb8    .word 0xe0014768
    0xe00146cc     0xbc    .word 0xe0014808
    0xe00146d0     0xc0    .word 0xe0014808
    0xe00146d4     0xc4    .word 0xe0014808
    0xe00146d8     0xc8    .word 0xe0014808
    0xe00146dc     0xcc    .word 0xe0014808
    0xe00146e0     0xd0    .word 0xe0014808
    0xe00146e4     0xd4    .word 0xe0014808
    0xe00146e8     0xd8    .word 0xe0014808
    0xe00146ec     0xdc    .word 0xe0014808
    0xe00146f0     0xe0    .word 0xe0014808
    0xe00146f4     0xe4    .word 0xe0014808
    0xe00146f8     0xe8    .word 0xe0014808
    0xe00146fc     0xec    .word 0xe0014808
    0xe0014700     0xf0    .word 0xe0014808
    0xe0014704     0xf4    .word 0xe0014808
    0xe0014708     0xf8    .word 0xe0014768
    0xe001470c     0xfc    .word 0xe0014808
    0xe0014710    0x100    .word 0xe0014808
    0xe0014714    0x104    .word 0xe0014808
    0xe0014718    0x108    .word 0xe0014808
    0xe001471c    0x10c    .word 0xe0014808
    0xe0014720    0x110    .word 0xe0014808
    0xe0014724    0x114    .word 0xe0014808
    0xe0014728    0x118    .word 0xe0014808
    0xe001472c    0x11c    .word 0xe0014808
    0xe0014730    0x120    .word 0xe0014808
    0xe0014734    0x124    .word 0xe0014808
    0xe0014738    0x128    .word 0xe0014808
    0xe001473c    0x12c    .word 0xe0014808
    0xe0014740    0x130    .word 0xe0014808
    0xe0014744    0x134    .word 0xe0014808
    0xe0014748    0x138    .word 0xe0014768
    0xe001474c    0x13c    add r3, sp, #8
    0xe0014750    0x140    ldmdb r3, {r2, r3}    ; stack access
    0xe0014754    0x144    mov r0, r4
    0xe0014758    0x148    bl e0011588 <Arch_maskCapRights>
    0xe001475c    0x14c    mov r0, r4
    0xe0014760    0x150    add sp, sp, #8
    0xe0014764    0x154    pop {r4, pc}          ; stack access
    0xe0014768    0x158    add r3, sp, #8
    0xe001476c    0x15c    ldmdb r3, {r0, r1}    ; stack access
    0xe0014770    0x160    stm r4, {r0, r1}      ; stack access
    0xe0014774    0x164    b e001475c <maskCapRights+0x14c>
    0xe0014778    0x168    str r3, [r4]          ; stack access
    0xe001477c    0x16c    and r3, r1, r0
    0xe0014780    0x170    and r3, r3, #2
    0xe0014784    0x174    mvn r2, r1, lsl #31
    0xe0014788    0x178    mvn r2, r2, lsr #31
    0xe001478c    0x17c    bic ip, r0, #2
    0xe0014790    0x180    and r2, r2, ip
    0xe0014794    0x184    orr r3, r3, r2
    0xe0014798    0x188    and r2, r1, r0
    0xe001479c    0x18c    and r2, r2, #4
    0xe00147a0    0x190    bic r3, r3, #12
    0xe00147a4    0x194    orr r3, r3, r2
    0xe00147a8    0x198    and r1, r1, r0
    0xe00147ac    0x19c    and r1, r1, #8
    0xe00147b0    0x1a0    orr r1, r3, r1
    0xe00147b4    0x1a4    str r1, [r4, #4]      ; stack access
    0xe00147b8    0x1a8    b e001475c <maskCapRights+0x14c>
    0xe00147bc    0x1ac    str r3, [r4]          ; stack access
    0xe00147c0    0x1b0    and r3, r1, r0
    0xe00147c4    0x1b4    and r3, r3, #2
    0xe00147c8    0x1b8    mvn r1, r1, lsl #31
    0xe00147cc    0x1bc    mvn r1, r1, lsr #31
    0xe00147d0    0x1c0    bic r0, r0, #2
    0xe00147d4    0x1c4    and r1, r1, r0
    0xe00147d8    0x1c8    orr r1, r3, r1
    0xe00147dc    0x1cc    str r1, [r4, #4]      ; stack access
    0xe00147e0    0x1d0    b e001475c <maskCapRights+0x14c>
    0xe00147e4    0x1d4    lsr r2, r3, #5
    0xe00147e8    0x1d8    and r1, r2, r1, lsr #2
    0xe00147ec    0x1dc    lsl r1, r1, #5
    0xe00147f0    0x1e0    and r1, r1, #32
    0xe00147f4    0x1e4    bic r3, r3, #32
    0xe00147f8    0x1e8    orr r3, r1, r3
    0xe00147fc    0x1ec    str r3, [r4]          ; stack access
    0xe0014800    0x1f0    str r0, [r4, #4]      ; stack access
    0xe0014804    0x1f4    b e001475c <maskCapRights+0x14c>
    0xe0014808    0x1f8    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
64 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maskCapRights` has 276 nodes.

Section sameObjectAs (206 of 293)
=================================

Deriving specifications
-----------------------

Section `sameObjectAs` consists of 45 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `sameObjectAs`:

    0xe0014394     0x0    push {lr}             ; stack access
    0xe0014398     0x4    sub sp, sp, #20
    0xe001439c     0x8    add ip, sp, #16
    0xe00143a0     0xc    stmdb ip, {r0, r1}    ; stack access
    0xe00143a4    0x10    mov r1, sp
    0xe00143a8    0x14    stm r1, {r2, r3}      ; stack access
    0xe00143ac    0x18    ldr r3, [sp, #8]      ; stack access
    0xe00143b0    0x1c    and r2, r3, #14
    0xe00143b4    0x20    cmp r2, #14
    0xe00143b8    0x24    andne r3, r3, #15
    0xe00143bc    0x28    uxtbeq r3, r3
    0xe00143c0    0x2c    cmp r3, #2
    0xe00143c4    0x30    moveq r0, #0
    0xe00143c8    0x34    beq e001440c <sameObjectAs+0x78>
    0xe00143cc    0x38    ldr r2, [sp]          ; stack access
    0xe00143d0    0x3c    cmp r3, #14
    0xe00143d4    0x40    beq e0014414 <sameObjectAs+0x80>
    0xe00143d8    0x44    tst r3, #1
    0xe00143dc    0x48    beq e00143f8 <sameObjectAs+0x64>
    0xe00143e0    0x4c    and r3, r2, #14
    0xe00143e4    0x50    cmp r3, #14
    0xe00143e8    0x54    andne r2, r2, #15
    0xe00143ec    0x58    uxtbeq r2, r2
    0xe00143f0    0x5c    tst r2, #1
    0xe00143f4    0x60    bne e0014434 <sameObjectAs+0xa0>
    0xe00143f8    0x64    mov r3, sp
    0xe00143fc    0x68    ldm r3, {r2, r3}      ; stack access
    0xe0014400    0x6c    add r1, sp, #16
    0xe0014404    0x70    ldmdb r1, {r0, r1}    ; stack access
    0xe0014408    0x74    bl e00138ec <sameRegionAs>
    0xe001440c    0x78    add sp, sp, #20
    0xe0014410    0x7c    pop {pc}              ; stack access
    0xe0014414    0x80    and r3, r2, #14
    0xe0014418    0x84    cmp r3, #14
    0xe001441c    0x88    andne r2, r2, #15
    0xe0014420    0x8c    uxtbeq r2, r2
    0xe0014424    0x90    cmp r2, #30
    0xe0014428    0x94    bne e00143f8 <sameObjectAs+0x64>
    0xe001442c    0x98    mov r0, #0
    0xe0014430    0x9c    b e001440c <sameObjectAs+0x78>
    0xe0014434    0xa0    ldm r1, {r2, r3}      ; stack access
    0xe0014438    0xa4    add r1, sp, #16
    0xe001443c    0xa8    ldmdb r1, {r0, r1}    ; stack access
    0xe0014440    0xac    bl e001192c <Arch_sameObjectAs>
    0xe0014444    0xb0    b e001440c <sameObjectAs+0x78>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
45 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sameObjectAs` has 81 nodes.

Section deriveCap (207 of 293)
==============================

Deriving specifications
-----------------------

Section `deriveCap` consists of 44 instructions.


Stack analysis
---------------

Section `deriveCap` expects pointer to stack in r0.
9 stack accesses found. Annotated code for `deriveCap`:

    0xe00142e4     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00142e8     0x4    sub sp, sp, #8
    0xe00142ec     0x8    mov r4, r0
    0xe00142f0     0xc    add r0, sp, #8
    0xe00142f4    0x10    stmdb r0, {r2, r3}    ; stack access
    0xe00142f8    0x14    ldr r5, [sp]          ; stack access
    0xe00142fc    0x18    and r3, r5, #14
    0xe0014300    0x1c    cmp r3, #14
    0xe0014304    0x20    andne r3, r5, #15
    0xe0014308    0x24    uxtbeq r3, r5
    0xe001430c    0x28    tst r3, #1
    0xe0014310    0x2c    bne e0014344 <deriveCap+0x60>
    0xe0014314    0x30    ldr r6, [sp, #4]      ; stack access
    0xe0014318    0x34    cmp r3, #8
    0xe001431c    0x38    beq e0014384 <deriveCap+0xa0>
    0xe0014320    0x3c    bhi e0014358 <deriveCap+0x74>
    0xe0014324    0x40    cmp r3, #2
    0xe0014328    0x44    bne e0014368 <deriveCap+0x84>
    0xe001432c    0x48    mov r0, r1
    0xe0014330    0x4c    bl e00142a0 <ensureNoChildren>
    0xe0014334    0x50    cmp r0, #0
    0xe0014338    0x54    movne r6, #0
    0xe001433c    0x58    movne r5, r6
    0xe0014340    0x5c    b e001436c <deriveCap+0x88>
    0xe0014344    0x60    add r3, sp, #8
    0xe0014348    0x64    ldmdb r3, {r2, r3}    ; stack access
    0xe001434c    0x68    mov r0, r4
    0xe0014350    0x6c    bl e0011440 <Arch_deriveCap>
    0xe0014354    0x70    b e0014378 <deriveCap+0x94>
    0xe0014358    0x74    cmp r3, #14
    0xe001435c    0x78    beq e0014384 <deriveCap+0xa0>
    0xe0014360    0x7c    cmp r3, #46 
    0xe0014364    0x80    beq e0014384 <deriveCap+0xa0>
    0xe0014368    0x84    mov r0, #0
    0xe001436c    0x88    str r0, [r4]          ; stack access
    0xe0014370    0x8c    str r5, [r4, #4]      ; stack access
    0xe0014374    0x90    str r6, [r4, #8]      ; stack access
    0xe0014378    0x94    mov r0, r4
    0xe001437c    0x98    add sp, sp, #8
    0xe0014380    0x9c    pop {r4, r5, r6, pc}  ; stack access
    0xe0014384    0xa0    mov r6, #0
    0xe0014388    0xa4    mov r5, r6
    0xe001438c    0xa8    mov r0, r6
    0xe0014390    0xac    b e001436c <deriveCap+0x88>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
44 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deriveCap` has 75 nodes.

Section sameRegionAs (208 of 293)
=================================

Deriving specifications
-----------------------

Section `sameRegionAs` consists of 574 instructions.
Switch found.
Switch found.
Switch found.
Switch found.
 ANDLS (imm)....+++
Switch found.
Switch found.
Switch found.
Switch found.


Stack analysis
---------------

9 stack accesses found. Annotated code for `sameRegionAs`:

    0xe00138ec      0x0    push {r4, r5, lr}     ; stack access
    0xe00138f0      0x4    sub sp, sp, #20
    0xe00138f4      0x8    add ip, sp, #16
    0xe00138f8      0xc    stmdb ip, {r0, r1}    ; stack access
    0xe00138fc     0x10    mov r1, sp
    0xe0013900     0x14    stm r1, {r2, r3}      ; stack access
    0xe0013904     0x18    ldr lr, [sp, #12]     ; stack access
    0xe0013908     0x1c    mov r3, r2
    0xe001390c     0x20    ldr r4, [sp, #4]      ; stack access
    0xe0013910     0x24    ldr r2, [sp, #8]      ; stack access
    0xe0013914     0x28    and r1, r2, #14
    0xe0013918     0x2c    cmp r1, #14
    0xe001391c     0x30    andne ip, r2, #15
    0xe0013920     0x34    uxtbeq ip, r2
    0xe0013924     0x38    sub r1, ip, #2
    0xe0013928     0x3c    cmp r1, #60 
    0xe001392c     0x40    ldrls pc, [pc, r1, lsl #2]
    0xe0013930     0x44    b e0014194 <sameRegionAs+0x8a8>
    0xe0013934     0x48    .word 0xe0013a28
    0xe0013938     0x4c    .word 0xe0014194
    0xe001393c     0x50    .word 0xe0014000
    0xe0013940     0x54    .word 0xe0014194
    0xe0013944     0x58    .word 0xe0014034
    0xe0013948     0x5c    .word 0xe0014194
    0xe001394c     0x60    .word 0xe00140e4
    0xe0013950     0x64    .word 0xe0014194
    0xe0013954     0x68    .word 0xe0014068
    0xe0013958     0x6c    .word 0xe0014194
    0xe001395c     0x70    .word 0xe00140b0
    0xe0013960     0x74    .word 0xe0014194
    0xe0013964     0x78    .word 0xe001413c
    0xe0013968     0x7c    .word 0xe0014194
    0xe001396c     0x80    .word 0xe0014194
    0xe0013970     0x84    .word 0xe0014194
    0xe0013974     0x88    .word 0xe0014194
    0xe0013978     0x8c    .word 0xe0014194
    0xe001397c     0x90    .word 0xe0014194
    0xe0013980     0x94    .word 0xe0014194
    0xe0013984     0x98    .word 0xe0014194
    0xe0013988     0x9c    .word 0xe0014194
    0xe001398c     0xa0    .word 0xe0014194
    0xe0013990     0xa4    .word 0xe0014194
    0xe0013994     0xa8    .word 0xe0014194
    0xe0013998     0xac    .word 0xe0014194
    0xe001399c     0xb0    .word 0xe0014194
    0xe00139a0     0xb4    .word 0xe0014194
    0xe00139a4     0xb8    .word 0xe0014160
    0xe00139a8     0xbc    .word 0xe0014194
    0xe00139ac     0xc0    .word 0xe0014194
    0xe00139b0     0xc4    .word 0xe0014194
    0xe00139b4     0xc8    .word 0xe0014194
    0xe00139b8     0xcc    .word 0xe0014194
    0xe00139bc     0xd0    .word 0xe0014194
    0xe00139c0     0xd4    .word 0xe0014194
    0xe00139c4     0xd8    .word 0xe0014194
    0xe00139c8     0xdc    .word 0xe0014194
    0xe00139cc     0xe0    .word 0xe0014194
    0xe00139d0     0xe4    .word 0xe0014194
    0xe00139d4     0xe8    .word 0xe0014194
    0xe00139d8     0xec    .word 0xe0014194
    0xe00139dc     0xf0    .word 0xe0014194
    0xe00139e0     0xf4    .word 0xe0014194
    0xe00139e4     0xf8    .word 0xe0014194
    0xe00139e8     0xfc    .word 0xe0014194
    0xe00139ec    0x100    .word 0xe0014194
    0xe00139f0    0x104    .word 0xe0014194
    0xe00139f4    0x108    .word 0xe0014194
    0xe00139f8    0x10c    .word 0xe0014194
    0xe00139fc    0x110    .word 0xe0014194
    0xe0013a00    0x114    .word 0xe0014194
    0xe0013a04    0x118    .word 0xe0014194
    0xe0013a08    0x11c    .word 0xe0014194
    0xe0013a0c    0x120    .word 0xe0014194
    0xe0013a10    0x124    .word 0xe0014194
    0xe0013a14    0x128    .word 0xe0014194
    0xe0013a18    0x12c    .word 0xe0014194
    0xe0013a1c    0x130    .word 0xe0014194
    0xe0013a20    0x134    .word 0xe0014194
    0xe0013a24    0x138    .word 0xe0014118
    0xe0013a28    0x13c    and r1, r3, #14
    0xe0013a2c    0x140    cmp r1, #14
    0xe0013a30    0x144    andne r5, r3, #15
    0xe0013a34    0x148    uxtbeq r5, r3
    0xe0013a38    0x14c    sub r1, r5, #2
    0xe0013a3c    0x150    cmp r1, #60 
    0xe0013a40    0x154    ldrls pc, [pc, r1, lsl #2]
    0xe0013a44    0x158    b e0013b3c <sameRegionAs+0x250>
    0xe0013a48    0x15c    .word 0xe0013b70
    0xe0013a4c    0x160    .word 0xe0013b3c
    0xe0013a50    0x164    .word 0xe0013b70
    0xe0013a54    0x168    .word 0xe0013b3c
    0xe0013a58    0x16c    .word 0xe0013b70
    0xe0013a5c    0x170    .word 0xe0013b3c
    0xe0013a60    0x174    .word 0xe00141dc
    0xe0013a64    0x178    .word 0xe0013b3c
    0xe0013a68    0x17c    .word 0xe0013b70
    0xe0013a6c    0x180    .word 0xe0013b3c
    0xe0013a70    0x184    .word 0xe0013b70
    0xe0013a74    0x188    .word 0xe0013b3c
    0xe0013a78    0x18c    .word 0xe00141dc
    0xe0013a7c    0x190    .word 0xe0013b3c
    0xe0013a80    0x194    .word 0xe0013b3c
    0xe0013a84    0x198    .word 0xe0013b3c
    0xe0013a88    0x19c    .word 0xe0013b3c
    0xe0013a8c    0x1a0    .word 0xe0013b3c
    0xe0013a90    0x1a4    .word 0xe0013b3c
    0xe0013a94    0x1a8    .word 0xe0013b3c
    0xe0013a98    0x1ac    .word 0xe0013b3c
    0xe0013a9c    0x1b0    .word 0xe0013b3c
    0xe0013aa0    0x1b4    .word 0xe0013b3c
    0xe0013aa4    0x1b8    .word 0xe0013b3c
    0xe0013aa8    0x1bc    .word 0xe0013b3c
    0xe0013aac    0x1c0    .word 0xe0013b3c
    0xe0013ab0    0x1c4    .word 0xe0013b3c
    0xe0013ab4    0x1c8    .word 0xe0013b3c
    0xe0013ab8    0x1cc    .word 0xe00141dc
    0xe0013abc    0x1d0    .word 0xe0013b3c
    0xe0013ac0    0x1d4    .word 0xe0013b3c
    0xe0013ac4    0x1d8    .word 0xe0013b3c
    0xe0013ac8    0x1dc    .word 0xe0013b3c
    0xe0013acc    0x1e0    .word 0xe0013b3c
    0xe0013ad0    0x1e4    .word 0xe0013b3c
    0xe0013ad4    0x1e8    .word 0xe0013b3c
    0xe0013ad8    0x1ec    .word 0xe0013b3c
    0xe0013adc    0x1f0    .word 0xe0013b3c
    0xe0013ae0    0x1f4    .word 0xe0013b3c
    0xe0013ae4    0x1f8    .word 0xe0013b3c
    0xe0013ae8    0x1fc    .word 0xe0013b3c
    0xe0013aec    0x200    .word 0xe0013b3c
    0xe0013af0    0x204    .word 0xe0013b3c
    0xe0013af4    0x208    .word 0xe0013b3c
    0xe0013af8    0x20c    .word 0xe0013b70
    0xe0013afc    0x210    .word 0xe0013b3c
    0xe0013b00    0x214    .word 0xe0013b3c
    0xe0013b04    0x218    .word 0xe0013b3c
    0xe0013b08    0x21c    .word 0xe0013b3c
    0xe0013b0c    0x220    .word 0xe0013b3c
    0xe0013b10    0x224    .word 0xe0013b3c
    0xe0013b14    0x228    .word 0xe0013b3c
    0xe0013b18    0x22c    .word 0xe0013b3c
    0xe0013b1c    0x230    .word 0xe0013b3c
    0xe0013b20    0x234    .word 0xe0013b3c
    0xe0013b24    0x238    .word 0xe0013b3c
    0xe0013b28    0x23c    .word 0xe0013b3c
    0xe0013b2c    0x240    .word 0xe0013b3c
    0xe0013b30    0x244    .word 0xe0013b3c
    0xe0013b34    0x248    .word 0xe0013b3c
    0xe0013b38    0x24c    .word 0xe00141dc
    0xe0013b3c    0x250    sub r1, r5, #1
    0xe0013b40    0x254    cmp r1, #8
    0xe0013b44    0x258    ldrls pc, [pc, r1, lsl #2]
    0xe0013b48    0x25c    b e00141d4 <sameRegionAs+0x8e8>
    0xe0013b4c    0x260    .word 0xe0013b70
    0xe0013b50    0x264    .word 0xe00141d4
    0xe0013b54    0x268    .word 0xe0013b70
    0xe0013b58    0x26c    .word 0xe00141d4
    0xe0013b5c    0x270    .word 0xe0013b70
    0xe0013b60    0x274    .word 0xe00141d4
    0xe0013b64    0x278    .word 0xe0013b70
    0xe0013b68    0x27c    .word 0xe00141d4
    0xe0013b6c    0x280    .word 0xe0013b70
    0xe0013b70    0x284    bic ip, r2, #15
    0xe0013b74    0x288    sub r1, r5, #2
    0xe0013b78    0x28c    cmp r1, #60 
    0xe0013b7c    0x290    ldrls pc, [pc, r1, lsl #2]
    0xe0013b80    0x294    b e0013d78 <sameRegionAs+0x48c>
    0xe0013b84    0x298    .word 0xe0013c78
    0xe0013b88    0x29c    .word 0xe0013d78
    0xe0013b8c    0x2a0    .word 0xe0013c94
    0xe0013b90    0x2a4    .word 0xe0013d78
    0xe0013b94    0x2a8    .word 0xe0013ce0
    0xe0013b98    0x2ac    .word 0xe0013d78
    0xe0013b9c    0x2b0    .word 0xe0013e54
    0xe0013ba0    0x2b4    .word 0xe0013d78
    0xe0013ba4    0x2b8    .word 0xe0013ce8
    0xe0013ba8    0x2bc    .word 0xe0013d78
    0xe0013bac    0x2c0    .word 0xe0013d08
    0xe0013bb0    0x2c4    .word 0xe0013d78
    0xe0013bb4    0x2c8    .word 0xe0013e54
    0xe0013bb8    0x2cc    .word 0xe0013d78
    0xe0013bbc    0x2d0    .word 0xe0013d78
    0xe0013bc0    0x2d4    .word 0xe0013d78
    0xe0013bc4    0x2d8    .word 0xe0013d78
    0xe0013bc8    0x2dc    .word 0xe0013d78
    0xe0013bcc    0x2e0    .word 0xe0013d78
    0xe0013bd0    0x2e4    .word 0xe0013d78
    0xe0013bd4    0x2e8    .word 0xe0013d78
    0xe0013bd8    0x2ec    .word 0xe0013d78
    0xe0013bdc    0x2f0    .word 0xe0013d78
    0xe0013be0    0x2f4    .word 0xe0013d78
    0xe0013be4    0x2f8    .word 0xe0013d78
    0xe0013be8    0x2fc    .word 0xe0013d78
    0xe0013bec    0x300    .word 0xe0013d78
    0xe0013bf0    0x304    .word 0xe0013d78
    0xe0013bf4    0x308    .word 0xe0013e54
    0xe0013bf8    0x30c    .word 0xe0013d78
    0xe0013bfc    0x310    .word 0xe0013d78
    0xe0013c00    0x314    .word 0xe0013d78
    0xe0013c04    0x318    .word 0xe0013d78
    0xe0013c08    0x31c    .word 0xe0013d78
    0xe0013c0c    0x320    .word 0xe0013d78
    0xe0013c10    0x324    .word 0xe0013d78
    0xe0013c14    0x328    .word 0xe0013d78
    0xe0013c18    0x32c    .word 0xe0013d78
    0xe0013c1c    0x330    .word 0xe0013d78
    0xe0013c20    0x334    .word 0xe0013d78
    0xe0013c24    0x338    .word 0xe0013d78
    0xe0013c28    0x33c    .word 0xe0013d78
    0xe0013c2c    0x340    .word 0xe0013d78
    0xe0013c30    0x344    .word 0xe0013d78
    0xe0013c34    0x348    .word 0xe0013d28
    0xe0013c38    0x34c    .word 0xe0013d78
    0xe0013c3c    0x350    .word 0xe0013d78
    0xe0013c40    0x354    .word 0xe0013d78
    0xe0013c44    0x358    .word 0xe0013d78
    0xe0013c48    0x35c    .word 0xe0013d78
    0xe0013c4c    0x360    .word 0xe0013d78
    0xe0013c50    0x364    .word 0xe0013d78
    0xe0013c54    0x368    .word 0xe0013d78
    0xe0013c58    0x36c    .word 0xe0013d78
    0xe0013c5c    0x370    .word 0xe0013d78
    0xe0013c60    0x374    .word 0xe0013d78
    0xe0013c64    0x378    .word 0xe0013d78
    0xe0013c68    0x37c    .word 0xe0013d78
    0xe0013c6c    0x380    .word 0xe0013d78
    0xe0013c70    0x384    .word 0xe0013d78
    0xe0013c74    0x388    .word 0xe0013e54
    0xe0013c78    0x38c    bic r2, r3, #15
    0xe0013c7c    0x390    and r0, lr, #31
    0xe0013c80    0x394    sub r3, ip, #1
    0xe0013c84    0x398    mov r1, #1
    0xe0013c88    0x39c    add r0, r3, r1, lsl r0
    0xe0013c8c    0x3a0    and r3, r4, #31
    0xe0013c90    0x3a4    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013c94    0x3a8    bic r3, r4, #15
    0xe0013c98    0x3ac    mov r2, r3
    0xe0013c9c    0x3b0    and r0, lr, #31
    0xe0013ca0    0x3b4    sub r3, ip, #1
    0xe0013ca4    0x3b8    mov r1, #1
    0xe0013ca8    0x3bc    add r0, r3, r1, lsl r0
    0xe0013cac    0x3c0    mov r3, #4
    0xe0013cb0    0x3c4    sub r4, r2, #1
    0xe0013cb4    0x3c8    mov r1, #1
    0xe0013cb8    0x3cc    add r4, r4, r1, lsl r3
    0xe0013cbc    0x3d0    cmp r4, r0
    0xe0013cc0    0x3d4    movhi r3, #0
    0xe0013cc4    0x3d8    movls r3, #1
    0xe0013cc8    0x3dc    cmp r4, r2
    0xe0013ccc    0x3e0    movcc r3, #0
    0xe0013cd0    0x3e4    cmp ip, r2
    0xe0013cd4    0x3e8    movhi r0, #0
    0xe0013cd8    0x3ec    andls r0, r3, #1
    0xe0013cdc    0x3f0    b e0014134 <sameRegionAs+0x848>
    0xe0013ce0    0x3f4    bic r3, r3, #15
    0xe0013ce4    0x3f8    b e0013c98 <sameRegionAs+0x3ac>
    0xe0013ce8    0x3fc    bic r2, r3, #31
    0xe0013cec    0x400    and r0, lr, #31
    0xe0013cf0    0x404    sub r3, ip, #1
    0xe0013cf4    0x408    mov r1, #1
    0xe0013cf8    0x40c    add r0, r3, r1, lsl r0
    0xe0013cfc    0x410    ubfx r3, r4, #18, #5
    0xe0013d00    0x414    add r3, r3, #4
    0xe0013d04    0x418    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013d08    0x41c    bic r2, r3, #508 
    0xe0013d0c    0x420    bic r2, r2, #3
    0xe0013d10    0x424    and r0, lr, #31
    0xe0013d14    0x428    sub r3, ip, #1
    0xe0013d18    0x42c    mov r1, #1
    0xe0013d1c    0x430    add r0, r3, r1, lsl r0
    0xe0013d20    0x434    mov r3, #9
    0xe0013d24    0x438    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013d28    0x43c    lsr r2, r3, #8
    0xe0013d2c    0x440    and r1, r2, #63 
    0xe0013d30    0x444    cmp r1, #32
    0xe0013d34    0x448    andne r2, r2, #31
    0xe0013d38    0x44c    moveq r2, #4
    0xe0013d3c    0x450    add r2, r2, #1
    0xe0013d40    0x454    mov r1, #1
    0xe0013d44    0x458    lsl r2, r1, r2
    0xe0013d48    0x45c    rsb r2, r2, #0
    0xe0013d4c    0x460    and r2, r2, r4
    0xe0013d50    0x464    and lr, lr, #31
    0xe0013d54    0x468    sub r0, ip, #1
    0xe0013d58    0x46c    add r0, r0, r1, lsl lr
    0xe0013d5c    0x470    lsr r3, r3, #8
    0xe0013d60    0x474    and r1, r3, #63 
    0xe0013d64    0x478    cmp r1, #32
    0xe0013d68    0x47c    moveq r3, #9
    0xe0013d6c    0x480    andne r3, r3, #31
    0xe0013d70    0x484    addne r3, r3, #4
    0xe0013d74    0x488    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013d78    0x48c    sub r2, r5, #1
    0xe0013d7c    0x490    cmp r2, #8
    0xe0013d80    0x494    ldrls pc, [pc, r2, lsl #2]
    0xe0013d84    0x498    b e0013f74 <sameRegionAs+0x688>
    0xe0013d88    0x49c    .word 0xe0013dac
    0xe0013d8c    0x4a0    .word 0xe0013f74
    0xe0013d90    0x4a4    .word 0xe0013dac
    0xe0013d94    0x4a8    .word 0xe0013f74
    0xe0013d98    0x4ac    .word 0xe0013e4c
    0xe0013d9c    0x4b0    .word 0xe0013f74
    0xe0013da0    0x4b4    .word 0xe0013de8
    0xe0013da4    0x4b8    .word 0xe0013f74
    0xe0013da8    0x4bc    .word 0xe0013e40
    0xe0013dac    0x4c0    cmp r5, #1
    0xe0013db0    0x4c4    beq e0013dc4 <sameRegionAs+0x4d8>
    0xe0013db4    0x4c8    cmp r5, #3
    0xe0013db8    0x4cc    beq e0013dd8 <sameRegionAs+0x4ec>
    0xe0013dbc    0x4d0    mov r2, #0
    0xe0013dc0    0x4d4    b e0013dd0 <sameRegionAs+0x4e4>
    0xe0013dc4    0x4d8    lsl r2, r3, #8
    0xe0013dc8    0x4dc    bic r2, r2, #4080 
    0xe0013dcc    0x4e0    bic r2, r2, #15
    0xe0013dd0    0x4e4    mov r0, r2
    0xe0013dd4    0x4e8    b e0013e58 <sameRegionAs+0x56c>
    0xe0013dd8    0x4ec    lsl r2, r3, #10
    0xe0013ddc    0x4f0    bic r2, r2, #16320 
    0xe0013de0    0x4f4    bic r2, r2, #63 
    0xe0013de4    0x4f8    b e0013dd0 <sameRegionAs+0x4e4>
    0xe0013de8    0x4fc    bic r3, r3, #1020 
    0xe0013dec    0x500    bic r3, r3, #3
    0xe0013df0    0x504    mov r2, r3
    0xe0013df4    0x508    and lr, lr, #31
    0xe0013df8    0x50c    sub r3, ip, #1
    0xe0013dfc    0x510    mov r0, #1
    0xe0013e00    0x514    add r0, r3, r0, lsl lr
    0xe0013e04    0x518    sub r3, r5, #1
    0xe0013e08    0x51c    cmp r3, #10
    0xe0013e0c    0x520    ldrls pc, [pc, r3, lsl #2]
    0xe0013e10    0x524    b e0013fe0 <sameRegionAs+0x6f4>
    0xe0013e14    0x528    .word 0xe0013f8c
    0xe0013e18    0x52c    .word 0xe0013fe0
    0xe0013e1c    0x530    .word 0xe0013f8c
    0xe0013e20    0x534    .word 0xe0013fe0
    0xe0013e24    0x538    .word 0xe0013fd0
    0xe0013e28    0x53c    .word 0xe0013fe0
    0xe0013e2c    0x540    .word 0xe0013ff0
    0xe0013e30    0x544    .word 0xe0013fe0
    0xe0013e34    0x548    .word 0xe0013f84
    0xe0013e38    0x54c    .word 0xe0013fe0
    0xe0013e3c    0x550    .word 0xe0013fd8
    0xe0013e40    0x554    bic r3, r3, #16320 
    0xe0013e44    0x558    bic r3, r3, #63 
    0xe0013e48    0x55c    b e0013df0 <sameRegionAs+0x504>
    0xe0013e4c    0x560    bic r3, r3, #15
    0xe0013e50    0x564    b e0013df0 <sameRegionAs+0x504>
    0xe0013e54    0x568    mov r0, #0
    0xe0013e58    0x56c    mov r2, r0
    0xe0013e5c    0x570    and lr, lr, #31
    0xe0013e60    0x574    sub r0, ip, #1
    0xe0013e64    0x578    mov r1, #1
    0xe0013e68    0x57c    add r0, r0, r1, lsl lr
    0xe0013e6c    0x580    cmp r5, #62 
    0xe0013e70    0x584    ldrls pc, [pc, r5, lsl #2]
    0xe0013e74    0x588    b e0013e04 <sameRegionAs+0x518>
    0xe0013e78    0x58c    .word 0xe0013f7c
    0xe0013e7c    0x590    .word 0xe0013e04
    0xe0013e80    0x594    .word 0xe0013c8c
    0xe0013e84    0x598    .word 0xe0013e04
    0xe0013e88    0x59c    .word 0xe0013fe8
    0xe0013e8c    0x5a0    .word 0xe0013e04
    0xe0013e90    0x5a4    .word 0xe0013fe8
    0xe0013e94    0x5a8    .word 0xe0013e04
    0xe0013e98    0x5ac    .word 0xe0013f7c
    0xe0013e9c    0x5b0    .word 0xe0013e04
    0xe0013ea0    0x5b4    .word 0xe0013cfc
    0xe0013ea4    0x5b8    .word 0xe0013e04
    0xe0013ea8    0x5bc    .word 0xe0013d20
    0xe0013eac    0x5c0    .word 0xe0013e04
    0xe0013eb0    0x5c4    .word 0xe0013f7c
    0xe0013eb4    0x5c8    .word 0xe0013e04
    0xe0013eb8    0x5cc    .word 0xe0013e04
    0xe0013ebc    0x5d0    .word 0xe0013e04
    0xe0013ec0    0x5d4    .word 0xe0013e04
    0xe0013ec4    0x5d8    .word 0xe0013e04
    0xe0013ec8    0x5dc    .word 0xe0013e04
    0xe0013ecc    0x5e0    .word 0xe0013e04
    0xe0013ed0    0x5e4    .word 0xe0013e04
    0xe0013ed4    0x5e8    .word 0xe0013e04
    0xe0013ed8    0x5ec    .word 0xe0013e04
    0xe0013edc    0x5f0    .word 0xe0013e04
    0xe0013ee0    0x5f4    .word 0xe0013e04
    0xe0013ee4    0x5f8    .word 0xe0013e04
    0xe0013ee8    0x5fc    .word 0xe0013e04
    0xe0013eec    0x600    .word 0xe0013e04
    0xe0013ef0    0x604    .word 0xe0013f7c
    0xe0013ef4    0x608    .word 0xe0013e04
    0xe0013ef8    0x60c    .word 0xe0013e04
    0xe0013efc    0x610    .word 0xe0013e04
    0xe0013f00    0x614    .word 0xe0013e04
    0xe0013f04    0x618    .word 0xe0013e04
    0xe0013f08    0x61c    .word 0xe0013e04
    0xe0013f0c    0x620    .word 0xe0013e04
    0xe0013f10    0x624    .word 0xe0013e04
    0xe0013f14    0x628    .word 0xe0013e04
    0xe0013f18    0x62c    .word 0xe0013e04
    0xe0013f1c    0x630    .word 0xe0013e04
    0xe0013f20    0x634    .word 0xe0013e04
    0xe0013f24    0x638    .word 0xe0013e04
    0xe0013f28    0x63c    .word 0xe0013e04
    0xe0013f2c    0x640    .word 0xe0013e04
    0xe0013f30    0x644    .word 0xe0013d5c
    0xe0013f34    0x648    .word 0xe0013e04
    0xe0013f38    0x64c    .word 0xe0013e04
    0xe0013f3c    0x650    .word 0xe0013e04
    0xe0013f40    0x654    .word 0xe0013e04
    0xe0013f44    0x658    .word 0xe0013e04
    0xe0013f48    0x65c    .word 0xe0013e04
    0xe0013f4c    0x660    .word 0xe0013e04
    0xe0013f50    0x664    .word 0xe0013e04
    0xe0013f54    0x668    .word 0xe0013e04
    0xe0013f58    0x66c    .word 0xe0013e04
    0xe0013f5c    0x670    .word 0xe0013e04
    0xe0013f60    0x674    .word 0xe0013e04
    0xe0013f64    0x678    .word 0xe0013e04
    0xe0013f68    0x67c    .word 0xe0013e04
    0xe0013f6c    0x680    .word 0xe0013e04
    0xe0013f70    0x684    .word 0xe0013f7c
    0xe0013f74    0x688    mov r0, #0
    0xe0013f78    0x68c    b e0013e58 <sameRegionAs+0x56c>
    0xe0013f7c    0x690    mov r3, #0
    0xe0013f80    0x694    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013f84    0x698    mov r3, #14
    0xe0013f88    0x69c    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013f8c    0x6a0    cmp r5, #3
    0xe0013f90    0x6a4    lsreq r3, r4, #30
    0xe0013f94    0x6a8    movne r3, #0
    0xe0013f98    0x6ac    cmp r3, #3
    0xe0013f9c    0x6b0    ldrls pc, [pc, r3, lsl #2]
    0xe0013fa0    0x6b4    b e0013fcc <sameRegionAs+0x6e0>
    0xe0013fa4    0x6b8    .word 0xe0013ff8
    0xe0013fa8    0x6bc    .word 0xe0013fb4
    0xe0013fac    0x6c0    .word 0xe0013fbc
    0xe0013fb0    0x6c4    .word 0xe0013fc4
    0xe0013fb4    0x6c8    mov r3, #16
    0xe0013fb8    0x6cc    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013fbc    0x6d0    mov r3, #20
    0xe0013fc0    0x6d4    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013fc4    0x6d8    mov r3, #24
    0xe0013fc8    0x6dc    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013fcc    0x6e0    bl e0010904 <halt>
    0xe0013fd0    0x6e4    mov r3, #12
    0xe0013fd4    0x6e8    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013fd8    0x6ec    mov r3, #0
    0xe0013fdc    0x6f0    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013fe0    0x6f4    mov r3, #0
    0xe0013fe4    0x6f8    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013fe8    0x6fc    mov r3, #4
    0xe0013fec    0x700    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013ff0    0x704    mov r3, #10
    0xe0013ff4    0x708    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0013ff8    0x70c    mov r3, #12
    0xe0013ffc    0x710    b e0013cb0 <sameRegionAs+0x3c4>
    0xe0014000    0x714    and r2, r3, #14
    0xe0014004    0x718    cmp r2, #14
    0xe0014008    0x71c    andne r3, r3, #15
    0xe001400c    0x720    uxtbeq r3, r3
    0xe0014010    0x724    cmp r3, #4
    0xe0014014    0x728    movne r0, #0
    0xe0014018    0x72c    bne e0014134 <sameRegionAs+0x848>
    0xe001401c    0x730    bic r3, r4, #15
    0xe0014020    0x734    bic r0, lr, #15
    0xe0014024    0x738    cmp r3, r0
    0xe0014028    0x73c    movne r0, #0
    0xe001402c    0x740    moveq r0, #1
    0xe0014030    0x744    b e0014134 <sameRegionAs+0x848>
    0xe0014034    0x748    and r1, r3, #14
    0xe0014038    0x74c    cmp r1, #14
    0xe001403c    0x750    andne r1, r3, #15
    0xe0014040    0x754    uxtbeq r1, r3
    0xe0014044    0x758    cmp r1, #6
    0xe0014048    0x75c    movne r0, #0
    0xe001404c    0x760    bne e0014134 <sameRegionAs+0x848>
    0xe0014050    0x764    bic r3, r3, #15
    0xe0014054    0x768    bic r2, r2, #15
    0xe0014058    0x76c    cmp r3, r2
    0xe001405c    0x770    movne r0, #0
    0xe0014060    0x774    moveq r0, #1
    0xe0014064    0x778    b e0014134 <sameRegionAs+0x848>
    0xe0014068    0x77c    and r1, r3, #14
    0xe001406c    0x780    cmp r1, #14
    0xe0014070    0x784    andne r1, r3, #15
    0xe0014074    0x788    uxtbeq r1, r3
    0xe0014078    0x78c    cmp r1, #10
    0xe001407c    0x790    movne r0, #0
    0xe0014080    0x794    bne e0014134 <sameRegionAs+0x848>
    0xe0014084    0x798    bic r3, r3, #31
    0xe0014088    0x79c    bic r2, r2, #31
    0xe001408c    0x7a0    cmp r3, r2
    0xe0014090    0x7a4    movne r0, #0
    0xe0014094    0x7a8    bne e0014134 <sameRegionAs+0x848>
    0xe0014098    0x7ac    ubfx r3, r4, #18, #5
    0xe001409c    0x7b0    ubfx r0, lr, #18, #5
    0xe00140a0    0x7b4    cmp r3, r0
    0xe00140a4    0x7b8    movne r0, #0
    0xe00140a8    0x7bc    moveq r0, #1
    0xe00140ac    0x7c0    b e0014134 <sameRegionAs+0x848>
    0xe00140b0    0x7c4    and r1, r3, #14
    0xe00140b4    0x7c8    cmp r1, #14
    0xe00140b8    0x7cc    andne r1, r3, #15
    0xe00140bc    0x7d0    uxtbeq r1, r3
    0xe00140c0    0x7d4    cmp r1, #12
    0xe00140c4    0x7d8    movne r0, #0
    0xe00140c8    0x7dc    bne e0014134 <sameRegionAs+0x848>
    0xe00140cc    0x7e0    bic r3, r3, #15
    0xe00140d0    0x7e4    bic r2, r2, #15
    0xe00140d4    0x7e8    cmp r3, r2
    0xe00140d8    0x7ec    movne r0, #0
    0xe00140dc    0x7f0    moveq r0, #1
    0xe00140e0    0x7f4    b e0014134 <sameRegionAs+0x848>
    0xe00140e4    0x7f8    and r1, r3, #14
    0xe00140e8    0x7fc    cmp r1, #14
    0xe00140ec    0x800    andne r1, r3, #15
    0xe00140f0    0x804    uxtbeq r1, r3
    0xe00140f4    0x808    cmp r1, #8
    0xe00140f8    0x80c    movne r0, #0
    0xe00140fc    0x810    bne e0014134 <sameRegionAs+0x848>
    0xe0014100    0x814    bic r3, r3, #63 
    0xe0014104    0x818    bic r2, r2, #63 
    0xe0014108    0x81c    cmp r3, r2
    0xe001410c    0x820    movne r0, #0
    0xe0014110    0x824    moveq r0, #1
    0xe0014114    0x828    b e0014134 <sameRegionAs+0x848>
    0xe0014118    0x82c    and r2, r3, #14
    0xe001411c    0x830    cmp r2, #14
    0xe0014120    0x834    andne r3, r3, #15
    0xe0014124    0x838    uxtbeq r3, r3
    0xe0014128    0x83c    cmp r3, #62 
    0xe001412c    0x840    movne r0, #0
    0xe0014130    0x844    moveq r0, #1
    0xe0014134    0x848    add sp, sp, #20
    0xe0014138    0x84c    pop {r4, r5, pc}      ; stack access
    0xe001413c    0x850    and r2, r3, #14
    0xe0014140    0x854    cmp r2, #14
    0xe0014144    0x858    andne r3, r3, #15
    0xe0014148    0x85c    uxtbeq r3, r3
    0xe001414c    0x860    bic r3, r3, #16
    0xe0014150    0x864    cmp r3, #14
    0xe0014154    0x868    movne r0, #0
    0xe0014158    0x86c    moveq r0, #1
    0xe001415c    0x870    b e0014134 <sameRegionAs+0x848>
    0xe0014160    0x874    and r2, r3, #14
    0xe0014164    0x878    cmp r2, #14
    0xe0014168    0x87c    andne r3, r3, #15
    0xe001416c    0x880    uxtbeq r3, r3
    0xe0014170    0x884    cmp r3, #30
    0xe0014174    0x888    movne r0, #0
    0xe0014178    0x88c    bne e0014134 <sameRegionAs+0x848>
    0xe001417c    0x890    uxtb r3, r4
    0xe0014180    0x894    uxtb r0, lr
    0xe0014184    0x898    cmp r3, r0
    0xe0014188    0x89c    movne r0, #0
    0xe001418c    0x8a0    moveq r0, #1
    0xe0014190    0x8a4    b e0014134 <sameRegionAs+0x848>
    0xe0014194    0x8a8    tst ip, #1
    0xe0014198    0x8ac    moveq r0, #0
    0xe001419c    0x8b0    beq e0014134 <sameRegionAs+0x848>
    0xe00141a0    0x8b4    and r2, r3, #14
    0xe00141a4    0x8b8    cmp r2, #14
    0xe00141a8    0x8bc    andne r3, r3, #15
    0xe00141ac    0x8c0    uxtbeq r3, r3
    0xe00141b0    0x8c4    tst r3, #1
    0xe00141b4    0x8c8    moveq r0, #0
    0xe00141b8    0x8cc    beq e0014134 <sameRegionAs+0x848>
    0xe00141bc    0x8d0    mov r3, sp
    0xe00141c0    0x8d4    ldm r3, {r2, r3}      ; stack access
    0xe00141c4    0x8d8    add r1, sp, #16
    0xe00141c8    0x8dc    ldmdb r1, {r0, r1}    ; stack access
    0xe00141cc    0x8e0    bl e0011624 <Arch_sameRegionAs>
    0xe00141d0    0x8e4    b e0014134 <sameRegionAs+0x848>
    0xe00141d4    0x8e8    mov r0, #0
    0xe00141d8    0x8ec    b e0014134 <sameRegionAs+0x848>
    0xe00141dc    0x8f0    mov r0, #0
    0xe00141e0    0x8f4    b e0014134 <sameRegionAs+0x848>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
295 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sameRegionAs` has 1291 nodes.

Section getObjectSize (209 of 293)
==================================

Deriving specifications
-----------------------

Section `getObjectSize` consists of 22 instructions.
Switch found.


Stack analysis
---------------

6 stack accesses found. Annotated code for `getObjectSize`:

    0xe0013838     0x0    push {r4, lr}         ; stack access
    0xe001383c     0x4    cmp r0, #4
    0xe0013840     0x8    bhi e0013864 <getObjectSize+0x2c>
    0xe0013844     0xc    cmp r0, #4
    0xe0013848    0x10    ldrls pc, [pc, r0, lsl #2]
    0xe001384c    0x14    b e001387c <getObjectSize+0x44>
    0xe0013850    0x18    .word 0xe0013888
    0xe0013854    0x1c    .word 0xe0013880
    0xe0013858    0x20    .word 0xe001386c
    0xe001385c    0x24    .word 0xe001386c
    0xe0013860    0x28    .word 0xe0013874
    0xe0013864    0x2c    bl e0011a68 <Arch_getObjectSize>
    0xe0013868    0x30    pop {r4, pc}          ; stack access
    0xe001386c    0x34    mov r0, #4
    0xe0013870    0x38    pop {r4, pc}          ; stack access
    0xe0013874    0x3c    add r0, r1, #4
    0xe0013878    0x40    pop {r4, pc}          ; stack access
    0xe001387c    0x44    bl e0010904 <halt>
    0xe0013880    0x48    mov r0, #9
    0xe0013884    0x4c    pop {r4, pc}          ; stack access
    0xe0013888    0x50    mov r0, r1
    0xe001388c    0x54    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getObjectSize` has 43 nodes.

Section invokeIRQControl (210 of 293)
=====================================

Deriving specifications
-----------------------

Section `invokeIRQControl` consists of 20 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `invokeIRQControl`:

    0xe0013684     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0013688     0x4    sub sp, sp, #8
    0xe001368c     0x8    mov r4, r0
    0xe0013690     0xc    mov r6, r1
    0xe0013694    0x10    mov r5, r2
    0xe0013698    0x14    mov r1, r0
    0xe001369c    0x18    mov r0, #1
    0xe00136a0    0x1c    bl e0013648 <setIRQState>
    0xe00136a4    0x20    mov r3, #30
    0xe00136a8    0x24    str r3, [sp]          ; stack access
    0xe00136ac    0x28    uxtb r4, r4
    0xe00136b0    0x2c    str r4, [sp, #4]      ; stack access
    0xe00136b4    0x30    mov r3, r6
    0xe00136b8    0x34    mov r2, r5
    0xe00136bc    0x38    add r1, sp, #8
    0xe00136c0    0x3c    ldmdb r1, {r0, r1}    ; stack access
    0xe00136c4    0x40    bl e0012fa8 <cteInsert>
    0xe00136c8    0x44    mov r0, #0
    0xe00136cc    0x48    add sp, sp, #8
    0xe00136d0    0x4c    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQControl` has 27 nodes.

Section getReceiveSlots (211 of 293)
====================================

Deriving specifications
-----------------------

Section `getReceiveSlots` consists of 40 instructions.


Stack analysis
---------------

9 stack accesses found. Annotated code for `getReceiveSlots`:

    0xe001353c     0x0    subs r3, r1, #0
    0xe0013540     0x4    beq e00135cc <getReceiveSlots+0x90>
    0xe0013544     0x8    push {r4, r5, lr}     ; stack access
    0xe0013548     0xc    sub sp, sp, #44 
    0xe001354c    0x10    mov r1, r0
    0xe0013550    0x14    ldr r4, [r3, #504] 
    0xe0013554    0x18    ldr r5, [r3, #508] 
    0xe0013558    0x1c    ldr r2, [r3, #500] 
    0xe001355c    0x20    add r0, sp, #28
    0xe0013560    0x24    bl e0012c1c <lookupCap>
    0xe0013564    0x28    ldr r3, [sp, #28]     ; stack access
    0xe0013568    0x2c    cmp r3, #0
    0xe001356c    0x30    movne r0, #0
    0xe0013570    0x34    bne e00135c4 <getReceiveSlots+0x88>
    0xe0013574    0x38    add r2, sp, #12
    0xe0013578    0x3c    add r3, sp, #40 
    0xe001357c    0x40    ldmdb r3, {r0, r1}    ; stack access
    0xe0013580    0x44    stm r2, {r0, r1}      ; stack access
    0xe0013584    0x48    str r5, [sp]          ; stack access
    0xe0013588    0x4c    mov r3, r4
    0xe001358c    0x50    ldm r2, {r1, r2}      ; stack access
    0xe0013590    0x54    add r0, sp, #20
    0xe0013594    0x58    bl e0012e64 <lookupTargetSlot>
    0xe0013598    0x5c    ldr r3, [sp, #20]     ; stack access
    0xe001359c    0x60    cmp r3, #0
    0xe00135a0    0x64    bne e00135d4 <getReceiveSlots+0x98>
    0xe00135a4    0x68    ldr r0, [sp, #24]     ; stack access
    0xe00135a8    0x6c    ldr r3, [r0]
    0xe00135ac    0x70    and r2, r3, #14
    0xe00135b0    0x74    cmp r2, #14
    0xe00135b4    0x78    andne r3, r3, #15
    0xe00135b8    0x7c    uxtbeq r3, r3
    0xe00135bc    0x80    cmp r3, #0
    0xe00135c0    0x84    movne r0, #0
    0xe00135c4    0x88    add sp, sp, #44 
    0xe00135c8    0x8c    pop {r4, r5, pc}      ; stack access
    0xe00135cc    0x90    mov r0, #0
    0xe00135d0    0x94    bx lr
    0xe00135d4    0x98    mov r0, #0
    0xe00135d8    0x9c    b e00135c4 <getReceiveSlots+0x88>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
40 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getReceiveSlots` has 70 nodes.

Section invokeCNodeRotate (212 of 293)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeRotate` consists of 31 instructions.


Stack analysis
---------------

15 stack accesses found. Annotated code for `invokeCNodeRotate`:

    0xe0013384     0x0    push {r4, lr}         ; stack access
    0xe0013388     0x4    sub sp, sp, #24
    0xe001338c     0x8    add ip, sp, #24
    0xe0013390     0xc    stmdb ip, {r0, r1}    ; stack access
    0xe0013394    0x10    add r1, sp, #8
    0xe0013398    0x14    stm r1, {r2, r3}      ; stack access
    0xe001339c    0x18    ldr r4, [sp, #32]     ; stack access
    0xe00133a0    0x1c    ldr r3, [sp, #40]     ; stack access
    0xe00133a4    0x20    cmp r4, r3
    0xe00133a8    0x24    beq e00133dc <invokeCNodeRotate+0x58>
    0xe00133ac    0x28    ldr r2, [sp, #36]     ; stack access
    0xe00133b0    0x2c    add r1, sp, #8
    0xe00133b4    0x30    ldm r1, {r0, r1}      ; stack access
    0xe00133b8    0x34    bl e00131b0 <cteMove>
    0xe00133bc    0x38    ldr r3, [sp, #36]     ; stack access
    0xe00133c0    0x3c    mov r2, r4
    0xe00133c4    0x40    add r1, sp, #24
    0xe00133c8    0x44    ldmdb r1, {r0, r1}    ; stack access
    0xe00133cc    0x48    bl e00131b0 <cteMove>
    0xe00133d0    0x4c    mov r0, #0
    0xe00133d4    0x50    add sp, sp, #24
    0xe00133d8    0x54    pop {r4, pc}          ; stack access
    0xe00133dc    0x58    ldr r3, [sp, #36]     ; stack access
    0xe00133e0    0x5c    str r3, [sp, #4]      ; stack access
    0xe00133e4    0x60    ldr r3, [sp, #12]     ; stack access
    0xe00133e8    0x64    str r3, [sp]          ; stack access
    0xe00133ec    0x68    mov r3, r2
    0xe00133f0    0x6c    mov r2, r4
    0xe00133f4    0x70    ldmdb ip, {r0, r1}    ; stack access
    0xe00133f8    0x74    bl e00132c4 <cteSwap>
    0xe00133fc    0x78    b e00133d0 <invokeCNodeRotate+0x4c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
31 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeRotate` has 51 nodes.

Section invokeCNodeSaveCaller (213 of 293)
==========================================

Deriving specifications
-----------------------

Section `invokeCNodeSaveCaller` consists of 31 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `invokeCNodeSaveCaller`:

    0xe0013248     0x0    push {lr}             ; stack access
    0xe001324c     0x4    sub sp, sp, #12
    0xe0013250     0x8    mov r3, r0
    0xe0013254     0xc    movw r2, #13900 
    0xe0013258    0x10    movt r2, #57347 
    0xe001325c    0x14    ldr r2, [r2]
    0xe0013260    0x18    bic r2, r2, #508 
    0xe0013264    0x1c    bic r2, r2, #3
    0xe0013268    0x20    add r2, r2, #48 
    0xe001326c    0x24    ldm r2, {r0, r1}
    0xe0013270    0x28    add ip, sp, #8
    0xe0013274    0x2c    stmdb ip, {r0, r1}    ; stack access
    0xe0013278    0x30    and r1, r0, #14
    0xe001327c    0x34    cmp r1, #14
    0xe0013280    0x38    andne r1, r0, #15
    0xe0013284    0x3c    uxtbeq r1, r0
    0xe0013288    0x40    cmp r1, #0
    0xe001328c    0x44    beq e00132a0 <invokeCNodeSaveCaller+0x58>
    0xe0013290    0x48    cmp r1, #8
    0xe0013294    0x4c    bne e00132c0 <invokeCNodeSaveCaller+0x78>
    0xe0013298    0x50    tst r0, #16
    0xe001329c    0x54    beq e00132ac <invokeCNodeSaveCaller+0x64>
    0xe00132a0    0x58    mov r0, #0
    0xe00132a4    0x5c    add sp, sp, #12
    0xe00132a8    0x60    pop {pc}              ; stack access
    0xe00132ac    0x64    add r1, sp, #8
    0xe00132b0    0x68    str r0, [r1, #-8]!    ; stack access
    0xe00132b4    0x6c    ldm r1, {r0, r1}      ; stack access
    0xe00132b8    0x70    bl e00131b0 <cteMove>
    0xe00132bc    0x74    b e00132a0 <invokeCNodeSaveCaller+0x58>
    0xe00132c0    0x78    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
31 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeSaveCaller` has 50 nodes.

Section arch_clean_invalidate_caches (214 of 293)
=================================================

Deriving specifications
-----------------------

Section `arch_clean_invalidate_caches` consists of 43 instructions.
Skipping f57ff05f dmb sy
Skipping f57ff05f dmb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `arch_clean_invalidate_caches`:

    0xe00128b0     0x0    push {r4, lr}         ; stack access
    0xe00128b4     0x4    bl e0012620 <cleanCaches_PoU>
    0xe00128b8     0x8    movw r3, #12543 
    0xe00128bc     0xc    movt r3, #65520 
    0xe00128c0    0x10    movw r2, #65535 
    0xe00128c4    0x14    str r2, [r3, #1725] 
    0xe00128c8    0x18    movw r2, #12543 
    0xe00128cc    0x1c    movt r2, #65520 
    0xe00128d0    0x20    ldr r3, [r2, #1725] 
    0xe00128d4    0x24    cmp r3, #0
    0xe00128d8    0x28    bne e00128d0 <arch_clean_invalidate_caches+0x20>
    0xe00128dc    0x2c    dmb sy
    0xe00128e0    0x30    movw r3, #12543 
    0xe00128e4    0x34    movt r3, #65520 
    0xe00128e8    0x38    mov r2, #0
    0xe00128ec    0x3c    str r2, [r3, #1585] 
    0xe00128f0    0x40    movw r2, #12543 
    0xe00128f4    0x44    movt r2, #65520 
    0xe00128f8    0x48    ldr r3, [r2, #1585] 
    0xe00128fc    0x4c    tst r3, #1
    0xe0012900    0x50    bne e00128f8 <arch_clean_invalidate_caches+0x48>
    0xe0012904    0x54    movw r3, #12543 
    0xe0012908    0x58    movt r3, #65520 
    0xe001290c    0x5c    movw r2, #65535 
    0xe0012910    0x60    str r2, [r3, #1661] 
    0xe0012914    0x64    movw r2, #12543 
    0xe0012918    0x68    movt r2, #65520 
    0xe001291c    0x6c    ldr r3, [r2, #1661] 
    0xe0012920    0x70    cmp r3, #0
    0xe0012924    0x74    bne e001291c <arch_clean_invalidate_caches+0x6c>
    0xe0012928    0x78    dmb sy
    0xe001292c    0x7c    movw r3, #12543 
    0xe0012930    0x80    movt r3, #65520 
    0xe0012934    0x84    mov r2, #0
    0xe0012938    0x88    str r2, [r3, #1585] 
    0xe001293c    0x8c    movw r2, #12543 
    0xe0012940    0x90    movt r2, #65520 
    0xe0012944    0x94    ldr r3, [r2, #1585] 
    0xe0012948    0x98    tst r3, #1
    0xe001294c    0x9c    bne e0012944 <arch_clean_invalidate_caches+0x94>
    0xe0012950    0xa0    bl e001288c <cleanInvalidateL1Caches>
    0xe0012954    0xa4    isb sy
    0xe0012958    0xa8    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
43 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arch_clean_invalidate_caches` has 66 nodes.

Section flushSpace (215 of 293)
===============================

Deriving specifications
-----------------------

Section `flushSpace` consists of 12 instructions.
Skipping f57ff04f dsb sy
Skipping ee084f57 mcr 15, 0, r4, cr8, cr7, {2}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

3 stack accesses found. Annotated code for `flushSpace`:

    0xe0012644     0x0    push {r4, lr}         ; stack access
    0xe0012648     0x4    bl e0010868 <loadHWASID>
    0xe001264c     0x8    mov r4, r0
    0xe0012650     0xc    bl e0012620 <cleanCaches_PoU>
    0xe0012654    0x10    tst r4, #8388608 
    0xe0012658    0x14    popeq {r4, pc}        ; stack access
    0xe001265c    0x18    dsb sy
    0xe0012660    0x1c    lsr r4, r4, #24
    0xe0012664    0x20    mcr 15, 0, r4, cr8, cr7, {2}
    0xe0012668    0x24    dsb sy
    0xe001266c    0x28    isb sy
    0xe0012670    0x2c    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `flushSpace` has 23 nodes.

Section setMRs_fault (216 of 293)
=================================

Deriving specifications
-----------------------

Section `setMRs_fault` consists of 106 instructions.
Switch found.


Stack analysis
---------------

13 stack accesses found. Annotated code for `setMRs_fault`:

    0xe0011b24      0x0    push {r4, lr}         ; stack access
    0xe0011b28      0x4    ldr r3, [r0, #96] 
    0xe0011b2c      0x8    and r3, r3, #15
    0xe0011b30      0xc    cmp r3, #2
    0xe0011b34     0x10    beq e0011bfc <setMRs_fault+0xd8>
    0xe0011b38     0x14    cmp r3, #3
    0xe0011b3c     0x18    beq e0011c54 <setMRs_fault+0x130>
    0xe0011b40     0x1c    cmp r3, #1
    0xe0011b44     0x20    beq e0011b50 <setMRs_fault+0x2c>
    0xe0011b48     0x24    bl e0011ae4 <Arch_setMRs_fault>
    0xe0011b4c     0x28    pop {r4, pc}          ; stack access
    0xe0011b50     0x2c    ldr r3, [r0, #68] 
    0xe0011b54     0x30    str r3, [r1, #8]
    0xe0011b58     0x34    ldr r3, [r0, #100] 
    0xe0011b5c     0x38    str r3, [r1, #12]
    0xe0011b60     0x3c    ldr r3, [r0, #96] 
    0xe0011b64     0x40    lsr r3, r3, #31
    0xe0011b68     0x44    str r3, [r1, #16]
    0xe0011b6c     0x48    ldr ip, [r0, #104] 
    0xe0011b70     0x4c    ldr lr, [r0, #108] 
    0xe0011b74     0x50    and r3, ip, #3
    0xe0011b78     0x54    add r0, r3, #1
    0xe0011b7c     0x58    str r0, [r1, #20]
    0xe0011b80     0x5c    cmp r3, #3
    0xe0011b84     0x60    ldrls pc, [pc, r3, lsl #2]
    0xe0011b88     0x64    b e0011bf8 <setMRs_fault+0xd4>
    0xe0011b8c     0x68    .word 0xe0011c90
    0xe0011b90     0x6c    .word 0xe0011b9c
    0xe0011b94     0x70    .word 0xe0011bb4
    0xe0011b98     0x74    .word 0xe0011bd4
    0xe0011b9c     0x78    cmp r2, #0
    0xe0011ba0     0x7c    beq e0011c98 <setMRs_fault+0x174>
    0xe0011ba4     0x80    ubfx ip, ip, #2, #6
    0xe0011ba8     0x84    str ip, [r2, #20]
    0xe0011bac     0x88    mov r0, #5
    0xe0011bb0     0x8c    pop {r4, pc}          ; stack access
    0xe0011bb4     0x90    cmp r2, #0
    0xe0011bb8     0x94    beq e0011ca0 <setMRs_fault+0x17c>
    0xe0011bbc     0x98    ubfx r3, ip, #2, #6
    0xe0011bc0     0x9c    str r3, [r2, #20]
    0xe0011bc4     0xa0    ubfx ip, ip, #8, #6
    0xe0011bc8     0xa4    str ip, [r2, #24]
    0xe0011bcc     0xa8    mov r0, #6
    0xe0011bd0     0xac    pop {r4, pc}          ; stack access
    0xe0011bd4     0xb0    cmp r2, #0
    0xe0011bd8     0xb4    beq e0011ca8 <setMRs_fault+0x184>
    0xe0011bdc     0xb8    ubfx r3, ip, #8, #6
    0xe0011be0     0xbc    str r3, [r2, #20]
    0xe0011be4     0xc0    str lr, [r2, #24]
    0xe0011be8     0xc4    ubfx ip, ip, #2, #6
    0xe0011bec     0xc8    str ip, [r2, #28]
    0xe0011bf0     0xcc    mov r0, #7
    0xe0011bf4     0xd0    pop {r4, pc}          ; stack access
    0xe0011bf8     0xd4    bl e0010904 <halt>
    0xe0011bfc     0xd8    ldr r3, [r0]
    0xe0011c00     0xdc    str r3, [r1, #8]
    0xe0011c04     0xe0    ldr r3, [r0, #4]
    0xe0011c08     0xe4    str r3, [r1, #12]
    0xe0011c0c     0xe8    ldr r3, [r0, #8]
    0xe0011c10     0xec    str r3, [r1, #16]
    0xe0011c14     0xf0    ldr r3, [r0, #12]
    0xe0011c18     0xf4    str r3, [r1, #20]
    0xe0011c1c     0xf8    cmp r2, #0
    0xe0011c20     0xfc    beq e0011cb0 <setMRs_fault+0x18c>
    0xe0011c24    0x100    ldr r1, [pc, #156] 
    0xe0011c28    0x104    add r3, r2, #16
    0xe0011c2c    0x108    add lr, r2, #48 
    0xe0011c30    0x10c    ldr ip, [r1], #4
    0xe0011c34    0x110    ldr ip, [r0, ip, lsl #2]
    0xe0011c38    0x114    str ip, [r3, #4]!
    0xe0011c3c    0x118    cmp r3, lr
    0xe0011c40    0x11c    bne e0011c30 <setMRs_fault+0x10c>
    0xe0011c44    0x120    ldr r3, [r0, #100] 
    0xe0011c48    0x124    str r3, [r2, #52] 
    0xe0011c4c    0x128    mov r0, #13
    0xe0011c50    0x12c    pop {r4, pc}          ; stack access
    0xe0011c54    0x130    ldr r3, [r0, #68] 
    0xe0011c58    0x134    str r3, [r1, #8]
    0xe0011c5c    0x138    ldr r3, [r0, #52] 
    0xe0011c60    0x13c    str r3, [r1, #12]
    0xe0011c64    0x140    ldr r3, [r0, #64] 
    0xe0011c68    0x144    str r3, [r1, #16]
    0xe0011c6c    0x148    cmp r2, #0
    0xe0011c70    0x14c    beq e0011cb8 <setMRs_fault+0x194>
    0xe0011c74    0x150    ldr r3, [r0, #100] 
    0xe0011c78    0x154    str r3, [r1, #20]
    0xe0011c7c    0x158    ldr r3, [r0, #96] 
    0xe0011c80    0x15c    lsr r3, r3, #4
    0xe0011c84    0x160    str r3, [r2, #20]
    0xe0011c88    0x164    mov r0, #5
    0xe0011c8c    0x168    pop {r4, pc}          ; stack access
    0xe0011c90    0x16c    mov r0, #4
    0xe0011c94    0x170    pop {r4, pc}          ; stack access
    0xe0011c98    0x174    mov r0, #4
    0xe0011c9c    0x178    pop {r4, pc}          ; stack access
    0xe0011ca0    0x17c    mov r0, #4
    0xe0011ca4    0x180    pop {r4, pc}          ; stack access
    0xe0011ca8    0x184    mov r0, #4
    0xe0011cac    0x188    pop {r4, pc}          ; stack access
    0xe0011cb0    0x18c    mov r0, #4
    0xe0011cb4    0x190    pop {r4, pc}          ; stack access
    0xe0011cb8    0x194    ldr r3, [r0, #100] 
    0xe0011cbc    0x198    str r3, [r1, #20]
    0xe0011cc0    0x19c    mov r0, #4
    0xe0011cc4    0x1a0    pop {r4, pc}          ; stack access
    0xe0011cc8    0x1a4    .word 0xe001b4dc

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
101 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMRs_fault` has 188 nodes.

Section unmapPageTable (217 of 293)
===================================

Deriving specifications
-----------------------

Section `unmapPageTable` consists of 18 instructions.
Skipping ee072f3b mcr 15, 0, r2, cr7, cr11, {1}
Skipping f57ff05f dmb sy


Stack analysis
---------------

3 stack accesses found. Annotated code for `unmapPageTable`:

    0xe00113bc     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00113c0     0x4    mov r5, r0
    0xe00113c4     0x8    mov r4, r1
    0xe00113c8     0xc    mov r6, r2
    0xe00113cc    0x10    bl e0010f4c <pageTableMapped>
    0xe00113d0    0x14    cmp r0, #0
    0xe00113d4    0x18    popeq {r4, r5, r6, pc}  ; stack access
    0xe00113d8    0x1c    lsr r3, r4, #20
    0xe00113dc    0x20    add r2, r0, r3, lsl #2
    0xe00113e0    0x24    mov r1, #0
    0xe00113e4    0x28    str r1, [r0, r3, lsl #2]
    0xe00113e8    0x2c    mcr 15, 0, r2, cr7, cr11, {1}
    0xe00113ec    0x30    dmb sy
    0xe00113f0    0x34    mov r3, r6
    0xe00113f4    0x38    mov r2, r4
    0xe00113f8    0x3c    mov r1, r5
    0xe00113fc    0x40    bl e001136c <flushTable>
    0xe0011400    0x44    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unmapPageTable` has 28 nodes.

Section setVMRoot (218 of 293)
==============================

Deriving specifications
-----------------------

Section `setVMRoot` consists of 55 instructions.
Skipping f57ff04f dsb sy
Skipping ee023f10 mcr 15, 0, r3, cr2, cr0, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping ee023f10 mcr 15, 0, r3, cr2, cr0, {0}
Skipping f57ff06f isb sy
Skipping ee0d0f30 mcr 15, 0, r0, cr13, cr0, {1}
Skipping f57ff06f isb sy
Skipping ee023f10 mcr 15, 0, r3, cr2, cr0, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping ee023f10 mcr 15, 0, r3, cr2, cr0, {0}
Skipping f57ff06f isb sy


Stack analysis
---------------

4 stack accesses found. Annotated code for `setVMRoot`:

    0xe00110b8     0x0    bic r0, r0, #508 
    0xe00110bc     0x4    bic r0, r0, #3
    0xe00110c0     0x8    add r1, r0, #16
    0xe00110c4     0xc    ldr r3, [r0, #16]
    0xe00110c8    0x10    and r2, r3, #14
    0xe00110cc    0x14    cmp r2, #14
    0xe00110d0    0x18    andne r2, r3, #15
    0xe00110d4    0x1c    uxtbeq r2, r3
    0xe00110d8    0x20    cmp r2, #9
    0xe00110dc    0x24    beq e00110f8 <setVMRoot+0x40>
    0xe00110e0    0x28    dsb sy
    0xe00110e4    0x2c    ldr r3, [pc, #164] 
    0xe00110e8    0x30    orr r3, r3, #24
    0xe00110ec    0x34    mcr 15, 0, r3, cr2, cr0, {0}
    0xe00110f0    0x38    isb sy
    0xe00110f4    0x3c    bx lr
    0xe00110f8    0x40    tst r3, #16
    0xe00110fc    0x44    beq e00110e0 <setVMRoot+0x28>
    0xe0011100    0x48    push {r4, r5, lr}     ; stack access
    0xe0011104    0x4c    sub sp, sp, #12
    0xe0011108    0x50    bic r4, r3, #16320 
    0xe001110c    0x54    bic r4, r4, #63 
    0xe0011110    0x58    ldr r5, [r1, #4]
    0xe0011114    0x5c    ubfx r5, r5, #0, #17
    0xe0011118    0x60    mov r1, r5
    0xe001111c    0x64    mov r0, sp
    0xe0011120    0x68    bl e0010a84 <findPDForASID>
    0xe0011124    0x6c    ldr r3, [sp]          ; stack access
    0xe0011128    0x70    cmp r3, #0
    0xe001112c    0x74    bne e0011178 <setVMRoot+0xc0>
    0xe0011130    0x78    ldr r3, [sp, #4]      ; stack access
    0xe0011134    0x7c    cmp r3, r4
    0xe0011138    0x80    bne e0011178 <setVMRoot+0xc0>
    0xe001113c    0x84    mov r0, r5
    0xe0011140    0x88    bl e0011060 <getHWASID>
    0xe0011144    0x8c    dsb sy
    0xe0011148    0x90    ldr r3, [pc, #64] 
    0xe001114c    0x94    orr r3, r3, #24
    0xe0011150    0x98    mcr 15, 0, r3, cr2, cr0, {0}
    0xe0011154    0x9c    isb sy
    0xe0011158    0xa0    mcr 15, 0, r0, cr13, cr0, {1}
    0xe001115c    0xa4    isb sy
    0xe0011160    0xa8    add r3, r4, #805306368 
    0xe0011164    0xac    orr r3, r3, #24
    0xe0011168    0xb0    mcr 15, 0, r3, cr2, cr0, {0}
    0xe001116c    0xb4    isb sy
    0xe0011170    0xb8    add sp, sp, #12
    0xe0011174    0xbc    pop {r4, r5, pc}      ; stack access
    0xe0011178    0xc0    dsb sy
    0xe001117c    0xc4    ldr r3, [pc, #12] 
    0xe0011180    0xc8    orr r3, r3, #24
    0xe0011184    0xcc    mcr 15, 0, r3, cr2, cr0, {0}
    0xe0011188    0xd0    isb sy
    0xe001118c    0xd4    b e0011170 <setVMRoot+0xb8>
    0xe0011190    0xd8    .word 0x10024000

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
54 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setVMRoot` has 88 nodes.

Section getHWASID (219 of 293)
==============================

Deriving specifications
-----------------------

Section `getHWASID` consists of 22 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `getHWASID`:

    0xe0011060     0x0    push {r4, lr}         ; stack access
    0xe0011064     0x4    mov r4, r0
    0xe0011068     0x8    bl e0010868 <loadHWASID>
    0xe001106c     0xc    tst r0, #8388608 
    0xe0011070    0x10    beq e001107c <getHWASID+0x1c>
    0xe0011074    0x14    lsr r0, r0, #24
    0xe0011078    0x18    pop {r4, pc}          ; stack access
    0xe001107c    0x1c    bl e0010fb8 <findFreeHWASID>
    0xe0011080    0x20    movw r3, #37576 
    0xe0011084    0x24    movt r3, #57346 
    0xe0011088    0x28    lsr r2, r4, #10
    0xe001108c    0x2c    ldr r3, [r3, r2, lsl #2]
    0xe0011090    0x30    ubfx r2, r4, #0, #10
    0xe0011094    0x34    ldr r3, [r3, r2, lsl #2]
    0xe0011098    0x38    add r3, r3, #12288 
    0xe001109c    0x3c    lsl r2, r0, #24
    0xe00110a0    0x40    orr r2, r2, #8388608 
    0xe00110a4    0x44    str r2, [r3, #4032] 
    0xe00110a8    0x48    movw r3, #12872 
    0xe00110ac    0x4c    movt r3, #57347 
    0xe00110b0    0x50    str r4, [r3, r0, lsl #2]
    0xe00110b4    0x54    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getHWASID` has 33 nodes.

Section handleFaultReply (220 of 293)
=====================================

Deriving specifications
-----------------------

Section `handleFaultReply` consists of 120 instructions.
 BICHI (imm)....+++
 ORRHI (imm)....+++


Stack analysis
---------------

5 stack accesses found. Annotated code for `handleFaultReply`:

    0xe0010c28      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0010c2c      0x4    mov r5, r0
    0xe0010c30      0x8    ldr r3, [r1, #4]
    0xe0010c34      0xc    and r2, r3, #127 
    0xe0010c38     0x10    cmp r2, #120 
    0xe0010c3c     0x14    bichi r3, r3, #127 
    0xe0010c40     0x18    orrhi r3, r3, #120 
    0xe0010c44     0x1c    lsr r6, r3, #12
    0xe0010c48     0x20    and r3, r3, #127 
    0xe0010c4c     0x24    ldr r2, [r0, #96] 
    0xe0010c50     0x28    and r2, r2, #15
    0xe0010c54     0x2c    cmp r2, #2
    0xe0010c58     0x30    beq e0010c7c <handleFaultReply+0x54>
    0xe0010c5c     0x34    cmp r2, #3
    0xe0010c60     0x38    beq e0010d38 <handleFaultReply+0x110>
    0xe0010c64     0x3c    cmp r2, #1
    0xe0010c68     0x40    beq e0010df8 <handleFaultReply+0x1d0>
    0xe0010c6c     0x44    cmp r2, #5
    0xe0010c70     0x48    bne e0010df4 <handleFaultReply+0x1cc>
    0xe0010c74     0x4c    mov r0, #1
    0xe0010c78     0x50    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0010c7c     0x54    cmp r3, #12
    0xe0010c80     0x58    movcc r7, r3
    0xe0010c84     0x5c    movcs r7, #12
    0xe0010c88     0x60    cmp r3, #4
    0xe0010c8c     0x64    movcc ip, r3
    0xe0010c90     0x68    movcs ip, #4
    0xe0010c94     0x6c    cmp r3, #0
    0xe0010c98     0x70    beq e0010d2c <handleFaultReply+0x104>
    0xe0010c9c     0x74    ldr r3, [r1, #8]
    0xe0010ca0     0x78    mov r4, #0
    0xe0010ca4     0x7c    mov r2, r4
    0xe0010ca8     0x80    movw r0, #46284 
    0xe0010cac     0x84    movt r0, #57345 
    0xe0010cb0     0x88    add lr, r0, #96 
    0xe0010cb4     0x8c    b e0010cd0 <handleFaultReply+0xa8>
    0xe0010cb8     0x90    ldr r2, [r0, r4, lsl #2]
    0xe0010cbc     0x94    ldr r3, [lr, r4, lsl #2]
    0xe0010cc0     0x98    ldr r3, [r1, r3, lsl #2]
    0xe0010cc4     0x9c    cmp r2, #16
    0xe0010cc8     0xa0    andeq r3, r3, #-134217728 
    0xe0010ccc     0xa4    orreq r3, r3, #336 
    0xe0010cd0     0xa8    str r3, [r5, r2, lsl #2]
    0xe0010cd4     0xac    add r4, r4, #1
    0xe0010cd8     0xb0    cmp r4, ip
    0xe0010cdc     0xb4    bcc e0010cb8 <handleFaultReply+0x90>
    0xe0010ce0     0xb8    cmp r7, r4
    0xe0010ce4     0xbc    bls e0010d2c <handleFaultReply+0x104>
    0xe0010ce8     0xc0    mov r0, #0
    0xe0010cec     0xc4    bl e0010b04 <lookupIPCBuffer>
    0xe0010cf0     0xc8    cmp r0, #0
    0xe0010cf4     0xcc    beq e0010d2c <handleFaultReply+0x104>
    0xe0010cf8     0xd0    lsl r4, r4, #2
    0xe0010cfc     0xd4    ldr r1, [pc, #252] 
    0xe0010d00     0xd8    add r1, r4, r1
    0xe0010d04     0xdc    add r4, r0, r4
    0xe0010d08     0xe0    add r7, r0, r7, lsl #2
    0xe0010d0c     0xe4    ldr r2, [r1, #4]!
    0xe0010d10     0xe8    ldr r3, [r4, #4]!
    0xe0010d14     0xec    cmp r2, #16
    0xe0010d18     0xf0    andeq r3, r3, #-134217728 
    0xe0010d1c     0xf4    orreq r3, r3, #336 
    0xe0010d20     0xf8    str r3, [r5, r2, lsl #2]
    0xe0010d24     0xfc    cmp r7, r4
    0xe0010d28    0x100    bne e0010d0c <handleFaultReply+0xe4>
    0xe0010d2c    0x104    clz r0, r6
    0xe0010d30    0x108    lsr r0, r0, #5
    0xe0010d34    0x10c    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0010d38    0x110    cmp r3, #3
    0xe0010d3c    0x114    movcc r4, r3
    0xe0010d40    0x118    movcs r4, #3
    0xe0010d44    0x11c    mov lr, r4
    0xe0010d48    0x120    cmp r3, #0
    0xe0010d4c    0x124    beq e0010de8 <handleFaultReply+0x1c0>
    0xe0010d50    0x128    ldr r2, [r1, #8]
    0xe0010d54    0x12c    ldr ip, [pc, #168] 
    0xe0010d58    0x130    mov r7, #0
    0xe0010d5c    0x134    mov r0, #17
    0xe0010d60    0x138    add r8, ip, #44 
    0xe0010d64    0x13c    b e0010d84 <handleFaultReply+0x15c>
    0xe0010d68    0x140    ldr r0, [ip], #4
    0xe0010d6c    0x144    ldr r2, [r8, r3, lsl #2]
    0xe0010d70    0x148    ldr r2, [r1, r2, lsl #2]
    0xe0010d74    0x14c    cmp r0, #16
    0xe0010d78    0x150    andeq r2, r2, #-134217728 
    0xe0010d7c    0x154    orreq r2, r2, #336 
    0xe0010d80    0x158    mov r7, r3
    0xe0010d84    0x15c    str r2, [r5, r0, lsl #2]
    0xe0010d88    0x160    add r3, r7, #1
    0xe0010d8c    0x164    cmp r3, lr
    0xe0010d90    0x168    bcc e0010d68 <handleFaultReply+0x140>
    0xe0010d94    0x16c    cmp r4, r3
    0xe0010d98    0x170    bls e0010de8 <handleFaultReply+0x1c0>
    0xe0010d9c    0x174    mov r0, #0
    0xe0010da0    0x178    bl e0010b04 <lookupIPCBuffer>
    0xe0010da4    0x17c    cmp r0, #0
    0xe0010da8    0x180    beq e0010de8 <handleFaultReply+0x1c0>
    0xe0010dac    0x184    add r3, r7, #13
    0xe0010db0    0x188    lsl r3, r3, #2
    0xe0010db4    0x18c    ldr ip, [pc, #68] 
    0xe0010db8    0x190    add ip, r3, ip
    0xe0010dbc    0x194    sub r3, r3, #48 
    0xe0010dc0    0x198    add r3, r0, r3
    0xe0010dc4    0x19c    add r4, r0, r4, lsl #2
    0xe0010dc8    0x1a0    ldr r1, [ip, #4]!
    0xe0010dcc    0x1a4    ldr r2, [r3, #4]!
    0xe0010dd0    0x1a8    cmp r1, #16
    0xe0010dd4    0x1ac    andeq r2, r2, #-134217728 
    0xe0010dd8    0x1b0    orreq r2, r2, #336 
    0xe0010ddc    0x1b4    str r2, [r5, r1, lsl #2]
    0xe0010de0    0x1b8    cmp r3, r4
    0xe0010de4    0x1bc    bne e0010dc8 <handleFaultReply+0x1a0>
    0xe0010de8    0x1c0    clz r0, r6
    0xe0010dec    0x1c4    lsr r0, r0, #5
    0xe0010df0    0x1c8    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0010df4    0x1cc    bl e0010904 <halt>
    0xe0010df8    0x1d0    mov r0, #1
    0xe0010dfc    0x1d4    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0010e00    0x1d8    .word 0xe001b4c8
    0xe0010e04    0x1dc    .word 0xe001b500

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
118 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleFaultReply` has 204 nodes.

Section makeUserPDE (221 of 293)
================================

Deriving specifications
-----------------------

Section `makeUserPDE` consists of 55 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `makeUserPDE`:

    0xe0010954     0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0010958     0x4    mov r8, r0
    0xe001095c     0x8    mov r6, r1
    0xe0010960     0xc    mov r5, r2
    0xe0010964    0x10    mov r9, r3
    0xe0010968    0x14    ldr r4, [sp, #32]     ; stack access
    0xe001096c    0x18    ldr r7, [sp, #36]     ; stack access
    0xe0010970    0x1c    ldr r0, [sp, #40]     ; stack access
    0xe0010974    0x20    bl e0010910 <APFromVMRights>
    0xe0010978    0x24    cmp r8, #2
    0xe001097c    0x28    beq e00109e0 <makeUserPDE+0x8c>
    0xe0010980    0x2c    cmp r8, #3
    0xe0010984    0x30    bne e00109dc <makeUserPDE+0x88>
    0xe0010988    0x34    mov r2, #1
    0xe001098c    0x38    cmp r9, #0
    0xe0010990    0x3c    bne e00109e8 <makeUserPDE+0x94>
    0xe0010994    0x40    lsl r3, r4, #4
    0xe0010998    0x44    and r3, r3, #16
    0xe001099c    0x48    orr r3, r3, #196608 
    0xe00109a0    0x4c    orr r3, r3, #2
    0xe00109a4    0x50    lsl r7, r7, #5
    0xe00109a8    0x54    and r7, r7, #480 
    0xe00109ac    0x58    orr r3, r3, r7
    0xe00109b0    0x5c    lsr r6, r6, #20
    0xe00109b4    0x60    lsl r6, r6, #20
    0xe00109b8    0x64    orr r3, r3, r6
    0xe00109bc    0x68    lsl r5, r5, #9
    0xe00109c0    0x6c    and r5, r5, #512 
    0xe00109c4    0x70    orr r3, r3, r5
    0xe00109c8    0x74    lsl r0, r0, #10
    0xe00109cc    0x78    and r0, r0, #3072 
    0xe00109d0    0x7c    orr r3, r3, r0
    0xe00109d4    0x80    orr r0, r3, r2, lsl #18
    0xe00109d8    0x84    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe00109dc    0x88    bl e0010904 <halt>
    0xe00109e0    0x8c    mov r2, #0
    0xe00109e4    0x90    b e001098c <makeUserPDE+0x38>
    0xe00109e8    0x94    lsl r4, r4, #4
    0xe00109ec    0x98    and r4, r4, #16
    0xe00109f0    0x9c    orr r4, r4, #151552 
    0xe00109f4    0xa0    orr r4, r4, #6
    0xe00109f8    0xa4    lsl r7, r7, #5
    0xe00109fc    0xa8    and r7, r7, #480 
    0xe0010a00    0xac    orr r4, r4, r7
    0xe0010a04    0xb0    lsr r6, r6, #20
    0xe0010a08    0xb4    lsl r6, r6, #20
    0xe0010a0c    0xb8    orr r4, r4, r6
    0xe0010a10    0xbc    lsl r5, r5, #9
    0xe0010a14    0xc0    and r5, r5, #512 
    0xe0010a18    0xc4    orr r4, r4, r5
    0xe0010a1c    0xc8    lsl r0, r0, #10
    0xe0010a20    0xcc    and r0, r0, #3072 
    0xe0010a24    0xd0    orr r4, r4, r0
    0xe0010a28    0xd4    orr r0, r4, r2, lsl #18
    0xe0010a2c    0xd8    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
55 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `makeUserPDE` has 69 nodes.

Section c_handle_instruction_fault (222 of 293)
===============================================

Deriving specifications
-----------------------

Section `c_handle_instruction_fault` consists of 15 instructions.
Skipping ee1d2f50 mrc 15, 0, r2, cr13, cr0, {2}
Skipping ee1d2f70 mrc 15, 0, r2, cr13, cr0, {3}
 MSR (cpsr, imm) NOP.+


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_instruction_fault`:

    0xe00101a4     0x0    push {r4, lr}         ; stack access
    0xe00101a8     0x4    movw r3, #13900 
    0xe00101ac     0x8    movt r3, #57347 
    0xe00101b0     0xc    ldr r3, [r3]
    0xe00101b4    0x10    mrc 15, 0, r2, cr13, cr0, {2}
    0xe00101b8    0x14    str r2, [r3, #72] 
    0xe00101bc    0x18    mrc 15, 0, r2, cr13, cr0, {3}
    0xe00101c0    0x1c    str r2, [r3, #76] 
    0xe00101c4    0x20    mov r0, #1
    0xe00101c8    0x24    bl e00173e4 <handleVMFaultEvent>
    0xe00101cc    0x28    bl e00108d8 <restore_user_context>
    0xe00101d0    0x2c    nop {0}
    0xe00101d4    0x30    nop {0}
    0xe00101d8    0x34    nop {0}
    0xe00101dc    0x38    nop {0}

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_instruction_fault` has 23 nodes.

Section c_handle_data_fault (223 of 293)
========================================

Deriving specifications
-----------------------

Section `c_handle_data_fault` consists of 11 instructions.
Skipping ee1d2f50 mrc 15, 0, r2, cr13, cr0, {2}
Skipping ee1d2f70 mrc 15, 0, r2, cr13, cr0, {3}


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_data_fault`:

    0xe0010178     0x0    push {r4, lr}         ; stack access
    0xe001017c     0x4    movw r3, #13900 
    0xe0010180     0x8    movt r3, #57347 
    0xe0010184     0xc    ldr r3, [r3]
    0xe0010188    0x10    mrc 15, 0, r2, cr13, cr0, {2}
    0xe001018c    0x14    str r2, [r3, #72] 
    0xe0010190    0x18    mrc 15, 0, r2, cr13, cr0, {3}
    0xe0010194    0x1c    str r2, [r3, #76] 
    0xe0010198    0x20    mov r0, #0
    0xe001019c    0x24    bl e00173e4 <handleVMFaultEvent>
    0xe00101a0    0x28    bl e00108d8 <restore_user_context>

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_data_fault` has 19 nodes.

Section c_handle_undefined_instruction (224 of 293)
===================================================

Deriving specifications
-----------------------

Section `c_handle_undefined_instruction` consists of 12 instructions.
Skipping ee1d2f50 mrc 15, 0, r2, cr13, cr0, {2}
Skipping ee1d2f70 mrc 15, 0, r2, cr13, cr0, {3}


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_undefined_instruction`:

    0xe0010148     0x0    push {r4, lr}         ; stack access
    0xe001014c     0x4    movw r3, #13900 
    0xe0010150     0x8    movt r3, #57347 
    0xe0010154     0xc    ldr r3, [r3]
    0xe0010158    0x10    mrc 15, 0, r2, cr13, cr0, {2}
    0xe001015c    0x14    str r2, [r3, #72] 
    0xe0010160    0x18    mrc 15, 0, r2, cr13, cr0, {3}
    0xe0010164    0x1c    str r2, [r3, #76] 
    0xe0010168    0x20    mov r1, #0
    0xe001016c    0x24    mov r0, r1
    0xe0010170    0x28    bl e00173a8 <handleUserLevelFault>
    0xe0010174    0x2c    bl e00108d8 <restore_user_context>

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_undefined_instruction` has 20 nodes.

Section c_handle_interrupt (225 of 293)
=======================================

Deriving specifications
-----------------------

Section `c_handle_interrupt` consists of 10 instructions.
Skipping ee1d2f50 mrc 15, 0, r2, cr13, cr0, {2}
Skipping ee1d2f70 mrc 15, 0, r2, cr13, cr0, {3}


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_interrupt`:

    0xe0010120     0x0    push {r4, lr}         ; stack access
    0xe0010124     0x4    movw r3, #13900 
    0xe0010128     0x8    movt r3, #57347 
    0xe001012c     0xc    ldr r3, [r3]
    0xe0010130    0x10    mrc 15, 0, r2, cr13, cr0, {2}
    0xe0010134    0x14    str r2, [r3, #72] 
    0xe0010138    0x18    mrc 15, 0, r2, cr13, cr0, {3}
    0xe001013c    0x1c    str r2, [r3, #76] 
    0xe0010140    0x20    bl e0016a64 <handleInterruptEntry>
    0xe0010144    0x24    bl e00108d8 <restore_user_context>

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_interrupt` has 18 nodes.

Section arm_data_abort_exception (226 of 293)
=============================================

Deriving specifications
-----------------------

Section `arm_data_abort_exception` consists of 10 instructions.
Skipping f8cd0513 srsia sp, #19
Skipping f1020013 cps #19
Skipping e94d7fff stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
 LDMIA;9,8...+
Skipping ee1ddf90 mrc 15, 0, sp, cr13, cr0, {4}


Stack analysis
---------------

2 stack accesses found. Annotated code for `arm_data_abort_exception`:

    0xe00100b8     0x0    srsia sp, #19
    0xe00100bc     0x4    cps #19
    0xe00100c0     0x8    stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    0xe00100c4     0xc    ldm sp, {r8, r9}      ; stack access
    0xe00100c8    0x10    tst r9, #15
    0xe00100cc    0x14    sub r8, r8, #8
    0xe00100d0    0x18    bne e00100e0 <kernel_data_fault>
    0xe00100d4    0x1c    str r8, [sp, #8]      ; stack access
    0xe00100d8    0x20    mrc 15, 0, sp, cr13, cr0, {4}
    0xe00100dc    0x24    b e0010178 <c_handle_data_fault>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_data_abort_exception` has 21 nodes.

Section arm_prefetch_abort_exception (227 of 293)
=================================================

Deriving specifications
-----------------------

Section `arm_prefetch_abort_exception` consists of 10 instructions.
Skipping f8cd0513 srsia sp, #19
Skipping f1020013 cps #19
Skipping e94d7fff stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
Skipping ee1ddf90 mrc 15, 0, sp, cr13, cr0, {4}


Stack analysis
---------------

2 stack accesses found. Annotated code for `arm_prefetch_abort_exception`:

    0xe0010088     0x0    srsia sp, #19
    0xe001008c     0x4    cps #19
    0xe0010090     0x8    stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    0xe0010094     0xc    ldm sp, {r8, r9}      ; stack access
    0xe0010098    0x10    tst r9, #15
    0xe001009c    0x14    sub r8, r8, #4
    0xe00100a0    0x18    bne e00100b0 <kernel_prefetch_fault>
    0xe00100a4    0x1c    str r8, [sp, #8]      ; stack access
    0xe00100a8    0x20    mrc 15, 0, sp, cr13, cr0, {4}
    0xe00100ac    0x24    b e00101a4 <c_handle_instruction_fault>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_prefetch_abort_exception` has 21 nodes.

Section create_frames_of_region (228 of 293)
============================================

Deriving specifications
-----------------------

Section `create_frames_of_region` consists of 68 instructions.


Stack analysis
---------------

Section `create_frames_of_region` expects pointer to stack in r0.
25 stack accesses found. Annotated code for `create_frames_of_region`:

    0xe00019a8      0x0    sub sp, sp, #8
    0xe00019ac      0x4    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00019b0      0x8    sub sp, sp, #44 
    0xe00019b4      0xc    mov r9, r0
    0xe00019b8     0x10    add r0, sp, #24
    0xe00019bc     0x14    stm r0, {r1, r2}      ; stack access
    0xe00019c0     0x18    str r3, [sp, #84]     ; stack access
    0xe00019c4     0x1c    ldr r7, [sp, #100]    ; stack access
    0xe00019c8     0x20    ldr sl, [sp, #104]    ; stack access
    0xe00019cc     0x24    ldr r6, [sp, #96]     ; stack access
    0xe00019d0     0x28    movw r3, #47104 
    0xe00019d4     0x2c    movt r3, #57345 
    0xe00019d8     0x30    ldr r3, [r3, #128] 
    0xe00019dc     0x34    str r3, [sp, #20]     ; stack access
    0xe00019e0     0x38    ldr r4, [sp, #92]     ; stack access
    0xe00019e4     0x3c    cmp r6, r4
    0xe00019e8     0x40    bls e0001a84 <create_frames_of_region+0xdc>
    0xe00019ec     0x44    mov fp, #3145728 
    0xe00019f0     0x48    add r5, sp, #32
    0xe00019f4     0x4c    mov r8, #1
    0xe00019f8     0x50    b e0001a34 <create_frames_of_region+0x8c>
    0xe00019fc     0x54    lsr r3, r4, #8
    0xe0001a00     0x58    bic r3, r3, #15
    0xe0001a04     0x5c    orr r3, r3, #1
    0xe0001a08     0x60    str r3, [sp, #32]     ; stack access
    0xe0001a0c     0x64    str fp, [sp, #36]     ; stack access
    0xe0001a10     0x68    ldm r5, {r2, r3}      ; stack access
    0xe0001a14     0x6c    add r1, sp, #24
    0xe0001a18     0x70    ldm r1, {r0, r1}      ; stack access
    0xe0001a1c     0x74    bl e00013e4 <provide_cap>
    0xe0001a20     0x78    cmp r0, #0
    0xe0001a24     0x7c    beq e0001a70 <create_frames_of_region+0xc8>
    0xe0001a28     0x80    add r4, r4, #4096 
    0xe0001a2c     0x84    cmp r6, r4
    0xe0001a30     0x88    bls e0001a84 <create_frames_of_region+0xdc>
    0xe0001a34     0x8c    cmp r7, #0
    0xe0001a38     0x90    beq e00019fc <create_frames_of_region+0x54>
    0xe0001a3c     0x94    str r8, [sp, #12]     ; stack access
    0xe0001a40     0x98    mov r3, #0
    0xe0001a44     0x9c    str r3, [sp, #8]      ; stack access
    0xe0001a48     0xa0    str r8, [sp, #4]      ; stack access
    0xe0001a4c     0xa4    rsb r3, sl, #805306368 
    0xe0001a50     0xa8    add r3, r3, r4
    0xe0001a54     0xac    str r3, [sp]          ; stack access
    0xe0001a58     0xb0    mov r3, r4
    0xe0001a5c     0xb4    add r2, sp, #84 
    0xe0001a60     0xb8    ldm r2, {r1, r2}      ; stack access
    0xe0001a64     0xbc    mov r0, r5
    0xe0001a68     0xc0    bl e0000408 <create_mapped_it_frame_cap>
    0xe0001a6c     0xc4    b e0001a10 <create_frames_of_region+0x68>
    0xe0001a70     0xc8    mov r3, #0
    0xe0001a74     0xcc    str r3, [r9]          ; stack access
    0xe0001a78     0xd0    str r3, [r9, #4]      ; stack access
    0xe0001a7c     0xd4    str r3, [r9, #8]      ; stack access
    0xe0001a80     0xd8    b e0001aa4 <create_frames_of_region+0xfc>
    0xe0001a84     0xdc    movw r3, #47104 
    0xe0001a88     0xe0    movt r3, #57345 
    0xe0001a8c     0xe4    ldr r3, [r3, #128] 
    0xe0001a90     0xe8    ldr r2, [sp, #20]     ; stack access
    0xe0001a94     0xec    str r2, [r9]          ; stack access
    0xe0001a98     0xf0    str r3, [r9, #4]      ; stack access
    0xe0001a9c     0xf4    mov r3, #1
    0xe0001aa0     0xf8    str r3, [r9, #8]      ; stack access
    0xe0001aa4     0xfc    mov r0, r9
    0xe0001aa8    0x100    add sp, sp, #44 
    0xe0001aac    0x104    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0001ab0    0x108    add sp, sp, #8
    0xe0001ab4    0x10c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
68 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_frames_of_region` has 106 nodes.

Section map_kernel_devices (229 of 293)
=======================================

Deriving specifications
-----------------------

Section `map_kernel_devices` consists of 31 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `map_kernel_devices`:

    0xe0000d20     0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0000d24     0x4    sub sp, sp, #8
    0xe0000d28     0x8    movw r6, #17216 
    0xe0000d2c     0xc    movt r6, #57344 
    0xe0000d30    0x10    add r4, r6, #8
    0xe0000d34    0x14    add r6, r6, #56 
    0xe0000d38    0x18    mov r7, #1
    0xe0000d3c    0x1c    mov r8, sp
    0xe0000d40    0x20    b e0000d50 <map_kernel_devices+0x30>
    0xe0000d44    0x24    add r4, r4, #16
    0xe0000d48    0x28    cmp r4, r6
    0xe0000d4c    0x2c    beq e0000d94 <map_kernel_devices+0x74>
    0xe0000d50    0x30    ldr r5, [r4]
    0xe0000d54    0x34    ldr r3, [r4, #8]
    0xe0000d58    0x38    lsl r3, r3, #2
    0xe0000d5c    0x3c    and r3, r3, #4
    0xe0000d60    0x40    mov r2, r7
    0xe0000d64    0x44    ldr r1, [r4, #4]
    0xe0000d68    0x48    mov r0, r5
    0xe0000d6c    0x4c    bl e0000334 <map_kernel_frame>
    0xe0000d70    0x50    ldr r3, [r4, #12]
    0xe0000d74    0x54    cmp r3, #0
    0xe0000d78    0x58    bne e0000d44 <map_kernel_devices+0x24>
    0xe0000d7c    0x5c    str r5, [sp]          ; stack access
    0xe0000d80    0x60    add r5, r5, #4096 
    0xe0000d84    0x64    str r5, [sp, #4]      ; stack access
    0xe0000d88    0x68    ldm r8, {r0, r1}      ; stack access
    0xe0000d8c    0x6c    bl e0000b7c <reserve_region>
    0xe0000d90    0x70    b e0000d44 <map_kernel_devices+0x24>
    0xe0000d94    0x74    add sp, sp, #8
    0xe0000d98    0x78    pop {r4, r5, r6, r7, r8, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
31 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_devices` has 46 nodes.

Section activate_global_pd (230 of 293)
=======================================

Deriving specifications
-----------------------

Section `activate_global_pd` consists of 19 instructions.
Skipping f57ff04f dsb sy
Skipping ee023f10 mcr 15, 0, r3, cr2, cr0, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping ee083f17 mcr 15, 0, r3, cr8, cr7, {0}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `activate_global_pd`:

    0xe00009bc     0x0    push {r4, lr}         ; stack access
    0xe00009c0     0x4    bl e001288c <cleanInvalidateL1Caches>
    0xe00009c4     0x8    dsb sy
    0xe00009c8     0xc    ldr r3, [pc, #52] 
    0xe00009cc    0x10    orr r3, r3, #24
    0xe00009d0    0x14    mcr 15, 0, r3, cr2, cr0, {0}
    0xe00009d4    0x18    isb sy
    0xe00009d8    0x1c    dsb sy
    0xe00009dc    0x20    mov r3, #0
    0xe00009e0    0x24    mcr 15, 0, r3, cr8, cr7, {0}
    0xe00009e4    0x28    dsb sy
    0xe00009e8    0x2c    isb sy
    0xe00009ec    0x30    mov r0, #-536870912 
    0xe00009f0    0x34    bl e0011f18 <lockTLBEntry>
    0xe00009f4    0x38    mov r0, #0
    0xe00009f8    0x3c    movt r0, #65535 
    0xe00009fc    0x40    bl e0011f18 <lockTLBEntry>
    0xe0000a00    0x44    pop {r4, pc}          ; stack access
    0xe0000a04    0x48    .word 0x10024000

Proving inst theorems
---------------------

18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `activate_global_pd` has 30 nodes.

Section slowpath (231 of 293)
=============================

Deriving specifications
-----------------------

Section `slowpath` consists of 7 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `slowpath`:

    0xe001b2f4     0x0    push {r4, lr}         ; stack access
    0xe001b2f8     0x4    cmn r0, #9
    0xe001b2fc     0x8    bls e001b308 <slowpath+0x14>
    0xe001b300     0xc    bl e001b11c <handleSyscall>
    0xe001b304    0x10    bl e00108d8 <restore_user_context>
    0xe001b308    0x14    bl e0017370 <handleUnknownSyscall>
    0xe001b30c    0x18    b e001b304 <slowpath+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `slowpath` has 13 nodes.

Section invokeTCB_ReadRegisters (232 of 293)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_ReadRegisters` consists of 91 instructions.
 TST (reg).....++
 CMPLS (reg)......+++


Stack analysis
---------------

3 stack accesses found. Annotated code for `invokeTCB_ReadRegisters`:

    0xe00186b4      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00186b8      0x4    mov r6, r0
    0xe00186bc      0x8    mov r4, r2
    0xe00186c0      0xc    movw r3, #13900 
    0xe00186c4     0x10    movt r3, #57347 
    0xe00186c8     0x14    ldr r5, [r3]
    0xe00186cc     0x18    cmp r1, #0
    0xe00186d0     0x1c    bne e0018794 <invokeTCB_ReadRegisters+0xe0>
    0xe00186d4     0x20    ldr r3, [sp, #16]     ; stack access
    0xe00186d8     0x24    cmp r3, #0
    0xe00186dc     0x28    beq e0018780 <invokeTCB_ReadRegisters+0xcc>
    0xe00186e0     0x2c    mov r1, r5
    0xe00186e4     0x30    mov r0, #1
    0xe00186e8     0x34    bl e0010b04 <lookupIPCBuffer>
    0xe00186ec     0x38    mov r3, #0
    0xe00186f0     0x3c    str r3, [r5]
    0xe00186f4     0x40    cmp r4, r3
    0xe00186f8     0x44    moveq r2, r4
    0xe00186fc     0x48    beq e0018774 <invokeTCB_ReadRegisters+0xc0>
    0xe0018700     0x4c    movw r3, #46284 
    0xe0018704     0x50    movt r3, #57345 
    0xe0018708     0x54    add ip, r3, #96 
    0xe001870c     0x58    add r3, r3, #136 
    0xe0018710     0x5c    mov r2, #0
    0xe0018714     0x60    ldr r1, [ip], #4
    0xe0018718     0x64    ldr lr, [r3], #4
    0xe001871c     0x68    ldr lr, [r6, lr, lsl #2]
    0xe0018720     0x6c    str lr, [r5, r1, lsl #2]
    0xe0018724     0x70    add r2, r2, #1
    0xe0018728     0x74    cmp r4, r2
    0xe001872c     0x78    movls r1, #0
    0xe0018730     0x7c    movhi r1, #1
    0xe0018734     0x80    cmp r2, #3
    0xe0018738     0x84    movhi lr, #0
    0xe001873c     0x88    andls lr, r1, #1
    0xe0018740     0x8c    cmp lr, #0
    0xe0018744     0x90    bne e0018714 <invokeTCB_ReadRegisters+0x60>
    0xe0018748     0x94    cmp r2, #9
    0xe001874c     0x98    movhi r3, #0
    0xe0018750     0x9c    movls r3, #1
    0xe0018754     0xa0    cmp r0, #0
    0xe0018758     0xa4    movne ip, r1
    0xe001875c     0xa8    moveq ip, #0
    0xe0018760     0xac    tst r3, ip
    0xe0018764     0xb0    bne e001879c <invokeTCB_ReadRegisters+0xe8>
    0xe0018768     0xb4    cmp r0, #0
    0xe001876c     0xb8    moveq r4, #0
    0xe0018770     0xbc    bne e00187d4 <invokeTCB_ReadRegisters+0x120>
    0xe0018774     0xc0    add r2, r2, r4
    0xe0018778     0xc4    and r2, r2, #127 
    0xe001877c     0xc8    str r2, [r5, #4]
    0xe0018780     0xcc    mov r1, #1
    0xe0018784     0xd0    mov r0, r5
    0xe0018788     0xd4    bl e0014ad8 <setThreadState>
    0xe001878c     0xd8    mov r0, #0
    0xe0018790     0xdc    pop {r4, r5, r6, pc}  ; stack access
    0xe0018794     0xe0    bl e001584c <suspend>
    0xe0018798     0xe4    b e00186d4 <invokeTCB_ReadRegisters+0x20>
    0xe001879c     0xe8    tst r1, r3
    0xe00187a0     0xec    beq e0018768 <invokeTCB_ReadRegisters+0xb4>
    0xe00187a4     0xf0    lsl r3, r2, #2
    0xe00187a8     0xf4    ldr r1, [pc, #104] 
    0xe00187ac     0xf8    add r1, r3, r1
    0xe00187b0     0xfc    add r3, r0, r3
    0xe00187b4    0x100    add r2, r2, #1
    0xe00187b8    0x104    ldr ip, [r1, #4]!
    0xe00187bc    0x108    ldr ip, [r6, ip, lsl #2]
    0xe00187c0    0x10c    str ip, [r3, #4]!
    0xe00187c4    0x110    cmp r2, #9
    0xe00187c8    0x114    cmpls r2, r4
    0xe00187cc    0x118    bcc e00187b4 <invokeTCB_ReadRegisters+0x100>
    0xe00187d0    0x11c    b e0018768 <invokeTCB_ReadRegisters+0xb4>
    0xe00187d4    0x120    cmp r4, #10
    0xe00187d8    0x124    movls r4, #0
    0xe00187dc    0x128    bls e0018774 <invokeTCB_ReadRegisters+0xc0>
    0xe00187e0    0x12c    ldr r3, [r6, #8]
    0xe00187e4    0x130    str r3, [r0, #44]! 
    0xe00187e8    0x134    ldr r3, [pc, #44] 
    0xe00187ec    0x138    sub ip, r4, #10
    0xe00187f0    0x13c    mov r4, #1
    0xe00187f4    0x140    cmp ip, r4
    0xe00187f8    0x144    beq e0018774 <invokeTCB_ReadRegisters+0xc0>
    0xe00187fc    0x148    ldr r1, [r3], #4
    0xe0018800    0x14c    ldr r1, [r6, r1, lsl #2]
    0xe0018804    0x150    str r1, [r0, #4]!
    0xe0018808    0x154    add r4, r4, #1
    0xe001880c    0x158    cmp r4, #9
    0xe0018810    0x15c    bne e00187f4 <invokeTCB_ReadRegisters+0x140>
    0xe0018814    0x160    b e0018774 <invokeTCB_ReadRegisters+0xc0>
    0xe0018818    0x164    .word 0xe001b550
    0xe001881c    0x168    .word 0xe001b580

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
89 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_ReadRegisters` has 156 nodes.

Section invokeTCB_CopyRegisters (233 of 293)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_CopyRegisters` consists of 49 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `invokeTCB_CopyRegisters`:

    0xe0018520     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0018524     0x4    mov r4, r0
    0xe0018528     0x8    mov r5, r1
    0xe001852c     0xc    mov r6, r3
    0xe0018530    0x10    cmp r2, #0
    0xe0018534    0x14    bne e00185c4 <invokeTCB_CopyRegisters+0xa4>
    0xe0018538    0x18    cmp r6, #0
    0xe001853c    0x1c    bne e00185d0 <invokeTCB_CopyRegisters+0xb0>
    0xe0018540    0x20    ldr r3, [sp, #16]     ; stack access
    0xe0018544    0x24    cmp r3, #0
    0xe0018548    0x28    beq e0018578 <invokeTCB_CopyRegisters+0x58>
    0xe001854c    0x2c    movw r0, #46284 
    0xe0018550    0x30    movt r0, #57345 
    0xe0018554    0x34    add r3, r0, #136 
    0xe0018558    0x38    add r0, r0, #176 
    0xe001855c    0x3c    ldr r2, [r3], #4
    0xe0018560    0x40    ldr r1, [r5, r2, lsl #2]
    0xe0018564    0x44    str r1, [r4, r2, lsl #2]
    0xe0018568    0x48    cmp r3, r0
    0xe001856c    0x4c    bne e001855c <invokeTCB_CopyRegisters+0x3c>
    0xe0018570    0x50    ldr r3, [r4, #68] 
    0xe0018574    0x54    str r3, [r4, #60] 
    0xe0018578    0x58    ldr r3, [sp, #20]     ; stack access
    0xe001857c    0x5c    cmp r3, #0
    0xe0018580    0x60    beq e00185a8 <invokeTCB_CopyRegisters+0x88>
    0xe0018584    0x64    movw r0, #46284 
    0xe0018588    0x68    movt r0, #57345 
    0xe001858c    0x6c    add r3, r0, #172 
    0xe0018590    0x70    add r0, r0, #208 
    0xe0018594    0x74    ldr r2, [r3, #4]!
    0xe0018598    0x78    ldr r1, [r5, r2, lsl #2]
    0xe001859c    0x7c    str r1, [r4, r2, lsl #2]
    0xe00185a0    0x80    cmp r3, r0
    0xe00185a4    0x84    bne e0018594 <invokeTCB_CopyRegisters+0x74>
    0xe00185a8    0x88    movw r3, #13900 
    0xe00185ac    0x8c    movt r3, #57347 
    0xe00185b0    0x90    ldr r3, [r3]
    0xe00185b4    0x94    cmp r3, r4
    0xe00185b8    0x98    beq e00185dc <invokeTCB_CopyRegisters+0xbc>
    0xe00185bc    0x9c    mov r0, #0
    0xe00185c0    0xa0    pop {r4, r5, r6, pc}  ; stack access
    0xe00185c4    0xa4    mov r0, r1
    0xe00185c8    0xa8    bl e001584c <suspend>
    0xe00185cc    0xac    b e0018538 <invokeTCB_CopyRegisters+0x18>
    0xe00185d0    0xb0    mov r0, r4
    0xe00185d4    0xb4    bl e0016718 <restart>
    0xe00185d8    0xb8    b e0018540 <invokeTCB_CopyRegisters+0x20>
    0xe00185dc    0xbc    bl e0014a4c <rescheduleRequired>
    0xe00185e0    0xc0    b e00185bc <invokeTCB_CopyRegisters+0x9c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
49 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_CopyRegisters` has 79 nodes.

Section handleUserLevelFault (234 of 293)
=========================================

Deriving specifications
-----------------------

Section `handleUserLevelFault` consists of 15 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleUserLevelFault`:

    0xe00173a8     0x0    push {r4, lr}         ; stack access
    0xe00173ac     0x4    movw r3, #32768 
    0xe00173b0     0x8    movt r3, #57346 
    0xe00173b4     0xc    lsl r1, r1, #4
    0xe00173b8    0x10    orr r1, r1, #3
    0xe00173bc    0x14    str r1, [r3]
    0xe00173c0    0x18    str r0, [r3, #4]
    0xe00173c4    0x1c    movw r3, #13900 
    0xe00173c8    0x20    movt r3, #57347 
    0xe00173cc    0x24    ldr r0, [r3]
    0xe00173d0    0x28    bl e001734c <handleFault>
    0xe00173d4    0x2c    bl e00152f8 <schedule>
    0xe00173d8    0x30    bl e0014c6c <activateThread>
    0xe00173dc    0x34    mov r0, #0
    0xe00173e0    0x38    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleUserLevelFault` has 23 nodes.

Section handleUnknownSyscall (235 of 293)
=========================================

Deriving specifications
-----------------------

Section `handleUnknownSyscall` consists of 14 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleUnknownSyscall`:

    0xe0017370     0x0    push {r4, lr}         ; stack access
    0xe0017374     0x4    movw r3, #32768 
    0xe0017378     0x8    movt r3, #57346 
    0xe001737c     0xc    mov r2, #2
    0xe0017380    0x10    str r2, [r3]
    0xe0017384    0x14    str r0, [r3, #4]
    0xe0017388    0x18    movw r3, #13900 
    0xe001738c    0x1c    movt r3, #57347 
    0xe0017390    0x20    ldr r0, [r3]
    0xe0017394    0x24    bl e001734c <handleFault>
    0xe0017398    0x28    bl e00152f8 <schedule>
    0xe001739c    0x2c    bl e0014c6c <activateThread>
    0xe00173a0    0x30    mov r0, #0
    0xe00173a4    0x34    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleUnknownSyscall` has 22 nodes.

Section doIPCTransfer (236 of 293)
==================================

Deriving specifications
-----------------------

Section `doIPCTransfer` consists of 33 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `doIPCTransfer`:

    0xe0016ec4     0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe0016ec8     0x4    sub sp, sp, #20
    0xe0016ecc     0x8    mov r4, r0
    0xe0016ed0     0xc    mov r8, r1
    0xe0016ed4    0x10    mov r6, r2
    0xe0016ed8    0x14    mov r9, r3
    0xe0016edc    0x18    ldr r5, [sp, #48]     ; stack access
    0xe0016ee0    0x1c    mov r1, r5
    0xe0016ee4    0x20    mov r0, #1
    0xe0016ee8    0x24    bl e0010b04 <lookupIPCBuffer>
    0xe0016eec    0x28    mov r7, r0
    0xe0016ef0    0x2c    ldr r3, [r4, #96] 
    0xe0016ef4    0x30    tst r3, #15
    0xe0016ef8    0x34    bne e0016f30 <doIPCTransfer+0x6c>
    0xe0016efc    0x38    mov r1, r4
    0xe0016f00    0x3c    mov r0, #0
    0xe0016f04    0x40    bl e0010b04 <lookupIPCBuffer>
    0xe0016f08    0x44    str r7, [sp, #8]      ; stack access
    0xe0016f0c    0x48    str r5, [sp, #4]      ; stack access
    0xe0016f10    0x4c    str r9, [sp]          ; stack access
    0xe0016f14    0x50    mov r3, r6
    0xe0016f18    0x54    mov r2, r8
    0xe0016f1c    0x58    mov r1, r0
    0xe0016f20    0x5c    mov r0, r4
    0xe0016f24    0x60    bl e0016cc0 <doNormalTransfer>
    0xe0016f28    0x64    add sp, sp, #20
    0xe0016f2c    0x68    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0016f30    0x6c    mov r3, r0
    0xe0016f34    0x70    mov r2, r5
    0xe0016f38    0x74    mov r1, r4
    0xe0016f3c    0x78    mov r0, r6
    0xe0016f40    0x7c    bl e0012ed4 <doFaultTransfer>
    0xe0016f44    0x80    b e0016f28 <doIPCTransfer+0x64>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
33 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doIPCTransfer` has 46 nodes.

Section handleInterruptEntry (237 of 293)
=========================================

Deriving specifications
-----------------------

Section `handleInterruptEntry` consists of 26 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleInterruptEntry`:

    0xe0016a64     0x0    push {r4, lr}         ; stack access
    0xe0016a68     0x4    movw r3, #46524 
    0xe0016a6c     0x8    movt r3, #57345 
    0xe0016a70     0xc    ldr r0, [r3]
    0xe0016a74    0x10    ubfx r0, r0, #0, #10
    0xe0016a78    0x14    cmp r0, #1020 
    0xe0016a7c    0x18    bcc e0016aa4 <handleInterruptEntry+0x40>
    0xe0016a80    0x1c    movw r3, #8703 
    0xe0016a84    0x20    movt r3, #65520 
    0xe0016a88    0x24    ldr r0, [r3, #-243] 
    0xe0016a8c    0x28    movw r3, #46524 
    0xe0016a90    0x2c    movt r3, #57345 
    0xe0016a94    0x30    str r0, [r3]
    0xe0016a98    0x34    ubfx r0, r0, #0, #10
    0xe0016a9c    0x38    cmp r0, #1020 
    0xe0016aa0    0x3c    bcs e0016abc <handleInterruptEntry+0x58>
    0xe0016aa4    0x40    movw r3, #46524 
    0xe0016aa8    0x44    movt r3, #57345 
    0xe0016aac    0x48    ldr r3, [r3, #4]
    0xe0016ab0    0x4c    cmp r3, r0
    0xe0016ab4    0x50    beq e0016abc <handleInterruptEntry+0x58>
    0xe0016ab8    0x54    bl e0016898 <handleInterrupt>
    0xe0016abc    0x58    bl e00152f8 <schedule>
    0xe0016ac0    0x5c    bl e0014c6c <activateThread>
    0xe0016ac4    0x60    mov r0, #0
    0xe0016ac8    0x64    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInterruptEntry` has 42 nodes.

Section handleInterrupt (238 of 293)
====================================

Deriving specifications
-----------------------

Section `handleInterrupt` consists of 115 instructions.
Switch found.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleInterrupt`:

    0xe0016898      0x0    cmp r0, #159 
    0xe001689c      0x4    bhi e00168d0 <handleInterrupt+0x38>
    0xe00168a0      0x8    push {r4, lr}         ; stack access
    0xe00168a4      0xc    mov r4, r0
    0xe00168a8     0x10    movw r3, #36936 
    0xe00168ac     0x14    movt r3, #57346 
    0xe00168b0     0x18    ldr r3, [r3, r0, lsl #2]
    0xe00168b4     0x1c    cmp r3, #3
    0xe00168b8     0x20    ldrls pc, [pc, r3, lsl #2]
    0xe00168bc     0x24    b e0016a60 <handleInterrupt+0x1c8>
    0xe00168c0     0x28    .word 0xe0016a38
    0xe00168c4     0x2c    .word 0xe0016940
    0xe00168c8     0x30    .word 0xe0016a20
    0xe00168cc     0x34    .word 0xe001698c
    0xe00168d0     0x38    and r3, r0, #31
    0xe00168d4     0x3c    mov r1, #1
    0xe00168d8     0x40    lsl r1, r1, r3
    0xe00168dc     0x44    lsr r3, r0, #5
    0xe00168e0     0x48    lsl r3, r3, #2
    0xe00168e4     0x4c    sub r3, r3, #1044480 
    0xe00168e8     0x50    str r1, [r3, #384] 
    0xe00168ec     0x54    lsr ip, r0, #4
    0xe00168f0     0x58    lsl ip, ip, #2
    0xe00168f4     0x5c    movw r2, #7423 
    0xe00168f8     0x60    movt r2, #65520 
    0xe00168fc     0x64    add r2, ip, r2
    0xe0016900     0x68    ldr r2, [r2, #-255] 
    0xe0016904     0x6c    and r0, r0, #15
    0xe0016908     0x70    lsl r0, r0, #1
    0xe001690c     0x74    add r0, r0, #1
    0xe0016910     0x78    lsr r0, r2, r0
    0xe0016914     0x7c    tst r0, #1
    0xe0016918     0x80    strne r1, [r3, #640] 
    0xe001691c     0x84    movw r3, #46524 
    0xe0016920     0x88    movt r3, #57345 
    0xe0016924     0x8c    ldr r1, [r3]
    0xe0016928     0x90    movw r2, #8703 
    0xe001692c     0x94    movt r2, #65520 
    0xe0016930     0x98    str r1, [r2, #-239] 
    0xe0016934     0x9c    movw r2, #1023 
    0xe0016938     0xa0    str r2, [r3]
    0xe001693c     0xa4    bx lr
    0xe0016940     0xa8    movw r3, #8192 
    0xe0016944     0xac    movt r3, #57347 
    0xe0016948     0xb0    add r2, r3, r0, lsl #4
    0xe001694c     0xb4    ldr r0, [r3, r0, lsl #4]
    0xe0016950     0xb8    and r3, r0, #14
    0xe0016954     0xbc    cmp r3, #14
    0xe0016958     0xc0    andne r3, r0, #15
    0xe001695c     0xc4    uxtbeq r3, r0
    0xe0016960     0xc8    cmp r3, #6
    0xe0016964     0xcc    beq e0016a04 <handleInterrupt+0x16c>
    0xe0016968     0xd0    lsr r3, r4, #5
    0xe001696c     0xd4    and r2, r4, #31
    0xe0016970     0xd8    mov r1, #1
    0xe0016974     0xdc    lsl r1, r1, r2
    0xe0016978     0xe0    lsl r3, r3, #2
    0xe001697c     0xe4    movw r2, #4735 
    0xe0016980     0xe8    movt r2, #65520 
    0xe0016984     0xec    add r2, r3, r2
    0xe0016988     0xf0    str r1, [r2, #-255] 
    0xe001698c     0xf4    lsr r2, r4, #4
    0xe0016990     0xf8    lsl r2, r2, #2
    0xe0016994     0xfc    movw r3, #7423 
    0xe0016998    0x100    movt r3, #65520 
    0xe001699c    0x104    add r3, r2, r3
    0xe00169a0    0x108    ldr r2, [r3, #-255] 
    0xe00169a4    0x10c    and r3, r4, #15
    0xe00169a8    0x110    lsl r3, r3, #1
    0xe00169ac    0x114    add r3, r3, #1
    0xe00169b0    0x118    lsr r3, r2, r3
    0xe00169b4    0x11c    tst r3, #1
    0xe00169b8    0x120    beq e00169e0 <handleInterrupt+0x148>
    0xe00169bc    0x124    lsr r2, r4, #5
    0xe00169c0    0x128    and r4, r4, #31
    0xe00169c4    0x12c    mov r0, #1
    0xe00169c8    0x130    lsl r4, r0, r4
    0xe00169cc    0x134    lsl r2, r2, #2
    0xe00169d0    0x138    movw r3, #4991 
    0xe00169d4    0x13c    movt r3, #65520 
    0xe00169d8    0x140    add r3, r2, r3
    0xe00169dc    0x144    str r4, [r3, #-255] 
    0xe00169e0    0x148    movw r3, #46524 
    0xe00169e4    0x14c    movt r3, #57345 
    0xe00169e8    0x150    ldr r1, [r3]
    0xe00169ec    0x154    movw r2, #8703 
    0xe00169f0    0x158    movt r2, #65520 
    0xe00169f4    0x15c    str r1, [r2, #-239] 
    0xe00169f8    0x160    movw r2, #1023 
    0xe00169fc    0x164    str r2, [r3]
    0xe0016a00    0x168    pop {r4, pc}          ; stack access
    0xe0016a04    0x16c    ldr r1, [r2, #4]
    0xe0016a08    0x170    tst r1, #1
    0xe0016a0c    0x174    beq e0016968 <handleInterrupt+0xd0>
    0xe0016a10    0x178    lsr r1, r1, #4
    0xe0016a14    0x17c    bic r0, r0, #15
    0xe0016a18    0x180    bl e0016764 <sendSignal>
    0xe0016a1c    0x184    b e0016968 <handleInterrupt+0xd0>
    0xe0016a20    0x188    bl e0015088 <timerTick>
    0xe0016a24    0x18c    movw r3, #9983 
    0xe0016a28    0x190    movt r3, #65520 
    0xe0016a2c    0x194    mov r2, #1
    0xe0016a30    0x198    str r2, [r3, #-243] 
    0xe0016a34    0x19c    b e001698c <handleInterrupt+0xf4>
    0xe0016a38    0x1a0    lsr r3, r0, #5
    0xe0016a3c    0x1a4    and r2, r0, #31
    0xe0016a40    0x1a8    mov r1, #1
    0xe0016a44    0x1ac    lsl r1, r1, r2
    0xe0016a48    0x1b0    lsl r3, r3, #2
    0xe0016a4c    0x1b4    movw r2, #4735 
    0xe0016a50    0x1b8    movt r2, #65520 
    0xe0016a54    0x1bc    add r2, r3, r2
    0xe0016a58    0x1c0    str r1, [r2, #-255] 
    0xe0016a5c    0x1c4    b e001698c <handleInterrupt+0xf4>
    0xe0016a60    0x1c8    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
111 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInterrupt` has 161 nodes.

Section cteDeleteOne (239 of 293)
=================================

Deriving specifications
-----------------------

Section `cteDeleteOne` consists of 26 instructions.
 LDMDB;2,1...+


Stack analysis
---------------

6 stack accesses found. Annotated code for `cteDeleteOne`:

    0xe00164f8     0x0    ldr r3, [r0]
    0xe00164fc     0x4    and r2, r3, #14
    0xe0016500     0x8    cmp r2, #14
    0xe0016504     0xc    andne r3, r3, #15
    0xe0016508    0x10    uxtbeq r3, r3
    0xe001650c    0x14    cmp r3, #0
    0xe0016510    0x18    bxeq lr
    0xe0016514    0x1c    push {r4, lr}         ; stack access
    0xe0016518    0x20    sub sp, sp, #32
    0xe001651c    0x24    mov r4, r0
    0xe0016520    0x28    bl e0014448 <isFinalCapability>
    0xe0016524    0x2c    mov r3, #1
    0xe0016528    0x30    str r3, [sp]          ; stack access
    0xe001652c    0x34    mov r3, r0
    0xe0016530    0x38    ldm r4, {r1, r2}
    0xe0016534    0x3c    add r0, sp, #8
    0xe0016538    0x40    bl e0015884 <finaliseCap>
    0xe001653c    0x44    mov r3, #0
    0xe0016540    0x48    str r3, [sp, #24]     ; stack access
    0xe0016544    0x4c    str r3, [sp, #28]     ; stack access
    0xe0016548    0x50    add r3, sp, #32
    0xe001654c    0x54    ldmdb r3, {r1, r2}    ; stack access
    0xe0016550    0x58    mov r0, r4
    0xe0016554    0x5c    bl e00136e8 <emptySlot>
    0xe0016558    0x60    add sp, sp, #32
    0xe001655c    0x64    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteDeleteOne` has 44 nodes.

Section cteRevoke (240 of 293)
==============================

Deriving specifications
-----------------------

Section `cteRevoke` consists of 25 instructions.
 LDMIANE (wb);15,6,5,4..++


Stack analysis
---------------

6 stack accesses found. Annotated code for `cteRevoke`:

    0xe0015d68     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0015d6c     0x4    ldr r4, [r0, #12]
    0xe0015d70     0x8    bics r4, r4, #7
    0xe0015d74     0xc    beq e0015dc4 <cteRevoke+0x5c>
    0xe0015d78    0x10    mov r5, r0
    0xe0015d7c    0x14    mov r6, #1
    0xe0015d80    0x18    mov r1, r4
    0xe0015d84    0x1c    mov r0, r5
    0xe0015d88    0x20    bl e00141e4 <isMDBParentOf>
    0xe0015d8c    0x24    cmp r0, #0
    0xe0015d90    0x28    popeq {r4, r5, r6, pc}  ; stack access
    0xe0015d94    0x2c    mov r1, r6
    0xe0015d98    0x30    mov r0, r4
    0xe0015d9c    0x34    bl e0015b14 <cteDelete>
    0xe0015da0    0x38    cmp r0, #0
    0xe0015da4    0x3c    popne {r4, r5, r6, pc}  ; stack access
    0xe0015da8    0x40    bl e0012f4c <preemptionPoint>
    0xe0015dac    0x44    cmp r0, #0
    0xe0015db0    0x48    popne {r4, r5, r6, pc}  ; stack access
    0xe0015db4    0x4c    ldr r4, [r5, #12]
    0xe0015db8    0x50    bics r4, r4, #7
    0xe0015dbc    0x54    bne e0015d80 <cteRevoke+0x18>
    0xe0015dc0    0x58    pop {r4, r5, r6, pc}  ; stack access
    0xe0015dc4    0x5c    mov r0, #0
    0xe0015dc8    0x60    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteRevoke` has 46 nodes.

Section suspend (241 of 293)
============================

Deriving specifications
-----------------------

Section `suspend` consists of 14 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `suspend`:

    0xe001584c     0x0    push {r4, lr}         ; stack access
    0xe0015850     0x4    mov r4, r0
    0xe0015854     0x8    bl e001575c <cancelIPC>
    0xe0015858     0xc    ldr r3, [r4, #80] 
    0xe001585c    0x10    and r3, r3, #15
    0xe0015860    0x14    cmp r3, #1
    0xe0015864    0x18    ldreq r3, [r4, #60] 
    0xe0015868    0x1c    streq r3, [r4, #68] 
    0xe001586c    0x20    mov r1, #0
    0xe0015870    0x24    mov r0, r4
    0xe0015874    0x28    bl e0014ad8 <setThreadState>
    0xe0015878    0x2c    mov r0, r4
    0xe001587c    0x30    bl e00150f4 <tcbSchedDequeue>
    0xe0015880    0x34    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `suspend` has 26 nodes.

Section setPriority (242 of 293)
================================

Deriving specifications
-----------------------

Section `setPriority` consists of 20 instructions.
 LDMIAHI (wb);15,6,5,4..++


Stack analysis
---------------

4 stack accesses found. Annotated code for `setPriority`:

    0xe00154ac     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00154b0     0x4    mov r4, r0
    0xe00154b4     0x8    mov r5, r1
    0xe00154b8     0xc    bl e00150f4 <tcbSchedDequeue>
    0xe00154bc    0x10    str r5, [r4, #120] 
    0xe00154c0    0x14    ldr r3, [r4, #80] 
    0xe00154c4    0x18    and r3, r3, #15
    0xe00154c8    0x1c    sub r3, r3, #1
    0xe00154cc    0x20    cmp r3, #1
    0xe00154d0    0x24    pophi {r4, r5, r6, pc}  ; stack access
    0xe00154d4    0x28    movw r3, #13900 
    0xe00154d8    0x2c    movt r3, #57347 
    0xe00154dc    0x30    ldr r3, [r3]
    0xe00154e0    0x34    cmp r3, r4
    0xe00154e4    0x38    beq e00154f4 <setPriority+0x48>
    0xe00154e8    0x3c    mov r0, r4
    0xe00154ec    0x40    bl e0014ed4 <possibleSwitchTo>
    0xe00154f0    0x44    pop {r4, r5, r6, pc}  ; stack access
    0xe00154f4    0x48    bl e0014a4c <rescheduleRequired>
    0xe00154f8    0x4c    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setPriority` has 34 nodes.

Section setDomain (243 of 293)
==============================

Deriving specifications
-----------------------

Section `setDomain` consists of 20 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `setDomain`:

    0xe001545c     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0015460     0x4    mov r4, r0
    0xe0015464     0x8    mov r5, r1
    0xe0015468     0xc    bl e00150f4 <tcbSchedDequeue>
    0xe001546c    0x10    str r5, [r4, #112] 
    0xe0015470    0x14    ldr r3, [r4, #80] 
    0xe0015474    0x18    and r3, r3, #15
    0xe0015478    0x1c    sub r3, r3, #1
    0xe001547c    0x20    cmp r3, #1
    0xe0015480    0x24    bls e00154a0 <setDomain+0x44>
    0xe0015484    0x28    movw r3, #13900 
    0xe0015488    0x2c    movt r3, #57347 
    0xe001548c    0x30    ldr r3, [r3]
    0xe0015490    0x34    cmp r3, r4
    0xe0015494    0x38    popne {r4, r5, r6, pc}  ; stack access
    0xe0015498    0x3c    bl e0014a4c <rescheduleRequired>
    0xe001549c    0x40    pop {r4, r5, r6, pc}  ; stack access
    0xe00154a0    0x44    mov r0, r4
    0xe00154a4    0x48    bl e00149a8 <tcbSchedEnqueue>
    0xe00154a8    0x4c    b e0015484 <setDomain+0x28>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setDomain` has 33 nodes.

Section cancelAllSignals (244 of 293)
=====================================

Deriving specifications
-----------------------

Section `cancelAllSignals` consists of 23 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `cancelAllSignals`:

    0xe0014f88     0x0    ldr r3, [r0]
    0xe0014f8c     0x4    and r2, r3, #3
    0xe0014f90     0x8    cmp r2, #1
    0xe0014f94     0xc    bxne lr
    0xe0014f98    0x10    push {r4, r5, r6, lr}  ; stack access
    0xe0014f9c    0x14    ldr r4, [r0, #4]
    0xe0014fa0    0x18    and r2, r4, #15
    0xe0014fa4    0x1c    str r2, [r0, #4]
    0xe0014fa8    0x20    and r3, r3, #12
    0xe0014fac    0x24    str r3, [r0]
    0xe0014fb0    0x28    bics r4, r4, #15
    0xe0014fb4    0x2c    beq e0014fdc <cancelAllSignals+0x54>
    0xe0014fb8    0x30    mov r5, #2
    0xe0014fbc    0x34    mov r1, r5
    0xe0014fc0    0x38    mov r0, r4
    0xe0014fc4    0x3c    bl e0014ad8 <setThreadState>
    0xe0014fc8    0x40    mov r0, r4
    0xe0014fcc    0x44    bl e00149a8 <tcbSchedEnqueue>
    0xe0014fd0    0x48    ldr r4, [r4, #144] 
    0xe0014fd4    0x4c    cmp r4, #0
    0xe0014fd8    0x50    bne e0014fbc <cancelAllSignals+0x34>
    0xe0014fdc    0x54    bl e0014a4c <rescheduleRequired>
    0xe0014fe0    0x58    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelAllSignals` has 40 nodes.

Section cancelAllIPC (245 of 293)
=================================

Deriving specifications
-----------------------

Section `cancelAllIPC` consists of 22 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `cancelAllIPC`:

    0xe0014f30     0x0    ldr r3, [r0]
    0xe0014f34     0x4    tst r3, #3
    0xe0014f38     0x8    bxeq lr
    0xe0014f3c     0xc    push {r4, r5, r6, lr}  ; stack access
    0xe0014f40    0x10    ldr r4, [r0, #4]
    0xe0014f44    0x14    and r2, r4, #15
    0xe0014f48    0x18    str r2, [r0, #4]
    0xe0014f4c    0x1c    and r3, r3, #12
    0xe0014f50    0x20    str r3, [r0]
    0xe0014f54    0x24    bics r4, r4, #15
    0xe0014f58    0x28    beq e0014f80 <cancelAllIPC+0x50>
    0xe0014f5c    0x2c    mov r5, #2
    0xe0014f60    0x30    mov r1, r5
    0xe0014f64    0x34    mov r0, r4
    0xe0014f68    0x38    bl e0014ad8 <setThreadState>
    0xe0014f6c    0x3c    mov r0, r4
    0xe0014f70    0x40    bl e00149a8 <tcbSchedEnqueue>
    0xe0014f74    0x44    ldr r4, [r4, #144] 
    0xe0014f78    0x48    cmp r4, #0
    0xe0014f7c    0x4c    bne e0014f60 <cancelAllIPC+0x30>
    0xe0014f80    0x50    bl e0014a4c <rescheduleRequired>
    0xe0014f84    0x54    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelAllIPC` has 39 nodes.

Section createNewObjects (246 of 293)
=====================================

Deriving specifications
-----------------------

Section `createNewObjects` consists of 39 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `createNewObjects`:

    0xe001490c     0x0    sub sp, sp, #8
    0xe0014910     0x4    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0014914     0x8    sub sp, sp, #20
    0xe0014918     0xc    mov r9, r0
    0xe001491c    0x10    mov sl, r1
    0xe0014920    0x14    add r1, sp, #52 
    0xe0014924    0x18    stmib r1, {r2, r3}    ; stack access
    0xe0014928    0x1c    ldr fp, [sp, #76]     ; stack access
    0xe001492c    0x20    ldr r8, [sp, #64]     ; stack access
    0xe0014930    0x24    ldr r1, [sp, #72]     ; stack access
    0xe0014934    0x28    bl e0013838 <getObjectSize>
    0xe0014938    0x2c    cmp r8, #0
    0xe001493c    0x30    beq e0014998 <createNewObjects+0x8c>
    0xe0014940    0x34    mov r7, #1
    0xe0014944    0x38    lsl r7, r7, r0
    0xe0014948    0x3c    ldr r6, [sp, #68]     ; stack access
    0xe001494c    0x40    mov r4, #0
    0xe0014950    0x44    add r5, sp, #8
    0xe0014954    0x48    str fp, [sp]          ; stack access
    0xe0014958    0x4c    ldr r3, [sp, #72]     ; stack access
    0xe001495c    0x50    mov r2, r6
    0xe0014960    0x54    mov r1, r9
    0xe0014964    0x58    mov r0, r5
    0xe0014968    0x5c    bl e001480c <createObject>
    0xe001496c    0x60    ldr r1, [sp, #60]     ; stack access
    0xe0014970    0x64    add r1, r4, r1
    0xe0014974    0x68    ldm r5, {r2, r3}      ; stack access
    0xe0014978    0x6c    ldr r0, [sp, #56]     ; stack access
    0xe001497c    0x70    add r1, r0, r1, lsl #4
    0xe0014980    0x74    mov r0, sl
    0xe0014984    0x78    bl e0013450 <insertNewCap>
    0xe0014988    0x7c    add r4, r4, #1
    0xe001498c    0x80    add r6, r6, r7
    0xe0014990    0x84    cmp r8, r4
    0xe0014994    0x88    bne e0014954 <createNewObjects+0x48>
    0xe0014998    0x8c    add sp, sp, #20
    0xe001499c    0x90    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00149a0    0x94    add sp, sp, #8
    0xe00149a4    0x98    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `createNewObjects` has 59 nodes.

Section deleteASID (247 of 293)
===============================

Deriving specifications
-----------------------

Section `deleteASID` consists of 22 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `deleteASID`:

    0xe00126f4     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00126f8     0x4    movw r3, #37576 
    0xe00126fc     0x8    movt r3, #57346 
    0xe0012700     0xc    lsr r2, r0, #10
    0xe0012704    0x10    ldr r5, [r3, r2, lsl #2]
    0xe0012708    0x14    cmp r5, #0
    0xe001270c    0x18    popeq {r4, r5, r6, pc}  ; stack access
    0xe0012710    0x1c    ubfx r6, r0, #0, #10
    0xe0012714    0x20    ldr r3, [r5, r6, lsl #2]
    0xe0012718    0x24    cmp r3, r1
    0xe001271c    0x28    popne {r4, r5, r6, pc}  ; stack access
    0xe0012720    0x2c    mov r4, r0
    0xe0012724    0x30    bl e0012644 <flushSpace>
    0xe0012728    0x34    mov r0, r4
    0xe001272c    0x38    bl e001088c <invalidateASIDEntry>
    0xe0012730    0x3c    mov r3, #0
    0xe0012734    0x40    str r3, [r5, r6, lsl #2]
    0xe0012738    0x44    movw r3, #13900 
    0xe001273c    0x48    movt r3, #57347 
    0xe0012740    0x4c    ldr r0, [r3]
    0xe0012744    0x50    bl e00110b8 <setVMRoot>
    0xe0012748    0x54    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteASID` has 37 nodes.

Section deleteASIDPool (248 of 293)
===================================

Deriving specifications
-----------------------

Section `deleteASIDPool` consists of 32 instructions.
 LDMIANE (wb);15,8,7,6,5,4..++


Stack analysis
---------------

3 stack accesses found. Annotated code for `deleteASIDPool`:

    0xe0012674     0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0012678     0x4    lsr r7, r0, #10
    0xe001267c     0x8    movw r3, #37576 
    0xe0012680     0xc    movt r3, #57346 
    0xe0012684    0x10    ldr r6, [r3, r7, lsl #2]
    0xe0012688    0x14    cmp r6, r1
    0xe001268c    0x18    popne {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0012690    0x1c    mov r4, r0
    0xe0012694    0x20    sub r5, r6, #4
    0xe0012698    0x24    add r6, r6, #4080 
    0xe001269c    0x28    add r6, r6, #12
    0xe00126a0    0x2c    b e00126b0 <deleteASIDPool+0x3c>
    0xe00126a4    0x30    add r4, r4, #1
    0xe00126a8    0x34    cmp r5, r6
    0xe00126ac    0x38    beq e00126d0 <deleteASIDPool+0x5c>
    0xe00126b0    0x3c    ldr r3, [r5, #4]!
    0xe00126b4    0x40    cmp r3, #0
    0xe00126b8    0x44    beq e00126a4 <deleteASIDPool+0x30>
    0xe00126bc    0x48    mov r0, r4
    0xe00126c0    0x4c    bl e0012644 <flushSpace>
    0xe00126c4    0x50    mov r0, r4
    0xe00126c8    0x54    bl e001088c <invalidateASIDEntry>
    0xe00126cc    0x58    b e00126a4 <deleteASIDPool+0x30>
    0xe00126d0    0x5c    movw r3, #37576 
    0xe00126d4    0x60    movt r3, #57346 
    0xe00126d8    0x64    mov r2, #0
    0xe00126dc    0x68    str r2, [r3, r7, lsl #2]
    0xe00126e0    0x6c    movw r3, #13900 
    0xe00126e4    0x70    movt r3, #57347 
    0xe00126e8    0x74    ldr r0, [r3]
    0xe00126ec    0x78    bl e00110b8 <setVMRoot>
    0xe00126f0    0x7c    pop {r4, r5, r6, r7, r8, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteASIDPool` has 48 nodes.

Section Arch_createObject (249 of 293)
======================================

Deriving specifications
-----------------------

Section `Arch_createObject` consists of 86 instructions.
Switch found.


Stack analysis
---------------

Section `Arch_createObject` expects pointer to stack in r0.
18 stack accesses found. Annotated code for `Arch_createObject`:

    0xe00122bc      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00122c0      0x4    mov r5, r0
    0xe00122c4      0x8    mov r4, r2
    0xe00122c8      0xc    sub r1, r1, #5
    0xe00122cc     0x10    cmp r1, #5
    0xe00122d0     0x14    ldrls pc, [pc, r1, lsl #2]
    0xe00122d4     0x18    b e0012410 <Arch_createObject+0x154>
    0xe00122d8     0x1c    .word 0xe00122f0
    0xe00122dc     0x20    .word 0xe0012320
    0xe00122e0     0x24    .word 0xe0012354
    0xe00122e4     0x28    .word 0xe0012388
    0xe00122e8     0x2c    .word 0xe00123bc
    0xe00122ec     0x30    .word 0xe00123d8
    0xe00122f0     0x34    ldr r3, [sp, #16]     ; stack access
    0xe00122f4     0x38    cmp r3, #0
    0xe00122f8     0x3c    movne r3, #-2147483647 
    0xe00122fc     0x40    moveq r3, #1
    0xe0012300     0x44    lsr r4, r2, #8
    0xe0012304     0x48    bic r4, r4, #15
    0xe0012308     0x4c    orr r4, r3, r4
    0xe001230c     0x50    str r4, [r0]          ; stack access
    0xe0012310     0x54    mov r3, #3145728 
    0xe0012314     0x58    str r3, [r0, #4]      ; stack access
    0xe0012318     0x5c    mov r0, r5
    0xe001231c     0x60    pop {r4, r5, r6, pc}  ; stack access
    0xe0012320     0x64    ldr r3, [sp, #16]     ; stack access
    0xe0012324     0x68    cmp r3, #0
    0xe0012328     0x6c    movne r3, #536870915 
    0xe001232c     0x70    moveq r3, #3
    0xe0012330     0x74    lsr r4, r2, #10
    0xe0012334     0x78    bic r4, r4, #-268435441 
    0xe0012338     0x7c    bic r4, r4, #264241152 
    0xe001233c     0x80    orr r4, r3, r4
    0xe0012340     0x84    str r4, [r0]          ; stack access
    0xe0012344     0x88    mov r3, #0
    0xe0012348     0x8c    movt r3, #16396 
    0xe001234c     0x90    str r3, [r0, #4]      ; stack access
    0xe0012350     0x94    b e0012318 <Arch_createObject+0x5c>
    0xe0012354     0x98    ldr r3, [sp, #16]     ; stack access
    0xe0012358     0x9c    cmp r3, #0
    0xe001235c     0xa0    movne r3, #536870915 
    0xe0012360     0xa4    moveq r3, #3
    0xe0012364     0xa8    lsr r4, r2, #10
    0xe0012368     0xac    bic r4, r4, #-268435441 
    0xe001236c     0xb0    bic r4, r4, #264241152 
    0xe0012370     0xb4    orr r4, r3, r4
    0xe0012374     0xb8    str r4, [r0]          ; stack access
    0xe0012378     0xbc    mov r3, #0
    0xe001237c     0xc0    movt r3, #32780 
    0xe0012380     0xc4    str r3, [r0, #4]      ; stack access
    0xe0012384     0xc8    b e0012318 <Arch_createObject+0x5c>
    0xe0012388     0xcc    ldr r3, [sp, #16]     ; stack access
    0xe001238c     0xd0    cmp r3, #0
    0xe0012390     0xd4    movne r3, #536870915 
    0xe0012394     0xd8    moveq r3, #3
    0xe0012398     0xdc    lsr r4, r2, #10
    0xe001239c     0xe0    bic r4, r4, #-268435441 
    0xe00123a0     0xe4    bic r4, r4, #264241152 
    0xe00123a4     0xe8    orr r4, r3, r4
    0xe00123a8     0xec    str r4, [r0]          ; stack access
    0xe00123ac     0xf0    mov r3, #0
    0xe00123b0     0xf4    movt r3, #49164 
    0xe00123b4     0xf8    str r3, [r0, #4]      ; stack access
    0xe00123b8     0xfc    b e0012318 <Arch_createObject+0x5c>
    0xe00123bc    0x100    bic r4, r2, #1020 
    0xe00123c0    0x104    bic r4, r4, #3
    0xe00123c4    0x108    orr r4, r4, #7
    0xe00123c8    0x10c    str r4, [r0]          ; stack access
    0xe00123cc    0x110    mov r3, #0
    0xe00123d0    0x114    str r3, [r0, #4]      ; stack access
    0xe00123d4    0x118    b e0012318 <Arch_createObject+0x5c>
    0xe00123d8    0x11c    mov r0, r2
    0xe00123dc    0x120    bl e0011268 <copyGlobalMappings>
    0xe00123e0    0x124    add r2, r4, #805306368 
    0xe00123e4    0x128    add r1, r4, #16320 
    0xe00123e8    0x12c    add r1, r1, #63 
    0xe00123ec    0x130    mov r0, r4
    0xe00123f0    0x134    bl e00120c8 <cleanCacheRange_PoU>
    0xe00123f4    0x138    bic r4, r4, #16320 
    0xe00123f8    0x13c    bic r4, r4, #63 
    0xe00123fc    0x140    orr r4, r4, #9
    0xe0012400    0x144    str r4, [r5]          ; stack access
    0xe0012404    0x148    mov r3, #0
    0xe0012408    0x14c    str r3, [r5, #4]      ; stack access
    0xe001240c    0x150    b e0012318 <Arch_createObject+0x5c>
    0xe0012410    0x154    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
80 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_createObject` has 136 nodes.

Section flushTable (250 of 293)
===============================

Deriving specifications
-----------------------

Section `flushTable` consists of 20 instructions.
Skipping f57ff04f dsb sy
Skipping ee080f57 mcr 15, 0, r0, cr8, cr7, {2}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

4 stack accesses found. Annotated code for `flushTable`:

    0xe001136c     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0011370     0x4    mov r4, r1
    0xe0011374     0x8    bl e00111c8 <setVMRootForFlush>
    0xe0011378     0xc    mov r5, r0
    0xe001137c    0x10    mov r0, r4
    0xe0011380    0x14    bl e0010868 <loadHWASID>
    0xe0011384    0x18    tst r0, #8388608 
    0xe0011388    0x1c    popeq {r4, r5, r6, pc}  ; stack access
    0xe001138c    0x20    dsb sy
    0xe0011390    0x24    lsr r0, r0, #24
    0xe0011394    0x28    mcr 15, 0, r0, cr8, cr7, {2}
    0xe0011398    0x2c    dsb sy
    0xe001139c    0x30    isb sy
    0xe00113a0    0x34    cmp r5, #0
    0xe00113a4    0x38    popeq {r4, r5, r6, pc}  ; stack access
    0xe00113a8    0x3c    movw r3, #13900 
    0xe00113ac    0x40    movt r3, #57347 
    0xe00113b0    0x44    ldr r0, [r3]
    0xe00113b4    0x48    bl e00110b8 <setVMRoot>
    0xe00113b8    0x4c    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `flushTable` has 36 nodes.

Section flushPage (251 of 293)
==============================

Deriving specifications
-----------------------

Section `flushPage` consists of 25 instructions.
Skipping f57ff04f dsb sy
Skipping ee083f37 mcr 15, 0, r3, cr8, cr7, {1}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

4 stack accesses found. Annotated code for `flushPage`:

    0xe0011308     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe001130c     0x4    mov r0, r1
    0xe0011310     0x8    mov r5, r2
    0xe0011314     0xc    mov r4, r3
    0xe0011318    0x10    mov r1, r2
    0xe001131c    0x14    bl e00111c8 <setVMRootForFlush>
    0xe0011320    0x18    mov r6, r0
    0xe0011324    0x1c    mov r0, r5
    0xe0011328    0x20    bl e0010868 <loadHWASID>
    0xe001132c    0x24    tst r0, #8388608 
    0xe0011330    0x28    popeq {r4, r5, r6, pc}  ; stack access
    0xe0011334    0x2c    dsb sy
    0xe0011338    0x30    bic r3, r4, #4080 
    0xe001133c    0x34    bic r3, r3, #15
    0xe0011340    0x38    orr r3, r3, r0, lsr #24
    0xe0011344    0x3c    mcr 15, 0, r3, cr8, cr7, {1}
    0xe0011348    0x40    dsb sy
    0xe001134c    0x44    isb sy
    0xe0011350    0x48    cmp r6, #0
    0xe0011354    0x4c    popeq {r4, r5, r6, pc}  ; stack access
    0xe0011358    0x50    movw r3, #13900 
    0xe001135c    0x54    movt r3, #57347 
    0xe0011360    0x58    ldr r0, [r3]
    0xe0011364    0x5c    bl e00110b8 <setVMRoot>
    0xe0011368    0x60    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `flushPage` has 41 nodes.

Section arm_swi_syscall (252 of 293)
====================================

Deriving specifications
-----------------------

Section `arm_swi_syscall` consists of 11 instructions.
Skipping f8cd0513 srsia sp, #19
Skipping e94d7fff stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
Skipping ee1ddf90 mrc 15, 0, sp, cr13, cr0, {4}


Stack analysis
---------------

1 stack accesses found. Annotated code for `arm_swi_syscall`:

    0xe001005c     0x0    srsia sp, #19
    0xe0010060     0x4    sub lr, lr, #4
    0xe0010064     0x8    str lr, [sp, #8]      ; stack access
    0xe0010068     0xc    stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    0xe001006c    0x10    mrc 15, 0, sp, cr13, cr0, {4}
    0xe0010070    0x14    cmn r7, #1
    0xe0010074    0x18    beq e00101e0 <c_handle_fastpath_call>
    0xe0010078    0x1c    cmn r7, #2
    0xe001007c    0x20    beq e00104e0 <c_handle_fastpath_reply_recv>
    0xe0010080    0x24    mov r2, r7
    0xe0010084    0x28    b e0010810 <c_handle_syscall>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_swi_syscall` has 24 nodes.

Section populate_bi_frame (253 of 293)
======================================

Deriving specifications
-----------------------

Section `populate_bi_frame` consists of 61 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `populate_bi_frame`:

    0xe0003a20     0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0003a24     0x4    mov r8, r0
    0xe0003a28     0x8    mov r7, r1
    0xe0003a2c     0xc    mov r6, r2
    0xe0003a30    0x10    mov r5, r3
    0xe0003a34    0x14    movw r3, #47104 
    0xe0003a38    0x18    movt r3, #57345 
    0xe0003a3c    0x1c    ldr r4, [r3, #152] 
    0xe0003a40    0x20    mov r1, #4096 
    0xe0003a44    0x24    mov r0, r4
    0xe0003a48    0x28    bl e0019244 <memzero>
    0xe0003a4c    0x2c    add r2, r4, #805306368 
    0xe0003a50    0x30    add r1, r4, #4080 
    0xe0003a54    0x34    add r1, r1, #15
    0xe0003a58    0x38    mov r0, r4
    0xe0003a5c    0x3c    bl e00120c8 <cleanCacheRange_PoU>
    0xe0003a60    0x40    cmp r5, #0
    0xe0003a64    0x44    bne e0003ad4 <populate_bi_frame+0xb4>
    0xe0003a68    0x48    movw r3, #47104 
    0xe0003a6c    0x4c    movt r3, #57345 
    0xe0003a70    0x50    ldr r2, [r3, #152] 
    0xe0003a74    0x54    str r2, [r3, #124] 
    0xe0003a78    0x58    mov r1, #14
    0xe0003a7c    0x5c    str r1, [r3, #128] 
    0xe0003a80    0x60    str r8, [r2, #4]
    0xe0003a84    0x64    ldr r2, [r3, #152] 
    0xe0003a88    0x68    str r7, [r2, #8]
    0xe0003a8c    0x6c    ldr r2, [r3, #152] 
    0xe0003a90    0x70    mov r1, #0
    0xe0003a94    0x74    str r1, [r2, #12]
    0xe0003a98    0x78    ldr r2, [r3, #152] 
    0xe0003a9c    0x7c    str r6, [r2, #16]
    0xe0003aa0    0x80    ldr r2, [r3, #152] 
    0xe0003aa4    0x84    mov r3, #12
    0xe0003aa8    0x88    str r3, [r2, #68] 
    0xe0003aac    0x8c    movw r3, #46284 
    0xe0003ab0    0x90    movt r3, #57345 
    0xe0003ab4    0x94    movw r1, #13904 
    0xe0003ab8    0x98    movt r1, #57347 
    0xe0003abc    0x9c    ldr r1, [r1]
    0xe0003ac0    0xa0    add r3, r3, r1, lsl #3
    0xe0003ac4    0xa4    ldr r3, [r3, #112] 
    0xe0003ac8    0xa8    str r3, [r2, #72] 
    0xe0003acc    0xac    str r5, [r2]
    0xe0003ad0    0xb0    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe0003ad4    0xb4    movw r3, #47104 
    0xe0003ad8    0xb8    movt r3, #57345 
    0xe0003adc    0xbc    ldr r4, [r3, #156] 
    0xe0003ae0    0xc0    mov r0, r5
    0xe0003ae4    0xc4    bl e00013ac <calculate_extra_bi_size_bits>
    0xe0003ae8    0xc8    mov r9, #1
    0xe0003aec    0xcc    lsl r9, r9, r0
    0xe0003af0    0xd0    mov r1, r9
    0xe0003af4    0xd4    mov r0, r4
    0xe0003af8    0xd8    bl e0019244 <memzero>
    0xe0003afc    0xdc    sub r1, r4, #1
    0xe0003b00    0xe0    add r2, r4, #805306368 
    0xe0003b04    0xe4    add r1, r1, r9
    0xe0003b08    0xe8    mov r0, r4
    0xe0003b0c    0xec    bl e00120c8 <cleanCacheRange_PoU>
    0xe0003b10    0xf0    b e0003a68 <populate_bi_frame+0x48>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
61 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `populate_bi_frame` has 88 nodes.

Section create_ipcbuf_frame_cap (254 of 293)
============================================

Deriving specifications
-----------------------

Section `create_ipcbuf_frame_cap` consists of 172 instructions.
Switch found.
Switch found.


Stack analysis
---------------

Section `create_ipcbuf_frame_cap` expects pointer to stack in r0.
14 stack accesses found. Annotated code for `create_ipcbuf_frame_cap`:

    0xe0003770      0x0    sub sp, sp, #8
    0xe0003774      0x4    push {r4, r5, r6, lr}  ; stack access
    0xe0003778      0x8    sub sp, sp, #24
    0xe000377c      0xc    mov r4, r0
    0xe0003780     0x10    add r0, sp, #24
    0xe0003784     0x14    stmdb r0, {r1, r2}    ; stack access
    0xe0003788     0x18    str r3, [sp, #44]     ; stack access
    0xe000378c     0x1c    movw r5, #47104 
    0xe0003790     0x20    movt r5, #57345 
    0xe0003794     0x24    ldr r6, [r5, #148] 
    0xe0003798     0x28    mov r1, #4096 
    0xe000379c     0x2c    mov r0, r6
    0xe00037a0     0x30    bl e0019244 <memzero>
    0xe00037a4     0x34    add r2, r6, #805306368 
    0xe00037a8     0x38    add r1, r6, #4080 
    0xe00037ac     0x3c    add r1, r1, #15
    0xe00037b0     0x40    mov r0, r6
    0xe00037b4     0x44    bl e00120c8 <cleanCacheRange_PoU>
    0xe00037b8     0x48    ldr r3, [r5, #148] 
    0xe00037bc     0x4c    mov r2, #0
    0xe00037c0     0x50    str r2, [sp, #12]     ; stack access
    0xe00037c4     0x54    str r2, [sp, #8]      ; stack access
    0xe00037c8     0x58    mov r2, #1
    0xe00037cc     0x5c    str r2, [sp, #4]      ; stack access
    0xe00037d0     0x60    ldr r2, [sp, #52]     ; stack access
    0xe00037d4     0x64    str r2, [sp]          ; stack access
    0xe00037d8     0x68    add r2, sp, #44 
    0xe00037dc     0x6c    ldm r2, {r1, r2}      ; stack access
    0xe00037e0     0x70    mov r0, r4
    0xe00037e4     0x74    bl e0000408 <create_mapped_it_frame_cap>
    0xe00037e8     0x78    ldr r3, [sp, #16]     ; stack access
    0xe00037ec     0x7c    ldr r0, [sp, #20]     ; stack access
    0xe00037f0     0x80    and r2, r3, #14
    0xe00037f4     0x84    cmp r2, #14
    0xe00037f8     0x88    andne r1, r3, #15
    0xe00037fc     0x8c    uxtbeq r1, r3
    0xe0003800     0x90    sub r2, r1, #2
    0xe0003804     0x94    cmp r2, #60 
    0xe0003808     0x98    ldrls pc, [pc, r2, lsl #2]
    0xe000380c     0x9c    b e0003954 <create_ipcbuf_frame_cap+0x1e4>
    0xe0003810     0xa0    .word 0xe0003904
    0xe0003814     0xa4    .word 0xe0003954
    0xe0003818     0xa8    .word 0xe000390c
    0xe000381c     0xac    .word 0xe0003954
    0xe0003820     0xb0    .word 0xe0003914
    0xe0003824     0xb4    .word 0xe0003954
    0xe0003828     0xb8    .word 0xe00039e0
    0xe000382c     0xbc    .word 0xe0003954
    0xe0003830     0xc0    .word 0xe000391c
    0xe0003834     0xc4    .word 0xe0003954
    0xe0003838     0xc8    .word 0xe0003924
    0xe000383c     0xcc    .word 0xe0003954
    0xe0003840     0xd0    .word 0xe00039e0
    0xe0003844     0xd4    .word 0xe0003954
    0xe0003848     0xd8    .word 0xe0003954
    0xe000384c     0xdc    .word 0xe0003954
    0xe0003850     0xe0    .word 0xe0003954
    0xe0003854     0xe4    .word 0xe0003954
    0xe0003858     0xe8    .word 0xe0003954
    0xe000385c     0xec    .word 0xe0003954
    0xe0003860     0xf0    .word 0xe0003954
    0xe0003864     0xf4    .word 0xe0003954
    0xe0003868     0xf8    .word 0xe0003954
    0xe000386c     0xfc    .word 0xe0003954
    0xe0003870    0x100    .word 0xe0003954
    0xe0003874    0x104    .word 0xe0003954
    0xe0003878    0x108    .word 0xe0003954
    0xe000387c    0x10c    .word 0xe0003954
    0xe0003880    0x110    .word 0xe00039e0
    0xe0003884    0x114    .word 0xe0003954
    0xe0003888    0x118    .word 0xe0003954
    0xe000388c    0x11c    .word 0xe0003954
    0xe0003890    0x120    .word 0xe0003954
    0xe0003894    0x124    .word 0xe0003954
    0xe0003898    0x128    .word 0xe0003954
    0xe000389c    0x12c    .word 0xe0003954
    0xe00038a0    0x130    .word 0xe0003954
    0xe00038a4    0x134    .word 0xe0003954
    0xe00038a8    0x138    .word 0xe0003954
    0xe00038ac    0x13c    .word 0xe0003954
    0xe00038b0    0x140    .word 0xe0003954
    0xe00038b4    0x144    .word 0xe0003954
    0xe00038b8    0x148    .word 0xe0003954
    0xe00038bc    0x14c    .word 0xe0003954
    0xe00038c0    0x150    .word 0xe0003930
    0xe00038c4    0x154    .word 0xe0003954
    0xe00038c8    0x158    .word 0xe0003954
    0xe00038cc    0x15c    .word 0xe0003954
    0xe00038d0    0x160    .word 0xe0003954
    0xe00038d4    0x164    .word 0xe0003954
    0xe00038d8    0x168    .word 0xe0003954
    0xe00038dc    0x16c    .word 0xe0003954
    0xe00038e0    0x170    .word 0xe0003954
    0xe00038e4    0x174    .word 0xe0003954
    0xe00038e8    0x178    .word 0xe0003954
    0xe00038ec    0x17c    .word 0xe0003954
    0xe00038f0    0x180    .word 0xe0003954
    0xe00038f4    0x184    .word 0xe0003954
    0xe00038f8    0x188    .word 0xe0003954
    0xe00038fc    0x18c    .word 0xe0003954
    0xe0003900    0x190    .word 0xe00039e0
    0xe0003904    0x194    bic r3, r3, #15
    0xe0003908    0x198    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe000390c    0x19c    bic r3, r0, #15
    0xe0003910    0x1a0    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe0003914    0x1a4    bic r3, r3, #15
    0xe0003918    0x1a8    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe000391c    0x1ac    bic r3, r3, #31
    0xe0003920    0x1b0    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe0003924    0x1b4    bic r3, r3, #508 
    0xe0003928    0x1b8    bic r3, r3, #3
    0xe000392c    0x1bc    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe0003930    0x1c0    lsr r3, r3, #8
    0xe0003934    0x1c4    and r2, r3, #63 
    0xe0003938    0x1c8    cmp r2, #32
    0xe000393c    0x1cc    andne r3, r3, #31
    0xe0003940    0x1d0    moveq r3, #4
    0xe0003944    0x1d4    add r3, r3, #1
    0xe0003948    0x1d8    mvn r2, #0
    0xe000394c    0x1dc    and r3, r0, r2, lsl r3
    0xe0003950    0x1e0    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe0003954    0x1e4    sub r2, r1, #1
    0xe0003958    0x1e8    cmp r2, #8
    0xe000395c    0x1ec    ldrls pc, [pc, r2, lsl #2]
    0xe0003960    0x1f0    b e0003a18 <create_ipcbuf_frame_cap+0x2a8>
    0xe0003964    0x1f4    .word 0xe0003988
    0xe0003968    0x1f8    .word 0xe0003a18
    0xe000396c    0x1fc    .word 0xe0003988
    0xe0003970    0x200    .word 0xe0003a18
    0xe0003974    0x204    .word 0xe00039d8
    0xe0003978    0x208    .word 0xe0003a18
    0xe000397c    0x20c    .word 0xe00039c0
    0xe0003980    0x210    .word 0xe0003a18
    0xe0003984    0x214    .word 0xe00039cc
    0xe0003988    0x218    cmp r1, #1
    0xe000398c    0x21c    beq e00039a0 <create_ipcbuf_frame_cap+0x230>
    0xe0003990    0x220    cmp r1, #3
    0xe0003994    0x224    beq e00039b0 <create_ipcbuf_frame_cap+0x240>
    0xe0003998    0x228    mov r3, #0
    0xe000399c    0x22c    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe00039a0    0x230    lsl r3, r3, #8
    0xe00039a4    0x234    bic r3, r3, #4080 
    0xe00039a8    0x238    bic r3, r3, #15
    0xe00039ac    0x23c    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe00039b0    0x240    lsl r3, r3, #10
    0xe00039b4    0x244    bic r3, r3, #16320 
    0xe00039b8    0x248    bic r3, r3, #63 
    0xe00039bc    0x24c    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe00039c0    0x250    bic r3, r3, #1020 
    0xe00039c4    0x254    bic r3, r3, #3
    0xe00039c8    0x258    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe00039cc    0x25c    bic r3, r3, #16320 
    0xe00039d0    0x260    bic r3, r3, #63 
    0xe00039d4    0x264    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe00039d8    0x268    bic r3, r3, #15
    0xe00039dc    0x26c    b e00039e4 <create_ipcbuf_frame_cap+0x274>
    0xe00039e0    0x270    mov r3, #0
    0xe00039e4    0x274    ldr r2, [r4, #4]      ; stack access
    0xe00039e8    0x278    ldr r1, [r4]          ; stack access
    0xe00039ec    0x27c    str r1, [r3, #160] 
    0xe00039f0    0x280    str r2, [r3, #164] 
    0xe00039f4    0x284    mov r2, #0
    0xe00039f8    0x288    str r2, [r3, #168] 
    0xe00039fc    0x28c    mov r2, #3
    0xe0003a00    0x290    str r2, [r3, #172] 
    0xe0003a04    0x294    mov r0, r4
    0xe0003a08    0x298    add sp, sp, #24
    0xe0003a0c    0x29c    pop {r4, r5, r6, lr}  ; stack access
    0xe0003a10    0x2a0    add sp, sp, #8
    0xe0003a14    0x2a4    bx lr
    0xe0003a18    0x2a8    mov r3, #0
    0xe0003a1c    0x2ac    b e00039e4 <create_ipcbuf_frame_cap+0x274>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
102 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_ipcbuf_frame_cap` has 351 nodes.

Section create_rootserver_objects (255 of 293)
==============================================

Deriving specifications
-----------------------

Section `create_rootserver_objects` consists of 72 instructions.
 STMDB;2,0...+
 MOVNE (reg-shift)......++++++


Stack analysis
---------------

7 stack accesses found. Annotated code for `create_rootserver_objects`:

    0xe00031f0      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe00031f4      0x4    sub sp, sp, #16
    0xe00031f8      0x8    mov r5, r0
    0xe00031fc      0xc    mov r0, sp
    0xe0003200     0x10    stm r0, {r1, r2}      ; stack access
    0xe0003204     0x14    mov r6, r3
    0xe0003208     0x18    cmp r3, #16
    0xe000320c     0x1c    movcs r7, r3
    0xe0003210     0x20    movcc r7, #16
    0xe0003214     0x24    ldm r0, {r0, r1}      ; stack access
    0xe0003218     0x28    add r3, sp, #16
    0xe000321c     0x2c    stmdb r3, {r0, r2}    ; stack access
    0xe0003220     0x30    cmp r6, #0
    0xe0003224     0x34    movne r3, #1
    0xe0003228     0x38    lslne r8, r3, r6
    0xe000322c     0x3c    moveq r8, #0
    0xe0003230     0x40    add r3, sp, #16
    0xe0003234     0x44    ldmdb r3, {r0, r1}    ; stack access
    0xe0003238     0x48    bl e0000384 <arch_get_n_paging>
    0xe000323c     0x4c    movw r4, #47104 
    0xe0003240     0x50    movt r4, #57345 
    0xe0003244     0x54    str r5, [r4, #172] 
    0xe0003248     0x58    add r3, r5, #94208 
    0xe000324c     0x5c    add r3, r3, #512 
    0xe0003250     0x60    add r3, r3, r8
    0xe0003254     0x64    add r3, r3, r0, lsl #10
    0xe0003258     0x68    str r3, [r4, #176] 
    0xe000325c     0x6c    mov r1, r6
    0xe0003260     0x70    mov r0, r7
    0xe0003264     0x74    bl e00031b4 <maybe_alloc_extra_bi>
    0xe0003268     0x78    mov r1, #1
    0xe000326c     0x7c    mov r0, #16
    0xe0003270     0x80    bl e0003188 <alloc_rootserver_obj>
    0xe0003274     0x84    str r0, [r4, #136] 
    0xe0003278     0x88    mov r1, r6
    0xe000327c     0x8c    mov r0, #14
    0xe0003280     0x90    bl e00031b4 <maybe_alloc_extra_bi>
    0xe0003284     0x94    mov r1, #1
    0xe0003288     0x98    mov r0, #14
    0xe000328c     0x9c    bl e0003188 <alloc_rootserver_obj>
    0xe0003290     0xa0    str r0, [r4, #140] 
    0xe0003294     0xa4    mov r1, r6
    0xe0003298     0xa8    mov r0, #12
    0xe000329c     0xac    bl e00031b4 <maybe_alloc_extra_bi>
    0xe00032a0     0xb0    mov r1, #1
    0xe00032a4     0xb4    mov r0, #12
    0xe00032a8     0xb8    bl e0003188 <alloc_rootserver_obj>
    0xe00032ac     0xbc    str r0, [r4, #144] 
    0xe00032b0     0xc0    mov r1, #1
    0xe00032b4     0xc4    mov r0, #12
    0xe00032b8     0xc8    bl e0003188 <alloc_rootserver_obj>
    0xe00032bc     0xcc    str r0, [r4, #148] 
    0xe00032c0     0xd0    mov r1, #1
    0xe00032c4     0xd4    mov r0, #12
    0xe00032c8     0xd8    bl e0003188 <alloc_rootserver_obj>
    0xe00032cc     0xdc    str r0, [r4, #152] 
    0xe00032d0     0xe0    mov r3, sp
    0xe00032d4     0xe4    ldm r3, {r0, r1}      ; stack access
    0xe00032d8     0xe8    bl e0000384 <arch_get_n_paging>
    0xe00032dc     0xec    mov r5, r0
    0xe00032e0     0xf0    mov r1, r0
    0xe00032e4     0xf4    mov r0, #10
    0xe00032e8     0xf8    bl e0003188 <alloc_rootserver_obj>
    0xe00032ec     0xfc    str r0, [r4, #164] 
    0xe00032f0    0x100    add r0, r0, r5, lsl #10
    0xe00032f4    0x104    str r0, [r4, #168] 
    0xe00032f8    0x108    mov r1, #1
    0xe00032fc    0x10c    mov r0, #9
    0xe0003300    0x110    bl e0003188 <alloc_rootserver_obj>
    0xe0003304    0x114    str r0, [r4, #160] 
    0xe0003308    0x118    add sp, sp, #16
    0xe000330c    0x11c    pop {r4, r5, r6, r7, r8, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
72 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_rootserver_objects` has 111 nodes.

Section map_kernel_window (256 of 293)
======================================

Deriving specifications
-----------------------

Section `map_kernel_window` consists of 87 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `map_kernel_window`:

    0xe000302c      0x0    push {r4, lr}         ; stack access
    0xe0003030      0x4    ldr lr, [pc, #324] 
    0xe0003034      0x8    mov r3, #3584 
    0xe0003038      0xc    mov ip, #268435456 
    0xe000303c     0x10    movw r4, #22022 
    0xe0003040     0x14    movt r4, #4
    0xe0003044     0x18    b e000305c <map_kernel_window+0x30>
    0xe0003048     0x1c    add ip, ip, #16777216 
    0xe000304c     0x20    add lr, lr, #64 
    0xe0003050     0x24    mov r3, r1
    0xe0003054     0x28    cmp ip, #788529152 
    0xe0003058     0x2c    beq e0003084 <map_kernel_window+0x58>
    0xe000305c     0x30    orr r0, ip, r4
    0xe0003060     0x34    add r1, r3, #16
    0xe0003064     0x38    cmp r1, r3
    0xe0003068     0x3c    bls e0003048 <map_kernel_window+0x1c>
    0xe000306c     0x40    mov r2, lr
    0xe0003070     0x44    str r0, [r2], #4
    0xe0003074     0x48    add r3, r3, #1
    0xe0003078     0x4c    cmp r3, r1
    0xe000307c     0x50    bcc e0003070 <map_kernel_window+0x44>
    0xe0003080     0x54    b e0003048 <map_kernel_window+0x1c>
    0xe0003084     0x58    ldr r3, [pc, #244] 
    0xe0003088     0x5c    movw r2, #22022 
    0xe000308c     0x60    movt r2, #12032 
    0xe0003090     0x64    str r2, [r3, #4032] 
    0xe0003094     0x68    movw r2, #22022 
    0xe0003098     0x6c    movt r2, #12048 
    0xe000309c     0x70    str r2, [r3, #4036] 
    0xe00030a0     0x74    movw r2, #22022 
    0xe00030a4     0x78    movt r2, #12064 
    0xe00030a8     0x7c    str r2, [r3, #4040] 
    0xe00030ac     0x80    movw r2, #22022 
    0xe00030b0     0x84    movt r2, #12080 
    0xe00030b4     0x88    str r2, [r3, #4044] 
    0xe00030b8     0x8c    movw r2, #22022 
    0xe00030bc     0x90    movt r2, #12096 
    0xe00030c0     0x94    str r2, [r3, #4048] 
    0xe00030c4     0x98    movw r2, #22022 
    0xe00030c8     0x9c    movt r2, #12112 
    0xe00030cc     0xa0    str r2, [r3, #4052] 
    0xe00030d0     0xa4    movw r2, #22022 
    0xe00030d4     0xa8    movt r2, #12128 
    0xe00030d8     0xac    str r2, [r3, #4056] 
    0xe00030dc     0xb0    movw r2, #22022 
    0xe00030e0     0xb4    movt r2, #12144 
    0xe00030e4     0xb8    str r2, [r3, #4060] 
    0xe00030e8     0xbc    movw r2, #22022 
    0xe00030ec     0xc0    movt r2, #12160 
    0xe00030f0     0xc4    str r2, [r3, #4064] 
    0xe00030f4     0xc8    movw r2, #22022 
    0xe00030f8     0xcc    movt r2, #12176 
    0xe00030fc     0xd0    str r2, [r3, #4068] 
    0xe0003100     0xd4    movw r2, #22022 
    0xe0003104     0xd8    movt r2, #12192 
    0xe0003108     0xdc    str r2, [r3, #4072] 
    0xe000310c     0xe0    movw r2, #22022 
    0xe0003110     0xe4    movt r2, #12208 
    0xe0003114     0xe8    str r2, [r3, #4076] 
    0xe0003118     0xec    movw r2, #22022 
    0xe000311c     0xf0    movt r2, #12224 
    0xe0003120     0xf4    str r2, [r3, #4080] 
    0xe0003124     0xf8    movw r2, #22022 
    0xe0003128     0xfc    movt r2, #12240 
    0xe000312c    0x100    str r2, [r3, #4084] 
    0xe0003130    0x104    movw r2, #22022 
    0xe0003134    0x108    movt r2, #12256 
    0xe0003138    0x10c    str r2, [r3, #4088] 
    0xe000313c    0x110    movw r0, #0
    0xe0003140    0x114    movt r0, #57346 
    0xe0003144    0x118    add r2, r0, #805306368 
    0xe0003148    0x11c    orr r2, r2, #512 
    0xe000314c    0x120    orr r2, r2, #1
    0xe0003150    0x124    str r2, [r3, #4092] 
    0xe0003154    0x128    mov r1, #1024 
    0xe0003158    0x12c    bl e0019244 <memzero>
    0xe000315c    0x130    mov r3, #3
    0xe0003160    0x134    mov r2, #1
    0xe0003164    0x138    mov r1, #0
    0xe0003168    0x13c    movt r1, #65535 
    0xe000316c    0x140    ldr r0, [pc, #16] 
    0xe0003170    0x144    bl e0000334 <map_kernel_frame>
    0xe0003174    0x148    bl e0000d20 <map_kernel_devices>
    0xe0003178    0x14c    pop {r4, pc}          ; stack access
    0xe000317c    0x150    .word 0xe0027800
    0xe0003180    0x154    .word 0xe0027000
    0xe0003184    0x158    .word 0x10010000

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
84 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_window` has 112 nodes.

Section create_it_address_space (257 of 293)
============================================

Deriving specifications
-----------------------

Section `create_it_address_space` consists of 210 instructions.
Switch found.
Switch found.


Stack analysis
---------------

Section `create_it_address_space` expects pointer to stack in r0.
18 stack accesses found. Annotated code for `create_it_address_space`:

    0xe0001660      0x0    sub sp, sp, #8
    0xe0001664      0x4    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0001668      0x8    sub sp, sp, #28
    0xe000166c      0xc    mov sl, r0
    0xe0001670     0x10    add r0, sp, #8
    0xe0001674     0x14    stm r0, {r1, r2}      ; stack access
    0xe0001678     0x18    str r3, [sp, #68]     ; stack access
    0xe000167c     0x1c    ldr r8, [sp, #72]     ; stack access
    0xe0001680     0x20    movw r4, #47104 
    0xe0001684     0x24    movt r4, #57345 
    0xe0001688     0x28    ldr r0, [r4, #140] 
    0xe000168c     0x2c    bl e0011268 <copyGlobalMappings>
    0xe0001690     0x30    ldr r0, [r4, #140] 
    0xe0001694     0x34    add r2, r0, #805306368 
    0xe0001698     0x38    add r1, r0, #16320 
    0xe000169c     0x3c    add r1, r1, #63 
    0xe00016a0     0x40    bl e00120c8 <cleanCacheRange_PoU>
    0xe00016a4     0x44    ldr r7, [r4, #140] 
    0xe00016a8     0x48    bic r7, r7, #16320 
    0xe00016ac     0x4c    bic r7, r7, #63 
    0xe00016b0     0x50    orr fp, r7, #25
    0xe00016b4     0x54    ldr r3, [r4, #128] 
    0xe00016b8     0x58    str r3, [sp, #4]      ; stack access
    0xe00016bc     0x5c    ldr r3, [sp, #8]      ; stack access
    0xe00016c0     0x60    ldr r0, [sp, #12]     ; stack access
    0xe00016c4     0x64    and r2, r3, #14
    0xe00016c8     0x68    cmp r2, #14
    0xe00016cc     0x6c    andne r1, r3, #15
    0xe00016d0     0x70    uxtbeq r1, r3
    0xe00016d4     0x74    sub r2, r1, #2
    0xe00016d8     0x78    cmp r2, #60 
    0xe00016dc     0x7c    ldrls pc, [pc, r2, lsl #2]
    0xe00016e0     0x80    b e0001828 <create_it_address_space+0x1c8>
    0xe00016e4     0x84    .word 0xe00017d8
    0xe00016e8     0x88    .word 0xe0001828
    0xe00016ec     0x8c    .word 0xe00017e0
    0xe00016f0     0x90    .word 0xe0001828
    0xe00016f4     0x94    .word 0xe00017e8
    0xe00016f8     0x98    .word 0xe0001828
    0xe00016fc     0x9c    .word 0xe00018b4
    0xe0001700     0xa0    .word 0xe0001828
    0xe0001704     0xa4    .word 0xe00017f0
    0xe0001708     0xa8    .word 0xe0001828
    0xe000170c     0xac    .word 0xe00017f8
    0xe0001710     0xb0    .word 0xe0001828
    0xe0001714     0xb4    .word 0xe00018b4
    0xe0001718     0xb8    .word 0xe0001828
    0xe000171c     0xbc    .word 0xe0001828
    0xe0001720     0xc0    .word 0xe0001828
    0xe0001724     0xc4    .word 0xe0001828
    0xe0001728     0xc8    .word 0xe0001828
    0xe000172c     0xcc    .word 0xe0001828
    0xe0001730     0xd0    .word 0xe0001828
    0xe0001734     0xd4    .word 0xe0001828
    0xe0001738     0xd8    .word 0xe0001828
    0xe000173c     0xdc    .word 0xe0001828
    0xe0001740     0xe0    .word 0xe0001828
    0xe0001744     0xe4    .word 0xe0001828
    0xe0001748     0xe8    .word 0xe0001828
    0xe000174c     0xec    .word 0xe0001828
    0xe0001750     0xf0    .word 0xe0001828
    0xe0001754     0xf4    .word 0xe00018b4
    0xe0001758     0xf8    .word 0xe0001828
    0xe000175c     0xfc    .word 0xe0001828
    0xe0001760    0x100    .word 0xe0001828
    0xe0001764    0x104    .word 0xe0001828
    0xe0001768    0x108    .word 0xe0001828
    0xe000176c    0x10c    .word 0xe0001828
    0xe0001770    0x110    .word 0xe0001828
    0xe0001774    0x114    .word 0xe0001828
    0xe0001778    0x118    .word 0xe0001828
    0xe000177c    0x11c    .word 0xe0001828
    0xe0001780    0x120    .word 0xe0001828
    0xe0001784    0x124    .word 0xe0001828
    0xe0001788    0x128    .word 0xe0001828
    0xe000178c    0x12c    .word 0xe0001828
    0xe0001790    0x130    .word 0xe0001828
    0xe0001794    0x134    .word 0xe0001804
    0xe0001798    0x138    .word 0xe0001828
    0xe000179c    0x13c    .word 0xe0001828
    0xe00017a0    0x140    .word 0xe0001828
    0xe00017a4    0x144    .word 0xe0001828
    0xe00017a8    0x148    .word 0xe0001828
    0xe00017ac    0x14c    .word 0xe0001828
    0xe00017b0    0x150    .word 0xe0001828
    0xe00017b4    0x154    .word 0xe0001828
    0xe00017b8    0x158    .word 0xe0001828
    0xe00017bc    0x15c    .word 0xe0001828
    0xe00017c0    0x160    .word 0xe0001828
    0xe00017c4    0x164    .word 0xe0001828
    0xe00017c8    0x168    .word 0xe0001828
    0xe00017cc    0x16c    .word 0xe0001828
    0xe00017d0    0x170    .word 0xe0001828
    0xe00017d4    0x174    .word 0xe00018b4
    0xe00017d8    0x178    bic r3, r3, #15
    0xe00017dc    0x17c    b e00018b8 <create_it_address_space+0x258>
    0xe00017e0    0x180    bic r3, r0, #15
    0xe00017e4    0x184    b e00018b8 <create_it_address_space+0x258>
    0xe00017e8    0x188    bic r3, r3, #15
    0xe00017ec    0x18c    b e00018b8 <create_it_address_space+0x258>
    0xe00017f0    0x190    bic r3, r3, #31
    0xe00017f4    0x194    b e00018b8 <create_it_address_space+0x258>
    0xe00017f8    0x198    bic r3, r3, #508 
    0xe00017fc    0x19c    bic r3, r3, #3
    0xe0001800    0x1a0    b e00018b8 <create_it_address_space+0x258>
    0xe0001804    0x1a4    lsr r3, r3, #8
    0xe0001808    0x1a8    and r2, r3, #63 
    0xe000180c    0x1ac    cmp r2, #32
    0xe0001810    0x1b0    andne r3, r3, #31
    0xe0001814    0x1b4    moveq r3, #4
    0xe0001818    0x1b8    add r3, r3, #1
    0xe000181c    0x1bc    mvn r2, #0
    0xe0001820    0x1c0    and r3, r0, r2, lsl r3
    0xe0001824    0x1c4    b e00018b8 <create_it_address_space+0x258>
    0xe0001828    0x1c8    sub r2, r1, #1
    0xe000182c    0x1cc    cmp r2, #8
    0xe0001830    0x1d0    ldrls pc, [pc, r2, lsl #2]
    0xe0001834    0x1d4    b e0001990 <create_it_address_space+0x330>
    0xe0001838    0x1d8    .word 0xe000185c
    0xe000183c    0x1dc    .word 0xe0001990
    0xe0001840    0x1e0    .word 0xe000185c
    0xe0001844    0x1e4    .word 0xe0001990
    0xe0001848    0x1e8    .word 0xe00018ac
    0xe000184c    0x1ec    .word 0xe0001990
    0xe0001850    0x1f0    .word 0xe0001894
    0xe0001854    0x1f4    .word 0xe0001990
    0xe0001858    0x1f8    .word 0xe00018a0
    0xe000185c    0x1fc    cmp r1, #1
    0xe0001860    0x200    beq e0001874 <create_it_address_space+0x214>
    0xe0001864    0x204    cmp r1, #3
    0xe0001868    0x208    beq e0001884 <create_it_address_space+0x224>
    0xe000186c    0x20c    mov r3, #0
    0xe0001870    0x210    b e00018b8 <create_it_address_space+0x258>
    0xe0001874    0x214    lsl r3, r3, #8
    0xe0001878    0x218    bic r3, r3, #4080 
    0xe000187c    0x21c    bic r3, r3, #15
    0xe0001880    0x220    b e00018b8 <create_it_address_space+0x258>
    0xe0001884    0x224    lsl r3, r3, #10
    0xe0001888    0x228    bic r3, r3, #16320 
    0xe000188c    0x22c    bic r3, r3, #63 
    0xe0001890    0x230    b e00018b8 <create_it_address_space+0x258>
    0xe0001894    0x234    bic r3, r3, #1020 
    0xe0001898    0x238    bic r3, r3, #3
    0xe000189c    0x23c    b e00018b8 <create_it_address_space+0x258>
    0xe00018a0    0x240    bic r3, r3, #16320 
    0xe00018a4    0x244    bic r3, r3, #63 
    0xe00018a8    0x248    b e00018b8 <create_it_address_space+0x258>
    0xe00018ac    0x24c    bic r3, r3, #15
    0xe00018b0    0x250    b e00018b8 <create_it_address_space+0x258>
    0xe00018b4    0x254    mov r3, #0
    0xe00018b8    0x258    str fp, [r3, #48] 
    0xe00018bc    0x25c    mov r2, #1
    0xe00018c0    0x260    str r2, [r3, #52] 
    0xe00018c4    0x264    mov r2, #0
    0xe00018c8    0x268    str r2, [r3, #56] 
    0xe00018cc    0x26c    mov r2, #3
    0xe00018d0    0x270    str r2, [r3, #60] 
    0xe00018d4    0x274    ldr r4, [sp, #68]     ; stack access
    0xe00018d8    0x278    lsr r4, r4, #20
    0xe00018dc    0x27c    lsl r4, r4, #20
    0xe00018e0    0x280    cmp r8, r4
    0xe00018e4    0x284    bls e0001954 <create_it_address_space+0x2f4>
    0xe00018e8    0x288    movw r5, #47104 
    0xe00018ec    0x28c    movt r5, #57345 
    0xe00018f0    0x290    movw r9, #513 
    0xe00018f4    0x294    add r6, sp, #16
    0xe00018f8    0x298    ldr r3, [r5, #164] 
    0xe00018fc    0x29c    add r2, r3, #1024 
    0xe0001900    0x2a0    str r2, [r5, #164] 
    0xe0001904    0x2a4    bic r3, r3, #1020 
    0xe0001908    0x2a8    bic r3, r3, #3
    0xe000190c    0x2ac    lsr r2, r4, #20
    0xe0001910    0x2b0    add r1, r3, #805306368 
    0xe0001914    0x2b4    orr r1, r1, r9
    0xe0001918    0x2b8    str r1, [r7, r2, lsl #2]
    0xe000191c    0x2bc    orr r3, r3, #7
    0xe0001920    0x2c0    str r3, [sp, #16]     ; stack access
    0xe0001924    0x2c4    orr r3, r2, #536870912 
    0xe0001928    0x2c8    orr r3, r3, #4096 
    0xe000192c    0x2cc    str r3, [sp, #20]     ; stack access
    0xe0001930    0x2d0    ldm r6, {r2, r3}      ; stack access
    0xe0001934    0x2d4    add r1, sp, #8
    0xe0001938    0x2d8    ldm r1, {r0, r1}      ; stack access
    0xe000193c    0x2dc    bl e00013e4 <provide_cap>
    0xe0001940    0x2e0    cmp r0, #0
    0xe0001944    0x2e4    beq e0001998 <create_it_address_space+0x338>
    0xe0001948    0x2e8    add r4, r4, #1048576 
    0xe000194c    0x2ec    cmp r8, r4
    0xe0001950    0x2f0    bhi e00018f8 <create_it_address_space+0x298>
    0xe0001954    0x2f4    movw r3, #47104 
    0xe0001958    0x2f8    movt r3, #57345 
    0xe000195c    0x2fc    ldr r2, [r3, #128] 
    0xe0001960    0x300    ldr r3, [r3, #124] 
    0xe0001964    0x304    ldr r1, [sp, #4]      ; stack access
    0xe0001968    0x308    str r1, [r3, #44] 
    0xe000196c    0x30c    str r2, [r3, #48] 
    0xe0001970    0x310    str fp, [sl]          ; stack access
    0xe0001974    0x314    mov r3, #1
    0xe0001978    0x318    str r3, [sl, #4]      ; stack access
    0xe000197c    0x31c    mov r0, sl
    0xe0001980    0x320    add sp, sp, #28
    0xe0001984    0x324    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0001988    0x328    add sp, sp, #8
    0xe000198c    0x32c    bx lr
    0xe0001990    0x330    mov r3, #0
    0xe0001994    0x334    b e00018b8 <create_it_address_space+0x258>
    0xe0001998    0x338    mov r3, #0
    0xe000199c    0x33c    str r3, [sl]          ; stack access
    0xe00019a0    0x340    str r3, [sl, #4]      ; stack access
    0xe00019a4    0x344    b e000197c <create_it_address_space+0x31c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
140 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_it_address_space` has 408 nodes.

Section _start (258 of 293)
===========================

Deriving specifications
-----------------------

Section `_start` consists of 24 instructions.
 LDMIA (wb);8,7.+
 MSR (cpsr, reg, control).+
Skipping ee114f10 mrc 15, 0, r4, cr1, cr0, {0}
 BIC (reg)..........+++++
Skipping ee014f10 mcr 15, 0, r4, cr1, cr0, {0}
 STMDB (wb);8,7,3,2,1,0..+
 LDMIA (wb);8,7,3,2,1,0.+
Skipping f1020017 cps #23
Skipping f1020013 cps #19
 STMDB (wb);8,7..+


Stack analysis
---------------

1 stack accesses found. Annotated code for `_start`:

    0xe0000000     0x0    pop {r7, r8}          ; stack access
    0xe0000004     0x4    ldr r5, [pc, #64] 
    0xe0000008     0x8    msr CPSR_fc, r5
    0xe000000c     0xc    mrc 15, 0, r4, cr1, cr0, {0}
    0xe0000010    0x10    ldr r5, [pc, #56] 
    0xe0000014    0x14    ldr r6, [pc, #56] 
    0xe0000018    0x18    orr r4, r4, r5
    0xe000001c    0x1c    bic r4, r4, r6
    0xe0000020    0x20    mcr 15, 0, r4, cr1, cr0, {0}
    0xe0000024    0x24    ldr sp, [pc, #44] 
    0xe0000028    0x28    push {r0, r1, r2, r3, r7, r8}
    0xe000002c    0x2c    bl e0000a08 <arm_errata>
    0xe0000030    0x30    pop {r0, r1, r2, r3, r7, r8}
    0xe0000034    0x34    cps #23
    0xe0000038    0x38    ldr sp, [pc, #28] 
    0xe000003c    0x3c    cps #19
    0xe0000040    0x40    push {r7, r8}
    0xe0000044    0x44    bl e0003b14 <init_kernel>
    0xe0000048    0x48    b e00108d8 <restore_user_context>
    0xe000004c    0x4c    .word 0x000001d3
    0xe0000050    0x50    .word 0x00c03805
    0xe0000054    0x54    .word 0x33004382
    0xe0000058    0x58    .word 0xe0029010
    0xe000005c    0x5c    .word 0xe001c8b8

Proving inst theorems
---------------------

Graph spec failed in _start for pos 0xe0000008.
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `_start` has 29 nodes.

Section decodeSetIPCBuffer (259 of 293)
=======================================

Deriving specifications
-----------------------

Section `decodeSetIPCBuffer` consists of 74 instructions.
+


Stack analysis
---------------

25 stack accesses found. Annotated code for `decodeSetIPCBuffer`:

    0xe00181a8      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00181ac      0x4    sub sp, sp, #88 
    0xe00181b0      0x8    add ip, sp, #48 
    0xe00181b4      0xc    stm ip, {r0, r1}      ; stack access
    0xe00181b8     0x10    ldr r4, [sp, #104]    ; stack access
    0xe00181bc     0x14    cmp r2, #0
    0xe00181c0     0x18    cmpne r4, #0
    0xe00181c4     0x1c    beq e0018234 <decodeSetIPCBuffer+0x8c>
    0xe00181c8     0x20    mov r6, r3
    0xe00181cc     0x24    movw r2, #13900 
    0xe00181d0     0x28    movt r2, #57347 
    0xe00181d4     0x2c    ldr r3, [r2]
    0xe00181d8     0x30    ldr r5, [r3, #8]
    0xe00181dc     0x34    add r2, sp, #72 
    0xe00181e0     0x38    ldm r4, {r0, r1}
    0xe00181e4     0x3c    stm r2, {r0, r1}      ; stack access
    0xe00181e8     0x40    cmp r5, #0
    0xe00181ec     0x44    beq e0018250 <decodeSetIPCBuffer+0xa8>
    0xe00181f0     0x48    ldm r2, {r2, r3}      ; stack access
    0xe00181f4     0x4c    mov r1, r4
    0xe00181f8     0x50    add r0, sp, #60 
    0xe00181fc     0x54    bl e00142e4 <deriveCap>
    0xe0018200     0x58    ldr r0, [sp, #60]     ; stack access
    0xe0018204     0x5c    cmp r0, #0
    0xe0018208     0x60    bne e0018248 <decodeSetIPCBuffer+0xa0>
    0xe001820c     0x64    add r3, sp, #72 
    0xe0018210     0x68    add r2, sp, #64 
    0xe0018214     0x6c    ldm r2, {r0, r1}      ; stack access
    0xe0018218     0x70    stm r3, {r0, r1}      ; stack access
    0xe001821c     0x74    ldm r3, {r1, r2}      ; stack access
    0xe0018220     0x78    mov r0, r5
    0xe0018224     0x7c    bl e0010e08 <checkValidIPCBuffer>
    0xe0018228     0x80    cmp r0, #0
    0xe001822c     0x84    beq e0018254 <decodeSetIPCBuffer+0xac>
    0xe0018230     0x88    b e0018248 <decodeSetIPCBuffer+0xa0>
    0xe0018234     0x8c    movw r3, #36896 
    0xe0018238     0x90    movt r3, #57346 
    0xe001823c     0x94    mov r2, #7
    0xe0018240     0x98    str r2, [r3, #24]
    0xe0018244     0x9c    mov r0, #3
    0xe0018248     0xa0    add sp, sp, #88 
    0xe001824c     0xa4    pop {r4, r5, r6, pc}  ; stack access
    0xe0018250     0xa8    mov r4, #0
    0xe0018254     0xac    movw r3, #13900 
    0xe0018258     0xb0    movt r3, #57347 
    0xe001825c     0xb4    mov r1, #2
    0xe0018260     0xb8    ldr r0, [r3]
    0xe0018264     0xbc    bl e0014ad8 <setThreadState>
    0xe0018268     0xc0    mov r2, #0
    0xe001826c     0xc4    str r2, [sp, #80]     ; stack access
    0xe0018270     0xc8    str r2, [sp, #84]     ; stack access
    0xe0018274     0xcc    mov r3, #2
    0xe0018278     0xd0    str r3, [sp, #44]     ; stack access
    0xe001827c     0xd4    str r4, [sp, #40]     ; stack access
    0xe0018280     0xd8    add r3, sp, #32
    0xe0018284     0xdc    add r1, sp, #72 
    0xe0018288     0xe0    ldm r1, {r0, r1}      ; stack access
    0xe001828c     0xe4    stm r3, {r0, r1}      ; stack access
    0xe0018290     0xe8    str r5, [sp, #28]     ; stack access
    0xe0018294     0xec    str r2, [sp, #24]     ; stack access
    0xe0018298     0xf0    add r3, sp, #16
    0xe001829c     0xf4    add ip, sp, #80 
    0xe00182a0     0xf8    ldm ip, {r0, r1}      ; stack access
    0xe00182a4     0xfc    stm r3, {r0, r1}      ; stack access
    0xe00182a8    0x100    str r2, [sp, #12]     ; stack access
    0xe00182ac    0x104    ldm ip, {r0, r1}      ; stack access
    0xe00182b0    0x108    stmib sp, {r0, r1}    ; stack access
    0xe00182b4    0x10c    str r2, [sp]          ; stack access
    0xe00182b8    0x110    mov r3, r2
    0xe00182bc    0x114    mov r1, r6
    0xe00182c0    0x118    ldr r0, [sp, #48]     ; stack access
    0xe00182c4    0x11c    bic r0, r0, #15
    0xe00182c8    0x120    bl e0017924 <invokeTCB_ThreadControl>
    0xe00182cc    0x124    b e0018248 <decodeSetIPCBuffer+0xa0>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
74 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetIPCBuffer` has 118 nodes.

Section handleVMFaultEvent (260 of 293)
=======================================

Deriving specifications
-----------------------

Section `handleVMFaultEvent` consists of 17 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleVMFaultEvent`:

    0xe00173e4     0x0    push {r4, lr}         ; stack access
    0xe00173e8     0x4    movw r3, #13900 
    0xe00173ec     0x8    movt r3, #57347 
    0xe00173f0     0xc    mov r1, r0
    0xe00173f4    0x10    ldr r0, [r3]
    0xe00173f8    0x14    bl e00112a0 <handleVMFault>
    0xe00173fc    0x18    cmp r0, #0
    0xe0017400    0x1c    bne e0017414 <handleVMFaultEvent+0x30>
    0xe0017404    0x20    bl e00152f8 <schedule>
    0xe0017408    0x24    bl e0014c6c <activateThread>
    0xe001740c    0x28    mov r0, #0
    0xe0017410    0x2c    pop {r4, pc}          ; stack access
    0xe0017414    0x30    movw r3, #13900 
    0xe0017418    0x34    movt r3, #57347 
    0xe001741c    0x38    ldr r0, [r3]
    0xe0017420    0x3c    bl e001734c <handleFault>
    0xe0017424    0x40    b e0017404 <handleVMFaultEvent+0x20>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleVMFaultEvent` has 27 nodes.

Section sendSignal (261 of 293)
===============================

Deriving specifications
-----------------------

Section `sendSignal` consists of 77 instructions.


Stack analysis
---------------

9 stack accesses found. Annotated code for `sendSignal`:

    0xe0016764      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0016768      0x4    sub sp, sp, #16
    0xe001676c      0x8    mov r4, r0
    0xe0016770      0xc    mov r5, r1
    0xe0016774     0x10    ldr r3, [r0]
    0xe0016778     0x14    and r2, r3, #3
    0xe001677c     0x18    cmp r2, #1
    0xe0016780     0x1c    beq e0016800 <sendSignal+0x9c>
    0xe0016784     0x20    bcc e0016798 <sendSignal+0x34>
    0xe0016788     0x24    cmp r2, #2
    0xe001678c     0x28    beq e0016888 <sendSignal+0x124>
    0xe0016790     0x2c    add sp, sp, #16
    0xe0016794     0x30    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0016798     0x34    ldr r0, [r0, #12]
    0xe001679c     0x38    bics r6, r0, #15
    0xe00167a0     0x3c    beq e00167ec <sendSignal+0x88>
    0xe00167a4     0x40    ldr r2, [r6, #80] 
    0xe00167a8     0x44    and r2, r2, #15
    0xe00167ac     0x48    cmp r2, #3
    0xe00167b0     0x4c    beq e00167c8 <sendSignal+0x64>
    0xe00167b4     0x50    bic r3, r3, #3
    0xe00167b8     0x54    orr r3, r3, #2
    0xe00167bc     0x58    str r3, [r4]
    0xe00167c0     0x5c    str r1, [r4, #8]
    0xe00167c4     0x60    b e0016790 <sendSignal+0x2c>
    0xe00167c8     0x64    mov r0, r6
    0xe00167cc     0x68    bl e001575c <cancelIPC>
    0xe00167d0     0x6c    mov r1, #1
    0xe00167d4     0x70    mov r0, r6
    0xe00167d8     0x74    bl e0014ad8 <setThreadState>
    0xe00167dc     0x78    str r5, [r6]
    0xe00167e0     0x7c    mov r0, r6
    0xe00167e4     0x80    bl e0014ed4 <possibleSwitchTo>
    0xe00167e8     0x84    b e0016790 <sendSignal+0x2c>
    0xe00167ec     0x88    bic r3, r3, #3
    0xe00167f0     0x8c    orr r3, r3, #2
    0xe00167f4     0x90    str r3, [r4]
    0xe00167f8     0x94    str r1, [r4, #8]
    0xe00167fc     0x98    b e0016790 <sendSignal+0x2c>
    0xe0016800     0x9c    ldr r6, [r0, #4]
    0xe0016804     0xa0    bic r6, r6, #15
    0xe0016808     0xa4    str r6, [sp, #8]      ; stack access
    0xe001680c     0xa8    bic r3, r3, #15
    0xe0016810     0xac    str r3, [sp, #12]     ; stack access
    0xe0016814     0xb0    mov r8, sp
    0xe0016818     0xb4    add r7, sp, #8
    0xe001681c     0xb8    ldm r7, {r2, r3}      ; stack access
    0xe0016820     0xbc    mov r1, r6
    0xe0016824     0xc0    mov r0, r8
    0xe0016828     0xc4    bl e0015538 <tcbEPDequeue>
    0xe001682c     0xc8    ldm r8, {r0, r1}      ; stack access
    0xe0016830     0xcc    stm r7, {r0, r1}      ; stack access
    0xe0016834     0xd0    ldr r1, [sp, #8]      ; stack access
    0xe0016838     0xd4    ldr r3, [r4, #4]
    0xe001683c     0xd8    and r3, r3, #15
    0xe0016840     0xdc    bic r2, r1, #15
    0xe0016844     0xe0    orr r3, r3, r2
    0xe0016848     0xe4    str r3, [r4, #4]
    0xe001684c     0xe8    ldr r3, [r4]
    0xe0016850     0xec    and r3, r3, #15
    0xe0016854     0xf0    ldr r2, [sp, #12]     ; stack access
    0xe0016858     0xf4    bic r2, r2, #15
    0xe001685c     0xf8    orr r3, r3, r2
    0xe0016860     0xfc    cmp r1, #0
    0xe0016864    0x100    biceq r3, r3, #3
    0xe0016868    0x104    str r3, [r4]
    0xe001686c    0x108    mov r1, #1
    0xe0016870    0x10c    mov r0, r6
    0xe0016874    0x110    bl e0014ad8 <setThreadState>
    0xe0016878    0x114    str r5, [r6]
    0xe001687c    0x118    mov r0, r6
    0xe0016880    0x11c    bl e0014ed4 <possibleSwitchTo>
    0xe0016884    0x120    b e0016790 <sendSignal+0x2c>
    0xe0016888    0x124    ldr r3, [r0, #8]
    0xe001688c    0x128    orr r5, r3, r1
    0xe0016890    0x12c    str r5, [r0, #8]
    0xe0016894    0x130    b e0016790 <sendSignal+0x2c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
77 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendSignal` has 120 nodes.

Section decodeIRQHandlerInvocation (262 of 293)
===============================================

Deriving specifications
-----------------------

Section `decodeIRQHandlerInvocation` consists of 82 instructions.
 LDMIA (wb);14,7,6,5,4.+
+


Stack analysis
---------------

8 stack accesses found. Annotated code for `decodeIRQHandlerInvocation`:

    0xe00165b8      0x0    sub sp, sp, #8
    0xe00165bc      0x4    push {r4, r5, r6, r7, lr}  ; stack access
    0xe00165c0      0x8    sub sp, sp, #12
    0xe00165c4      0xc    mov r4, r1
    0xe00165c8     0x10    add r1, sp, #28
    0xe00165cc     0x14    stmib r1, {r2, r3}    ; stack access
    0xe00165d0     0x18    cmp r0, #27
    0xe00165d4     0x1c    beq e001662c <decodeIRQHandlerInvocation+0x74>
    0xe00165d8     0x20    cmp r0, #28
    0xe00165dc     0x24    beq e00166dc <decodeIRQHandlerInvocation+0x124>
    0xe00165e0     0x28    cmp r0, #26
    0xe00165e4     0x2c    beq e00165fc <decodeIRQHandlerInvocation+0x44>
    0xe00165e8     0x30    movw r3, #36896 
    0xe00165ec     0x34    movt r3, #57346 
    0xe00165f0     0x38    mov r0, #3
    0xe00165f4     0x3c    str r0, [r3, #24]
    0xe00165f8     0x40    b e001661c <decodeIRQHandlerInvocation+0x64>
    0xe00165fc     0x44    movw r3, #13900 
    0xe0016600     0x48    movt r3, #57347 
    0xe0016604     0x4c    mov r1, #2
    0xe0016608     0x50    ldr r0, [r3]
    0xe001660c     0x54    bl e0014ad8 <setThreadState>
    0xe0016610     0x58    mov r0, r4
    0xe0016614     0x5c    bl e0013608 <invokeIRQHandler_AckIRQ>
    0xe0016618     0x60    mov r0, #0
    0xe001661c     0x64    add sp, sp, #12
    0xe0016620     0x68    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0016624     0x6c    add sp, sp, #8
    0xe0016628     0x70    bx lr
    0xe001662c     0x74    ldr r5, [sp, #32]     ; stack access
    0xe0016630     0x78    cmp r5, #0
    0xe0016634     0x7c    beq e0016680 <decodeIRQHandlerInvocation+0xc8>
    0xe0016638     0x80    ldm r5, {r0, r1}
    0xe001663c     0x84    add r3, sp, #8
    0xe0016640     0x88    stmdb r3, {r0, r1}    ; stack access
    0xe0016644     0x8c    mov r6, r0
    0xe0016648     0x90    and r3, r0, #14
    0xe001664c     0x94    cmp r3, #14
    0xe0016650     0x98    andne r3, r0, #15
    0xe0016654     0x9c    uxtbeq r3, r0
    0xe0016658     0xa0    cmp r3, #6
    0xe001665c     0xa4    beq e0016698 <decodeIRQHandlerInvocation+0xe0>
    0xe0016660     0xa8    movw r3, #36896 
    0xe0016664     0xac    movt r3, #57346 
    0xe0016668     0xb0    mov r2, #2
    0xe001666c     0xb4    str r2, [r3, #24]
    0xe0016670     0xb8    mov r2, #0
    0xe0016674     0xbc    str r2, [r3, #4]
    0xe0016678     0xc0    mov r0, #3
    0xe001667c     0xc4    b e001661c <decodeIRQHandlerInvocation+0x64>
    0xe0016680     0xc8    movw r3, #36896 
    0xe0016684     0xcc    movt r3, #57346 
    0xe0016688     0xd0    mov r2, #7
    0xe001668c     0xd4    str r2, [r3, #24]
    0xe0016690     0xd8    mov r0, #3
    0xe0016694     0xdc    b e001661c <decodeIRQHandlerInvocation+0x64>
    0xe0016698     0xe0    ldr r7, [r5, #4]
    0xe001669c     0xe4    tst r7, #1
    0xe00166a0     0xe8    beq e0016660 <decodeIRQHandlerInvocation+0xa8>
    0xe00166a4     0xec    movw r3, #13900 
    0xe00166a8     0xf0    movt r3, #57347 
    0xe00166ac     0xf4    mov r1, #2
    0xe00166b0     0xf8    ldr r0, [r3]
    0xe00166b4     0xfc    bl e0014ad8 <setThreadState>
    0xe00166b8    0x100    str r6, [sp]          ; stack access
    0xe00166bc    0x104    str r7, [sp, #4]      ; stack access
    0xe00166c0    0x108    mov r3, r5
    0xe00166c4    0x10c    add r2, sp, #8
    0xe00166c8    0x110    ldmdb r2, {r1, r2}    ; stack access
    0xe00166cc    0x114    mov r0, r4
    0xe00166d0    0x118    bl e0016560 <invokeIRQHandler_SetIRQHandler>
    0xe00166d4    0x11c    mov r0, #0
    0xe00166d8    0x120    b e001661c <decodeIRQHandlerInvocation+0x64>
    0xe00166dc    0x124    movw r3, #13900 
    0xe00166e0    0x128    movt r3, #57347 
    0xe00166e4    0x12c    mov r1, #2
    0xe00166e8    0x130    ldr r0, [r3]
    0xe00166ec    0x134    bl e0014ad8 <setThreadState>
    0xe00166f0    0x138    mov r0, r4
    0xe00166f4    0x13c    bl e00165a0 <invokeIRQHandler_ClearIRQHandler>
    0xe00166f8    0x140    mov r0, #0
    0xe00166fc    0x144    b e001661c <decodeIRQHandlerInvocation+0x64>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
82 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeIRQHandlerInvocation` has 122 nodes.

Section cancelIPC (263 of 293)
==============================

Deriving specifications
-----------------------

Section `cancelIPC` consists of 60 instructions.
Switch found.


Stack analysis
---------------

9 stack accesses found. Annotated code for `cancelIPC`:

    0xe001575c     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0015760     0x4    sub sp, sp, #20
    0xe0015764     0x8    mov r4, r0
    0xe0015768     0xc    ldr r1, [r0, #80] 
    0xe001576c    0x10    and r3, r1, #15
    0xe0015770    0x14    sub r3, r3, #3
    0xe0015774    0x18    cmp r3, #3
    0xe0015778    0x1c    ldrls pc, [pc, r3, lsl #2]
    0xe001577c    0x20    b e0015810 <cancelIPC+0xb4>
    0xe0015780    0x24    .word 0xe0015790
    0xe0015784    0x28    .word 0xe0015790
    0xe0015788    0x2c    .word 0xe0015824
    0xe001578c    0x30    .word 0xe0015818
    0xe0015790    0x34    bic r5, r1, #15
    0xe0015794    0x38    ldr r3, [r5]
    0xe0015798    0x3c    bic r3, r3, #15
    0xe001579c    0x40    ldr r2, [r5, #4]
    0xe00157a0    0x44    bic r2, r2, #15
    0xe00157a4    0x48    str r2, [sp, #8]      ; stack access
    0xe00157a8    0x4c    str r3, [sp, #12]     ; stack access
    0xe00157ac    0x50    mov r7, sp
    0xe00157b0    0x54    add r6, sp, #8
    0xe00157b4    0x58    ldm r6, {r2, r3}      ; stack access
    0xe00157b8    0x5c    mov r1, r0
    0xe00157bc    0x60    mov r0, r7
    0xe00157c0    0x64    bl e0015538 <tcbEPDequeue>
    0xe00157c4    0x68    ldm r7, {r0, r1}      ; stack access
    0xe00157c8    0x6c    stm r6, {r0, r1}      ; stack access
    0xe00157cc    0x70    ldr r1, [sp, #8]      ; stack access
    0xe00157d0    0x74    ldr r3, [r5, #4]
    0xe00157d4    0x78    and r3, r3, #15
    0xe00157d8    0x7c    bic r2, r1, #15
    0xe00157dc    0x80    orr r3, r3, r2
    0xe00157e0    0x84    str r3, [r5, #4]
    0xe00157e4    0x88    ldr r3, [r5]
    0xe00157e8    0x8c    and r3, r3, #15
    0xe00157ec    0x90    ldr r2, [sp, #12]     ; stack access
    0xe00157f0    0x94    bic r2, r2, #15
    0xe00157f4    0x98    orr r3, r3, r2
    0xe00157f8    0x9c    cmp r1, #0
    0xe00157fc    0xa0    biceq r3, r3, #3
    0xe0015800    0xa4    str r3, [r5]
    0xe0015804    0xa8    mov r1, #0
    0xe0015808    0xac    mov r0, r4
    0xe001580c    0xb0    bl e0014ad8 <setThreadState>
    0xe0015810    0xb4    add sp, sp, #20
    0xe0015814    0xb8    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0015818    0xbc    bic r1, r1, #15
    0xe001581c    0xc0    bl e00156c8 <cancelSignal>
    0xe0015820    0xc4    b e0015810 <cancelIPC+0xb4>
    0xe0015824    0xc8    mov r3, #0
    0xe0015828    0xcc    str r3, [r0, #96] 
    0xe001582c    0xd0    str r3, [r0, #100] 
    0xe0015830    0xd4    bic r4, r0, #508 
    0xe0015834    0xd8    bic r4, r4, #3
    0xe0015838    0xdc    ldr r0, [r4, #44] 
    0xe001583c    0xe0    bics r0, r0, #7
    0xe0015840    0xe4    beq e0015810 <cancelIPC+0xb4>
    0xe0015844    0xe8    bl e00164f8 <cteDeleteOne>
    0xe0015848    0xec    b e0015810 <cancelIPC+0xb4>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
56 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelIPC` has 96 nodes.

Section schedule (264 of 293)
=============================

Deriving specifications
-----------------------

Section `schedule` consists of 89 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `schedule`:

    0xe00152f8      0x0    movw r3, #36892 
    0xe00152fc      0x4    movt r3, #57346 
    0xe0015300      0x8    ldr r3, [r3]
    0xe0015304      0xc    cmp r3, #0
    0xe0015308     0x10    beq e0015448 <schedule+0x150>
    0xe001530c     0x14    push {r4, lr}         ; stack access
    0xe0015310     0x18    movw r3, #13900 
    0xe0015314     0x1c    movt r3, #57347 
    0xe0015318     0x20    ldr r0, [r3]
    0xe001531c     0x24    ldr r3, [r0, #80] 
    0xe0015320     0x28    and r3, r3, #15
    0xe0015324     0x2c    sub r3, r3, #1
    0xe0015328     0x30    cmp r3, #1
    0xe001532c     0x34    movhi ip, #0
    0xe0015330     0x38    bls e00153e8 <schedule+0xf0>
    0xe0015334     0x3c    movw r3, #36892 
    0xe0015338     0x40    movt r3, #57346 
    0xe001533c     0x44    ldr r0, [r3]
    0xe0015340     0x48    cmp r0, #1
    0xe0015344     0x4c    beq e00153f4 <schedule+0xfc>
    0xe0015348     0x50    movw r3, #13900 
    0xe001534c     0x54    movt r3, #57347 
    0xe0015350     0x58    ldr r2, [r3]
    0xe0015354     0x5c    movw r3, #36880 
    0xe0015358     0x60    movt r3, #57346 
    0xe001535c     0x64    ldr r3, [r3]
    0xe0015360     0x68    cmp r2, r3
    0xe0015364     0x6c    beq e0015378 <schedule+0x80>
    0xe0015368     0x70    ldr r1, [r0, #120] 
    0xe001536c     0x74    ldr r3, [r2, #120] 
    0xe0015370     0x78    cmp r1, r3
    0xe0015374     0x7c    bcs e00153fc <schedule+0x104>
    0xe0015378     0x80    movw r3, #12288 
    0xe001537c     0x84    movt r3, #57347 
    0xe0015380     0x88    ldr r1, [r3]
    0xe0015384     0x8c    movw r3, #12808 
    0xe0015388     0x90    movt r3, #57347 
    0xe001538c     0x94    ldr r3, [r3, r1, lsl #2]
    0xe0015390     0x98    cmp r3, #0
    0xe0015394     0x9c    beq e00153fc <schedule+0x104>
    0xe0015398     0xa0    clz r3, r3
    0xe001539c     0xa4    rsb r3, r3, #31
    0xe00153a0     0xa8    movw lr, #12292 
    0xe00153a4     0xac    movt lr, #57347 
    0xe00153a8     0xb0    rsb r4, r3, #7
    0xe00153ac     0xb4    add r1, r4, r1, lsl #3
    0xe00153b0     0xb8    ldr r1, [lr, r1, lsl #2]
    0xe00153b4     0xbc    clz r1, r1
    0xe00153b8     0xc0    rsb r1, r1, #31
    0xe00153bc     0xc4    orr r3, r1, r3, lsl #5
    0xe00153c0     0xc8    ldr r1, [r0, #120] 
    0xe00153c4     0xcc    cmp r1, r3
    0xe00153c8     0xd0    bcs e00153fc <schedule+0x104>
    0xe00153cc     0xd4    bl e00149a8 <tcbSchedEnqueue>
    0xe00153d0     0xd8    movw r3, #36892 
    0xe00153d4     0xdc    movt r3, #57346 
    0xe00153d8     0xe0    mov r2, #1
    0xe00153dc     0xe4    str r2, [r3]
    0xe00153e0     0xe8    bl e001525c <scheduleChooseNewThread>
    0xe00153e4     0xec    b e0015418 <schedule+0x120>
    0xe00153e8     0xf0    bl e00149a8 <tcbSchedEnqueue>
    0xe00153ec     0xf4    mov ip, #1
    0xe00153f0     0xf8    b e0015334 <schedule+0x3c>
    0xe00153f4     0xfc    bl e001525c <scheduleChooseNewThread>
    0xe00153f8    0x100    b e0015418 <schedule+0x120>
    0xe00153fc    0x104    cmp ip, #0
    0xe0015400    0x108    beq e0015414 <schedule+0x11c>
    0xe0015404    0x10c    ldr r1, [r0, #120] 
    0xe0015408    0x110    ldr r3, [r2, #120] 
    0xe001540c    0x114    cmp r1, r3
    0xe0015410    0x118    beq e001542c <schedule+0x134>
    0xe0015414    0x11c    bl e00151cc <switchToThread>
    0xe0015418    0x120    movw r3, #36892 
    0xe001541c    0x124    movt r3, #57346 
    0xe0015420    0x128    mov r2, #0
    0xe0015424    0x12c    str r2, [r3]
    0xe0015428    0x130    pop {r4, pc}          ; stack access
    0xe001542c    0x134    bl e0014fe4 <tcbSchedAppend>
    0xe0015430    0x138    movw r3, #36892 
    0xe0015434    0x13c    movt r3, #57346 
    0xe0015438    0x140    mov r2, #1
    0xe001543c    0x144    str r2, [r3]
    0xe0015440    0x148    bl e001525c <scheduleChooseNewThread>
    0xe0015444    0x14c    b e0015418 <schedule+0x120>
    0xe0015448    0x150    movw r3, #36892 
    0xe001544c    0x154    movt r3, #57346 
    0xe0015450    0x158    mov r2, #0
    0xe0015454    0x15c    str r2, [r3]
    0xe0015458    0x160    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
89 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `schedule` has 137 nodes.

Section Arch_finaliseCap (265 of 293)
=====================================

Deriving specifications
-----------------------

Section `Arch_finaliseCap` consists of 80 instructions.
Switch found.
 ADDS (reg)..........+++++


Stack analysis
---------------

Section `Arch_finaliseCap` expects pointer to stack in r0.
9 stack accesses found. Annotated code for `Arch_finaliseCap`:

    0xe001274c      0x0    push {r4, lr}         ; stack access
    0xe0012750      0x4    sub sp, sp, #8
    0xe0012754      0x8    mov r4, r0
    0xe0012758      0xc    add r0, sp, #8
    0xe001275c     0x10    stmdb r0, {r1, r2}    ; stack access
    0xe0012760     0x14    ldr r0, [sp, #4]      ; stack access
    0xe0012764     0x18    ldr r2, [sp]          ; stack access
    0xe0012768     0x1c    and r1, r2, #14
    0xe001276c     0x20    cmp r1, #14
    0xe0012770     0x24    andne ip, r2, #15
    0xe0012774     0x28    uxtbeq ip, r2
    0xe0012778     0x2c    sub ip, ip, #1
    0xe001277c     0x30    cmp ip, #8
    0xe0012780     0x34    ldrls pc, [pc, ip, lsl #2]
    0xe0012784     0x38    b e00127b4 <Arch_finaliseCap+0x68>
    0xe0012788     0x3c    .word 0xe0012830
    0xe001278c     0x40    .word 0xe00127b4
    0xe0012790     0x44    .word 0xe001285c
    0xe0012794     0x48    .word 0xe00127b4
    0xe0012798     0x4c    .word 0xe00127ac
    0xe001279c     0x50    .word 0xe00127b4
    0xe00127a0     0x54    .word 0xe0012808
    0xe00127a4     0x58    .word 0xe00127b4
    0xe00127a8     0x5c    .word 0xe00127e4
    0xe00127ac     0x60    cmp r3, #0
    0xe00127b0     0x64    bne e00127d4 <Arch_finaliseCap+0x88>
    0xe00127b4     0x68    mov r3, #0
    0xe00127b8     0x6c    str r3, [r4]          ; stack access
    0xe00127bc     0x70    str r3, [r4, #4]      ; stack access
    0xe00127c0     0x74    str r3, [r4, #8]      ; stack access
    0xe00127c4     0x78    str r3, [r4, #12]     ; stack access
    0xe00127c8     0x7c    mov r0, r4
    0xe00127cc     0x80    add sp, sp, #8
    0xe00127d0     0x84    pop {r4, pc}          ; stack access
    0xe00127d4     0x88    bic r1, r2, #15
    0xe00127d8     0x8c    ubfx r0, r0, #0, #17
    0xe00127dc     0x90    bl e0012674 <deleteASIDPool>
    0xe00127e0     0x94    b e00127b4 <Arch_finaliseCap+0x68>
    0xe00127e4     0x98    cmp r3, #0
    0xe00127e8     0x9c    beq e00127b4 <Arch_finaliseCap+0x68>
    0xe00127ec     0xa0    tst r2, #16
    0xe00127f0     0xa4    beq e00127b4 <Arch_finaliseCap+0x68>
    0xe00127f4     0xa8    bic r1, r2, #16320 
    0xe00127f8     0xac    bic r1, r1, #63 
    0xe00127fc     0xb0    ubfx r0, r0, #0, #17
    0xe0012800     0xb4    bl e00126f4 <deleteASID>
    0xe0012804     0xb8    b e00127b4 <Arch_finaliseCap+0x68>
    0xe0012808     0xbc    cmp r3, #0
    0xe001280c     0xc0    beq e00127b4 <Arch_finaliseCap+0x68>
    0xe0012810     0xc4    tst r0, #536870912 
    0xe0012814     0xc8    beq e00127b4 <Arch_finaliseCap+0x68>
    0xe0012818     0xcc    bic r2, r2, #1020 
    0xe001281c     0xd0    bic r2, r2, #3
    0xe0012820     0xd4    lsl r1, r0, #20
    0xe0012824     0xd8    ubfx r0, r0, #12, #17
    0xe0012828     0xdc    bl e00113bc <unmapPageTable>
    0xe001282c     0xe0    b e00127b4 <Arch_finaliseCap+0x68>
    0xe0012830     0xe4    lsr r1, r2, #14
    0xe0012834     0xe8    and r1, r1, #130048 
    0xe0012838     0xec    adds r1, r1, r0, lsr #22
    0xe001283c     0xf0    beq e00127b4 <Arch_finaliseCap+0x68>
    0xe0012840     0xf4    lsl r3, r2, #8
    0xe0012844     0xf8    bic r3, r3, #4080 
    0xe0012848     0xfc    bic r3, r3, #15
    0xe001284c    0x100    lsl r2, r0, #12
    0xe0012850    0x104    mov r0, #0
    0xe0012854    0x108    bl e00120fc <unmapPage>
    0xe0012858    0x10c    b e00127b4 <Arch_finaliseCap+0x68>
    0xe001285c    0x110    lsr r1, r2, #12
    0xe0012860    0x114    and r1, r1, #130048 
    0xe0012864    0x118    ubfx r3, r0, #20, #10
    0xe0012868    0x11c    orrs r1, r1, r3
    0xe001286c    0x120    beq e00127b4 <Arch_finaliseCap+0x68>
    0xe0012870    0x124    lsl r3, r2, #10
    0xe0012874    0x128    bic r3, r3, #16320 
    0xe0012878    0x12c    bic r3, r3, #63 
    0xe001287c    0x130    lsl r2, r0, #14
    0xe0012880    0x134    lsr r0, r0, #30
    0xe0012884    0x138    bl e00120fc <unmapPage>
    0xe0012888    0x13c    b e00127b4 <Arch_finaliseCap+0x68>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
71 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_finaliseCap` has 131 nodes.

Section create_initial_thread (266 of 293)
==========================================

Deriving specifications
-----------------------

Section `create_initial_thread` consists of 804 instructions.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.


Stack analysis
---------------

15 stack accesses found. Annotated code for `create_initial_thread`:

    0xe0002354      0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0002358      0x4    sub sp, sp, #32
    0xe000235c      0x8    add ip, sp, #8
    0xe0002360      0xc    stm ip, {r0, r1}      ; stack access
    0xe0002364     0x10    mov r1, sp
    0xe0002368     0x14    stm r1, {r2, r3}      ; stack access
    0xe000236c     0x18    movw r3, #47104 
    0xe0002370     0x1c    movt r3, #57345 
    0xe0002374     0x20    ldr r6, [r3, #160] 
    0xe0002378     0x24    add r5, r6, #256 
    0xe000237c     0x28    mov r7, r5
    0xe0002380     0x2c    mov r3, #5
    0xe0002384     0x30    str r3, [r5, #124] 
    0xe0002388     0x34    mov r3, #336 
    0xe000238c     0x38    str r3, [r5, #64] 
    0xe0002390     0x3c    mov r4, r0
    0xe0002394     0x40    ldr r9, [sp, #12]     ; stack access
    0xe0002398     0x44    and r8, r0, #14
    0xe000239c     0x48    cmp r8, #14
    0xe00023a0     0x4c    andne r2, r0, #15
    0xe00023a4     0x50    uxtbeq r2, r0
    0xe00023a8     0x54    sub r3, r2, #2
    0xe00023ac     0x58    cmp r3, #60 
    0xe00023b0     0x5c    ldrls pc, [pc, r3, lsl #2]
    0xe00023b4     0x60    b e00024fc <create_initial_thread+0x1a8>
    0xe00023b8     0x64    .word 0xe00024ac
    0xe00023bc     0x68    .word 0xe00024fc
    0xe00023c0     0x6c    .word 0xe00024b4
    0xe00023c4     0x70    .word 0xe00024fc
    0xe00023c8     0x74    .word 0xe00024bc
    0xe00023cc     0x78    .word 0xe00024fc
    0xe00023d0     0x7c    .word 0xe0002588
    0xe00023d4     0x80    .word 0xe00024fc
    0xe00023d8     0x84    .word 0xe00024c4
    0xe00023dc     0x88    .word 0xe00024fc
    0xe00023e0     0x8c    .word 0xe00024cc
    0xe00023e4     0x90    .word 0xe00024fc
    0xe00023e8     0x94    .word 0xe0002588
    0xe00023ec     0x98    .word 0xe00024fc
    0xe00023f0     0x9c    .word 0xe00024fc
    0xe00023f4     0xa0    .word 0xe00024fc
    0xe00023f8     0xa4    .word 0xe00024fc
    0xe00023fc     0xa8    .word 0xe00024fc
    0xe0002400     0xac    .word 0xe00024fc
    0xe0002404     0xb0    .word 0xe00024fc
    0xe0002408     0xb4    .word 0xe00024fc
    0xe000240c     0xb8    .word 0xe00024fc
    0xe0002410     0xbc    .word 0xe00024fc
    0xe0002414     0xc0    .word 0xe00024fc
    0xe0002418     0xc4    .word 0xe00024fc
    0xe000241c     0xc8    .word 0xe00024fc
    0xe0002420     0xcc    .word 0xe00024fc
    0xe0002424     0xd0    .word 0xe00024fc
    0xe0002428     0xd4    .word 0xe0002588
    0xe000242c     0xd8    .word 0xe00024fc
    0xe0002430     0xdc    .word 0xe00024fc
    0xe0002434     0xe0    .word 0xe00024fc
    0xe0002438     0xe4    .word 0xe00024fc
    0xe000243c     0xe8    .word 0xe00024fc
    0xe0002440     0xec    .word 0xe00024fc
    0xe0002444     0xf0    .word 0xe00024fc
    0xe0002448     0xf4    .word 0xe00024fc
    0xe000244c     0xf8    .word 0xe00024fc
    0xe0002450     0xfc    .word 0xe00024fc
    0xe0002454    0x100    .word 0xe00024fc
    0xe0002458    0x104    .word 0xe00024fc
    0xe000245c    0x108    .word 0xe00024fc
    0xe0002460    0x10c    .word 0xe00024fc
    0xe0002464    0x110    .word 0xe00024fc
    0xe0002468    0x114    .word 0xe00024d8
    0xe000246c    0x118    .word 0xe00024fc
    0xe0002470    0x11c    .word 0xe00024fc
    0xe0002474    0x120    .word 0xe00024fc
    0xe0002478    0x124    .word 0xe00024fc
    0xe000247c    0x128    .word 0xe00024fc
    0xe0002480    0x12c    .word 0xe00024fc
    0xe0002484    0x130    .word 0xe00024fc
    0xe0002488    0x134    .word 0xe00024fc
    0xe000248c    0x138    .word 0xe00024fc
    0xe0002490    0x13c    .word 0xe00024fc
    0xe0002494    0x140    .word 0xe00024fc
    0xe0002498    0x144    .word 0xe00024fc
    0xe000249c    0x148    .word 0xe00024fc
    0xe00024a0    0x14c    .word 0xe00024fc
    0xe00024a4    0x150    .word 0xe00024fc
    0xe00024a8    0x154    .word 0xe0002588
    0xe00024ac    0x158    bic r1, r0, #15
    0xe00024b0    0x15c    b e000258c <create_initial_thread+0x238>
    0xe00024b4    0x160    bic r1, r9, #15
    0xe00024b8    0x164    b e000258c <create_initial_thread+0x238>
    0xe00024bc    0x168    bic r1, r0, #15
    0xe00024c0    0x16c    b e000258c <create_initial_thread+0x238>
    0xe00024c4    0x170    bic r1, r0, #31
    0xe00024c8    0x174    b e000258c <create_initial_thread+0x238>
    0xe00024cc    0x178    bic r1, r0, #508 
    0xe00024d0    0x17c    bic r1, r1, #3
    0xe00024d4    0x180    b e000258c <create_initial_thread+0x238>
    0xe00024d8    0x184    lsr r1, r0, #8
    0xe00024dc    0x188    and r3, r1, #63 
    0xe00024e0    0x18c    cmp r3, #32
    0xe00024e4    0x190    andne r1, r1, #31
    0xe00024e8    0x194    moveq r1, #4
    0xe00024ec    0x198    add r3, r1, #1
    0xe00024f0    0x19c    mvn r1, #0
    0xe00024f4    0x1a0    and r1, r9, r1, lsl r3
    0xe00024f8    0x1a4    b e000258c <create_initial_thread+0x238>
    0xe00024fc    0x1a8    sub r3, r2, #1
    0xe0002500    0x1ac    cmp r3, #8
    0xe0002504    0x1b0    ldrls pc, [pc, r3, lsl #2]
    0xe0002508    0x1b4    b e00026c0 <create_initial_thread+0x36c>
    0xe000250c    0x1b8    .word 0xe0002530
    0xe0002510    0x1bc    .word 0xe00026c0
    0xe0002514    0x1c0    .word 0xe0002530
    0xe0002518    0x1c4    .word 0xe00026c0
    0xe000251c    0x1c8    .word 0xe0002580
    0xe0002520    0x1cc    .word 0xe00026c0
    0xe0002524    0x1d0    .word 0xe0002568
    0xe0002528    0x1d4    .word 0xe00026c0
    0xe000252c    0x1d8    .word 0xe0002574
    0xe0002530    0x1dc    cmp r2, #1
    0xe0002534    0x1e0    beq e0002548 <create_initial_thread+0x1f4>
    0xe0002538    0x1e4    cmp r2, #3
    0xe000253c    0x1e8    beq e0002558 <create_initial_thread+0x204>
    0xe0002540    0x1ec    mov r1, #0
    0xe0002544    0x1f0    b e000258c <create_initial_thread+0x238>
    0xe0002548    0x1f4    lsl r1, r0, #8
    0xe000254c    0x1f8    bic r1, r1, #4080 
    0xe0002550    0x1fc    bic r1, r1, #15
    0xe0002554    0x200    b e000258c <create_initial_thread+0x238>
    0xe0002558    0x204    lsl r1, r0, #10
    0xe000255c    0x208    bic r1, r1, #16320 
    0xe0002560    0x20c    bic r1, r1, #63 
    0xe0002564    0x210    b e000258c <create_initial_thread+0x238>
    0xe0002568    0x214    bic r1, r0, #1020 
    0xe000256c    0x218    bic r1, r1, #3
    0xe0002570    0x21c    b e000258c <create_initial_thread+0x238>
    0xe0002574    0x220    bic r1, r0, #16320 
    0xe0002578    0x224    bic r1, r1, #63 
    0xe000257c    0x228    b e000258c <create_initial_thread+0x238>
    0xe0002580    0x22c    bic r1, r0, #15
    0xe0002584    0x230    b e000258c <create_initial_thread+0x238>
    0xe0002588    0x234    mov r1, #0
    0xe000258c    0x238    add r3, sp, #76 
    0xe0002590    0x23c    ldm r3, {r2, r3}      ; stack access
    0xe0002594    0x240    add r1, r1, #160 
    0xe0002598    0x244    add r0, sp, #20
    0xe000259c    0x248    bl e00142e4 <deriveCap>
    0xe00025a0    0x24c    ldr r3, [sp, #20]     ; stack access
    0xe00025a4    0x250    cmp r3, #0
    0xe00025a8    0x254    movne r7, #0
    0xe00025ac    0x258    bne e0002f8c <create_initial_thread+0xc38>
    0xe00025b0    0x25c    cmp r8, #14
    0xe00025b4    0x260    beq e00026c8 <create_initial_thread+0x374>
    0xe00025b8    0x264    and r3, r4, #15
    0xe00025bc    0x268    sub r2, r3, #2
    0xe00025c0    0x26c    cmp r2, #60 
    0xe00025c4    0x270    ldrls pc, [pc, r2, lsl #2]
    0xe00025c8    0x274    b e0002948 <create_initial_thread+0x5f4>
    0xe00025cc    0x278    .word 0xe00027d0
    0xe00025d0    0x27c    .word 0xe0002948
    0xe00025d4    0x280    .word 0xe0002900
    0xe00025d8    0x284    .word 0xe0002948
    0xe00025dc    0x288    .word 0xe0002908
    0xe00025e0    0x28c    .word 0xe0002948
    0xe00025e4    0x290    .word 0xe0002fa0
    0xe00025e8    0x294    .word 0xe0002948
    0xe00025ec    0x298    .word 0xe0002910
    0xe00025f0    0x29c    .word 0xe0002948
    0xe00025f4    0x2a0    .word 0xe0002918
    0xe00025f8    0x2a4    .word 0xe0002948
    0xe00025fc    0x2a8    .word 0xe0002fa0
    0xe0002600    0x2ac    .word 0xe0002948
    0xe0002604    0x2b0    .word 0xe0002948
    0xe0002608    0x2b4    .word 0xe0002948
    0xe000260c    0x2b8    .word 0xe0002948
    0xe0002610    0x2bc    .word 0xe0002948
    0xe0002614    0x2c0    .word 0xe0002948
    0xe0002618    0x2c4    .word 0xe0002948
    0xe000261c    0x2c8    .word 0xe0002948
    0xe0002620    0x2cc    .word 0xe0002948
    0xe0002624    0x2d0    .word 0xe0002948
    0xe0002628    0x2d4    .word 0xe0002948
    0xe000262c    0x2d8    .word 0xe0002948
    0xe0002630    0x2dc    .word 0xe0002948
    0xe0002634    0x2e0    .word 0xe0002948
    0xe0002638    0x2e4    .word 0xe0002948
    0xe000263c    0x2e8    .word 0xe0002fa0
    0xe0002640    0x2ec    .word 0xe0002948
    0xe0002644    0x2f0    .word 0xe0002948
    0xe0002648    0x2f4    .word 0xe0002948
    0xe000264c    0x2f8    .word 0xe0002948
    0xe0002650    0x2fc    .word 0xe0002948
    0xe0002654    0x300    .word 0xe0002948
    0xe0002658    0x304    .word 0xe0002948
    0xe000265c    0x308    .word 0xe0002948
    0xe0002660    0x30c    .word 0xe0002948
    0xe0002664    0x310    .word 0xe0002948
    0xe0002668    0x314    .word 0xe0002948
    0xe000266c    0x318    .word 0xe0002948
    0xe0002670    0x31c    .word 0xe0002948
    0xe0002674    0x320    .word 0xe0002948
    0xe0002678    0x324    .word 0xe0002948
    0xe000267c    0x328    .word 0xe0002924
    0xe0002680    0x32c    .word 0xe0002948
    0xe0002684    0x330    .word 0xe0002948
    0xe0002688    0x334    .word 0xe0002948
    0xe000268c    0x338    .word 0xe0002948
    0xe0002690    0x33c    .word 0xe0002948
    0xe0002694    0x340    .word 0xe0002948
    0xe0002698    0x344    .word 0xe0002948
    0xe000269c    0x348    .word 0xe0002948
    0xe00026a0    0x34c    .word 0xe0002948
    0xe00026a4    0x350    .word 0xe0002948
    0xe00026a8    0x354    .word 0xe0002948
    0xe00026ac    0x358    .word 0xe0002948
    0xe00026b0    0x35c    .word 0xe0002948
    0xe00026b4    0x360    .word 0xe0002948
    0xe00026b8    0x364    .word 0xe0002948
    0xe00026bc    0x368    .word 0xe0002fa0
    0xe00026c0    0x36c    mov r1, #0
    0xe00026c4    0x370    b e000258c <create_initial_thread+0x238>
    0xe00026c8    0x374    uxtb r3, r4
    0xe00026cc    0x378    sub r2, r3, #2
    0xe00026d0    0x37c    cmp r2, #60 
    0xe00026d4    0x380    ldrls pc, [pc, r2, lsl #2]
    0xe00026d8    0x384    b e0002948 <create_initial_thread+0x5f4>
    0xe00026dc    0x388    .word 0xe00027d0
    0xe00026e0    0x38c    .word 0xe0002948
    0xe00026e4    0x390    .word 0xe0002900
    0xe00026e8    0x394    .word 0xe0002948
    0xe00026ec    0x398    .word 0xe0002908
    0xe00026f0    0x39c    .word 0xe0002948
    0xe00026f4    0x3a0    .word 0xe0002fc0
    0xe00026f8    0x3a4    .word 0xe0002948
    0xe00026fc    0x3a8    .word 0xe0002910
    0xe0002700    0x3ac    .word 0xe0002948
    0xe0002704    0x3b0    .word 0xe0002918
    0xe0002708    0x3b4    .word 0xe0002948
    0xe000270c    0x3b8    .word 0xe0002fc0
    0xe0002710    0x3bc    .word 0xe0002948
    0xe0002714    0x3c0    .word 0xe0002948
    0xe0002718    0x3c4    .word 0xe0002948
    0xe000271c    0x3c8    .word 0xe0002948
    0xe0002720    0x3cc    .word 0xe0002948
    0xe0002724    0x3d0    .word 0xe0002948
    0xe0002728    0x3d4    .word 0xe0002948
    0xe000272c    0x3d8    .word 0xe0002948
    0xe0002730    0x3dc    .word 0xe0002948
    0xe0002734    0x3e0    .word 0xe0002948
    0xe0002738    0x3e4    .word 0xe0002948
    0xe000273c    0x3e8    .word 0xe0002948
    0xe0002740    0x3ec    .word 0xe0002948
    0xe0002744    0x3f0    .word 0xe0002948
    0xe0002748    0x3f4    .word 0xe0002948
    0xe000274c    0x3f8    .word 0xe0002fc0
    0xe0002750    0x3fc    .word 0xe0002948
    0xe0002754    0x400    .word 0xe0002948
    0xe0002758    0x404    .word 0xe0002948
    0xe000275c    0x408    .word 0xe0002948
    0xe0002760    0x40c    .word 0xe0002948
    0xe0002764    0x410    .word 0xe0002948
    0xe0002768    0x414    .word 0xe0002948
    0xe000276c    0x418    .word 0xe0002948
    0xe0002770    0x41c    .word 0xe0002948
    0xe0002774    0x420    .word 0xe0002948
    0xe0002778    0x424    .word 0xe0002948
    0xe000277c    0x428    .word 0xe0002948
    0xe0002780    0x42c    .word 0xe0002948
    0xe0002784    0x430    .word 0xe0002948
    0xe0002788    0x434    .word 0xe0002948
    0xe000278c    0x438    .word 0xe0002924
    0xe0002790    0x43c    .word 0xe0002948
    0xe0002794    0x440    .word 0xe0002948
    0xe0002798    0x444    .word 0xe0002948
    0xe000279c    0x448    .word 0xe0002948
    0xe00027a0    0x44c    .word 0xe0002948
    0xe00027a4    0x450    .word 0xe0002948
    0xe00027a8    0x454    .word 0xe0002948
    0xe00027ac    0x458    .word 0xe0002948
    0xe00027b0    0x45c    .word 0xe0002948
    0xe00027b4    0x460    .word 0xe0002948
    0xe00027b8    0x464    .word 0xe0002948
    0xe00027bc    0x468    .word 0xe0002948
    0xe00027c0    0x46c    .word 0xe0002948
    0xe00027c4    0x470    .word 0xe0002948
    0xe00027c8    0x474    .word 0xe0002948
    0xe00027cc    0x478    .word 0xe0002fc0
    0xe00027d0    0x47c    bic r2, r4, #15
    0xe00027d4    0x480    movw r3, #47104 
    0xe00027d8    0x484    movt r3, #57345 
    0xe00027dc    0x488    ldr r3, [r3, #160] 
    0xe00027e0    0x48c    add r2, r2, #32
    0xe00027e4    0x490    add r1, sp, #8
    0xe00027e8    0x494    ldm r1, {r0, r1}      ; stack access
    0xe00027ec    0x498    bl e0012fa8 <cteInsert>
    0xe00027f0    0x49c    cmp r8, #14
    0xe00027f4    0x4a0    beq e0002fdc <create_initial_thread+0xc88>
    0xe00027f8    0x4a4    and r2, r4, #15
    0xe00027fc    0x4a8    sub r3, r2, #2
    0xe0002800    0x4ac    cmp r3, #60 
    0xe0002804    0x4b0    ldrls pc, [pc, r3, lsl #2]
    0xe0002808    0x4b4    b e0002a2c <create_initial_thread+0x6d8>
    0xe000280c    0x4b8    .word 0xe00029dc
    0xe0002810    0x4bc    .word 0xe0002a2c
    0xe0002814    0x4c0    .word 0xe00029e4
    0xe0002818    0x4c4    .word 0xe0002a2c
    0xe000281c    0x4c8    .word 0xe00029ec
    0xe0002820    0x4cc    .word 0xe0002a2c
    0xe0002824    0x4d0    .word 0xe0002ab8
    0xe0002828    0x4d4    .word 0xe0002a2c
    0xe000282c    0x4d8    .word 0xe00029f4
    0xe0002830    0x4dc    .word 0xe0002a2c
    0xe0002834    0x4e0    .word 0xe00029fc
    0xe0002838    0x4e4    .word 0xe0002a2c
    0xe000283c    0x4e8    .word 0xe0002ab8
    0xe0002840    0x4ec    .word 0xe0002a2c
    0xe0002844    0x4f0    .word 0xe0002a2c
    0xe0002848    0x4f4    .word 0xe0002a2c
    0xe000284c    0x4f8    .word 0xe0002a2c
    0xe0002850    0x4fc    .word 0xe0002a2c
    0xe0002854    0x500    .word 0xe0002a2c
    0xe0002858    0x504    .word 0xe0002a2c
    0xe000285c    0x508    .word 0xe0002a2c
    0xe0002860    0x50c    .word 0xe0002a2c
    0xe0002864    0x510    .word 0xe0002a2c
    0xe0002868    0x514    .word 0xe0002a2c
    0xe000286c    0x518    .word 0xe0002a2c
    0xe0002870    0x51c    .word 0xe0002a2c
    0xe0002874    0x520    .word 0xe0002a2c
    0xe0002878    0x524    .word 0xe0002a2c
    0xe000287c    0x528    .word 0xe0002ab8
    0xe0002880    0x52c    .word 0xe0002a2c
    0xe0002884    0x530    .word 0xe0002a2c
    0xe0002888    0x534    .word 0xe0002a2c
    0xe000288c    0x538    .word 0xe0002a2c
    0xe0002890    0x53c    .word 0xe0002a2c
    0xe0002894    0x540    .word 0xe0002a2c
    0xe0002898    0x544    .word 0xe0002a2c
    0xe000289c    0x548    .word 0xe0002a2c
    0xe00028a0    0x54c    .word 0xe0002a2c
    0xe00028a4    0x550    .word 0xe0002a2c
    0xe00028a8    0x554    .word 0xe0002a2c
    0xe00028ac    0x558    .word 0xe0002a2c
    0xe00028b0    0x55c    .word 0xe0002a2c
    0xe00028b4    0x560    .word 0xe0002a2c
    0xe00028b8    0x564    .word 0xe0002a2c
    0xe00028bc    0x568    .word 0xe0002a08
    0xe00028c0    0x56c    .word 0xe0002a2c
    0xe00028c4    0x570    .word 0xe0002a2c
    0xe00028c8    0x574    .word 0xe0002a2c
    0xe00028cc    0x578    .word 0xe0002a2c
    0xe00028d0    0x57c    .word 0xe0002a2c
    0xe00028d4    0x580    .word 0xe0002a2c
    0xe00028d8    0x584    .word 0xe0002a2c
    0xe00028dc    0x588    .word 0xe0002a2c
    0xe00028e0    0x58c    .word 0xe0002a2c
    0xe00028e4    0x590    .word 0xe0002a2c
    0xe00028e8    0x594    .word 0xe0002a2c
    0xe00028ec    0x598    .word 0xe0002a2c
    0xe00028f0    0x59c    .word 0xe0002a2c
    0xe00028f4    0x5a0    .word 0xe0002a2c
    0xe00028f8    0x5a4    .word 0xe0002a2c
    0xe00028fc    0x5a8    .word 0xe0002ab8
    0xe0002900    0x5ac    bic r2, r9, #15
    0xe0002904    0x5b0    b e00027d4 <create_initial_thread+0x480>
    0xe0002908    0x5b4    bic r2, r4, #15
    0xe000290c    0x5b8    b e00027d4 <create_initial_thread+0x480>
    0xe0002910    0x5bc    bic r2, r4, #31
    0xe0002914    0x5c0    b e00027d4 <create_initial_thread+0x480>
    0xe0002918    0x5c4    bic r2, r4, #508 
    0xe000291c    0x5c8    bic r2, r2, #3
    0xe0002920    0x5cc    b e00027d4 <create_initial_thread+0x480>
    0xe0002924    0x5d0    lsr r2, r4, #8
    0xe0002928    0x5d4    and r3, r2, #63 
    0xe000292c    0x5d8    cmp r3, #32
    0xe0002930    0x5dc    andne r2, r2, #31
    0xe0002934    0x5e0    moveq r2, #4
    0xe0002938    0x5e4    add r3, r2, #1
    0xe000293c    0x5e8    mvn r2, #0
    0xe0002940    0x5ec    and r2, r9, r2, lsl r3
    0xe0002944    0x5f0    b e00027d4 <create_initial_thread+0x480>
    0xe0002948    0x5f4    sub r2, r3, #1
    0xe000294c    0x5f8    cmp r2, #8
    0xe0002950    0x5fc    ldrls pc, [pc, r2, lsl #2]
    0xe0002954    0x600    b e00029d4 <create_initial_thread+0x680>
    0xe0002958    0x604    .word 0xe000297c
    0xe000295c    0x608    .word 0xe00029d4
    0xe0002960    0x60c    .word 0xe000297c
    0xe0002964    0x610    .word 0xe00029d4
    0xe0002968    0x614    .word 0xe00029cc
    0xe000296c    0x618    .word 0xe00029d4
    0xe0002970    0x61c    .word 0xe00029b4
    0xe0002974    0x620    .word 0xe00029d4
    0xe0002978    0x624    .word 0xe00029c0
    0xe000297c    0x628    cmp r3, #1
    0xe0002980    0x62c    beq e0002994 <create_initial_thread+0x640>
    0xe0002984    0x630    cmp r3, #3
    0xe0002988    0x634    beq e00029a4 <create_initial_thread+0x650>
    0xe000298c    0x638    mov r2, #0
    0xe0002990    0x63c    b e00027d4 <create_initial_thread+0x480>
    0xe0002994    0x640    lsl r2, r4, #8
    0xe0002998    0x644    bic r2, r2, #4080 
    0xe000299c    0x648    bic r2, r2, #15
    0xe00029a0    0x64c    b e00027d4 <create_initial_thread+0x480>
    0xe00029a4    0x650    lsl r2, r4, #10
    0xe00029a8    0x654    bic r2, r2, #16320 
    0xe00029ac    0x658    bic r2, r2, #63 
    0xe00029b0    0x65c    b e00027d4 <create_initial_thread+0x480>
    0xe00029b4    0x660    bic r2, r4, #1020 
    0xe00029b8    0x664    bic r2, r2, #3
    0xe00029bc    0x668    b e00027d4 <create_initial_thread+0x480>
    0xe00029c0    0x66c    bic r2, r4, #16320 
    0xe00029c4    0x670    bic r2, r2, #63 
    0xe00029c8    0x674    b e00027d4 <create_initial_thread+0x480>
    0xe00029cc    0x678    bic r2, r4, #15
    0xe00029d0    0x67c    b e00027d4 <create_initial_thread+0x480>
    0xe00029d4    0x680    mov r2, #0
    0xe00029d8    0x684    b e00027d4 <create_initial_thread+0x480>
    0xe00029dc    0x688    bic r2, r4, #15
    0xe00029e0    0x68c    b e0002abc <create_initial_thread+0x768>
    0xe00029e4    0x690    bic r2, r9, #15
    0xe00029e8    0x694    b e0002abc <create_initial_thread+0x768>
    0xe00029ec    0x698    bic r2, r4, #15
    0xe00029f0    0x69c    b e0002abc <create_initial_thread+0x768>
    0xe00029f4    0x6a0    bic r2, r4, #31
    0xe00029f8    0x6a4    b e0002abc <create_initial_thread+0x768>
    0xe00029fc    0x6a8    bic r2, r4, #508 
    0xe0002a00    0x6ac    bic r2, r2, #3
    0xe0002a04    0x6b0    b e0002abc <create_initial_thread+0x768>
    0xe0002a08    0x6b4    lsr r2, r4, #8
    0xe0002a0c    0x6b8    and r3, r2, #63 
    0xe0002a10    0x6bc    cmp r3, #32
    0xe0002a14    0x6c0    andne r2, r2, #31
    0xe0002a18    0x6c4    moveq r2, #4
    0xe0002a1c    0x6c8    add r3, r2, #1
    0xe0002a20    0x6cc    mvn r2, #0
    0xe0002a24    0x6d0    and r2, r9, r2, lsl r3
    0xe0002a28    0x6d4    b e0002abc <create_initial_thread+0x768>
    0xe0002a2c    0x6d8    sub r3, r2, #1
    0xe0002a30    0x6dc    cmp r3, #8
    0xe0002a34    0x6e0    ldrls pc, [pc, r3, lsl #2]
    0xe0002a38    0x6e4    b e0002bec <create_initial_thread+0x898>
    0xe0002a3c    0x6e8    .word 0xe0002a60
    0xe0002a40    0x6ec    .word 0xe0002bec
    0xe0002a44    0x6f0    .word 0xe0002a60
    0xe0002a48    0x6f4    .word 0xe0002bec
    0xe0002a4c    0x6f8    .word 0xe0002ab0
    0xe0002a50    0x6fc    .word 0xe0002bec
    0xe0002a54    0x700    .word 0xe0002a98
    0xe0002a58    0x704    .word 0xe0002bec
    0xe0002a5c    0x708    .word 0xe0002aa4
    0xe0002a60    0x70c    cmp r2, #1
    0xe0002a64    0x710    beq e0002a78 <create_initial_thread+0x724>
    0xe0002a68    0x714    cmp r2, #3
    0xe0002a6c    0x718    beq e0002a88 <create_initial_thread+0x734>
    0xe0002a70    0x71c    mov r2, #0
    0xe0002a74    0x720    b e0002abc <create_initial_thread+0x768>
    0xe0002a78    0x724    lsl r2, r4, #8
    0xe0002a7c    0x728    bic r2, r2, #4080 
    0xe0002a80    0x72c    bic r2, r2, #15
    0xe0002a84    0x730    b e0002abc <create_initial_thread+0x768>
    0xe0002a88    0x734    lsl r2, r4, #10
    0xe0002a8c    0x738    bic r2, r2, #16320 
    0xe0002a90    0x73c    bic r2, r2, #63 
    0xe0002a94    0x740    b e0002abc <create_initial_thread+0x768>
    0xe0002a98    0x744    bic r2, r4, #1020 
    0xe0002a9c    0x748    bic r2, r2, #3
    0xe0002aa0    0x74c    b e0002abc <create_initial_thread+0x768>
    0xe0002aa4    0x750    bic r2, r4, #16320 
    0xe0002aa8    0x754    bic r2, r2, #63 
    0xe0002aac    0x758    b e0002abc <create_initial_thread+0x768>
    0xe0002ab0    0x75c    bic r2, r4, #15
    0xe0002ab4    0x760    b e0002abc <create_initial_thread+0x768>
    0xe0002ab8    0x764    mov r2, #0
    0xe0002abc    0x768    movw r3, #47104 
    0xe0002ac0    0x76c    movt r3, #57345 
    0xe0002ac4    0x770    ldr r3, [r3, #160] 
    0xe0002ac8    0x774    add r3, r3, #16
    0xe0002acc    0x778    add r2, r2, #48 
    0xe0002ad0    0x77c    mov r1, sp
    0xe0002ad4    0x780    ldm r1, {r0, r1}      ; stack access
    0xe0002ad8    0x784    bl e0012fa8 <cteInsert>
    0xe0002adc    0x788    cmp r8, #14
    0xe0002ae0    0x78c    andne r2, r4, #15
    0xe0002ae4    0x790    uxtbeq r2, r4
    0xe0002ae8    0x794    sub r3, r2, #2
    0xe0002aec    0x798    cmp r3, #60 
    0xe0002af0    0x79c    ldrls pc, [pc, r3, lsl #2]
    0xe0002af4    0x7a0    b e0002c44 <create_initial_thread+0x8f0>
    0xe0002af8    0x7a4    .word 0xe0002bf4
    0xe0002afc    0x7a8    .word 0xe0002c44
    0xe0002b00    0x7ac    .word 0xe0002bfc
    0xe0002b04    0x7b0    .word 0xe0002c44
    0xe0002b08    0x7b4    .word 0xe0002c04
    0xe0002b0c    0x7b8    .word 0xe0002c44
    0xe0002b10    0x7bc    .word 0xe0002cd0
    0xe0002b14    0x7c0    .word 0xe0002c44
    0xe0002b18    0x7c4    .word 0xe0002c0c
    0xe0002b1c    0x7c8    .word 0xe0002c44
    0xe0002b20    0x7cc    .word 0xe0002c14
    0xe0002b24    0x7d0    .word 0xe0002c44
    0xe0002b28    0x7d4    .word 0xe0002cd0
    0xe0002b2c    0x7d8    .word 0xe0002c44
    0xe0002b30    0x7dc    .word 0xe0002c44
    0xe0002b34    0x7e0    .word 0xe0002c44
    0xe0002b38    0x7e4    .word 0xe0002c44
    0xe0002b3c    0x7e8    .word 0xe0002c44
    0xe0002b40    0x7ec    .word 0xe0002c44
    0xe0002b44    0x7f0    .word 0xe0002c44
    0xe0002b48    0x7f4    .word 0xe0002c44
    0xe0002b4c    0x7f8    .word 0xe0002c44
    0xe0002b50    0x7fc    .word 0xe0002c44
    0xe0002b54    0x800    .word 0xe0002c44
    0xe0002b58    0x804    .word 0xe0002c44
    0xe0002b5c    0x808    .word 0xe0002c44
    0xe0002b60    0x80c    .word 0xe0002c44
    0xe0002b64    0x810    .word 0xe0002c44
    0xe0002b68    0x814    .word 0xe0002cd0
    0xe0002b6c    0x818    .word 0xe0002c44
    0xe0002b70    0x81c    .word 0xe0002c44
    0xe0002b74    0x820    .word 0xe0002c44
    0xe0002b78    0x824    .word 0xe0002c44
    0xe0002b7c    0x828    .word 0xe0002c44
    0xe0002b80    0x82c    .word 0xe0002c44
    0xe0002b84    0x830    .word 0xe0002c44
    0xe0002b88    0x834    .word 0xe0002c44
    0xe0002b8c    0x838    .word 0xe0002c44
    0xe0002b90    0x83c    .word 0xe0002c44
    0xe0002b94    0x840    .word 0xe0002c44
    0xe0002b98    0x844    .word 0xe0002c44
    0xe0002b9c    0x848    .word 0xe0002c44
    0xe0002ba0    0x84c    .word 0xe0002c44
    0xe0002ba4    0x850    .word 0xe0002c44
    0xe0002ba8    0x854    .word 0xe0002c20
    0xe0002bac    0x858    .word 0xe0002c44
    0xe0002bb0    0x85c    .word 0xe0002c44
    0xe0002bb4    0x860    .word 0xe0002c44
    0xe0002bb8    0x864    .word 0xe0002c44
    0xe0002bbc    0x868    .word 0xe0002c44
    0xe0002bc0    0x86c    .word 0xe0002c44
    0xe0002bc4    0x870    .word 0xe0002c44
    0xe0002bc8    0x874    .word 0xe0002c44
    0xe0002bcc    0x878    .word 0xe0002c44
    0xe0002bd0    0x87c    .word 0xe0002c44
    0xe0002bd4    0x880    .word 0xe0002c44
    0xe0002bd8    0x884    .word 0xe0002c44
    0xe0002bdc    0x888    .word 0xe0002c44
    0xe0002be0    0x88c    .word 0xe0002c44
    0xe0002be4    0x890    .word 0xe0002c44
    0xe0002be8    0x894    .word 0xe0002cd0
    0xe0002bec    0x898    mov r2, #0
    0xe0002bf0    0x89c    b e0002abc <create_initial_thread+0x768>
    0xe0002bf4    0x8a0    bic r2, r4, #15
    0xe0002bf8    0x8a4    b e0002cd4 <create_initial_thread+0x980>
    0xe0002bfc    0x8a8    bic r2, r9, #15
    0xe0002c00    0x8ac    b e0002cd4 <create_initial_thread+0x980>
    0xe0002c04    0x8b0    bic r2, r4, #15
    0xe0002c08    0x8b4    b e0002cd4 <create_initial_thread+0x980>
    0xe0002c0c    0x8b8    bic r2, r4, #31
    0xe0002c10    0x8bc    b e0002cd4 <create_initial_thread+0x980>
    0xe0002c14    0x8c0    bic r2, r4, #508 
    0xe0002c18    0x8c4    bic r2, r2, #3
    0xe0002c1c    0x8c8    b e0002cd4 <create_initial_thread+0x980>
    0xe0002c20    0x8cc    lsr r2, r4, #8
    0xe0002c24    0x8d0    and r3, r2, #63 
    0xe0002c28    0x8d4    cmp r3, #32
    0xe0002c2c    0x8d8    andne r2, r2, #31
    0xe0002c30    0x8dc    moveq r2, #4
    0xe0002c34    0x8e0    add r3, r2, #1
    0xe0002c38    0x8e4    mvn r2, #0
    0xe0002c3c    0x8e8    and r2, r9, r2, lsl r3
    0xe0002c40    0x8ec    b e0002cd4 <create_initial_thread+0x980>
    0xe0002c44    0x8f0    sub r3, r2, #1
    0xe0002c48    0x8f4    cmp r3, #8
    0xe0002c4c    0x8f8    ldrls pc, [pc, r3, lsl #2]
    0xe0002c50    0x8fc    b e0002e8c <create_initial_thread+0xb38>
    0xe0002c54    0x900    .word 0xe0002c78
    0xe0002c58    0x904    .word 0xe0002e8c
    0xe0002c5c    0x908    .word 0xe0002c78
    0xe0002c60    0x90c    .word 0xe0002e8c
    0xe0002c64    0x910    .word 0xe0002cc8
    0xe0002c68    0x914    .word 0xe0002e8c
    0xe0002c6c    0x918    .word 0xe0002cb0
    0xe0002c70    0x91c    .word 0xe0002e8c
    0xe0002c74    0x920    .word 0xe0002cbc
    0xe0002c78    0x924    cmp r2, #1
    0xe0002c7c    0x928    beq e0002c90 <create_initial_thread+0x93c>
    0xe0002c80    0x92c    cmp r2, #3
    0xe0002c84    0x930    beq e0002ca0 <create_initial_thread+0x94c>
    0xe0002c88    0x934    mov r2, #0
    0xe0002c8c    0x938    b e0002cd4 <create_initial_thread+0x980>
    0xe0002c90    0x93c    lsl r2, r4, #8
    0xe0002c94    0x940    bic r2, r2, #4080 
    0xe0002c98    0x944    bic r2, r2, #15
    0xe0002c9c    0x948    b e0002cd4 <create_initial_thread+0x980>
    0xe0002ca0    0x94c    lsl r2, r4, #10
    0xe0002ca4    0x950    bic r2, r2, #16320 
    0xe0002ca8    0x954    bic r2, r2, #63 
    0xe0002cac    0x958    b e0002cd4 <create_initial_thread+0x980>
    0xe0002cb0    0x95c    bic r2, r4, #1020 
    0xe0002cb4    0x960    bic r2, r2, #3
    0xe0002cb8    0x964    b e0002cd4 <create_initial_thread+0x980>
    0xe0002cbc    0x968    bic r2, r4, #16320 
    0xe0002cc0    0x96c    bic r2, r2, #63 
    0xe0002cc4    0x970    b e0002cd4 <create_initial_thread+0x980>
    0xe0002cc8    0x974    bic r2, r4, #15
    0xe0002ccc    0x978    b e0002cd4 <create_initial_thread+0x980>
    0xe0002cd0    0x97c    mov r2, #0
    0xe0002cd4    0x980    movw r3, #47104 
    0xe0002cd8    0x984    movt r3, #57345 
    0xe0002cdc    0x988    ldr r3, [r3, #160] 
    0xe0002ce0    0x98c    add r3, r3, #64 
    0xe0002ce4    0x990    add r2, r2, #160 
    0xe0002ce8    0x994    add r1, sp, #32
    0xe0002cec    0x998    ldmdb r1, {r0, r1}    ; stack access
    0xe0002cf0    0x99c    bl e0012fa8 <cteInsert>
    0xe0002cf4    0x9a0    ldr r3, [sp, #72]     ; stack access
    0xe0002cf8    0x9a4    str r3, [r5, #132] 
    0xe0002cfc    0x9a8    ldr r3, [sp, #68]     ; stack access
    0xe0002d00    0x9ac    str r3, [r6, #256] 
    0xe0002d04    0x9b0    ldr r3, [sp, #64]     ; stack access
    0xe0002d08    0x9b4    str r3, [r5, #60] 
    0xe0002d0c    0x9b8    mov r3, #255 
    0xe0002d10    0x9bc    str r3, [r5, #120] 
    0xe0002d14    0x9c0    str r3, [r5, #116] 
    0xe0002d18    0x9c4    movw r6, #46284 
    0xe0002d1c    0x9c8    movt r6, #57345 
    0xe0002d20    0x9cc    movw sl, #13904 
    0xe0002d24    0x9d0    movt sl, #57347 
    0xe0002d28    0x9d4    ldr r3, [sl]
    0xe0002d2c    0x9d8    add r3, r6, r3, lsl #3
    0xe0002d30    0x9dc    ldr r3, [r3, #112] 
    0xe0002d34    0x9e0    str r3, [r5, #112] 
    0xe0002d38    0x9e4    mov r0, r5
    0xe0002d3c    0x9e8    bl e00134bc <setupReplyMaster>
    0xe0002d40    0x9ec    mov r1, #1
    0xe0002d44    0x9f0    mov r0, r5
    0xe0002d48    0x9f4    bl e0014ad8 <setThreadState>
    0xe0002d4c    0x9f8    ldr r2, [sl]
    0xe0002d50    0x9fc    movw r3, #12288 
    0xe0002d54    0xa00    movt r3, #57347 
    0xe0002d58    0xa04    add r6, r6, r2, lsl #3
    0xe0002d5c    0xa08    ldr r2, [r6, #112] 
    0xe0002d60    0xa0c    str r2, [r3]
    0xe0002d64    0xa10    movw r3, #5324 
    0xe0002d68    0xa14    movt r3, #57347 
    0xe0002d6c    0xa18    ldr r2, [r6, #116] 
    0xe0002d70    0xa1c    str r2, [r3]
    0xe0002d74    0xa20    bic r5, r5, #15
    0xe0002d78    0xa24    orr r5, r5, #12
    0xe0002d7c    0xa28    cmp r8, #14
    0xe0002d80    0xa2c    andne r2, r4, #15
    0xe0002d84    0xa30    uxtbeq r2, r4
    0xe0002d88    0xa34    sub r3, r2, #2
    0xe0002d8c    0xa38    cmp r3, #60 
    0xe0002d90    0xa3c    ldrls pc, [pc, r3, lsl #2]
    0xe0002d94    0xa40    b e0002ee4 <create_initial_thread+0xb90>
    0xe0002d98    0xa44    .word 0xe0002e94
    0xe0002d9c    0xa48    .word 0xe0002ee4
    0xe0002da0    0xa4c    .word 0xe0002e9c
    0xe0002da4    0xa50    .word 0xe0002ee4
    0xe0002da8    0xa54    .word 0xe0002ea4
    0xe0002dac    0xa58    .word 0xe0002ee4
    0xe0002db0    0xa5c    .word 0xe0002f70
    0xe0002db4    0xa60    .word 0xe0002ee4
    0xe0002db8    0xa64    .word 0xe0002eac
    0xe0002dbc    0xa68    .word 0xe0002ee4
    0xe0002dc0    0xa6c    .word 0xe0002eb4
    0xe0002dc4    0xa70    .word 0xe0002ee4
    0xe0002dc8    0xa74    .word 0xe0002f70
    0xe0002dcc    0xa78    .word 0xe0002ee4
    0xe0002dd0    0xa7c    .word 0xe0002ee4
    0xe0002dd4    0xa80    .word 0xe0002ee4
    0xe0002dd8    0xa84    .word 0xe0002ee4
    0xe0002ddc    0xa88    .word 0xe0002ee4
    0xe0002de0    0xa8c    .word 0xe0002ee4
    0xe0002de4    0xa90    .word 0xe0002ee4
    0xe0002de8    0xa94    .word 0xe0002ee4
    0xe0002dec    0xa98    .word 0xe0002ee4
    0xe0002df0    0xa9c    .word 0xe0002ee4
    0xe0002df4    0xaa0    .word 0xe0002ee4
    0xe0002df8    0xaa4    .word 0xe0002ee4
    0xe0002dfc    0xaa8    .word 0xe0002ee4
    0xe0002e00    0xaac    .word 0xe0002ee4
    0xe0002e04    0xab0    .word 0xe0002ee4
    0xe0002e08    0xab4    .word 0xe0002f70
    0xe0002e0c    0xab8    .word 0xe0002ee4
    0xe0002e10    0xabc    .word 0xe0002ee4
    0xe0002e14    0xac0    .word 0xe0002ee4
    0xe0002e18    0xac4    .word 0xe0002ee4
    0xe0002e1c    0xac8    .word 0xe0002ee4
    0xe0002e20    0xacc    .word 0xe0002ee4
    0xe0002e24    0xad0    .word 0xe0002ee4
    0xe0002e28    0xad4    .word 0xe0002ee4
    0xe0002e2c    0xad8    .word 0xe0002ee4
    0xe0002e30    0xadc    .word 0xe0002ee4
    0xe0002e34    0xae0    .word 0xe0002ee4
    0xe0002e38    0xae4    .word 0xe0002ee4
    0xe0002e3c    0xae8    .word 0xe0002ee4
    0xe0002e40    0xaec    .word 0xe0002ee4
    0xe0002e44    0xaf0    .word 0xe0002ee4
    0xe0002e48    0xaf4    .word 0xe0002ec0
    0xe0002e4c    0xaf8    .word 0xe0002ee4
    0xe0002e50    0xafc    .word 0xe0002ee4
    0xe0002e54    0xb00    .word 0xe0002ee4
    0xe0002e58    0xb04    .word 0xe0002ee4
    0xe0002e5c    0xb08    .word 0xe0002ee4
    0xe0002e60    0xb0c    .word 0xe0002ee4
    0xe0002e64    0xb10    .word 0xe0002ee4
    0xe0002e68    0xb14    .word 0xe0002ee4
    0xe0002e6c    0xb18    .word 0xe0002ee4
    0xe0002e70    0xb1c    .word 0xe0002ee4
    0xe0002e74    0xb20    .word 0xe0002ee4
    0xe0002e78    0xb24    .word 0xe0002ee4
    0xe0002e7c    0xb28    .word 0xe0002ee4
    0xe0002e80    0xb2c    .word 0xe0002ee4
    0xe0002e84    0xb30    .word 0xe0002ee4
    0xe0002e88    0xb34    .word 0xe0002f70
    0xe0002e8c    0xb38    mov r2, #0
    0xe0002e90    0xb3c    b e0002cd4 <create_initial_thread+0x980>
    0xe0002e94    0xb40    bic r4, r4, #15
    0xe0002e98    0xb44    b e0002f74 <create_initial_thread+0xc20>
    0xe0002e9c    0xb48    bic r4, r9, #15
    0xe0002ea0    0xb4c    b e0002f74 <create_initial_thread+0xc20>
    0xe0002ea4    0xb50    bic r4, r4, #15
    0xe0002ea8    0xb54    b e0002f74 <create_initial_thread+0xc20>
    0xe0002eac    0xb58    bic r4, r4, #31
    0xe0002eb0    0xb5c    b e0002f74 <create_initial_thread+0xc20>
    0xe0002eb4    0xb60    bic r4, r4, #508 
    0xe0002eb8    0xb64    bic r4, r4, #3
    0xe0002ebc    0xb68    b e0002f74 <create_initial_thread+0xc20>
    0xe0002ec0    0xb6c    lsr r4, r4, #8
    0xe0002ec4    0xb70    and r3, r4, #63 
    0xe0002ec8    0xb74    cmp r3, #32
    0xe0002ecc    0xb78    andne r4, r4, #31
    0xe0002ed0    0xb7c    moveq r4, #4
    0xe0002ed4    0xb80    add r3, r4, #1
    0xe0002ed8    0xb84    mvn r4, #0
    0xe0002edc    0xb88    and r4, r9, r4, lsl r3
    0xe0002ee0    0xb8c    b e0002f74 <create_initial_thread+0xc20>
    0xe0002ee4    0xb90    sub r3, r2, #1
    0xe0002ee8    0xb94    cmp r3, #8
    0xe0002eec    0xb98    ldrls pc, [pc, r3, lsl #2]
    0xe0002ef0    0xb9c    b e0002f98 <create_initial_thread+0xc44>
    0xe0002ef4    0xba0    .word 0xe0002f18
    0xe0002ef8    0xba4    .word 0xe0002f98
    0xe0002efc    0xba8    .word 0xe0002f18
    0xe0002f00    0xbac    .word 0xe0002f98
    0xe0002f04    0xbb0    .word 0xe0002f68
    0xe0002f08    0xbb4    .word 0xe0002f98
    0xe0002f0c    0xbb8    .word 0xe0002f50
    0xe0002f10    0xbbc    .word 0xe0002f98
    0xe0002f14    0xbc0    .word 0xe0002f5c
    0xe0002f18    0xbc4    cmp r2, #1
    0xe0002f1c    0xbc8    beq e0002f30 <create_initial_thread+0xbdc>
    0xe0002f20    0xbcc    cmp r2, #3
    0xe0002f24    0xbd0    beq e0002f40 <create_initial_thread+0xbec>
    0xe0002f28    0xbd4    mov r4, #0
    0xe0002f2c    0xbd8    b e0002f74 <create_initial_thread+0xc20>
    0xe0002f30    0xbdc    lsl r4, r4, #8
    0xe0002f34    0xbe0    bic r4, r4, #4080 
    0xe0002f38    0xbe4    bic r4, r4, #15
    0xe0002f3c    0xbe8    b e0002f74 <create_initial_thread+0xc20>
    0xe0002f40    0xbec    lsl r4, r4, #10
    0xe0002f44    0xbf0    bic r4, r4, #16320 
    0xe0002f48    0xbf4    bic r4, r4, #63 
    0xe0002f4c    0xbf8    b e0002f74 <create_initial_thread+0xc20>
    0xe0002f50    0xbfc    bic r4, r4, #1020 
    0xe0002f54    0xc00    bic r4, r4, #3
    0xe0002f58    0xc04    b e0002f74 <create_initial_thread+0xc20>
    0xe0002f5c    0xc08    bic r4, r4, #16320 
    0xe0002f60    0xc0c    bic r4, r4, #63 
    0xe0002f64    0xc10    b e0002f74 <create_initial_thread+0xc20>
    0xe0002f68    0xc14    bic r4, r4, #15
    0xe0002f6c    0xc18    b e0002f74 <create_initial_thread+0xc20>
    0xe0002f70    0xc1c    mov r4, #0
    0xe0002f74    0xc20    str r5, [r4, #16]
    0xe0002f78    0xc24    mov r3, #0
    0xe0002f7c    0xc28    str r3, [r4, #20]
    0xe0002f80    0xc2c    str r3, [r4, #24]
    0xe0002f84    0xc30    mov r3, #3
    0xe0002f88    0xc34    str r3, [r4, #28]
    0xe0002f8c    0xc38    mov r0, r7
    0xe0002f90    0xc3c    add sp, sp, #32
    0xe0002f94    0xc40    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe0002f98    0xc44    mov r4, #0
    0xe0002f9c    0xc48    b e0002f74 <create_initial_thread+0xc20>
    0xe0002fa0    0xc4c    movw r3, #47104 
    0xe0002fa4    0xc50    movt r3, #57345 
    0xe0002fa8    0xc54    ldr r3, [r3, #160] 
    0xe0002fac    0xc58    mov r2, #32
    0xe0002fb0    0xc5c    add r1, sp, #8
    0xe0002fb4    0xc60    ldm r1, {r0, r1}      ; stack access
    0xe0002fb8    0xc64    bl e0012fa8 <cteInsert>
    0xe0002fbc    0xc68    b e00027f8 <create_initial_thread+0x4a4>
    0xe0002fc0    0xc6c    movw r3, #47104 
    0xe0002fc4    0xc70    movt r3, #57345 
    0xe0002fc8    0xc74    ldr r3, [r3, #160] 
    0xe0002fcc    0xc78    mov r2, #32
    0xe0002fd0    0xc7c    add r1, sp, #8
    0xe0002fd4    0xc80    ldm r1, {r0, r1}      ; stack access
    0xe0002fd8    0xc84    bl e0012fa8 <cteInsert>
    0xe0002fdc    0xc88    uxtb r2, r4
    0xe0002fe0    0xc8c    b e00027fc <create_initial_thread+0x4a8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
393 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_initial_thread` has 1749 nodes.

Section invokeUntyped_Retype (267 of 293)
=========================================

Deriving specifications
-----------------------

Section `invokeUntyped_Retype` consists of 86 instructions.
 MOVHI (reg)....+++
 ORRLS (imm)....+++


Stack analysis
---------------

11 stack accesses found. Annotated code for `invokeUntyped_Retype`:

    0xe0019260      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0019264      0x4    sub sp, sp, #20
    0xe0019268      0x8    mov r4, r0
    0xe001926c      0xc    mov fp, r2
    0xe0019270     0x10    mov sl, r3
    0xe0019274     0x14    ldr r9, [r0]
    0xe0019278     0x18    bic r5, r9, #15
    0xe001927c     0x1c    cmp r1, #0
    0xe0019280     0x20    beq e00192c4 <invokeUntyped_Retype+0x64>
    0xe0019284     0x24    ldr r8, [r0, #4]
    0xe0019288     0x28    lsr r6, r8, #6
    0xe001928c     0x2c    lsls r6, r6, #4
    0xe0019290     0x30    beq e00192c4 <invokeUntyped_Retype+0x64>
    0xe0019294     0x34    and r2, r8, #31
    0xe0019298     0x38    ubfx r3, r8, #5, #1
    0xe001929c     0x3c    cmp r2, #7
    0xe00192a0     0x40    movhi r1, r3
    0xe00192a4     0x44    orrls r1, r3, #1
    0xe00192a8     0x48    cmp r1, #0
    0xe00192ac     0x4c    beq e0019354 <invokeUntyped_Retype+0xf4>
    0xe00192b0     0x50    cmp r3, #0
    0xe00192b4     0x54    beq e0019328 <invokeUntyped_Retype+0xc8>
    0xe00192b8     0x58    str r9, [r4]
    0xe00192bc     0x5c    and r8, r8, #63 
    0xe00192c0     0x60    str r8, [r4, #4]
    0xe00192c4     0x64    ldr r6, [sp, #68]     ; stack access
    0xe00192c8     0x68    ldr r1, [sp, #56]     ; stack access
    0xe00192cc     0x6c    mov r0, sl
    0xe00192d0     0x70    bl e0013838 <getObjectSize>
    0xe00192d4     0x74    sub r5, fp, r5
    0xe00192d8     0x78    add r5, r5, r6, lsl r0
    0xe00192dc     0x7c    lsr r5, r5, #4
    0xe00192e0     0x80    ldr r0, [r4, #4]
    0xe00192e4     0x84    and r0, r0, #63 
    0xe00192e8     0x88    orr r5, r0, r5, lsl #6
    0xe00192ec     0x8c    str r5, [r4, #4]
    0xe00192f0     0x90    ldr r3, [sp, #72]     ; stack access
    0xe00192f4     0x94    str r3, [sp, #12]     ; stack access
    0xe00192f8     0x98    ldr r3, [sp, #56]     ; stack access
    0xe00192fc     0x9c    str r3, [sp, #8]      ; stack access
    0xe0019300     0xa0    str fp, [sp, #4]      ; stack access
    0xe0019304     0xa4    str r6, [sp]          ; stack access
    0xe0019308     0xa8    add r3, sp, #60 
    0xe001930c     0xac    ldm r3, {r2, r3}      ; stack access
    0xe0019310     0xb0    mov r1, r4
    0xe0019314     0xb4    mov r0, sl
    0xe0019318     0xb8    bl e001490c <createNewObjects>
    0xe001931c     0xbc    mov r0, #0
    0xe0019320     0xc0    add sp, sp, #20
    0xe0019324     0xc4    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0019328     0xc8    mov r6, #1
    0xe001932c     0xcc    lsl r6, r6, r2
    0xe0019330     0xd0    mov r1, r6
    0xe0019334     0xd4    mov r0, r5
    0xe0019338     0xd8    bl e0019244 <memzero>
    0xe001933c     0xdc    sub r1, r5, #1
    0xe0019340     0xe0    add r2, r5, #805306368 
    0xe0019344     0xe4    add r1, r1, r6
    0xe0019348     0xe8    mov r0, r5
    0xe001934c     0xec    bl e00120c8 <cleanCacheRange_PoU>
    0xe0019350     0xf0    b e00192b8 <invokeUntyped_Retype+0x58>
    0xe0019354     0xf4    sub r6, r6, #1
    0xe0019358     0xf8    bic r6, r6, #255 
    0xe001935c     0xfc    cmn r6, #256 
    0xe0019360    0x100    beq e00192c4 <invokeUntyped_Retype+0x64>
    0xe0019364    0x104    add r7, r5, r6
    0xe0019368    0x108    and r8, r8, #63 
    0xe001936c    0x10c    mov r1, #256 
    0xe0019370    0x110    mov r0, r7
    0xe0019374    0x114    bl e0019244 <memzero>
    0xe0019378    0x118    add r2, r7, #805306368 
    0xe001937c    0x11c    add r1, r7, #255 
    0xe0019380    0x120    mov r0, r7
    0xe0019384    0x124    bl e00120c8 <cleanCacheRange_PoU>
    0xe0019388    0x128    str r9, [r4]
    0xe001938c    0x12c    lsr r3, r6, #4
    0xe0019390    0x130    orr r3, r8, r3, lsl #6
    0xe0019394    0x134    str r3, [r4, #4]
    0xe0019398    0x138    bl e0012f4c <preemptionPoint>
    0xe001939c    0x13c    cmp r0, #0
    0xe00193a0    0x140    bne e0019320 <invokeUntyped_Retype+0xc0>
    0xe00193a4    0x144    sub r6, r6, #256 
    0xe00193a8    0x148    sub r7, r7, #256 
    0xe00193ac    0x14c    cmn r6, #256 
    0xe00193b0    0x150    bne e001936c <invokeUntyped_Retype+0x10c>
    0xe00193b4    0x154    b e00192c4 <invokeUntyped_Retype+0x64>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
86 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeUntyped_Retype` has 130 nodes.

Section invokeTCB_ThreadControl (268 of 293)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_ThreadControl` consists of 122 instructions.
 ANDS (imm)...++


Stack analysis
---------------

22 stack accesses found. Annotated code for `invokeTCB_ThreadControl`:

    0xe0017924      0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0017928      0x4    sub sp, sp, #12
    0xe001792c      0x8    mov r5, r0
    0xe0017930      0xc    mov r7, r1
    0xe0017934     0x10    ldr r4, [sp, #76]     ; stack access
    0xe0017938     0x14    bic r1, r0, #15
    0xe001793c     0x18    orr r1, r1, #12
    0xe0017940     0x1c    str r1, [sp]          ; stack access
    0xe0017944     0x20    mov r1, #0
    0xe0017948     0x24    str r1, [sp, #4]      ; stack access
    0xe001794c     0x28    ands r1, r4, #4
    0xe0017950     0x2c    beq e0017ae8 <invokeTCB_ThreadControl+0x1c4>
    0xe0017954     0x30    str r2, [r0, #128] 
    0xe0017958     0x34    tst r4, #8
    0xe001795c     0x38    bne e0017a14 <invokeTCB_ThreadControl+0xf0>
    0xe0017960     0x3c    bic r6, r5, #508 
    0xe0017964     0x40    bic r6, r6, #3
    0xe0017968     0x44    mov r1, #1
    0xe001796c     0x48    mov r0, r6
    0xe0017970     0x4c    bl e0015b14 <cteDelete>
    0xe0017974     0x50    cmp r0, #0
    0xe0017978     0x54    bne e0017b04 <invokeTCB_ThreadControl+0x1e0>
    0xe001797c     0x58    ldr r3, [sp, #44]     ; stack access
    0xe0017980     0x5c    ldm r3, {r2, r3}
    0xe0017984     0x60    add r1, sp, #36 
    0xe0017988     0x64    ldm r1, {r0, r1}      ; stack access
    0xe001798c     0x68    bl e0014394 <sameObjectAs>
    0xe0017990     0x6c    cmp r0, #0
    0xe0017994     0x70    beq e00179b0 <invokeTCB_ThreadControl+0x8c>
    0xe0017998     0x74    ldm r7, {r2, r3}
    0xe001799c     0x78    add r1, sp, #8
    0xe00179a0     0x7c    ldmdb r1, {r0, r1}    ; stack access
    0xe00179a4     0x80    bl e0014394 <sameObjectAs>
    0xe00179a8     0x84    cmp r0, #0
    0xe00179ac     0x88    bne e0017a24 <invokeTCB_ThreadControl+0x100>
    0xe00179b0     0x8c    add r6, r6, #16
    0xe00179b4     0x90    mov r1, #1
    0xe00179b8     0x94    mov r0, r6
    0xe00179bc     0x98    bl e0015b14 <cteDelete>
    0xe00179c0     0x9c    cmp r0, #0
    0xe00179c4     0xa0    bne e0017b04 <invokeTCB_ThreadControl+0x1e0>
    0xe00179c8     0xa4    ldr r3, [sp, #56]     ; stack access
    0xe00179cc     0xa8    ldm r3, {r2, r3}
    0xe00179d0     0xac    add r1, sp, #48 
    0xe00179d4     0xb0    ldm r1, {r0, r1}      ; stack access
    0xe00179d8     0xb4    bl e0014394 <sameObjectAs>
    0xe00179dc     0xb8    cmp r0, #0
    0xe00179e0     0xbc    beq e0017af0 <invokeTCB_ThreadControl+0x1cc>
    0xe00179e4     0xc0    ldm r7, {r2, r3}
    0xe00179e8     0xc4    add r1, sp, #8
    0xe00179ec     0xc8    ldmdb r1, {r0, r1}    ; stack access
    0xe00179f0     0xcc    bl e0014394 <sameObjectAs>
    0xe00179f4     0xd0    cmp r0, #0
    0xe00179f8     0xd4    beq e0017af0 <invokeTCB_ThreadControl+0x1cc>
    0xe00179fc     0xd8    mov r3, r6
    0xe0017a00     0xdc    ldr r2, [sp, #56]     ; stack access
    0xe0017a04     0xe0    add r1, sp, #48 
    0xe0017a08     0xe4    ldm r1, {r0, r1}      ; stack access
    0xe0017a0c     0xe8    bl e0012fa8 <cteInsert>
    0xe0017a10     0xec    b e0017af0 <invokeTCB_ThreadControl+0x1cc>
    0xe0017a14     0xf0    str r3, [r5, #116] 
    0xe0017a18     0xf4    cmp r1, #0
    0xe0017a1c     0xf8    beq e0017af0 <invokeTCB_ThreadControl+0x1cc>
    0xe0017a20     0xfc    b e0017960 <invokeTCB_ThreadControl+0x3c>
    0xe0017a24    0x100    mov r3, r6
    0xe0017a28    0x104    ldr r2, [sp, #44]     ; stack access
    0xe0017a2c    0x108    add r1, sp, #36 
    0xe0017a30    0x10c    ldm r1, {r0, r1}      ; stack access
    0xe0017a34    0x110    bl e0012fa8 <cteInsert>
    0xe0017a38    0x114    b e00179b0 <invokeTCB_ThreadControl+0x8c>
    0xe0017a3c    0x118    bic r0, r5, #508 
    0xe0017a40    0x11c    bic r0, r0, #3
    0xe0017a44    0x120    add r6, r0, #64 
    0xe0017a48    0x124    mov r1, #1
    0xe0017a4c    0x128    mov r0, r6
    0xe0017a50    0x12c    bl e0015b14 <cteDelete>
    0xe0017a54    0x130    cmp r0, #0
    0xe0017a58    0x134    bne e0017b04 <invokeTCB_ThreadControl+0x1e0>
    0xe0017a5c    0x138    ldr r3, [sp, #60]     ; stack access
    0xe0017a60    0x13c    str r3, [r5, #132] 
    0xe0017a64    0x140    ldr r3, [sp, #72]     ; stack access
    0xe0017a68    0x144    cmp r3, #0
    0xe0017a6c    0x148    beq e0017aa0 <invokeTCB_ThreadControl+0x17c>
    0xe0017a70    0x14c    ldm r3, {r2, r3}
    0xe0017a74    0x150    add r1, sp, #64 
    0xe0017a78    0x154    ldm r1, {r0, r1}      ; stack access
    0xe0017a7c    0x158    bl e0014394 <sameObjectAs>
    0xe0017a80    0x15c    cmp r0, #0
    0xe0017a84    0x160    beq e0017aa0 <invokeTCB_ThreadControl+0x17c>
    0xe0017a88    0x164    ldm r7, {r2, r3}
    0xe0017a8c    0x168    add r1, sp, #8
    0xe0017a90    0x16c    ldmdb r1, {r0, r1}    ; stack access
    0xe0017a94    0x170    bl e0014394 <sameObjectAs>
    0xe0017a98    0x174    cmp r0, #0
    0xe0017a9c    0x178    bne e0017abc <invokeTCB_ThreadControl+0x198>
    0xe0017aa0    0x17c    movw r3, #13900 
    0xe0017aa4    0x180    movt r3, #57347 
    0xe0017aa8    0x184    ldr r3, [r3]
    0xe0017aac    0x188    cmp r3, r5
    0xe0017ab0    0x18c    bne e0017af8 <invokeTCB_ThreadControl+0x1d4>
    0xe0017ab4    0x190    bl e0014a4c <rescheduleRequired>
    0xe0017ab8    0x194    b e0017af8 <invokeTCB_ThreadControl+0x1d4>
    0xe0017abc    0x198    mov r3, r6
    0xe0017ac0    0x19c    ldr r2, [sp, #72]     ; stack access
    0xe0017ac4    0x1a0    add r1, sp, #64 
    0xe0017ac8    0x1a4    ldm r1, {r0, r1}      ; stack access
    0xe0017acc    0x1a8    bl e0012fa8 <cteInsert>
    0xe0017ad0    0x1ac    b e0017aa0 <invokeTCB_ThreadControl+0x17c>
    0xe0017ad4    0x1b0    ldr r1, [sp, #32]     ; stack access
    0xe0017ad8    0x1b4    mov r0, r5
    0xe0017adc    0x1b8    bl e00154ac <setPriority>
    0xe0017ae0    0x1bc    mov r0, #0
    0xe0017ae4    0x1c0    b e0017b04 <invokeTCB_ThreadControl+0x1e0>
    0xe0017ae8    0x1c4    tst r4, #8
    0xe0017aec    0x1c8    bne e0017a14 <invokeTCB_ThreadControl+0xf0>
    0xe0017af0    0x1cc    tst r4, #2
    0xe0017af4    0x1d0    bne e0017a3c <invokeTCB_ThreadControl+0x118>
    0xe0017af8    0x1d4    tst r4, #1
    0xe0017afc    0x1d8    moveq r0, #0
    0xe0017b00    0x1dc    bne e0017ad4 <invokeTCB_ThreadControl+0x1b0>
    0xe0017b04    0x1e0    add sp, sp, #12
    0xe0017b08    0x1e4    pop {r4, r5, r6, r7, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
122 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_ThreadControl` has 204 nodes.

Section handleRecv (269 of 293)
===============================

Deriving specifications
-----------------------

Section `handleRecv` consists of 114 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `handleRecv`:

    0xe001763c      0x0    push {r4, r5, lr}     ; stack access
    0xe0017640      0x4    sub sp, sp, #20
    0xe0017644      0x8    mov r5, r0
    0xe0017648      0xc    movw r3, #13900 
    0xe001764c     0x10    movt r3, #57347 
    0xe0017650     0x14    ldr r1, [r3]
    0xe0017654     0x18    ldr r4, [r1]
    0xe0017658     0x1c    mov r2, r4
    0xe001765c     0x20    add r0, sp, #4
    0xe0017660     0x24    bl e0012c1c <lookupCap>
    0xe0017664     0x28    ldr r1, [sp, #12]     ; stack access
    0xe0017668     0x2c    ldr r3, [sp, #4]      ; stack access
    0xe001766c     0x30    cmp r3, #0
    0xe0017670     0x34    bne e00176dc <handleRecv+0xa0>
    0xe0017674     0x38    ldr r3, [sp, #8]      ; stack access
    0xe0017678     0x3c    and r2, r3, #14
    0xe001767c     0x40    cmp r2, #14
    0xe0017680     0x44    andne r2, r3, #15
    0xe0017684     0x48    uxtbeq r2, r3
    0xe0017688     0x4c    cmp r2, #4
    0xe001768c     0x50    beq e0017704 <handleRecv+0xc8>
    0xe0017690     0x54    cmp r2, #6
    0xe0017694     0x58    beq e0017774 <handleRecv+0x138>
    0xe0017698     0x5c    movw r3, #36884 
    0xe001769c     0x60    movt r3, #57346 
    0xe00176a0     0x64    mov r2, #1
    0xe00176a4     0x68    str r2, [r3]
    0xe00176a8     0x6c    mov r2, #0
    0xe00176ac     0x70    str r2, [r3, #4]
    0xe00176b0     0x74    movw r3, #32768 
    0xe00176b4     0x78    movt r3, #57346 
    0xe00176b8     0x7c    mov r2, #-2147483647 
    0xe00176bc     0x80    str r2, [r3]
    0xe00176c0     0x84    str r4, [r3, #4]
    0xe00176c4     0x88    movw r3, #13900 
    0xe00176c8     0x8c    movt r3, #57347 
    0xe00176cc     0x90    ldr r0, [r3]
    0xe00176d0     0x94    bl e001734c <handleFault>
    0xe00176d4     0x98    add sp, sp, #20
    0xe00176d8     0x9c    pop {r4, r5, pc}      ; stack access
    0xe00176dc     0xa0    movw r3, #32768 
    0xe00176e0     0xa4    movt r3, #57346 
    0xe00176e4     0xa8    mov r2, #-2147483647 
    0xe00176e8     0xac    str r2, [r3]
    0xe00176ec     0xb0    str r4, [r3, #4]
    0xe00176f0     0xb4    movw r3, #13900 
    0xe00176f4     0xb8    movt r3, #57347 
    0xe00176f8     0xbc    ldr r0, [r3]
    0xe00176fc     0xc0    bl e001734c <handleFault>
    0xe0017700     0xc4    b e00176d4 <handleRecv+0x98>
    0xe0017704     0xc8    tst r1, #2
    0xe0017708     0xcc    beq e0017734 <handleRecv+0xf8>
    0xe001770c     0xd0    movw r4, #13900 
    0xe0017710     0xd4    movt r4, #57347 
    0xe0017714     0xd8    ldr r0, [r4]
    0xe0017718     0xdc    bl e0016b5c <deleteCallerCap>
    0xe001771c     0xe0    mov r3, r5
    0xe0017720     0xe4    add r2, sp, #16
    0xe0017724     0xe8    ldmdb r2, {r1, r2}    ; stack access
    0xe0017728     0xec    ldr r0, [r4]
    0xe001772c     0xf0    bl e0017468 <receiveIPC>
    0xe0017730     0xf4    b e00176d4 <handleRecv+0x98>
    0xe0017734     0xf8    movw r3, #36884 
    0xe0017738     0xfc    movt r3, #57346 
    0xe001773c    0x100    mov r2, #1
    0xe0017740    0x104    str r2, [r3]
    0xe0017744    0x108    mov r2, #0
    0xe0017748    0x10c    str r2, [r3, #4]
    0xe001774c    0x110    movw r3, #32768 
    0xe0017750    0x114    movt r3, #57346 
    0xe0017754    0x118    mov r2, #-2147483647 
    0xe0017758    0x11c    str r2, [r3]
    0xe001775c    0x120    str r4, [r3, #4]
    0xe0017760    0x124    movw r3, #13900 
    0xe0017764    0x128    movt r3, #57347 
    0xe0017768    0x12c    ldr r0, [r3]
    0xe001776c    0x130    bl e001734c <handleFault>
    0xe0017770    0x134    b e00176d4 <handleRecv+0x98>
    0xe0017774    0x138    bic r3, r3, #15
    0xe0017778    0x13c    ldr r3, [r3, #12]
    0xe001777c    0x140    bic r3, r3, #15
    0xe0017780    0x144    tst r1, #2
    0xe0017784    0x148    beq e00177c4 <handleRecv+0x188>
    0xe0017788    0x14c    cmp r3, #0
    0xe001778c    0x150    bne e00177b0 <handleRecv+0x174>
    0xe0017790    0x154    movw r0, #13900 
    0xe0017794    0x158    movt r0, #57347 
    0xe0017798    0x15c    mov r3, r5
    0xe001779c    0x160    add r2, sp, #16
    0xe00177a0    0x164    ldmdb r2, {r1, r2}    ; stack access
    0xe00177a4    0x168    ldr r0, [r0]
    0xe00177a8    0x16c    bl e0014e10 <receiveSignal>
    0xe00177ac    0x170    b e00176d4 <handleRecv+0x98>
    0xe00177b0    0x174    movw r2, #13900 
    0xe00177b4    0x178    movt r2, #57347 
    0xe00177b8    0x17c    ldr r2, [r2]
    0xe00177bc    0x180    cmp r2, r3
    0xe00177c0    0x184    beq e0017790 <handleRecv+0x154>
    0xe00177c4    0x188    movw r3, #36884 
    0xe00177c8    0x18c    movt r3, #57346 
    0xe00177cc    0x190    mov r2, #1
    0xe00177d0    0x194    str r2, [r3]
    0xe00177d4    0x198    mov r2, #0
    0xe00177d8    0x19c    str r2, [r3, #4]
    0xe00177dc    0x1a0    movw r3, #32768 
    0xe00177e0    0x1a4    movt r3, #57346 
    0xe00177e4    0x1a8    mov r2, #-2147483647 
    0xe00177e8    0x1ac    str r2, [r3]
    0xe00177ec    0x1b0    str r4, [r3, #4]
    0xe00177f0    0x1b4    movw r3, #13900 
    0xe00177f4    0x1b8    movt r3, #57347 
    0xe00177f8    0x1bc    ldr r0, [r3]
    0xe00177fc    0x1c0    bl e001734c <handleFault>
    0xe0017800    0x1c4    b e00176d4 <handleRecv+0x98>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
114 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleRecv` has 172 nodes.

Section doReplyTransfer (270 of 293)
====================================

Deriving specifications
-----------------------

Section `doReplyTransfer` consists of 41 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `doReplyTransfer`:

    0xe0016f48     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0016f4c     0x4    sub sp, sp, #8
    0xe0016f50     0x8    mov r5, r0
    0xe0016f54     0xc    mov r4, r1
    0xe0016f58    0x10    mov r6, r2
    0xe0016f5c    0x14    ldr r2, [r1, #96] 
    0xe0016f60    0x18    tst r2, #15
    0xe0016f64    0x1c    bne e0016f9c <doReplyTransfer+0x54>
    0xe0016f68    0x20    str r1, [sp]          ; stack access
    0xe0016f6c    0x24    mov r2, #0
    0xe0016f70    0x28    mov r1, r2
    0xe0016f74    0x2c    bl e0016ec4 <doIPCTransfer>
    0xe0016f78    0x30    mov r0, r6
    0xe0016f7c    0x34    bl e00164f8 <cteDeleteOne>
    0xe0016f80    0x38    mov r1, #1
    0xe0016f84    0x3c    mov r0, r4
    0xe0016f88    0x40    bl e0014ad8 <setThreadState>
    0xe0016f8c    0x44    mov r0, r4
    0xe0016f90    0x48    bl e0014ed4 <possibleSwitchTo>
    0xe0016f94    0x4c    add sp, sp, #8
    0xe0016f98    0x50    pop {r4, r5, r6, pc}  ; stack access
    0xe0016f9c    0x54    mov r0, r6
    0xe0016fa0    0x58    bl e00164f8 <cteDeleteOne>
    0xe0016fa4    0x5c    mov r1, r5
    0xe0016fa8    0x60    mov r0, r4
    0xe0016fac    0x64    bl e0010c28 <handleFaultReply>
    0xe0016fb0    0x68    mov r3, #0
    0xe0016fb4    0x6c    str r3, [r4, #96] 
    0xe0016fb8    0x70    str r3, [r4, #100] 
    0xe0016fbc    0x74    cmp r0, r3
    0xe0016fc0    0x78    bne e0016fd4 <doReplyTransfer+0x8c>
    0xe0016fc4    0x7c    mov r1, #0
    0xe0016fc8    0x80    mov r0, r4
    0xe0016fcc    0x84    bl e0014ad8 <setThreadState>
    0xe0016fd0    0x88    b e0016f94 <doReplyTransfer+0x4c>
    0xe0016fd4    0x8c    mov r1, #2
    0xe0016fd8    0x90    mov r0, r4
    0xe0016fdc    0x94    bl e0014ad8 <setThreadState>
    0xe0016fe0    0x98    mov r0, r4
    0xe0016fe4    0x9c    bl e0014ed4 <possibleSwitchTo>
    0xe0016fe8    0xa0    b e0016f94 <doReplyTransfer+0x4c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
41 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doReplyTransfer` has 60 nodes.

Section doNormalTransfer (271 of 293)
=====================================

Deriving specifications
-----------------------

Section `doNormalTransfer` consists of 129 instructions.
 STMDB;2,1,0....+
 LDMDB;2,1,0....++


Stack analysis
---------------

21 stack accesses found. Annotated code for `doNormalTransfer`:

    0xe0016cc0      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0016cc4      0x4    sub sp, sp, #60 
    0xe0016cc8      0x8    mov r6, r0
    0xe0016ccc      0xc    mov fp, r1
    0xe0016cd0     0x10    mov sl, r2
    0xe0016cd4     0x14    mov r9, r3
    0xe0016cd8     0x18    ldr r5, [sp, #100]    ; stack access
    0xe0016cdc     0x1c    ldr r7, [sp, #104]    ; stack access
    0xe0016ce0     0x20    ldr r4, [r0, #4]
    0xe0016ce4     0x24    and r3, r4, #127 
    0xe0016ce8     0x28    cmp r3, #120 
    0xe0016cec     0x2c    bichi r4, r4, #127 
    0xe0016cf0     0x30    orrhi r4, r4, #120 
    0xe0016cf4     0x34    ldr r3, [sp, #96]     ; stack access
    0xe0016cf8     0x38    cmp r3, #0
    0xe0016cfc     0x3c    bne e0016d7c <doNormalTransfer+0xbc>
    0xe0016d00     0x40    movw r3, #36924 
    0xe0016d04     0x44    movt r3, #57346 
    0xe0016d08     0x48    ldm r3, {r0, r1, r2}
    0xe0016d0c     0x4c    add r3, sp, #56 
    0xe0016d10     0x50    stmdb r3, {r0, r1, r2}  ; stack access
    0xe0016d14     0x54    mov r8, #0
    0xe0016d18     0x58    and r3, r4, #127 
    0xe0016d1c     0x5c    str r3, [sp]          ; stack access
    0xe0016d20     0x60    mov r3, r7
    0xe0016d24     0x64    mov r2, r5
    0xe0016d28     0x68    mov r1, fp
    0xe0016d2c     0x6c    mov r0, r6
    0xe0016d30     0x70    bl e0016c2c <copyMRs>
    0xe0016d34     0x74    mov r6, r0
    0xe0016d38     0x78    str r8, [sp, #44]     ; stack access
    0xe0016d3c     0x7c    add r3, sp, #20
    0xe0016d40     0x80    add r2, sp, #56 
    0xe0016d44     0x84    ldmdb r2, {r0, r1, r2}  ; stack access
    0xe0016d48     0x88    stm r3, {r0, r1, r2}  ; stack access
    0xe0016d4c     0x8c    bic r4, r4, #3968 
    0xe0016d50     0x90    mov r8, r0
    0xe0016d54     0x94    cmp r0, #0
    0xe0016d58     0x98    cmpne r7, #0
    0xe0016d5c     0x9c    bne e0016dac <doNormalTransfer+0xec>
    0xe0016d60     0xa0    bic r4, r4, #127 
    0xe0016d64     0xa4    and r6, r6, #127 
    0xe0016d68     0xa8    orr r4, r4, r6
    0xe0016d6c     0xac    str r4, [r5, #4]
    0xe0016d70     0xb0    str r9, [r5]
    0xe0016d74     0xb4    add sp, sp, #60 
    0xe0016d78     0xb8    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0016d7c     0xbc    mov r2, r4
    0xe0016d80     0xc0    bl e0016b74 <lookupExtraCaps>
    0xe0016d84     0xc4    mov ip, r0
    0xe0016d88     0xc8    movw r3, #36924 
    0xe0016d8c     0xcc    movt r3, #57346 
    0xe0016d90     0xd0    ldm r3, {r0, r1, r2}
    0xe0016d94     0xd4    add r3, sp, #56 
    0xe0016d98     0xd8    stmdb r3, {r0, r1, r2}  ; stack access
    0xe0016d9c     0xdc    cmp ip, #0
    0xe0016da0     0xe0    moveq r8, r0
    0xe0016da4     0xe4    movne r8, #0
    0xe0016da8     0xe8    b e0016d18 <doNormalTransfer+0x58>
    0xe0016dac     0xec    mov r1, r7
    0xe0016db0     0xf0    mov r0, r5
    0xe0016db4     0xf4    bl e001353c <getReceiveSlots>
    0xe0016db8     0xf8    cmp r8, #0
    0xe0016dbc     0xfc    beq e0016eb0 <doNormalTransfer+0x1f0>
    0xe0016dc0    0x100    mov fp, #0
    0xe0016dc4    0x104    str r7, [sp, #104]    ; stack access
    0xe0016dc8    0x108    mov r7, r0
    0xe0016dcc    0x10c    b e0016e50 <doNormalTransfer+0x190>
    0xe0016dd0    0x110    cmp r7, #0
    0xe0016dd4    0x114    beq e0016eb4 <doNormalTransfer+0x1f4>
    0xe0016dd8    0x118    str r0, [sp, #12]     ; stack access
    0xe0016ddc    0x11c    str r1, [sp, #16]     ; stack access
    0xe0016de0    0x120    add r3, sp, #12
    0xe0016de4    0x124    ldm r3, {r2, r3}      ; stack access
    0xe0016de8    0x128    mov r1, r8
    0xe0016dec    0x12c    add r0, sp, #32
    0xe0016df0    0x130    bl e00142e4 <deriveCap>
    0xe0016df4    0x134    ldr r3, [sp, #32]     ; stack access
    0xe0016df8    0x138    cmp r3, #0
    0xe0016dfc    0x13c    bne e0016eb4 <doNormalTransfer+0x1f4>
    0xe0016e00    0x140    ldr r3, [sp, #36]     ; stack access
    0xe0016e04    0x144    and r2, r3, #14
    0xe0016e08    0x148    cmp r2, #14
    0xe0016e0c    0x14c    andne r3, r3, #15
    0xe0016e10    0x150    uxtbeq r3, r3
    0xe0016e14    0x154    cmp r3, #0
    0xe0016e18    0x158    beq e0016eb4 <doNormalTransfer+0x1f4>
    0xe0016e1c    0x15c    mov r3, r7
    0xe0016e20    0x160    mov r2, r8
    0xe0016e24    0x164    add r1, sp, #36 
    0xe0016e28    0x168    ldm r1, {r0, r1}      ; stack access
    0xe0016e2c    0x16c    bl e0012fa8 <cteInsert>
    0xe0016e30    0x170    mov r7, #0
    0xe0016e34    0x174    add fp, fp, #1
    0xe0016e38    0x178    cmp fp, #3
    0xe0016e3c    0x17c    beq e0016eb4 <doNormalTransfer+0x1f4>
    0xe0016e40    0x180    add r3, sp, #20
    0xe0016e44    0x184    ldr r8, [r3, fp, lsl #2]  ; stack access
    0xe0016e48    0x188    cmp r8, #0
    0xe0016e4c    0x18c    beq e0016eb4 <doNormalTransfer+0x1f4>
    0xe0016e50    0x190    ldm r8, {r0, r1}
    0xe0016e54    0x194    add r3, sp, #12
    0xe0016e58    0x198    stm r3, {r0, r1}      ; stack access
    0xe0016e5c    0x19c    and r3, r0, #14
    0xe0016e60    0x1a0    cmp r3, #14
    0xe0016e64    0x1a4    andne r3, r0, #15
    0xe0016e68    0x1a8    uxtbeq r3, r0
    0xe0016e6c    0x1ac    cmp r3, #4
    0xe0016e70    0x1b0    bne e0016dd0 <doNormalTransfer+0x110>
    0xe0016e74    0x1b4    bic r3, r1, #15
    0xe0016e78    0x1b8    cmp sl, r3
    0xe0016e7c    0x1bc    bne e0016dd0 <doNormalTransfer+0x110>
    0xe0016e80    0x1c0    ldr r3, [sp, #104]    ; stack access
    0xe0016e84    0x1c4    add r3, r3, fp, lsl #2
    0xe0016e88    0x1c8    lsr r0, r0, #4
    0xe0016e8c    0x1cc    str r0, [r3, #488] 
    0xe0016e90    0x1d0    ubfx r3, r4, #9, #3
    0xe0016e94    0x1d4    mov r2, #1
    0xe0016e98    0x1d8    orr r3, r3, r2, lsl fp
    0xe0016e9c    0x1dc    lsl r3, r3, #9
    0xe0016ea0    0x1e0    and r3, r3, #3584 
    0xe0016ea4    0x1e4    bic r4, r4, #3584 
    0xe0016ea8    0x1e8    orr r4, r3, r4
    0xe0016eac    0x1ec    b e0016e34 <doNormalTransfer+0x174>
    0xe0016eb0    0x1f0    mov fp, #0
    0xe0016eb4    0x1f4    lsl r3, fp, #7
    0xe0016eb8    0x1f8    and r3, r3, #384 
    0xe0016ebc    0x1fc    orr r4, r4, r3
    0xe0016ec0    0x200    b e0016d60 <doNormalTransfer+0xa0>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
129 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doNormalTransfer` has 200 nodes.

Section restart (272 of 293)
============================

Deriving specifications
-----------------------

Section `restart` consists of 19 instructions.
 BXHI..++


Stack analysis
---------------

2 stack accesses found. Annotated code for `restart`:

    0xe0016718     0x0    ldr r3, [r0, #80] 
    0xe001671c     0x4    ands r3, r3, #15
    0xe0016720     0x8    beq e0016730 <restart+0x18>
    0xe0016724     0xc    sub r3, r3, #3
    0xe0016728    0x10    cmp r3, #3
    0xe001672c    0x14    bxhi lr
    0xe0016730    0x18    push {r4, lr}         ; stack access
    0xe0016734    0x1c    mov r4, r0
    0xe0016738    0x20    bl e001575c <cancelIPC>
    0xe001673c    0x24    mov r0, r4
    0xe0016740    0x28    bl e00134bc <setupReplyMaster>
    0xe0016744    0x2c    mov r1, #2
    0xe0016748    0x30    mov r0, r4
    0xe001674c    0x34    bl e0014ad8 <setThreadState>
    0xe0016750    0x38    mov r0, r4
    0xe0016754    0x3c    bl e00149a8 <tcbSchedEnqueue>
    0xe0016758    0x40    mov r0, r4
    0xe001675c    0x44    bl e0014ed4 <possibleSwitchTo>
    0xe0016760    0x48    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `restart` has 32 nodes.

Section cancelBadgedSends (273 of 293)
======================================

Deriving specifications
-----------------------

Section `cancelBadgedSends` consists of 66 instructions.
 ORRNE (imm)....+++


Stack analysis
---------------

9 stack accesses found. Annotated code for `cancelBadgedSends`:

    0xe0015588      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001558c      0x4    sub sp, sp, #20
    0xe0015590      0x8    ldr r3, [r0]
    0xe0015594      0xc    and r2, r3, #3
    0xe0015598     0x10    cmp r2, #1
    0xe001559c     0x14    beq e00155b0 <cancelBadgedSends+0x28>
    0xe00155a0     0x18    bcc e001567c <cancelBadgedSends+0xf4>
    0xe00155a4     0x1c    cmp r2, #2
    0xe00155a8     0x20    beq e001567c <cancelBadgedSends+0xf4>
    0xe00155ac     0x24    bl e0010904 <halt>
    0xe00155b0     0x28    mov r6, r0
    0xe00155b4     0x2c    mov r7, r1
    0xe00155b8     0x30    ldr r4, [r0, #4]
    0xe00155bc     0x34    bic r8, r3, #15
    0xe00155c0     0x38    and r2, r4, #15
    0xe00155c4     0x3c    str r2, [r0, #4]
    0xe00155c8     0x40    and r2, r3, #12
    0xe00155cc     0x44    str r2, [r0]
    0xe00155d0     0x48    bics r4, r4, #15
    0xe00155d4     0x4c    beq e0015684 <cancelBadgedSends+0xfc>
    0xe00155d8     0x50    mov sl, r4
    0xe00155dc     0x54    mov fp, sp
    0xe00155e0     0x58    add r9, sp, #8
    0xe00155e4     0x5c    b e00155f4 <cancelBadgedSends+0x6c>
    0xe00155e8     0x60    mov r4, r5
    0xe00155ec     0x64    cmp r5, #0
    0xe00155f0     0x68    beq e0015644 <cancelBadgedSends+0xbc>
    0xe00155f4     0x6c    ldr r5, [r4, #144] 
    0xe00155f8     0x70    ldr r3, [r4, #88] 
    0xe00155fc     0x74    cmp r7, r3, lsr #4
    0xe0015600     0x78    bne e00155e8 <cancelBadgedSends+0x60>
    0xe0015604     0x7c    mov r1, #2
    0xe0015608     0x80    mov r0, r4
    0xe001560c     0x84    bl e0014ad8 <setThreadState>
    0xe0015610     0x88    mov r0, r4
    0xe0015614     0x8c    bl e00149a8 <tcbSchedEnqueue>
    0xe0015618     0x90    str sl, [sp, #8]      ; stack access
    0xe001561c     0x94    str r8, [sp, #12]     ; stack access
    0xe0015620     0x98    ldm r9, {r2, r3}      ; stack access
    0xe0015624     0x9c    mov r1, r4
    0xe0015628     0xa0    mov r0, fp
    0xe001562c     0xa4    bl e0015538 <tcbEPDequeue>
    0xe0015630     0xa8    ldm fp, {r0, r1}      ; stack access
    0xe0015634     0xac    stm r9, {r0, r1}      ; stack access
    0xe0015638     0xb0    ldr sl, [sp, #8]      ; stack access
    0xe001563c     0xb4    ldr r8, [sp, #12]     ; stack access
    0xe0015640     0xb8    b e00155e8 <cancelBadgedSends+0x60>
    0xe0015644     0xbc    ldr r3, [r6, #4]
    0xe0015648     0xc0    and r3, r3, #15
    0xe001564c     0xc4    bic r2, sl, #15
    0xe0015650     0xc8    orr r3, r3, r2
    0xe0015654     0xcc    str r3, [r6, #4]
    0xe0015658     0xd0    ldr r3, [r6]
    0xe001565c     0xd4    and r3, r3, #15
    0xe0015660     0xd8    bic r8, r8, #15
    0xe0015664     0xdc    orr r3, r3, r8
    0xe0015668     0xe0    cmp sl, #0
    0xe001566c     0xe4    bicne r3, r3, #3
    0xe0015670     0xe8    orrne r3, r3, #1
    0xe0015674     0xec    str r3, [r6]
    0xe0015678     0xf0    bl e0014a4c <rescheduleRequired>
    0xe001567c     0xf4    add sp, sp, #20
    0xe0015680     0xf8    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0015684     0xfc    bic r3, r3, #3
    0xe0015688    0x100    str r3, [r0]
    0xe001568c    0x104    b e0015678 <cancelBadgedSends+0xf0>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
66 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelBadgedSends` has 107 nodes.

Section decodeIRQControlInvocation (274 of 293)
===============================================

Deriving specifications
-----------------------

Section `decodeIRQControlInvocation` consists of 87 instructions.


Stack analysis
---------------

13 stack accesses found. Annotated code for `decodeIRQControlInvocation`:

    0xe0014cb4      0x0    sub sp, sp, #8
    0xe0014cb8      0x4    push {r4, r5, r6, lr}  ; stack access
    0xe0014cbc      0x8    sub sp, sp, #32
    0xe0014cc0      0xc    mov lr, r1
    0xe0014cc4     0x10    mov r4, r2
    0xe0014cc8     0x14    str r3, [sp, #52]     ; stack access
    0xe0014ccc     0x18    cmp r0, #25
    0xe0014cd0     0x1c    bne e0014dd8 <decodeIRQControlInvocation+0x124>
    0xe0014cd4     0x20    mov r2, r3
    0xe0014cd8     0x24    cmp r3, #0
    0xe0014cdc     0x28    cmpne r1, #2
    0xe0014ce0     0x2c    bhi e0014cfc <decodeIRQControlInvocation+0x48>
    0xe0014ce4     0x30    movw r3, #36896 
    0xe0014ce8     0x34    movt r3, #57346 
    0xe0014cec     0x38    mov r2, #7
    0xe0014cf0     0x3c    str r2, [r3, #24]
    0xe0014cf4     0x40    mov r0, #3
    0xe0014cf8     0x44    b e0014e00 <decodeIRQControlInvocation+0x14c>
    0xe0014cfc     0x48    movw r3, #13900 
    0xe0014d00     0x4c    movt r3, #57347 
    0xe0014d04     0x50    ldr r1, [r3]
    0xe0014d08     0x54    ldr r5, [r1, #8]
    0xe0014d0c     0x58    ldr r3, [r1, #12]
    0xe0014d10     0x5c    ldr lr, [r1, #16]
    0xe0014d14     0x60    add ip, sp, #16
    0xe0014d18     0x64    ldm r2, {r0, r1}
    0xe0014d1c     0x68    stm ip, {r0, r1}      ; stack access
    0xe0014d20     0x6c    cmp r5, #159 
    0xe0014d24     0x70    bhi e0014d54 <decodeIRQControlInvocation+0xa0>
    0xe0014d28     0x74    movw r2, #36936 
    0xe0014d2c     0x78    movt r2, #57346 
    0xe0014d30     0x7c    ldr r2, [r2, r5, lsl #2]
    0xe0014d34     0x80    cmp r2, #0
    0xe0014d38     0x84    beq e0014d7c <decodeIRQControlInvocation+0xc8>
    0xe0014d3c     0x88    movw r3, #36896 
    0xe0014d40     0x8c    movt r3, #57346 
    0xe0014d44     0x90    mov r2, #9
    0xe0014d48     0x94    str r2, [r3, #24]
    0xe0014d4c     0x98    mov r0, #3
    0xe0014d50     0x9c    b e0014e00 <decodeIRQControlInvocation+0x14c>
    0xe0014d54     0xa0    movw r3, #36896 
    0xe0014d58     0xa4    movt r3, #57346 
    0xe0014d5c     0xa8    mov r2, #4
    0xe0014d60     0xac    str r2, [r3, #24]
    0xe0014d64     0xb0    mov r2, #0
    0xe0014d68     0xb4    str r2, [r3, #8]
    0xe0014d6c     0xb8    mov r2, #159 
    0xe0014d70     0xbc    str r2, [r3, #12]
    0xe0014d74     0xc0    mov r0, #3
    0xe0014d78     0xc4    b e0014e00 <decodeIRQControlInvocation+0x14c>
    0xe0014d7c     0xc8    str lr, [sp]          ; stack access
    0xe0014d80     0xcc    add r2, sp, #16
    0xe0014d84     0xd0    ldm r2, {r1, r2}      ; stack access
    0xe0014d88     0xd4    add r0, sp, #24
    0xe0014d8c     0xd8    bl e0012e64 <lookupTargetSlot>
    0xe0014d90     0xdc    ldr r0, [sp, #24]     ; stack access
    0xe0014d94     0xe0    cmp r0, #0
    0xe0014d98     0xe4    bne e0014e00 <decodeIRQControlInvocation+0x14c>
    0xe0014d9c     0xe8    ldr r6, [sp, #28]     ; stack access
    0xe0014da0     0xec    mov r0, r6
    0xe0014da4     0xf0    bl e0013508 <ensureEmptySlot>
    0xe0014da8     0xf4    cmp r0, #0
    0xe0014dac     0xf8    bne e0014e00 <decodeIRQControlInvocation+0x14c>
    0xe0014db0     0xfc    movw r3, #13900 
    0xe0014db4    0x100    movt r3, #57347 
    0xe0014db8    0x104    mov r1, #2
    0xe0014dbc    0x108    ldr r0, [r3]
    0xe0014dc0    0x10c    bl e0014ad8 <setThreadState>
    0xe0014dc4    0x110    mov r2, r4
    0xe0014dc8    0x114    mov r1, r6
    0xe0014dcc    0x118    mov r0, r5
    0xe0014dd0    0x11c    bl e0013684 <invokeIRQControl>
    0xe0014dd4    0x120    b e0014e00 <decodeIRQControlInvocation+0x14c>
    0xe0014dd8    0x124    mov ip, r0
    0xe0014ddc    0x128    ldr r3, [sp, #64]     ; stack access
    0xe0014de0    0x12c    str r3, [sp, #8]      ; stack access
    0xe0014de4    0x130    add r3, sp, #56 
    0xe0014de8    0x134    ldm r3, {r0, r1}      ; stack access
    0xe0014dec    0x138    stm sp, {r0, r1}      ; stack access
    0xe0014df0    0x13c    ldr r3, [sp, #52]     ; stack access
    0xe0014df4    0x140    mov r1, lr
    0xe0014df8    0x144    mov r0, ip
    0xe0014dfc    0x148    bl e0014af8 <Arch_decodeIRQControlInvocation>
    0xe0014e00    0x14c    add sp, sp, #32
    0xe0014e04    0x150    pop {r4, r5, r6, lr}  ; stack access
    0xe0014e08    0x154    add sp, sp, #8
    0xe0014e0c    0x158    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
87 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeIRQControlInvocation` has 132 nodes.

Section Arch_decodeIRQControlInvocation (275 of 293)
====================================================

Deriving specifications
-----------------------

Section `Arch_decodeIRQControlInvocation` consists of 85 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `Arch_decodeIRQControlInvocation`:

    0xe0014af8      0x0    sub sp, sp, #8
    0xe0014afc      0x4    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0014b00      0x8    sub sp, sp, #28
    0xe0014b04      0xc    str r3, [sp, #52]     ; stack access
    0xe0014b08     0x10    cmp r0, #45 
    0xe0014b0c     0x14    bne e0014c2c <Arch_decodeIRQControlInvocation+0x134>
    0xe0014b10     0x18    mov r0, r3
    0xe0014b14     0x1c    cmp r3, #0
    0xe0014b18     0x20    cmpne r1, #3
    0xe0014b1c     0x24    bhi e0014b38 <Arch_decodeIRQControlInvocation+0x40>
    0xe0014b20     0x28    movw r3, #36896 
    0xe0014b24     0x2c    movt r3, #57346 
    0xe0014b28     0x30    mov r2, #7
    0xe0014b2c     0x34    str r2, [r3, #24]
    0xe0014b30     0x38    mov r0, #3
    0xe0014b34     0x3c    b e0014c3c <Arch_decodeIRQControlInvocation+0x144>
    0xe0014b38     0x40    movw r3, #13900 
    0xe0014b3c     0x44    movt r3, #57347 
    0xe0014b40     0x48    ldr r1, [r3]
    0xe0014b44     0x4c    ldr r4, [r1, #8]
    0xe0014b48     0x50    ldr r5, [r1, #12]
    0xe0014b4c     0x54    ldr r3, [r1, #16]
    0xe0014b50     0x58    ldr lr, [r1, #20]
    0xe0014b54     0x5c    add ip, sp, #8
    0xe0014b58     0x60    ldm r0, {r0, r1}
    0xe0014b5c     0x64    stm ip, {r0, r1}      ; stack access
    0xe0014b60     0x68    cmp r4, #159 
    0xe0014b64     0x6c    bhi e0014b94 <Arch_decodeIRQControlInvocation+0x9c>
    0xe0014b68     0x70    movw r1, #36936 
    0xe0014b6c     0x74    movt r1, #57346 
    0xe0014b70     0x78    ldr r1, [r1, r4, lsl #2]
    0xe0014b74     0x7c    cmp r1, #0
    0xe0014b78     0x80    beq e0014bbc <Arch_decodeIRQControlInvocation+0xc4>
    0xe0014b7c     0x84    movw r3, #36896 
    0xe0014b80     0x88    movt r3, #57346 
    0xe0014b84     0x8c    mov r2, #9
    0xe0014b88     0x90    str r2, [r3, #24]
    0xe0014b8c     0x94    mov r0, #3
    0xe0014b90     0x98    b e0014c3c <Arch_decodeIRQControlInvocation+0x144>
    0xe0014b94     0x9c    movw r3, #36896 
    0xe0014b98     0xa0    movt r3, #57346 
    0xe0014b9c     0xa4    mov r2, #4
    0xe0014ba0     0xa8    str r2, [r3, #24]
    0xe0014ba4     0xac    mov r2, #0
    0xe0014ba8     0xb0    str r2, [r3, #8]
    0xe0014bac     0xb4    mov r2, #159 
    0xe0014bb0     0xb8    str r2, [r3, #12]
    0xe0014bb4     0xbc    mov r0, #3
    0xe0014bb8     0xc0    b e0014c3c <Arch_decodeIRQControlInvocation+0x144>
    0xe0014bbc     0xc4    mov r6, r2
    0xe0014bc0     0xc8    str lr, [sp]          ; stack access
    0xe0014bc4     0xcc    add r2, sp, #8
    0xe0014bc8     0xd0    ldm r2, {r1, r2}      ; stack access
    0xe0014bcc     0xd4    add r0, sp, #16
    0xe0014bd0     0xd8    bl e0012e64 <lookupTargetSlot>
    0xe0014bd4     0xdc    ldr r0, [sp, #16]     ; stack access
    0xe0014bd8     0xe0    cmp r0, #0
    0xe0014bdc     0xe4    bne e0014c3c <Arch_decodeIRQControlInvocation+0x144>
    0xe0014be0     0xe8    ldr r7, [sp, #20]     ; stack access
    0xe0014be4     0xec    mov r0, r7
    0xe0014be8     0xf0    bl e0013508 <ensureEmptySlot>
    0xe0014bec     0xf4    cmp r0, #0
    0xe0014bf0     0xf8    bne e0014c3c <Arch_decodeIRQControlInvocation+0x144>
    0xe0014bf4     0xfc    movw r3, #13900 
    0xe0014bf8    0x100    movt r3, #57347 
    0xe0014bfc    0x104    mov r1, #2
    0xe0014c00    0x108    ldr r0, [r3]
    0xe0014c04    0x10c    bl e0014ad8 <setThreadState>
    0xe0014c08    0x110    adds r1, r5, #0
    0xe0014c0c    0x114    movne r1, #1
    0xe0014c10    0x118    mov r0, r4
    0xe0014c14    0x11c    bl e001299c <setIRQTrigger>
    0xe0014c18    0x120    mov r2, r6
    0xe0014c1c    0x124    mov r1, r7
    0xe0014c20    0x128    mov r0, r4
    0xe0014c24    0x12c    bl e0013684 <invokeIRQControl>
    0xe0014c28    0x130    b e0014c3c <Arch_decodeIRQControlInvocation+0x144>
    0xe0014c2c    0x134    movw r3, #36896 
    0xe0014c30    0x138    movt r3, #57346 
    0xe0014c34    0x13c    mov r0, #3
    0xe0014c38    0x140    str r0, [r3, #24]
    0xe0014c3c    0x144    add sp, sp, #28
    0xe0014c40    0x148    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0014c44    0x14c    add sp, sp, #8
    0xe0014c48    0x150    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
85 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeIRQControlInvocation` has 129 nodes.

Section unmapPage (276 of 293)
==============================

Deriving specifications
-----------------------

Section `unmapPage` consists of 112 instructions.
Switch found.
Skipping ee072f3b mcr 15, 0, r2, cr7, cr11, {1}
Skipping f57ff05f dmb sy
 SUBEQ (imm)....+++
Skipping ee070f3b mcr 15, 0, r0, cr7, cr11, {1}
Skipping f57ff05f dmb sy


Stack analysis
---------------

8 stack accesses found. Annotated code for `unmapPage`:

    0xe00120fc      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0012100      0x4    sub sp, sp, #16
    0xe0012104      0x8    mov r4, r0
    0xe0012108      0xc    mov r7, r1
    0xe001210c     0x10    mov r6, r2
    0xe0012110     0x14    add r8, r3, #805306368 
    0xe0012114     0x18    add r0, sp, #8
    0xe0012118     0x1c    bl e0010a84 <findPDForASID>
    0xe001211c     0x20    ldr r5, [sp, #12]     ; stack access
    0xe0012120     0x24    ldr r3, [sp, #8]      ; stack access
    0xe0012124     0x28    cmp r3, #0
    0xe0012128     0x2c    bne e00121a8 <unmapPage+0xac>
    0xe001212c     0x30    cmp r4, #3
    0xe0012130     0x34    ldrls pc, [pc, r4, lsl #2]
    0xe0012134     0x38    b e00122b8 <unmapPage+0x1bc>
    0xe0012138     0x3c    .word 0xe0012148
    0xe001213c     0x40    .word 0xe00121b0
    0xe0012140     0x44    .word 0xe001221c
    0xe0012144     0x48    .word 0xe0012260
    0xe0012148     0x4c    mov r2, r6
    0xe001214c     0x50    mov r1, r5
    0xe0012150     0x54    mov r0, sp
    0xe0012154     0x58    bl e0010ea0 <lookupPTSlot>
    0xe0012158     0x5c    ldr r2, [sp, #4]      ; stack access
    0xe001215c     0x60    ldr r3, [sp]          ; stack access
    0xe0012160     0x64    cmp r3, #0
    0xe0012164     0x68    bne e00121a8 <unmapPage+0xac>
    0xe0012168     0x6c    ldr r3, [r2]
    0xe001216c     0x70    tst r3, #2
    0xe0012170     0x74    beq e00121a8 <unmapPage+0xac>
    0xe0012174     0x78    bic r3, r3, #4080 
    0xe0012178     0x7c    bic r3, r3, #15
    0xe001217c     0x80    cmp r8, r3
    0xe0012180     0x84    bne e00121a8 <unmapPage+0xac>
    0xe0012184     0x88    mov r3, #0
    0xe0012188     0x8c    str r3, [r2]
    0xe001218c     0x90    mcr 15, 0, r2, cr7, cr11, {1}
    0xe0012190     0x94    dmb sy
    0xe0012194     0x98    mov r3, r6
    0xe0012198     0x9c    mov r2, r7
    0xe001219c     0xa0    mov r1, r5
    0xe00121a0     0xa4    mov r0, r4
    0xe00121a4     0xa8    bl e0011308 <flushPage>
    0xe00121a8     0xac    add sp, sp, #16
    0xe00121ac     0xb0    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe00121b0     0xb4    mov r2, r6
    0xe00121b4     0xb8    mov r1, r5
    0xe00121b8     0xbc    mov r0, sp
    0xe00121bc     0xc0    bl e0010ea0 <lookupPTSlot>
    0xe00121c0     0xc4    ldr r0, [sp, #4]      ; stack access
    0xe00121c4     0xc8    ldr r3, [sp]          ; stack access
    0xe00121c8     0xcc    cmp r3, #0
    0xe00121cc     0xd0    bne e00121a8 <unmapPage+0xac>
    0xe00121d0     0xd4    ldr r3, [r0]
    0xe00121d4     0xd8    tst r3, #2
    0xe00121d8     0xdc    bne e00121a8 <unmapPage+0xac>
    0xe00121dc     0xe0    tst r3, #1
    0xe00121e0     0xe4    beq e00121a8 <unmapPage+0xac>
    0xe00121e4     0xe8    lsr r3, r3, #16
    0xe00121e8     0xec    lsl r3, r3, #16
    0xe00121ec     0xf0    cmp r8, r3
    0xe00121f0     0xf4    subeq r3, r0, #4
    0xe00121f4     0xf8    addeq r1, r0, #60 
    0xe00121f8     0xfc    moveq r2, #0
    0xe00121fc    0x100    bne e00121a8 <unmapPage+0xac>
    0xe0012200    0x104    str r2, [r3, #4]!
    0xe0012204    0x108    cmp r3, r1
    0xe0012208    0x10c    bne e0012200 <unmapPage+0x104>
    0xe001220c    0x110    add r2, r0, #805306368 
    0xe0012210    0x114    add r1, r0, #63 
    0xe0012214    0x118    bl e00120c8 <cleanCacheRange_PoU>
    0xe0012218    0x11c    b e0012194 <unmapPage+0x98>
    0xe001221c    0x120    lsr r2, r6, #20
    0xe0012220    0x124    add r0, r5, r2, lsl #2
    0xe0012224    0x128    ldr r3, [r5, r2, lsl #2]
    0xe0012228    0x12c    and r1, r3, #3
    0xe001222c    0x130    cmp r1, #2
    0xe0012230    0x134    bne e00121a8 <unmapPage+0xac>
    0xe0012234    0x138    tst r3, #262144 
    0xe0012238    0x13c    bne e00121a8 <unmapPage+0xac>
    0xe001223c    0x140    lsr r3, r3, #20
    0xe0012240    0x144    lsl r3, r3, #20
    0xe0012244    0x148    cmp r8, r3
    0xe0012248    0x14c    bne e00121a8 <unmapPage+0xac>
    0xe001224c    0x150    mov r3, #0
    0xe0012250    0x154    str r3, [r5, r2, lsl #2]
    0xe0012254    0x158    mcr 15, 0, r0, cr7, cr11, {1}
    0xe0012258    0x15c    dmb sy
    0xe001225c    0x160    b e0012194 <unmapPage+0x98>
    0xe0012260    0x164    lsr r3, r6, #20
    0xe0012264    0x168    add r0, r5, r3, lsl #2
    0xe0012268    0x16c    ldr r3, [r5, r3, lsl #2]
    0xe001226c    0x170    and r2, r3, #3
    0xe0012270    0x174    cmp r2, #2
    0xe0012274    0x178    bne e00121a8 <unmapPage+0xac>
    0xe0012278    0x17c    tst r3, #262144 
    0xe001227c    0x180    beq e00121a8 <unmapPage+0xac>
    0xe0012280    0x184    lsr r3, r3, #20
    0xe0012284    0x188    lsl r3, r3, #20
    0xe0012288    0x18c    cmp r8, r3
    0xe001228c    0x190    bne e00121a8 <unmapPage+0xac>
    0xe0012290    0x194    sub r3, r0, #4
    0xe0012294    0x198    add r1, r0, #60 
    0xe0012298    0x19c    mov r2, #0
    0xe001229c    0x1a0    str r2, [r3, #4]!
    0xe00122a0    0x1a4    cmp r3, r1
    0xe00122a4    0x1a8    bne e001229c <unmapPage+0x1a0>
    0xe00122a8    0x1ac    add r2, r0, #805306368 
    0xe00122ac    0x1b0    add r1, r0, #63 
    0xe00122b0    0x1b4    bl e00120c8 <cleanCacheRange_PoU>
    0xe00122b4    0x1b8    b e0012194 <unmapPage+0x98>
    0xe00122b8    0x1bc    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
108 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unmapPage` has 186 nodes.

Section init_freemem (277 of 293)
=================================

Deriving specifications
-----------------------

Section `init_freemem` consists of 280 instructions.
 ADDLS (imm)....+++
 CMPCC (reg)......+++
 ADDCS (imm)....+++
 ADDLS (reg)...........++++++
 LDMIALS;1,0....+++
 STMIALS;1,0....++
 LDMIB;2,1...++


Stack analysis
---------------

31 stack accesses found. Annotated code for `init_freemem`:

    0xe0003310      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0003314      0x4    sub sp, sp, #52 
    0xe0003318      0x8    str r0, [sp]          ; stack access
    0xe000331c      0xc    mov r8, r2
    0xe0003320     0x10    mov r7, r3
    0xe0003324     0x14    cmp r2, #1
    0xe0003328     0x18    bls e0003340 <init_freemem+0x30>
    0xe000332c     0x1c    sub r2, r2, #1
    0xe0003330     0x20    mov r3, #0
    0xe0003334     0x24    add r3, r3, #1
    0xe0003338     0x28    cmp r3, r2
    0xe000333c     0x2c    bne e0003334 <init_freemem+0x24>
    0xe0003340     0x30    ldr r3, [sp]          ; stack access
    0xe0003344     0x34    subs r2, r3, #1
    0xe0003348     0x38    beq e000335c <init_freemem+0x4c>
    0xe000334c     0x3c    mov r3, #0
    0xe0003350     0x40    add r3, r3, #1
    0xe0003354     0x44    cmp r3, r2
    0xe0003358     0x48    bne e0003350 <init_freemem+0x40>
    0xe000335c     0x4c    movw r3, #47104 
    0xe0003360     0x50    movt r3, #57345 
    0xe0003364     0x54    mov r2, #0
    0xe0003368     0x58    str r2, [r3, #92] 
    0xe000336c     0x5c    str r2, [r3, #96] 
    0xe0003370     0x60    str r2, [r3, #100] 
    0xe0003374     0x64    str r2, [r3, #104] 
    0xe0003378     0x68    str r2, [r3, #108] 
    0xe000337c     0x6c    str r2, [r3, #112] 
    0xe0003380     0x70    str r2, [r3, #116] 
    0xe0003384     0x74    str r2, [r3, #120] 
    0xe0003388     0x78    ldr r5, [sp]          ; stack access
    0xe000338c     0x7c    cmp r5, r2
    0xe0003390     0x80    beq e000373c <init_freemem+0x42c>
    0xe0003394     0x84    mov lr, r1
    0xe0003398     0x88    movw ip, #17280 
    0xe000339c     0x8c    movt ip, #57344 
    0xe00033a0     0x90    mov r6, r2
    0xe00033a4     0x94    mov r0, ip
    0xe00033a8     0x98    mov r4, r2
    0xe00033ac     0x9c    movt r4, #12272 
    0xe00033b0     0xa0    ldr r3, [lr, #4]
    0xe00033b4     0xa4    ldr r2, [r1, r6, lsl #3]
    0xe00033b8     0xa8    add r2, r2, #-805306368 
    0xe00033bc     0xac    str r2, [r0, r6, lsl #3]
    0xe00033c0     0xb0    mov r2, #0
    0xe00033c4     0xb4    movt r2, #65520 
    0xe00033c8     0xb8    cmp r3, r4
    0xe00033cc     0xbc    addls r3, r3, #-805306368 
    0xe00033d0     0xc0    movhi r3, r2
    0xe00033d4     0xc4    str r3, [ip, #4]
    0xe00033d8     0xc8    ldr r3, [r0, r6, lsl #3]
    0xe00033dc     0xcc    add r9, r3, #805306368 
    0xe00033e0     0xd0    mov r2, #0
    0xe00033e4     0xd4    movt r2, #65520 
    0xe00033e8     0xd8    cmp r9, r4
    0xe00033ec     0xdc    movhi r3, r2
    0xe00033f0     0xe0    str r3, [r0, r6, lsl #3]
    0xe00033f4     0xe4    add r6, r6, #1
    0xe00033f8     0xe8    add lr, lr, #8
    0xe00033fc     0xec    add ip, ip, #8
    0xe0003400     0xf0    cmp r5, r6
    0xe0003404     0xf4    bne e00033b0 <init_freemem+0xa0>
    0xe0003408     0xf8    mov r4, #0
    0xe000340c     0xfc    mov r5, r4
    0xe0003410    0x100    movw fp, #17280 
    0xe0003414    0x104    movt fp, #57344 
    0xe0003418    0x108    cmp r5, r6
    0xe000341c    0x10c    cmpcc r4, r8
    0xe0003420    0x110    bcs e0003548 <init_freemem+0x238>
    0xe0003424    0x114    lsl sl, r4, #3
    0xe0003428    0x118    add r9, r7, sl
    0xe000342c    0x11c    ldr r2, [r7, r4, lsl #3]
    0xe0003430    0x120    ldr r3, [r9, #4]
    0xe0003434    0x124    cmp r2, r3
    0xe0003438    0x128    addeq r4, r4, #1
    0xe000343c    0x12c    beq e0003418 <init_freemem+0x108>
    0xe0003440    0x130    ldr r1, [fp, r5, lsl #3]
    0xe0003444    0x134    add r0, fp, r5, lsl #3
    0xe0003448    0x138    ldr r0, [r0, #4]
    0xe000344c    0x13c    cmp r1, r0
    0xe0003450    0x140    addcs r5, r5, #1
    0xe0003454    0x144    bcs e0003418 <init_freemem+0x108>
    0xe0003458    0x148    cmp r3, r1
    0xe000345c    0x14c    bls e00034a8 <init_freemem+0x198>
    0xe0003460    0x150    cmp r2, r0
    0xe0003464    0x154    bcs e00034cc <init_freemem+0x1bc>
    0xe0003468    0x158    cmp r2, r1
    0xe000346c    0x15c    bhi e00034e0 <init_freemem+0x1d0>
    0xe0003470    0x160    cmp r3, r0
    0xe0003474    0x164    movcs r3, r0
    0xe0003478    0x168    str r3, [fp, r5, lsl #3]
    0xe000347c    0x16c    ldr r3, [r9, #4]
    0xe0003480    0x170    add r3, r3, #805306368 
    0xe0003484    0x174    ldr r2, [r7, sl]
    0xe0003488    0x178    add r2, r2, #805306368 
    0xe000348c    0x17c    str r2, [sp, #24]     ; stack access
    0xe0003490    0x180    str r3, [sp, #28]     ; stack access
    0xe0003494    0x184    add r3, sp, #24
    0xe0003498    0x188    ldm r3, {r0, r1}      ; stack access
    0xe000349c    0x18c    bl e0000b7c <reserve_region>
    0xe00034a0    0x190    add r4, r4, #1
    0xe00034a4    0x194    b e0003418 <init_freemem+0x108>
    0xe00034a8    0x198    add r2, r2, #805306368 
    0xe00034ac    0x19c    str r2, [sp, #16]     ; stack access
    0xe00034b0    0x1a0    add r3, r3, #805306368 
    0xe00034b4    0x1a4    str r3, [sp, #20]     ; stack access
    0xe00034b8    0x1a8    add r3, sp, #16
    0xe00034bc    0x1ac    ldm r3, {r0, r1}      ; stack access
    0xe00034c0    0x1b0    bl e0000b7c <reserve_region>
    0xe00034c4    0x1b4    add r4, r4, #1
    0xe00034c8    0x1b8    b e0003418 <init_freemem+0x108>
    0xe00034cc    0x1bc    add r3, fp, r5, lsl #3
    0xe00034d0    0x1c0    ldm r3, {r0, r1}
    0xe00034d4    0x1c4    bl e0000d9c <insert_region>
    0xe00034d8    0x1c8    add r5, r5, #1
    0xe00034dc    0x1cc    b e0003418 <init_freemem+0x108>
    0xe00034e0    0x1d0    add r3, fp, r5, lsl #3
    0xe00034e4    0x1d4    str r3, [sp, #4]      ; stack access
    0xe00034e8    0x1d8    ldm r3, {r0, r1}
    0xe00034ec    0x1dc    add r3, sp, #8
    0xe00034f0    0x1e0    stm r3, {r0, r1}      ; stack access
    0xe00034f4    0x1e4    str r2, [sp, #12]     ; stack access
    0xe00034f8    0x1e8    ldm r3, {r0, r1}      ; stack access
    0xe00034fc    0x1ec    bl e0000d9c <insert_region>
    0xe0003500    0x1f0    ldr r3, [r9, #4]
    0xe0003504    0x1f4    ldr r2, [sp, #4]      ; stack access
    0xe0003508    0x1f8    ldr r2, [r2, #4]
    0xe000350c    0x1fc    cmp r2, r3
    0xe0003510    0x200    addls r5, r5, #1
    0xe0003514    0x204    bls e0003418 <init_freemem+0x108>
    0xe0003518    0x208    str r3, [fp, r5, lsl #3]
    0xe000351c    0x20c    ldr r3, [r9, #4]
    0xe0003520    0x210    add r3, r3, #805306368 
    0xe0003524    0x214    ldr r2, [r7, sl]
    0xe0003528    0x218    add r2, r2, #805306368 
    0xe000352c    0x21c    str r2, [sp, #32]     ; stack access
    0xe0003530    0x220    str r3, [sp, #36]     ; stack access
    0xe0003534    0x224    add r3, sp, #32
    0xe0003538    0x228    ldm r3, {r0, r1}      ; stack access
    0xe000353c    0x22c    bl e0000b7c <reserve_region>
    0xe0003540    0x230    add r4, r4, #1
    0xe0003544    0x234    b e0003418 <init_freemem+0x108>
    0xe0003548    0x238    cmp r4, r8
    0xe000354c    0x23c    bcs e0003598 <init_freemem+0x288>
    0xe0003550    0x240    add r5, r7, r4, lsl #3
    0xe0003554    0x244    add r6, sp, #40 
    0xe0003558    0x248    b e000356c <init_freemem+0x25c>
    0xe000355c    0x24c    add r4, r4, #1
    0xe0003560    0x250    add r5, r5, #8
    0xe0003564    0x254    cmp r8, r4
    0xe0003568    0x258    bls e0003748 <init_freemem+0x438>
    0xe000356c    0x25c    ldr r2, [r7, r4, lsl #3]
    0xe0003570    0x260    ldr r3, [r5, #4]
    0xe0003574    0x264    cmp r2, r3
    0xe0003578    0x268    bcs e000355c <init_freemem+0x24c>
    0xe000357c    0x26c    add r2, r2, #805306368 
    0xe0003580    0x270    str r2, [sp, #40]     ; stack access
    0xe0003584    0x274    add r3, r3, #805306368 
    0xe0003588    0x278    str r3, [sp, #44]     ; stack access
    0xe000358c    0x27c    ldm r6, {r0, r1}      ; stack access
    0xe0003590    0x280    bl e0000b7c <reserve_region>
    0xe0003594    0x284    b e000355c <init_freemem+0x24c>
    0xe0003598    0x288    cmp r5, r6
    0xe000359c    0x28c    bcs e0003748 <init_freemem+0x438>
    0xe00035a0    0x290    movw r4, #17280 
    0xe00035a4    0x294    movt r4, #57344 
    0xe00035a8    0x298    add r4, r4, r5, lsl #3
    0xe00035ac    0x29c    movw r6, #17280 
    0xe00035b0    0x2a0    movt r6, #57344 
    0xe00035b4    0x2a4    ldr r7, [sp]          ; stack access
    0xe00035b8    0x2a8    b e00035cc <init_freemem+0x2bc>
    0xe00035bc    0x2ac    add r5, r5, #1
    0xe00035c0    0x2b0    add r4, r4, #8
    0xe00035c4    0x2b4    cmp r7, r5
    0xe00035c8    0x2b8    bls e0003748 <init_freemem+0x438>
    0xe00035cc    0x2bc    ldr r2, [r6, r5, lsl #3]
    0xe00035d0    0x2c0    ldr r3, [r4, #4]
    0xe00035d4    0x2c4    cmp r2, r3
    0xe00035d8    0x2c8    bcs e00035bc <init_freemem+0x2ac>
    0xe00035dc    0x2cc    add r3, r6, r5, lsl #3
    0xe00035e0    0x2d0    ldm r3, {r0, r1}
    0xe00035e4    0x2d4    bl e0000d9c <insert_region>
    0xe00035e8    0x2d8    b e00035bc <init_freemem+0x2ac>
    0xe00035ec    0x2dc    mov r8, r5
    0xe00035f0    0x2e0    sub r5, r8, #1
    0xe00035f4    0x2e4    ldr r2, [r3, #108] 
    0xe00035f8    0x2e8    sub r3, r3, #8
    0xe00035fc    0x2ec    ldr r1, [r3, #120] 
    0xe0003600    0x2f0    cmp r1, r2
    0xe0003604    0x2f4    beq e00035ec <init_freemem+0x2dc>
    0xe0003608    0x2f8    add r3, sp, #8
    0xe000360c    0x2fc    add r2, sp, #84 
    0xe0003610    0x300    ldmib r2, {r0, r1}    ; stack access
    0xe0003614    0x304    stm r3, {r0, r1}      ; stack access
    0xe0003618    0x308    ldr r3, [sp, #96]     ; stack access
    0xe000361c    0x30c    cmp r3, #0
    0xe0003620    0x310    movne r6, #1
    0xe0003624    0x314    lslne r6, r6, r3
    0xe0003628    0x318    moveq r6, #0
    0xe000362c    0x31c    add r3, sp, #8
    0xe0003630    0x320    ldm r3, {r0, r1}      ; stack access
    0xe0003634    0x324    bl e0000384 <arch_get_n_paging>
    0xe0003638    0x328    add r6, r6, #94208 
    0xe000363c    0x32c    add r6, r6, #512 
    0xe0003640    0x330    add r6, r6, r0, lsl #10
    0xe0003644    0x334    ldr r3, [sp, #96]     ; stack access
    0xe0003648    0x338    cmp r3, #16
    0xe000364c    0x33c    movcs r2, r3
    0xe0003650    0x340    movcc r2, #16
    0xe0003654    0x344    movw r3, #47104 
    0xe0003658    0x348    movt r3, #57345 
    0xe000365c    0x34c    add r1, r5, #11
    0xe0003660    0x350    add r3, r3, r1, lsl #3
    0xe0003664    0x354    ldr r4, [r3, #8]
    0xe0003668    0x358    sub r4, r4, r6
    0xe000366c    0x35c    lsr r4, r4, r2
    0xe0003670    0x360    lsl r4, r4, r2
    0xe0003674    0x364    ldr r3, [r3, #4]
    0xe0003678    0x368    cmp r4, r3
    0xe000367c    0x36c    bcs e00036dc <init_freemem+0x3cc>
    0xe0003680    0x370    movw r3, #47104 
    0xe0003684    0x374    movt r3, #57345 
    0xe0003688    0x378    add r3, r3, r5, lsl #3
    0xe000368c    0x37c    movw ip, #47104 
    0xe0003690    0x380    movt ip, #57345 
    0xe0003694    0x384    cmp r5, #3
    0xe0003698    0x388    addls r8, ip, r8, lsl #3
    0xe000369c    0x38c    addls r8, r8, #92 
    0xe00036a0    0x390    addls r1, r3, #92 
    0xe00036a4    0x394    ldmls r1, {r0, r1}
    0xe00036a8    0x398    stmls r8, {r0, r1}
    0xe00036ac    0x39c    sub r7, r5, #1
    0xe00036b0    0x3a0    ldr r4, [r3, #88] 
    0xe00036b4    0x3a4    sub r4, r4, r6
    0xe00036b8    0x3a8    lsr r4, r4, r2
    0xe00036bc    0x3ac    lsl r4, r4, r2
    0xe00036c0    0x3b0    sub r3, r3, #8
    0xe00036c4    0x3b4    mov r8, r5
    0xe00036c8    0x3b8    ldr r1, [r3, #92] 
    0xe00036cc    0x3bc    cmp r1, r4
    0xe00036d0    0x3c0    bls e00036e4 <init_freemem+0x3d4>
    0xe00036d4    0x3c4    mov r5, r7
    0xe00036d8    0x3c8    b e0003694 <init_freemem+0x384>
    0xe00036dc    0x3cc    mov r7, r5
    0xe00036e0    0x3d0    mov r5, r8
    0xe00036e4    0x3d4    ldr r3, [sp, #96]     ; stack access
    0xe00036e8    0x3d8    add r2, sp, #84 
    0xe00036ec    0x3dc    ldmib r2, {r1, r2}    ; stack access
    0xe00036f0    0x3e0    mov r0, r4
    0xe00036f4    0x3e4    bl e00031f0 <create_rootserver_objects>
    0xe00036f8    0x3e8    cmp r7, #3
    0xe00036fc    0x3ec    bhi e0003724 <init_freemem+0x414>
    0xe0003700    0x3f0    movw r3, #47104 
    0xe0003704    0x3f4    movt r3, #57345 
    0xe0003708    0x3f8    add r2, r3, r7, lsl #3
    0xe000370c    0x3fc    ldr r2, [r2, #96] 
    0xe0003710    0x400    add r5, r5, #11
    0xe0003714    0x404    add r3, r3, r5, lsl #3
    0xe0003718    0x408    str r2, [r3, #8]
    0xe000371c    0x40c    add r6, r6, r4
    0xe0003720    0x410    str r6, [r3, #4]
    0xe0003724    0x414    movw r3, #47104 
    0xe0003728    0x418    movt r3, #57345 
    0xe000372c    0x41c    add r7, r3, r7, lsl #3
    0xe0003730    0x420    str r4, [r7, #96] 
    0xe0003734    0x424    add sp, sp, #52 
    0xe0003738    0x428    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe000373c    0x42c    cmp r8, #0
    0xe0003740    0x430    ldrne r4, [sp]        ; stack access
    0xe0003744    0x434    bne e0003550 <init_freemem+0x240>
    0xe0003748    0x438    movw r3, #47104 
    0xe000374c    0x43c    movt r3, #57345 
    0xe0003750    0x440    ldr r2, [r3, #116] 
    0xe0003754    0x444    ldr r3, [r3, #120] 
    0xe0003758    0x448    cmp r2, r3
    0xe000375c    0x44c    movweq r3, #47104 
    0xe0003760    0x450    movteq r3, #57345 
    0xe0003764    0x454    moveq r8, #3
    0xe0003768    0x458    beq e00035f0 <init_freemem+0x2e0>
    0xe000376c    0x45c    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
280 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_freemem` has 462 nodes.

Section decodeSetSpace (278 of 293)
===================================

Deriving specifications
-----------------------

Section `decodeSetSpace` consists of 148 instructions.


Stack analysis
---------------

41 stack accesses found. Annotated code for `decodeSetSpace`:

    0xe00182d0      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00182d4      0x4    sub sp, sp, #108 
    0xe00182d8      0x8    add ip, sp, #56 
    0xe00182dc      0xc    stm ip, {r0, r1}      ; stack access
    0xe00182e0     0x10    ldr r4, [sp, #144]    ; stack access
    0xe00182e4     0x14    ldr r5, [sp, #148]    ; stack access
    0xe00182e8     0x18    clz r1, r5
    0xe00182ec     0x1c    lsr r1, r1, #5
    0xe00182f0     0x20    cmp r4, #0
    0xe00182f4     0x24    moveq r1, #1
    0xe00182f8     0x28    cmp r2, #2
    0xe00182fc     0x2c    orrls r1, r1, #1
    0xe0018300     0x30    cmp r1, #0
    0xe0018304     0x34    beq e0018324 <decodeSetSpace+0x54>
    0xe0018308     0x38    movw r3, #36896 
    0xe001830c     0x3c    movt r3, #57346 
    0xe0018310     0x40    mov r2, #7
    0xe0018314     0x44    str r2, [r3, #24]
    0xe0018318     0x48    mov r0, #3
    0xe001831c     0x4c    add sp, sp, #108 
    0xe0018320     0x50    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0018324     0x54    str r3, [sp, #52]     ; stack access
    0xe0018328     0x58    movw r3, #13900 
    0xe001832c     0x5c    movt r3, #57347 
    0xe0018330     0x60    ldr r3, [r3]
    0xe0018334     0x64    ldr fp, [r3, #8]
    0xe0018338     0x68    ldr r9, [r3, #12]
    0xe001833c     0x6c    ldr sl, [r3, #16]
    0xe0018340     0x70    add r3, sp, #88 
    0xe0018344     0x74    ldm r4, {r0, r1}
    0xe0018348     0x78    stm r3, {r0, r1}      ; stack access
    0xe001834c     0x7c    mov r7, r0
    0xe0018350     0x80    add r3, sp, #80 
    0xe0018354     0x84    ldm r5, {r0, r1}
    0xe0018358     0x88    stm r3, {r0, r1}      ; stack access
    0xe001835c     0x8c    ldr r8, [sp, #56]     ; stack access
    0xe0018360     0x90    bic r6, r8, #508 
    0xe0018364     0x94    bic r6, r6, #3
    0xe0018368     0x98    mov r0, r6
    0xe001836c     0x9c    bl e00144a4 <slotCapLongRunningDelete>
    0xe0018370     0xa0    cmp r0, #0
    0xe0018374     0xa4    bne e00184e4 <decodeSetSpace+0x214>
    0xe0018378     0xa8    add r0, r6, #16
    0xe001837c     0xac    bl e00144a4 <slotCapLongRunningDelete>
    0xe0018380     0xb0    cmp r0, #0
    0xe0018384     0xb4    bne e00184e4 <decodeSetSpace+0x214>
    0xe0018388     0xb8    cmp r9, #0
    0xe001838c     0xbc    beq e00183b4 <decodeSetSpace+0xe4>
    0xe0018390     0xc0    add r0, sp, #104 
    0xe0018394     0xc4    str r7, [r0, #-16]!   ; stack access
    0xe0018398     0xc8    ldr r3, [sp, #92]     ; stack access
    0xe001839c     0xcc    str r3, [sp]          ; stack access
    0xe00183a0     0xd0    mov r3, r7
    0xe00183a4     0xd4    mov r2, r9
    0xe00183a8     0xd8    mov r1, #0
    0xe00183ac     0xdc    bl e0014500 <updateCapData>
    0xe00183b0     0xe0    ldr r7, [sp, #88]     ; stack access
    0xe00183b4     0xe4    str r7, [sp, #88]     ; stack access
    0xe00183b8     0xe8    add r3, sp, #88 
    0xe00183bc     0xec    ldm r3, {r2, r3}      ; stack access
    0xe00183c0     0xf0    mov r1, r4
    0xe00183c4     0xf4    add r0, sp, #68 
    0xe00183c8     0xf8    bl e00142e4 <deriveCap>
    0xe00183cc     0xfc    ldr r0, [sp, #68]     ; stack access
    0xe00183d0    0x100    cmp r0, #0
    0xe00183d4    0x104    bne e001831c <decodeSetSpace+0x4c>
    0xe00183d8    0x108    add r3, sp, #88 
    0xe00183dc    0x10c    add r2, sp, #72 
    0xe00183e0    0x110    ldm r2, {r0, r1}      ; stack access
    0xe00183e4    0x114    stm r3, {r0, r1}      ; stack access
    0xe00183e8    0x118    mov r6, r0
    0xe00183ec    0x11c    and r3, r0, #14
    0xe00183f0    0x120    cmp r3, #14
    0xe00183f4    0x124    andne r3, r0, #15
    0xe00183f8    0x128    uxtbeq r3, r0
    0xe00183fc    0x12c    cmp r3, #10
    0xe0018400    0x130    bne e00184f8 <decodeSetSpace+0x228>
    0xe0018404    0x134    cmp sl, #0
    0xe0018408    0x138    beq e0018428 <decodeSetSpace+0x158>
    0xe001840c    0x13c    ldr r3, [sp, #84]     ; stack access
    0xe0018410    0x140    str r3, [sp]          ; stack access
    0xe0018414    0x144    ldr r3, [sp, #80]     ; stack access
    0xe0018418    0x148    mov r2, sl
    0xe001841c    0x14c    mov r1, #0
    0xe0018420    0x150    add r0, sp, #80 
    0xe0018424    0x154    bl e0014500 <updateCapData>
    0xe0018428    0x158    add r3, sp, #80 
    0xe001842c    0x15c    ldm r3, {r2, r3}      ; stack access
    0xe0018430    0x160    mov r1, r5
    0xe0018434    0x164    add r0, sp, #68 
    0xe0018438    0x168    bl e00142e4 <deriveCap>
    0xe001843c    0x16c    ldr r0, [sp, #68]     ; stack access
    0xe0018440    0x170    cmp r0, #0
    0xe0018444    0x174    bne e001831c <decodeSetSpace+0x4c>
    0xe0018448    0x178    add r3, sp, #80 
    0xe001844c    0x17c    add r2, sp, #72 
    0xe0018450    0x180    ldm r2, {r0, r1}      ; stack access
    0xe0018454    0x184    stm r3, {r0, r1}      ; stack access
    0xe0018458    0x188    bl e0010f00 <isValidVTableRoot>
    0xe001845c    0x18c    cmp r0, #0
    0xe0018460    0x190    beq e001850c <decodeSetSpace+0x23c>
    0xe0018464    0x194    movw r3, #13900 
    0xe0018468    0x198    movt r3, #57347 
    0xe001846c    0x19c    mov r1, #2
    0xe0018470    0x1a0    ldr r0, [r3]
    0xe0018474    0x1a4    bl e0014ad8 <setThreadState>
    0xe0018478    0x1a8    mov r3, #0
    0xe001847c    0x1ac    str r3, [sp, #96]     ; stack access
    0xe0018480    0x1b0    str r3, [sp, #100]    ; stack access
    0xe0018484    0x1b4    str r6, [sp, #88]     ; stack access
    0xe0018488    0x1b8    mov r2, #4
    0xe001848c    0x1bc    str r2, [sp, #44]     ; stack access
    0xe0018490    0x1c0    str r3, [sp, #40]     ; stack access
    0xe0018494    0x1c4    add r2, sp, #32
    0xe0018498    0x1c8    add r1, sp, #104 
    0xe001849c    0x1cc    ldmdb r1, {r0, r1}    ; stack access
    0xe00184a0    0x1d0    stm r2, {r0, r1}      ; stack access
    0xe00184a4    0x1d4    str r3, [sp, #28]     ; stack access
    0xe00184a8    0x1d8    str r5, [sp, #24]     ; stack access
    0xe00184ac    0x1dc    add r2, sp, #16
    0xe00184b0    0x1e0    add r1, sp, #80 
    0xe00184b4    0x1e4    ldm r1, {r0, r1}      ; stack access
    0xe00184b8    0x1e8    stm r2, {r0, r1}      ; stack access
    0xe00184bc    0x1ec    str r4, [sp, #12]     ; stack access
    0xe00184c0    0x1f0    add r2, sp, #88 
    0xe00184c4    0x1f4    ldm r2, {r0, r1}      ; stack access
    0xe00184c8    0x1f8    stmib sp, {r0, r1}    ; stack access
    0xe00184cc    0x1fc    str r3, [sp]          ; stack access
    0xe00184d0    0x200    mov r2, fp
    0xe00184d4    0x204    ldr r1, [sp, #52]     ; stack access
    0xe00184d8    0x208    bic r0, r8, #15
    0xe00184dc    0x20c    bl e0017924 <invokeTCB_ThreadControl>
    0xe00184e0    0x210    b e001831c <decodeSetSpace+0x4c>
    0xe00184e4    0x214    movw r3, #36896 
    0xe00184e8    0x218    movt r3, #57346 
    0xe00184ec    0x21c    mov r0, #3
    0xe00184f0    0x220    str r0, [r3, #24]
    0xe00184f4    0x224    b e001831c <decodeSetSpace+0x4c>
    0xe00184f8    0x228    movw r3, #36896 
    0xe00184fc    0x22c    movt r3, #57346 
    0xe0018500    0x230    mov r0, #3
    0xe0018504    0x234    str r0, [r3, #24]
    0xe0018508    0x238    b e001831c <decodeSetSpace+0x4c>
    0xe001850c    0x23c    movw r3, #36896 
    0xe0018510    0x240    movt r3, #57346 
    0xe0018514    0x244    mov r0, #3
    0xe0018518    0x248    str r0, [r3, #24]
    0xe001851c    0x24c    b e001831c <decodeSetSpace+0x4c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
148 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetSpace` has 235 nodes.

Section sendIPC (279 of 293)
============================

Deriving specifications
-----------------------

Section `sendIPC` consists of 116 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `sendIPC`:

    0xe0017070      0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0017074      0x4    sub sp, sp, #24
    0xe0017078      0x8    mov r7, r1
    0xe001707c      0xc    mov r8, r2
    0xe0017080     0x10    mov r6, r3
    0xe0017084     0x14    ldr r4, [sp, #64]     ; stack access
    0xe0017088     0x18    ldr r3, [r4]
    0xe001708c     0x1c    and r2, r3, #3
    0xe0017090     0x20    cmp r2, #1
    0xe0017094     0x24    bls e00170a8 <sendIPC+0x38>
    0xe0017098     0x28    cmp r2, #2
    0xe001709c     0x2c    beq e001716c <sendIPC+0xfc>
    0xe00170a0     0x30    add sp, sp, #24
    0xe00170a4     0x34    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe00170a8     0x38    cmp r0, #0
    0xe00170ac     0x3c    beq e00170a0 <sendIPC+0x30>
    0xe00170b0     0x40    bic r3, r4, #15
    0xe00170b4     0x44    orr r3, r3, #4
    0xe00170b8     0x48    ldr r2, [sp, #60]     ; stack access
    0xe00170bc     0x4c    str r3, [r2, #80] 
    0xe00170c0     0x50    ldr r3, [r2, #88] 
    0xe00170c4     0x54    and r3, r3, #15
    0xe00170c8     0x58    orr r3, r3, r8, lsl #4
    0xe00170cc     0x5c    lsl r6, r6, #3
    0xe00170d0     0x60    and r6, r6, #8
    0xe00170d4     0x64    bic r3, r3, #12
    0xe00170d8     0x68    orr r3, r3, r6
    0xe00170dc     0x6c    ldr r2, [sp, #56]     ; stack access
    0xe00170e0     0x70    lsl r2, r2, #2
    0xe00170e4     0x74    and r2, r2, #4
    0xe00170e8     0x78    orr r3, r3, r2
    0xe00170ec     0x7c    bic r3, r3, #2
    0xe00170f0     0x80    lsl r7, r1, #1
    0xe00170f4     0x84    and r7, r7, #2
    0xe00170f8     0x88    orr r7, r3, r7
    0xe00170fc     0x8c    ldr r3, [sp, #60]     ; stack access
    0xe0017100     0x90    str r7, [r3, #88] 
    0xe0017104     0x94    mov r0, r3
    0xe0017108     0x98    bl e0014a90 <scheduleTCB>
    0xe001710c     0x9c    ldr r3, [r4, #4]
    0xe0017110     0xa0    ldr r2, [r4]
    0xe0017114     0xa4    bic r2, r2, #15
    0xe0017118     0xa8    bics r3, r3, #15
    0xe001711c     0xac    ldrne r1, [sp, #60]   ; stack access
    0xe0017120     0xb0    strne r1, [r2, #144] 
    0xe0017124     0xb4    ldreq r3, [sp, #60]   ; stack access
    0xe0017128     0xb8    ldr r1, [sp, #60]     ; stack access
    0xe001712c     0xbc    str r2, [r1, #148] 
    0xe0017130     0xc0    mov r2, #0
    0xe0017134     0xc4    str r2, [r1, #144] 
    0xe0017138     0xc8    ldr r1, [r4]
    0xe001713c     0xcc    ldr r2, [r4, #4]
    0xe0017140     0xd0    and r2, r2, #15
    0xe0017144     0xd4    bic r3, r3, #15
    0xe0017148     0xd8    orr r3, r2, r3
    0xe001714c     0xdc    str r3, [r4, #4]
    0xe0017150     0xe0    ldr r3, [sp, #60]     ; stack access
    0xe0017154     0xe4    bic r3, r3, #15
    0xe0017158     0xe8    orr r3, r3, #1
    0xe001715c     0xec    and r2, r1, #12
    0xe0017160     0xf0    orr r3, r3, r2
    0xe0017164     0xf4    str r3, [r4]
    0xe0017168     0xf8    b e00170a0 <sendIPC+0x30>
    0xe001716c     0xfc    ldr r5, [r4, #4]
    0xe0017170    0x100    bic r5, r5, #15
    0xe0017174    0x104    str r5, [sp, #16]     ; stack access
    0xe0017178    0x108    bic r3, r3, #15
    0xe001717c    0x10c    str r3, [sp, #20]     ; stack access
    0xe0017180    0x110    add sl, sp, #8
    0xe0017184    0x114    add r9, sp, #16
    0xe0017188    0x118    ldm r9, {r2, r3}      ; stack access
    0xe001718c    0x11c    mov r1, r5
    0xe0017190    0x120    mov r0, sl
    0xe0017194    0x124    bl e0015538 <tcbEPDequeue>
    0xe0017198    0x128    ldm sl, {r0, r1}      ; stack access
    0xe001719c    0x12c    stm r9, {r0, r1}      ; stack access
    0xe00171a0    0x130    ldr r1, [sp, #16]     ; stack access
    0xe00171a4    0x134    ldr r3, [r4, #4]
    0xe00171a8    0x138    and r3, r3, #15
    0xe00171ac    0x13c    bic r2, r1, #15
    0xe00171b0    0x140    orr r3, r3, r2
    0xe00171b4    0x144    str r3, [r4, #4]
    0xe00171b8    0x148    ldr r3, [r4]
    0xe00171bc    0x14c    and r3, r3, #15
    0xe00171c0    0x150    ldr r2, [sp, #20]     ; stack access
    0xe00171c4    0x154    bic r2, r2, #15
    0xe00171c8    0x158    orr r3, r3, r2
    0xe00171cc    0x15c    cmp r1, #0
    0xe00171d0    0x160    biceq r3, r3, #3
    0xe00171d4    0x164    str r3, [r4]
    0xe00171d8    0x168    str r5, [sp]          ; stack access
    0xe00171dc    0x16c    mov r3, r6
    0xe00171e0    0x170    mov r2, r8
    0xe00171e4    0x174    mov r1, r4
    0xe00171e8    0x178    ldr r0, [sp, #60]     ; stack access
    0xe00171ec    0x17c    bl e0016ec4 <doIPCTransfer>
    0xe00171f0    0x180    ldr r4, [r5, #88] 
    0xe00171f4    0x184    mov r1, #1
    0xe00171f8    0x188    mov r0, r5
    0xe00171fc    0x18c    bl e0014ad8 <setThreadState>
    0xe0017200    0x190    mov r0, r5
    0xe0017204    0x194    bl e0014ed4 <possibleSwitchTo>
    0xe0017208    0x198    cmp r7, #0
    0xe001720c    0x19c    beq e00170a0 <sendIPC+0x30>
    0xe0017210    0x1a0    ldr r3, [sp, #56]     ; stack access
    0xe0017214    0x1a4    orrs r3, r6, r3
    0xe0017218    0x1a8    bne e001722c <sendIPC+0x1bc>
    0xe001721c    0x1ac    mov r1, #0
    0xe0017220    0x1b0    ldr r0, [sp, #60]     ; stack access
    0xe0017224    0x1b4    bl e0014ad8 <setThreadState>
    0xe0017228    0x1b8    b e00170a0 <sendIPC+0x30>
    0xe001722c    0x1bc    ubfx r2, r4, #3, #1
    0xe0017230    0x1c0    mov r1, r5
    0xe0017234    0x1c4    ldr r0, [sp, #60]     ; stack access
    0xe0017238    0x1c8    bl e0016af4 <setupCallerCap>
    0xe001723c    0x1cc    b e00170a0 <sendIPC+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
116 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendIPC` has 182 nodes.

Section handleInvocation (280 of 293)
=====================================

Deriving specifications
-----------------------

Section `handleInvocation` consists of 99 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `handleInvocation`:

    0xe001af90      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001af94      0x4    sub sp, sp, #52 
    0xe001af98      0x8    mov r8, r0
    0xe001af9c      0xc    mov sl, r1
    0xe001afa0     0x10    movw r3, #13900 
    0xe001afa4     0x14    movt r3, #57347 
    0xe001afa8     0x18    ldr r4, [r3]
    0xe001afac     0x1c    ldr r5, [r4, #4]
    0xe001afb0     0x20    and r3, r5, #127 
    0xe001afb4     0x24    cmp r3, #120 
    0xe001afb8     0x28    bichi r5, r5, #127 
    0xe001afbc     0x2c    orrhi r5, r5, #120 
    0xe001afc0     0x30    ldr r7, [r4]
    0xe001afc4     0x34    mov r2, r7
    0xe001afc8     0x38    mov r1, r4
    0xe001afcc     0x3c    add r0, sp, #32
    0xe001afd0     0x40    bl e0012c6c <lookupCapAndSlot>
    0xe001afd4     0x44    ldr fp, [sp, #32]     ; stack access
    0xe001afd8     0x48    cmp fp, #0
    0xe001afdc     0x4c    bne e001b094 <handleInvocation+0x104>
    0xe001afe0     0x50    mov r1, r4
    0xe001afe4     0x54    mov r0, #0
    0xe001afe8     0x58    bl e0010b04 <lookupIPCBuffer>
    0xe001afec     0x5c    mov r6, r0
    0xe001aff0     0x60    mov r2, r5
    0xe001aff4     0x64    mov r1, r0
    0xe001aff8     0x68    mov r0, r4
    0xe001affc     0x6c    bl e0016b74 <lookupExtraCaps>
    0xe001b000     0x70    subs r9, r0, #0
    0xe001b004     0x74    bne e001b0c4 <handleInvocation+0x134>
    0xe001b008     0x78    and lr, r5, #127 
    0xe001b00c     0x7c    cmp lr, #4
    0xe001b010     0x80    movls r3, #0
    0xe001b014     0x84    movhi r3, #1
    0xe001b018     0x88    cmp r6, #0
    0xe001b01c     0x8c    movne r3, #0
    0xe001b020     0x90    cmp r3, #0
    0xe001b024     0x94    str r6, [sp, #28]     ; stack access
    0xe001b028     0x98    str r8, [sp, #24]     ; stack access
    0xe001b02c     0x9c    str sl, [sp, #20]     ; stack access
    0xe001b030     0xa0    movw r3, #36924 
    0xe001b034     0xa4    movt r3, #57346 
    0xe001b038     0xa8    add ip, sp, #8
    0xe001b03c     0xac    ldm r3, {r0, r1, r2}
    0xe001b040     0xb0    stm ip, {r0, r1, r2}  ; stack access
    0xe001b044     0xb4    add r3, sp, #36 
    0xe001b048     0xb8    ldm r3, {r0, r1}      ; stack access
    0xe001b04c     0xbc    stm sp, {r0, r1}      ; stack access
    0xe001b050     0xc0    ldr r3, [sp, #44]     ; stack access
    0xe001b054     0xc4    mov r2, r7
    0xe001b058     0xc8    moveq r1, lr
    0xe001b05c     0xcc    movne r1, #4
    0xe001b060     0xd0    lsr r0, r5, #12
    0xe001b064     0xd4    bl e001abac <decodeInvocation>
    0xe001b068     0xd8    cmp r0, #4
    0xe001b06c     0xdc    beq e001b114 <handleInvocation+0x184>
    0xe001b070     0xe0    cmp r0, #3
    0xe001b074     0xe4    beq e001b0e0 <handleInvocation+0x150>
    0xe001b078     0xe8    ldr r3, [r4, #80] 
    0xe001b07c     0xec    and r3, r3, #15
    0xe001b080     0xf0    cmp r3, #2
    0xe001b084     0xf4    beq e001b0f4 <handleInvocation+0x164>
    0xe001b088     0xf8    mov r0, r9
    0xe001b08c     0xfc    add sp, sp, #52 
    0xe001b090    0x100    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe001b094    0x104    movw r3, #32768 
    0xe001b098    0x108    movt r3, #57346 
    0xe001b09c    0x10c    mov r2, #1
    0xe001b0a0    0x110    str r2, [r3]
    0xe001b0a4    0x114    str r7, [r3, #4]
    0xe001b0a8    0x118    cmp sl, #0
    0xe001b0ac    0x11c    moveq r9, #0
    0xe001b0b0    0x120    beq e001b088 <handleInvocation+0xf8>
    0xe001b0b4    0x124    mov r0, r4
    0xe001b0b8    0x128    bl e001734c <handleFault>
    0xe001b0bc    0x12c    mov r9, #0
    0xe001b0c0    0x130    b e001b088 <handleInvocation+0xf8>
    0xe001b0c4    0x134    cmp sl, #0
    0xe001b0c8    0x138    moveq r9, fp
    0xe001b0cc    0x13c    beq e001b088 <handleInvocation+0xf8>
    0xe001b0d0    0x140    mov r0, r4
    0xe001b0d4    0x144    bl e001734c <handleFault>
    0xe001b0d8    0x148    mov r9, fp
    0xe001b0dc    0x14c    b e001b088 <handleInvocation+0xf8>
    0xe001b0e0    0x150    cmp r8, #0
    0xe001b0e4    0x154    beq e001b088 <handleInvocation+0xf8>
    0xe001b0e8    0x158    mov r0, r4
    0xe001b0ec    0x15c    bl e00190a0 <replyFromKernel_error>
    0xe001b0f0    0x160    b e001b088 <handleInvocation+0xf8>
    0xe001b0f4    0x164    cmp r8, #0
    0xe001b0f8    0x168    movne r3, #0
    0xe001b0fc    0x16c    strne r3, [r4]
    0xe001b100    0x170    strne r3, [r4, #4]
    0xe001b104    0x174    mov r1, #1
    0xe001b108    0x178    mov r0, r4
    0xe001b10c    0x17c    bl e0014ad8 <setThreadState>
    0xe001b110    0x180    b e001b088 <handleInvocation+0xf8>
    0xe001b114    0x184    mov r9, r0
    0xe001b118    0x188    b e001b088 <handleInvocation+0xf8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
99 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInvocation` has 166 nodes.

Section decodeUntypedInvocation (281 of 293)
============================================

Deriving specifications
-----------------------

Section `decodeUntypedInvocation` consists of 245 instructions.
 CMPLS (imm)...++
 RSB (reg-shift)...............+++++++++++++++
 STMIB;2,1,0....+


Stack analysis
---------------

26 stack accesses found. Annotated code for `decodeUntypedInvocation`:

    0xe00193b8      0x0    sub sp, sp, #8
    0xe00193bc      0x4    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00193c0      0x8    sub sp, sp, #68 
    0xe00193c4      0xc    str r3, [sp, #108]    ; stack access
    0xe00193c8     0x10    cmp r0, #1
    0xe00193cc     0x14    bne e00195b4 <decodeUntypedInvocation+0x1fc>
    0xe00193d0     0x18    ldr r4, [sp, #116]    ; stack access
    0xe00193d4     0x1c    cmp r4, #0
    0xe00193d8     0x20    cmpne r1, #5
    0xe00193dc     0x24    bls e00195d4 <decodeUntypedInvocation+0x21c>
    0xe00193e0     0x28    movw r3, #13900 
    0xe00193e4     0x2c    movt r3, #57347 
    0xe00193e8     0x30    ldr r6, [r3]
    0xe00193ec     0x34    ldr r5, [r6, #8]
    0xe00193f0     0x38    cmp r5, #10
    0xe00193f4     0x3c    bhi e00195ec <decodeUntypedInvocation+0x234>
    0xe00193f8     0x40    str r2, [sp, #24]     ; stack access
    0xe00193fc     0x44    ldr r7, [r6, #12]
    0xe0019400     0x48    mov r1, r7
    0xe0019404     0x4c    mov r0, r5
    0xe0019408     0x50    bl e0013838 <getObjectSize>
    0xe001940c     0x54    mov r8, r0
    0xe0019410     0x58    cmp r0, #29
    0xe0019414     0x5c    cmpls r7, #31
    0xe0019418     0x60    bhi e001960c <decodeUntypedInvocation+0x254>
    0xe001941c     0x64    cmp r5, #4
    0xe0019420     0x68    cmpeq r7, #0
    0xe0019424     0x6c    beq e0019634 <decodeUntypedInvocation+0x27c>
    0xe0019428     0x70    cmp r7, #3
    0xe001942c     0x74    cmpls r5, #0
    0xe0019430     0x78    beq e0019650 <decodeUntypedInvocation+0x298>
    0xe0019434     0x7c    ldr r3, [sp, #112]    ; stack access
    0xe0019438     0x80    str r3, [sp, #28]     ; stack access
    0xe001943c     0x84    ldr r9, [r6, #20]
    0xe0019440     0x88    ldr r3, [sp, #132]    ; stack access
    0xe0019444     0x8c    ldr sl, [r3, #20]
    0xe0019448     0x90    ldr fp, [r3, #24]
    0xe001944c     0x94    cmp r9, #0
    0xe0019450     0x98    bne e001966c <decodeUntypedInvocation+0x2b4>
    0xe0019454     0x9c    ldr r3, [r4]
    0xe0019458     0xa0    ldr r2, [r4, #4]
    0xe001945c     0xa4    and r1, r3, #14
    0xe0019460     0xa8    cmp r1, #14
    0xe0019464     0xac    andne r1, r3, #15
    0xe0019468     0xb0    uxtbeq r1, r3
    0xe001946c     0xb4    cmp r1, #10
    0xe0019470     0xb8    bne e00196a8 <decodeUntypedInvocation+0x2f0>
    0xe0019474     0xbc    ubfx r1, r2, #18, #5
    0xe0019478     0xc0    mov r2, #1
    0xe001947c     0xc4    lsl r2, r2, r1
    0xe0019480     0xc8    sub r1, r2, #1
    0xe0019484     0xcc    cmp r1, sl
    0xe0019488     0xd0    bcc e00196e4 <decodeUntypedInvocation+0x32c>
    0xe001948c     0xd4    sub r1, fp, #1
    0xe0019490     0xd8    cmp r1, #255 
    0xe0019494     0xdc    bhi e0019708 <decodeUntypedInvocation+0x350>
    0xe0019498     0xe0    sub r2, r2, sl
    0xe001949c     0xe4    cmp r2, fp
    0xe00194a0     0xe8    bcc e0019730 <decodeUntypedInvocation+0x378>
    0xe00194a4     0xec    bic r9, r3, #31
    0xe00194a8     0xf0    str sl, [sp, #48]     ; stack access
    0xe00194ac     0xf4    str fp, [sp, #52]     ; stack access
    0xe00194b0     0xf8    add r6, fp, sl
    0xe00194b4     0xfc    cmp sl, r6
    0xe00194b8    0x100    bcs e00194e0 <decodeUntypedInvocation+0x128>
    0xe00194bc    0x104    add r4, r9, sl, lsl #4
    0xe00194c0    0x108    mov r0, r4
    0xe00194c4    0x10c    bl e0013508 <ensureEmptySlot>
    0xe00194c8    0x110    cmp r0, #0
    0xe00194cc    0x114    bne e00195c4 <decodeUntypedInvocation+0x20c>
    0xe00194d0    0x118    add sl, sl, #1
    0xe00194d4    0x11c    add r4, r4, #16
    0xe00194d8    0x120    cmp sl, r6
    0xe00194dc    0x124    bcc e00194c0 <decodeUntypedInvocation+0x108>
    0xe00194e0    0x128    ldr r0, [sp, #24]     ; stack access
    0xe00194e4    0x12c    bl e00142a0 <ensureNoChildren>
    0xe00194e8    0x130    cmp r0, #0
    0xe00194ec    0x134    ldrne r3, [sp, #28]   ; stack access
    0xe00194f0    0x138    lsrne r4, r3, #6
    0xe00194f4    0x13c    movne r6, #0
    0xe00194f8    0x140    moveq r6, #1
    0xe00194fc    0x144    moveq r4, #0
    0xe0019500    0x148    lsl r4, r4, #4
    0xe0019504    0x14c    ldr r3, [sp, #28]     ; stack access
    0xe0019508    0x150    and r2, r3, #31
    0xe001950c    0x154    mov r3, #1
    0xe0019510    0x158    rsb r3, r4, r3, lsl r2
    0xe0019514    0x15c    cmp fp, r3, lsr r8
    0xe0019518    0x160    bhi e0019754 <decodeUntypedInvocation+0x39c>
    0xe001951c    0x164    ldr r3, [sp, #28]     ; stack access
    0xe0019520    0x168    ubfx sl, r3, #5, #1
    0xe0019524    0x16c    cmp sl, #0
    0xe0019528    0x170    beq e001954c <decodeUntypedInvocation+0x194>
    0xe001952c    0x174    mov r0, r5
    0xe0019530    0x178    bl e001142c <Arch_isFrameType>
    0xe0019534    0x17c    clz r0, r0
    0xe0019538    0x180    lsr r0, r0, #5
    0xe001953c    0x184    cmp r5, #0
    0xe0019540    0x188    moveq r0, #0
    0xe0019544    0x18c    cmp r0, #0
    0xe0019548    0x190    bne e0019770 <decodeUntypedInvocation+0x3b8>
    0xe001954c    0x194    mov r3, #1
    0xe0019550    0x198    lsl r8, r3, r8
    0xe0019554    0x19c    ldr r3, [sp, #108]    ; stack access
    0xe0019558    0x1a0    bic r3, r3, #15
    0xe001955c    0x1a4    sub r3, r3, #1
    0xe0019560    0x1a8    add r3, r3, r8
    0xe0019564    0x1ac    add r4, r3, r4
    0xe0019568    0x1b0    rsb r8, r8, #0
    0xe001956c    0x1b4    and r4, r4, r8
    0xe0019570    0x1b8    movw r3, #13900 
    0xe0019574    0x1bc    movt r3, #57347 
    0xe0019578    0x1c0    mov r1, #2
    0xe001957c    0x1c4    ldr r0, [r3]
    0xe0019580    0x1c8    bl e0014ad8 <setThreadState>
    0xe0019584    0x1cc    add r3, sp, #64 
    0xe0019588    0x1d0    str r9, [r3, #-20]!   ; stack access
    0xe001958c    0x1d4    str sl, [sp, #16]     ; stack access
    0xe0019590    0x1d8    ldm r3, {r0, r1, r2}  ; stack access
    0xe0019594    0x1dc    stmib sp, {r0, r1, r2}  ; stack access
    0xe0019598    0x1e0    str r7, [sp]          ; stack access
    0xe001959c    0x1e4    mov r3, r5
    0xe00195a0    0x1e8    mov r2, r4
    0xe00195a4    0x1ec    mov r1, r6
    0xe00195a8    0x1f0    ldr r0, [sp, #24]     ; stack access
    0xe00195ac    0x1f4    bl e0019260 <invokeUntyped_Retype>
    0xe00195b0    0x1f8    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe00195b4    0x1fc    movw r3, #36896 
    0xe00195b8    0x200    movt r3, #57346 
    0xe00195bc    0x204    mov r0, #3
    0xe00195c0    0x208    str r0, [r3, #24]
    0xe00195c4    0x20c    add sp, sp, #68 
    0xe00195c8    0x210    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00195cc    0x214    add sp, sp, #8
    0xe00195d0    0x218    bx lr
    0xe00195d4    0x21c    movw r3, #36896 
    0xe00195d8    0x220    movt r3, #57346 
    0xe00195dc    0x224    mov r2, #7
    0xe00195e0    0x228    str r2, [r3, #24]
    0xe00195e4    0x22c    mov r0, #3
    0xe00195e8    0x230    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe00195ec    0x234    movw r3, #36896 
    0xe00195f0    0x238    movt r3, #57346 
    0xe00195f4    0x23c    mov r2, #1
    0xe00195f8    0x240    str r2, [r3, #24]
    0xe00195fc    0x244    mov r2, #0
    0xe0019600    0x248    str r2, [r3]
    0xe0019604    0x24c    mov r0, #3
    0xe0019608    0x250    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe001960c    0x254    movw r3, #36896 
    0xe0019610    0x258    movt r3, #57346 
    0xe0019614    0x25c    mov r2, #4
    0xe0019618    0x260    str r2, [r3, #24]
    0xe001961c    0x264    mov r2, #0
    0xe0019620    0x268    str r2, [r3, #8]
    0xe0019624    0x26c    mov r2, #29
    0xe0019628    0x270    str r2, [r3, #12]
    0xe001962c    0x274    mov r0, #3
    0xe0019630    0x278    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe0019634    0x27c    movw r3, #36896 
    0xe0019638    0x280    movt r3, #57346 
    0xe001963c    0x284    mov r2, #1
    0xe0019640    0x288    str r2, [r3, #24]
    0xe0019644    0x28c    str r2, [r3]
    0xe0019648    0x290    mov r0, #3
    0xe001964c    0x294    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe0019650    0x298    movw r3, #36896 
    0xe0019654    0x29c    movt r3, #57346 
    0xe0019658    0x2a0    mov r2, #1
    0xe001965c    0x2a4    str r2, [r3, #24]
    0xe0019660    0x2a8    str r2, [r3]
    0xe0019664    0x2ac    mov r0, #3
    0xe0019668    0x2b0    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe001966c    0x2b4    ldr r3, [r6, #16]
    0xe0019670    0x2b8    add r2, sp, #36 
    0xe0019674    0x2bc    ldm r4, {r0, r1}
    0xe0019678    0x2c0    stm r2, {r0, r1}      ; stack access
    0xe001967c    0x2c4    str r9, [sp]          ; stack access
    0xe0019680    0x2c8    ldm r2, {r1, r2}      ; stack access
    0xe0019684    0x2cc    add r0, sp, #56 
    0xe0019688    0x2d0    bl e0012e64 <lookupTargetSlot>
    0xe001968c    0x2d4    ldr r0, [sp, #56]     ; stack access
    0xe0019690    0x2d8    cmp r0, #0
    0xe0019694    0x2dc    bne e00195c4 <decodeUntypedInvocation+0x20c>
    0xe0019698    0x2e0    ldr r2, [sp, #60]     ; stack access
    0xe001969c    0x2e4    ldr r3, [r2]
    0xe00196a0    0x2e8    ldr r2, [r2, #4]
    0xe00196a4    0x2ec    b e001945c <decodeUntypedInvocation+0xa4>
    0xe00196a8    0x2f0    movw r3, #36896 
    0xe00196ac    0x2f4    movt r3, #57346 
    0xe00196b0    0x2f8    mov r2, #6
    0xe00196b4    0x2fc    str r2, [r3, #24]
    0xe00196b8    0x300    mov r1, #0
    0xe00196bc    0x304    str r1, [r3, #20]
    0xe00196c0    0x308    movw r2, #36884 
    0xe00196c4    0x30c    movt r2, #57346 
    0xe00196c8    0x310    lsl r3, r9, #2
    0xe00196cc    0x314    uxtb r3, r3
    0xe00196d0    0x318    orr r3, r3, #1
    0xe00196d4    0x31c    str r3, [r2]
    0xe00196d8    0x320    str r1, [r2, #4]
    0xe00196dc    0x324    mov r0, #3
    0xe00196e0    0x328    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe00196e4    0x32c    movw r3, #36896 
    0xe00196e8    0x330    movt r3, #57346 
    0xe00196ec    0x334    mov r2, #4
    0xe00196f0    0x338    str r2, [r3, #24]
    0xe00196f4    0x33c    mov r2, #0
    0xe00196f8    0x340    str r2, [r3, #8]
    0xe00196fc    0x344    str r1, [r3, #12]
    0xe0019700    0x348    mov r0, #3
    0xe0019704    0x34c    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe0019708    0x350    movw r3, #36896 
    0xe001970c    0x354    movt r3, #57346 
    0xe0019710    0x358    mov r2, #4
    0xe0019714    0x35c    str r2, [r3, #24]
    0xe0019718    0x360    mov r2, #1
    0xe001971c    0x364    str r2, [r3, #8]
    0xe0019720    0x368    mov r2, #256 
    0xe0019724    0x36c    str r2, [r3, #12]
    0xe0019728    0x370    mov r0, #3
    0xe001972c    0x374    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe0019730    0x378    movw r3, #36896 
    0xe0019734    0x37c    movt r3, #57346 
    0xe0019738    0x380    mov r1, #4
    0xe001973c    0x384    str r1, [r3, #24]
    0xe0019740    0x388    mov r1, #1
    0xe0019744    0x38c    str r1, [r3, #8]
    0xe0019748    0x390    str r2, [r3, #12]
    0xe001974c    0x394    mov r0, #3
    0xe0019750    0x398    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe0019754    0x39c    movw r2, #36896 
    0xe0019758    0x3a0    movt r2, #57346 
    0xe001975c    0x3a4    mov r1, #10
    0xe0019760    0x3a8    str r1, [r2, #24]
    0xe0019764    0x3ac    str r3, [r2, #16]
    0xe0019768    0x3b0    mov r0, #3
    0xe001976c    0x3b4    b e00195c4 <decodeUntypedInvocation+0x20c>
    0xe0019770    0x3b8    movw r3, #36896 
    0xe0019774    0x3bc    movt r3, #57346 
    0xe0019778    0x3c0    mov r2, #1
    0xe001977c    0x3c4    str r2, [r3, #24]
    0xe0019780    0x3c8    str r2, [r3]
    0xe0019784    0x3cc    mov r0, #3
    0xe0019788    0x3d0    b e00195c4 <decodeUntypedInvocation+0x20c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
245 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeUntypedInvocation` has 380 nodes.

Section decodeTCBConfigure (282 of 293)
=======================================

Deriving specifications
-----------------------

Section `decodeTCBConfigure` consists of 177 instructions.


Stack analysis
---------------

52 stack accesses found. Annotated code for `decodeTCBConfigure`:

    0xe0017b0c      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0017b10      0x4    sub sp, sp, #116 
    0xe0017b14      0x8    add ip, sp, #64 
    0xe0017b18      0xc    stm ip, {r0, r1}      ; stack access
    0xe0017b1c     0x10    ldr r5, [sp, #152]    ; stack access
    0xe0017b20     0x14    ldr r6, [sp, #156]    ; stack access
    0xe0017b24     0x18    ldr r4, [sp, #160]    ; stack access
    0xe0017b28     0x1c    clz r1, r6
    0xe0017b2c     0x20    lsr r1, r1, #5
    0xe0017b30     0x24    cmp r5, #0
    0xe0017b34     0x28    moveq r1, #1
    0xe0017b38     0x2c    cmp r4, #0
    0xe0017b3c     0x30    moveq r1, #1
    0xe0017b40     0x34    cmp r2, #3
    0xe0017b44     0x38    orrls r1, r1, #1
    0xe0017b48     0x3c    cmp r1, #0
    0xe0017b4c     0x40    beq e0017b6c <decodeTCBConfigure+0x60>
    0xe0017b50     0x44    movw r3, #36896 
    0xe0017b54     0x48    movt r3, #57346 
    0xe0017b58     0x4c    mov r2, #7
    0xe0017b5c     0x50    str r2, [r3, #24]
    0xe0017b60     0x54    mov r0, #3
    0xe0017b64     0x58    add sp, sp, #116 
    0xe0017b68     0x5c    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0017b6c     0x60    str r3, [sp, #60]     ; stack access
    0xe0017b70     0x64    movw r3, #13900 
    0xe0017b74     0x68    movt r3, #57347 
    0xe0017b78     0x6c    ldr r3, [r3]
    0xe0017b7c     0x70    ldr r2, [r3, #8]
    0xe0017b80     0x74    str r2, [sp, #56]     ; stack access
    0xe0017b84     0x78    ldr sl, [r3, #12]
    0xe0017b88     0x7c    ldr r9, [r3, #16]
    0xe0017b8c     0x80    ldr r8, [r3, #20]
    0xe0017b90     0x84    add r3, sp, #96 
    0xe0017b94     0x88    ldm r5, {r0, r1}
    0xe0017b98     0x8c    stm r3, {r0, r1}      ; stack access
    0xe0017b9c     0x90    str r0, [sp, #52]     ; stack access
    0xe0017ba0     0x94    add r3, sp, #88 
    0xe0017ba4     0x98    ldm r6, {r0, r1}
    0xe0017ba8     0x9c    stm r3, {r0, r1}      ; stack access
    0xe0017bac     0xa0    ldm r4, {r0, r1}
    0xe0017bb0     0xa4    add r3, sp, #112 
    0xe0017bb4     0xa8    stmdb r3, {r0, r1}    ; stack access
    0xe0017bb8     0xac    cmp r8, #0
    0xe0017bbc     0xb0    moveq r4, #0
    0xe0017bc0     0xb4    bne e0017d50 <decodeTCBConfigure+0x244>
    0xe0017bc4     0xb8    ldr fp, [sp, #64]     ; stack access
    0xe0017bc8     0xbc    bic r7, fp, #508 
    0xe0017bcc     0xc0    bic r7, r7, #3
    0xe0017bd0     0xc4    mov r0, r7
    0xe0017bd4     0xc8    bl e00144a4 <slotCapLongRunningDelete>
    0xe0017bd8     0xcc    cmp r0, #0
    0xe0017bdc     0xd0    bne e0017d94 <decodeTCBConfigure+0x288>
    0xe0017be0     0xd4    add r0, r7, #16
    0xe0017be4     0xd8    bl e00144a4 <slotCapLongRunningDelete>
    0xe0017be8     0xdc    cmp r0, #0
    0xe0017bec     0xe0    bne e0017d94 <decodeTCBConfigure+0x288>
    0xe0017bf0     0xe4    cmp sl, #0
    0xe0017bf4     0xe8    beq e0017c24 <decodeTCBConfigure+0x118>
    0xe0017bf8     0xec    add r0, sp, #112 
    0xe0017bfc     0xf0    ldr r2, [sp, #52]     ; stack access
    0xe0017c00     0xf4    str r2, [r0, #-16]!   ; stack access
    0xe0017c04     0xf8    ldr r3, [sp, #100]    ; stack access
    0xe0017c08     0xfc    str r3, [sp]          ; stack access
    0xe0017c0c    0x100    mov r3, r2
    0xe0017c10    0x104    mov r2, sl
    0xe0017c14    0x108    mov r1, #0
    0xe0017c18    0x10c    bl e0014500 <updateCapData>
    0xe0017c1c    0x110    ldr r3, [sp, #96]     ; stack access
    0xe0017c20    0x114    str r3, [sp, #52]     ; stack access
    0xe0017c24    0x118    ldr r3, [sp, #52]     ; stack access
    0xe0017c28    0x11c    str r3, [sp, #96]     ; stack access
    0xe0017c2c    0x120    add r3, sp, #96 
    0xe0017c30    0x124    ldm r3, {r2, r3}      ; stack access
    0xe0017c34    0x128    mov r1, r5
    0xe0017c38    0x12c    add r0, sp, #76 
    0xe0017c3c    0x130    bl e00142e4 <deriveCap>
    0xe0017c40    0x134    ldr r0, [sp, #76]     ; stack access
    0xe0017c44    0x138    cmp r0, #0
    0xe0017c48    0x13c    bne e0017b64 <decodeTCBConfigure+0x58>
    0xe0017c4c    0x140    add r3, sp, #96 
    0xe0017c50    0x144    add r2, sp, #80 
    0xe0017c54    0x148    ldm r2, {r0, r1}      ; stack access
    0xe0017c58    0x14c    stm r3, {r0, r1}      ; stack access
    0xe0017c5c    0x150    mov r7, r0
    0xe0017c60    0x154    and r3, r0, #14
    0xe0017c64    0x158    cmp r3, #14
    0xe0017c68    0x15c    andne r3, r0, #15
    0xe0017c6c    0x160    uxtbeq r3, r0
    0xe0017c70    0x164    cmp r3, #10
    0xe0017c74    0x168    bne e0017da8 <decodeTCBConfigure+0x29c>
    0xe0017c78    0x16c    cmp r9, #0
    0xe0017c7c    0x170    beq e0017c9c <decodeTCBConfigure+0x190>
    0xe0017c80    0x174    ldr r3, [sp, #92]     ; stack access
    0xe0017c84    0x178    str r3, [sp]          ; stack access
    0xe0017c88    0x17c    ldr r3, [sp, #88]     ; stack access
    0xe0017c8c    0x180    mov r2, r9
    0xe0017c90    0x184    mov r1, #0
    0xe0017c94    0x188    add r0, sp, #88 
    0xe0017c98    0x18c    bl e0014500 <updateCapData>
    0xe0017c9c    0x190    add r3, sp, #88 
    0xe0017ca0    0x194    ldm r3, {r2, r3}      ; stack access
    0xe0017ca4    0x198    mov r1, r6
    0xe0017ca8    0x19c    add r0, sp, #76 
    0xe0017cac    0x1a0    bl e00142e4 <deriveCap>
    0xe0017cb0    0x1a4    ldr r0, [sp, #76]     ; stack access
    0xe0017cb4    0x1a8    cmp r0, #0
    0xe0017cb8    0x1ac    bne e0017b64 <decodeTCBConfigure+0x58>
    0xe0017cbc    0x1b0    add r3, sp, #88 
    0xe0017cc0    0x1b4    add r2, sp, #80 
    0xe0017cc4    0x1b8    ldm r2, {r0, r1}      ; stack access
    0xe0017cc8    0x1bc    stm r3, {r0, r1}      ; stack access
    0xe0017ccc    0x1c0    bl e0010f00 <isValidVTableRoot>
    0xe0017cd0    0x1c4    cmp r0, #0
    0xe0017cd4    0x1c8    beq e0017dbc <decodeTCBConfigure+0x2b0>
    0xe0017cd8    0x1cc    movw r3, #13900 
    0xe0017cdc    0x1d0    movt r3, #57347 
    0xe0017ce0    0x1d4    mov r1, #2
    0xe0017ce4    0x1d8    ldr r0, [r3]
    0xe0017ce8    0x1dc    bl e0014ad8 <setThreadState>
    0xe0017cec    0x1e0    str r7, [sp, #96]     ; stack access
    0xe0017cf0    0x1e4    mov r3, #6
    0xe0017cf4    0x1e8    str r3, [sp, #44]     ; stack access
    0xe0017cf8    0x1ec    str r4, [sp, #40]     ; stack access
    0xe0017cfc    0x1f0    add r3, sp, #32
    0xe0017d00    0x1f4    add r2, sp, #112 
    0xe0017d04    0x1f8    ldmdb r2, {r0, r1}    ; stack access
    0xe0017d08    0x1fc    stm r3, {r0, r1}      ; stack access
    0xe0017d0c    0x200    str r8, [sp, #28]     ; stack access
    0xe0017d10    0x204    str r6, [sp, #24]     ; stack access
    0xe0017d14    0x208    add r3, sp, #16
    0xe0017d18    0x20c    add r2, sp, #88 
    0xe0017d1c    0x210    ldm r2, {r0, r1}      ; stack access
    0xe0017d20    0x214    stm r3, {r0, r1}      ; stack access
    0xe0017d24    0x218    str r5, [sp, #12]     ; stack access
    0xe0017d28    0x21c    add r3, sp, #96 
    0xe0017d2c    0x220    ldm r3, {r0, r1}      ; stack access
    0xe0017d30    0x224    stmib sp, {r0, r1}    ; stack access
    0xe0017d34    0x228    mov r3, #0
    0xe0017d38    0x22c    str r3, [sp]          ; stack access
    0xe0017d3c    0x230    ldr r2, [sp, #56]     ; stack access
    0xe0017d40    0x234    ldr r1, [sp, #60]     ; stack access
    0xe0017d44    0x238    bic r0, fp, #15
    0xe0017d48    0x23c    bl e0017924 <invokeTCB_ThreadControl>
    0xe0017d4c    0x240    b e0017b64 <decodeTCBConfigure+0x58>
    0xe0017d50    0x244    ldmdb r3, {r2, r3}    ; stack access
    0xe0017d54    0x248    mov r1, r4
    0xe0017d58    0x24c    add r0, sp, #76 
    0xe0017d5c    0x250    bl e00142e4 <deriveCap>
    0xe0017d60    0x254    ldr r0, [sp, #76]     ; stack access
    0xe0017d64    0x258    cmp r0, #0
    0xe0017d68    0x25c    bne e0017b64 <decodeTCBConfigure+0x58>
    0xe0017d6c    0x260    add r3, sp, #104 
    0xe0017d70    0x264    add r2, sp, #80 
    0xe0017d74    0x268    ldm r2, {r0, r1}      ; stack access
    0xe0017d78    0x26c    stm r3, {r0, r1}      ; stack access
    0xe0017d7c    0x270    ldm r3, {r1, r2}      ; stack access
    0xe0017d80    0x274    mov r0, r8
    0xe0017d84    0x278    bl e0010e08 <checkValidIPCBuffer>
    0xe0017d88    0x27c    cmp r0, #0
    0xe0017d8c    0x280    beq e0017bc4 <decodeTCBConfigure+0xb8>
    0xe0017d90    0x284    b e0017b64 <decodeTCBConfigure+0x58>
    0xe0017d94    0x288    movw r3, #36896 
    0xe0017d98    0x28c    movt r3, #57346 
    0xe0017d9c    0x290    mov r0, #3
    0xe0017da0    0x294    str r0, [r3, #24]
    0xe0017da4    0x298    b e0017b64 <decodeTCBConfigure+0x58>
    0xe0017da8    0x29c    movw r3, #36896 
    0xe0017dac    0x2a0    movt r3, #57346 
    0xe0017db0    0x2a4    mov r0, #3
    0xe0017db4    0x2a8    str r0, [r3, #24]
    0xe0017db8    0x2ac    b e0017b64 <decodeTCBConfigure+0x58>
    0xe0017dbc    0x2b0    movw r3, #36896 
    0xe0017dc0    0x2b4    movt r3, #57346 
    0xe0017dc4    0x2b8    mov r0, #3
    0xe0017dc8    0x2bc    str r0, [r3, #24]
    0xe0017dcc    0x2c0    b e0017b64 <decodeTCBConfigure+0x58>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
177 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeTCBConfigure` has 289 nodes.

Section receiveIPC (283 of 293)
===============================

Deriving specifications
-----------------------

Section `receiveIPC` consists of 117 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `receiveIPC`:

    0xe0017468      0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe001746c      0x4    sub sp, sp, #36 
    0xe0017470      0x8    mov r5, r0
    0xe0017474      0xc    add r0, sp, #16
    0xe0017478     0x10    stm r0, {r1, r2}      ; stack access
    0xe001747c     0x14    ldr r6, [sp, #20]     ; stack access
    0xe0017480     0x18    bic r4, r6, #15
    0xe0017484     0x1c    ldr r0, [r5, #92] 
    0xe0017488     0x20    cmp r0, #0
    0xe001748c     0x24    beq e00174a0 <receiveIPC+0x38>
    0xe0017490     0x28    ldr r2, [r0]
    0xe0017494     0x2c    and r2, r2, #3
    0xe0017498     0x30    cmp r2, #2
    0xe001749c     0x34    beq e00174c4 <receiveIPC+0x5c>
    0xe00174a0     0x38    ldr r1, [r4]
    0xe00174a4     0x3c    and r2, r1, #3
    0xe00174a8     0x40    cmp r2, #1
    0xe00174ac     0x44    beq e001755c <receiveIPC+0xf4>
    0xe00174b0     0x48    bcc e00174d0 <receiveIPC+0x68>
    0xe00174b4     0x4c    cmp r2, #2
    0xe00174b8     0x50    beq e00174d0 <receiveIPC+0x68>
    0xe00174bc     0x54    add sp, sp, #36 
    0xe00174c0     0x58    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe00174c4     0x5c    mov r1, r5
    0xe00174c8     0x60    bl e00137a8 <completeSignal>
    0xe00174cc     0x64    b e00174bc <receiveIPC+0x54>
    0xe00174d0     0x68    cmp r3, #0
    0xe00174d4     0x6c    moveq r3, #0
    0xe00174d8     0x70    streq r3, [r5]
    0xe00174dc     0x74    beq e00174bc <receiveIPC+0x54>
    0xe00174e0     0x78    orr r3, r4, #3
    0xe00174e4     0x7c    str r3, [r5, #80] 
    0xe00174e8     0x80    lsl r6, r6, #1
    0xe00174ec     0x84    and r6, r6, #8
    0xe00174f0     0x88    ldr r3, [r5, #88] 
    0xe00174f4     0x8c    bic r3, r3, #8
    0xe00174f8     0x90    orr r6, r6, r3
    0xe00174fc     0x94    str r6, [r5, #88] 
    0xe0017500     0x98    mov r0, r5
    0xe0017504     0x9c    bl e0014a90 <scheduleTCB>
    0xe0017508     0xa0    ldr r3, [r4, #4]
    0xe001750c     0xa4    ldr r2, [r4]
    0xe0017510     0xa8    bic r2, r2, #15
    0xe0017514     0xac    bics r3, r3, #15
    0xe0017518     0xb0    strne r5, [r2, #144] 
    0xe001751c     0xb4    moveq r3, r5
    0xe0017520     0xb8    str r2, [r5, #148] 
    0xe0017524     0xbc    mov r2, #0
    0xe0017528     0xc0    str r2, [r5, #144] 
    0xe001752c     0xc4    ldr r2, [r4]
    0xe0017530     0xc8    ldr r1, [r4, #4]
    0xe0017534     0xcc    and r1, r1, #15
    0xe0017538     0xd0    bic r3, r3, #15
    0xe001753c     0xd4    orr r3, r1, r3
    0xe0017540     0xd8    str r3, [r4, #4]
    0xe0017544     0xdc    and r3, r2, #12
    0xe0017548     0xe0    orr r3, r3, #2
    0xe001754c     0xe4    bic r5, r5, #15
    0xe0017550     0xe8    orr r5, r3, r5
    0xe0017554     0xec    str r5, [r4]
    0xe0017558     0xf0    b e00174bc <receiveIPC+0x54>
    0xe001755c     0xf4    ldr r7, [r4, #4]
    0xe0017560     0xf8    bic r7, r7, #15
    0xe0017564     0xfc    str r7, [sp, #24]     ; stack access
    0xe0017568    0x100    bic r1, r1, #15
    0xe001756c    0x104    str r1, [sp, #28]     ; stack access
    0xe0017570    0x108    add r9, sp, #8
    0xe0017574    0x10c    add r8, sp, #24
    0xe0017578    0x110    ldm r8, {r2, r3}      ; stack access
    0xe001757c    0x114    mov r1, r7
    0xe0017580    0x118    mov r0, r9
    0xe0017584    0x11c    bl e0015538 <tcbEPDequeue>
    0xe0017588    0x120    ldm r9, {r0, r1}      ; stack access
    0xe001758c    0x124    stm r8, {r0, r1}      ; stack access
    0xe0017590    0x128    ldr r1, [sp, #24]     ; stack access
    0xe0017594    0x12c    ldr r3, [r4, #4]
    0xe0017598    0x130    and r3, r3, #15
    0xe001759c    0x134    bic r2, r1, #15
    0xe00175a0    0x138    orr r3, r3, r2
    0xe00175a4    0x13c    str r3, [r4, #4]
    0xe00175a8    0x140    ldr r3, [r4]
    0xe00175ac    0x144    and r3, r3, #15
    0xe00175b0    0x148    ldr r2, [sp, #28]     ; stack access
    0xe00175b4    0x14c    bic r2, r2, #15
    0xe00175b8    0x150    orr r3, r3, r2
    0xe00175bc    0x154    cmp r1, #0
    0xe00175c0    0x158    biceq r3, r3, #3
    0xe00175c4    0x15c    str r3, [r4]
    0xe00175c8    0x160    ldr r9, [r7, #88] 
    0xe00175cc    0x164    lsr r8, r9, #3
    0xe00175d0    0x168    str r5, [sp]          ; stack access
    0xe00175d4    0x16c    and r3, r8, #1
    0xe00175d8    0x170    lsr r2, r9, #4
    0xe00175dc    0x174    mov r1, r4
    0xe00175e0    0x178    mov r0, r7
    0xe00175e4    0x17c    bl e0016ec4 <doIPCTransfer>
    0xe00175e8    0x180    ldr r3, [r7, #88] 
    0xe00175ec    0x184    tst r3, #2
    0xe00175f0    0x188    beq e0017624 <receiveIPC+0x1bc>
    0xe00175f4    0x18c    orr r8, r8, r9, lsr #2
    0xe00175f8    0x190    tst r8, #1
    0xe00175fc    0x194    beq e0017614 <receiveIPC+0x1ac>
    0xe0017600    0x198    ubfx r2, r6, #2, #1
    0xe0017604    0x19c    mov r1, r5
    0xe0017608    0x1a0    mov r0, r7
    0xe001760c    0x1a4    bl e0016af4 <setupCallerCap>
    0xe0017610    0x1a8    b e00174bc <receiveIPC+0x54>
    0xe0017614    0x1ac    mov r1, #0
    0xe0017618    0x1b0    mov r0, r7
    0xe001761c    0x1b4    bl e0014ad8 <setThreadState>
    0xe0017620    0x1b8    b e00174bc <receiveIPC+0x54>
    0xe0017624    0x1bc    mov r1, #1
    0xe0017628    0x1c0    mov r0, r7
    0xe001762c    0x1c4    bl e0014ad8 <setThreadState>
    0xe0017630    0x1c8    mov r0, r7
    0xe0017634    0x1cc    bl e0014ed4 <possibleSwitchTo>
    0xe0017638    0x1d0    b e00174bc <receiveIPC+0x54>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
117 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `receiveIPC` has 186 nodes.

Section cteDelete (284 of 293)
==============================

Deriving specifications
-----------------------

Section `cteDelete` consists of 145 instructions.
 BICS (reg-shift)...............+++++++++++++++
 CMPEQ (reg)......+++
 ADDEQ (reg)...........++++++
 ORREQ (reg)...........++++++


Stack analysis
---------------

12 stack accesses found. Annotated code for `cteDelete`:

    0xe0015b14      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0015b18      0x4    sub sp, sp, #44 
    0xe0015b1c      0x8    mov r4, r0
    0xe0015b20      0xc    mov r5, r1
    0xe0015b24     0x10    mov r6, #0
    0xe0015b28     0x14    mov r7, #4
    0xe0015b2c     0x18    b e0015bdc <cteDelete+0xc8>
    0xe0015b30     0x1c    bl e0010904 <halt>
    0xe0015b34     0x20    str r9, [sp, #32]     ; stack access
    0xe0015b38     0x24    str lr, [sp, #36]     ; stack access
    0xe0015b3c     0x28    b e0015b74 <cteDelete+0x60>
    0xe0015b40     0x2c    cmp r8, #32
    0xe0015b44     0x30    beq e0015bac <cteDelete+0x98>
    0xe0015b48     0x34    and r3, r2, #31
    0xe0015b4c     0x38    add r0, r3, #1
    0xe0015b50     0x3c    mvn r3, #0
    0xe0015b54     0x40    and r3, r1, r3, lsl r0
    0xe0015b58     0x44    cmp r4, r3
    0xe0015b5c     0x48    bne e0015ca8 <cteDelete+0x194>
    0xe0015b60     0x4c    mov r0, #0
    0xe0015b64     0x50    b e0015b88 <cteDelete+0x74>
    0xe0015b68     0x54    bl e0010904 <halt>
    0xe0015b6c     0x58    str r3, [sp, #32]     ; stack access
    0xe0015b70     0x5c    str r3, [sp, #36]     ; stack access
    0xe0015b74     0x60    add r3, sp, #40 
    0xe0015b78     0x64    ldmdb r3, {r1, r2}    ; stack access
    0xe0015b7c     0x68    mov r0, r4
    0xe0015b80     0x6c    bl e00136e8 <emptySlot>
    0xe0015b84     0x70    mov r0, #0
    0xe0015b88     0x74    add sp, sp, #44 
    0xe0015b8c     0x78    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0015b90     0x7c    mov r0, #0
    0xe0015b94     0x80    b e0015b88 <cteDelete+0x74>
    0xe0015b98     0x84    cmp r8, #32
    0xe0015b9c     0x88    bne e0015ca8 <cteDelete+0x194>
    0xe0015ba0     0x8c    bic r9, r1, #31
    0xe0015ba4     0x90    and sl, r1, #31
    0xe0015ba8     0x94    b e0015cc8 <cteDelete+0x1b4>
    0xe0015bac     0x98    bic r3, r1, #31
    0xe0015bb0     0x9c    cmp r4, r3
    0xe0015bb4     0xa0    beq e0015b90 <cteDelete+0x7c>
    0xe0015bb8     0xa4    bic r9, r1, #31
    0xe0015bbc     0xa8    b e0015bc4 <cteDelete+0xb0>
    0xe0015bc0     0xac    bic r9, r1, #31
    0xe0015bc4     0xb0    mov r1, r4
    0xe0015bc8     0xb4    mov r0, r9
    0xe0015bcc     0xb8    bl e0013400 <capSwapForDelete>
    0xe0015bd0     0xbc    bl e0012f4c <preemptionPoint>
    0xe0015bd4     0xc0    cmp r0, #0
    0xe0015bd8     0xc4    bne e0015b88 <cteDelete+0x74>
    0xe0015bdc     0xc8    ldr r3, [r4]
    0xe0015be0     0xcc    and r2, r3, #14
    0xe0015be4     0xd0    cmp r2, #14
    0xe0015be8     0xd4    andne r3, r3, #15
    0xe0015bec     0xd8    uxtbeq r3, r3
    0xe0015bf0     0xdc    cmp r3, #0
    0xe0015bf4     0xe0    beq e0015b6c <cteDelete+0x58>
    0xe0015bf8     0xe4    mov r0, r4
    0xe0015bfc     0xe8    bl e0014448 <isFinalCapability>
    0xe0015c00     0xec    str r6, [sp]          ; stack access
    0xe0015c04     0xf0    mov r3, r0
    0xe0015c08     0xf4    ldm r4, {r1, r2}
    0xe0015c0c     0xf8    add r0, sp, #8
    0xe0015c10     0xfc    bl e0015884 <finaliseCap>
    0xe0015c14    0x100    ldr r3, [sp, #8]      ; stack access
    0xe0015c18    0x104    ldr r9, [sp, #16]     ; stack access
    0xe0015c1c    0x108    ldr lr, [sp, #20]     ; stack access
    0xe0015c20    0x10c    and ip, r3, #14
    0xe0015c24    0x110    cmp ip, #14
    0xe0015c28    0x114    andne r2, r3, #15
    0xe0015c2c    0x118    uxtbeq r2, r3
    0xe0015c30    0x11c    cmp r2, #0
    0xe0015c34    0x120    beq e0015b34 <cteDelete+0x20>
    0xe0015c38    0x124    cmp r2, #46 
    0xe0015c3c    0x128    bne e0015b30 <cteDelete+0x1c>
    0xe0015c40    0x12c    lsr r2, r3, #8
    0xe0015c44    0x130    and r8, r2, #63 
    0xe0015c48    0x134    cmp r8, #32
    0xe0015c4c    0x138    andne r0, r2, #31
    0xe0015c50    0x13c    moveq r0, r7
    0xe0015c54    0x140    ldr r1, [sp, #12]     ; stack access
    0xe0015c58    0x144    add r0, r0, #1
    0xe0015c5c    0x148    mvn sl, #0
    0xe0015c60    0x14c    bics sl, r1, sl, lsl r0
    0xe0015c64    0x150    beq e0015b34 <cteDelete+0x20>
    0xe0015c68    0x154    mvn fp, #0
    0xe0015c6c    0x158    and r0, r1, fp, lsl r0
    0xe0015c70    0x15c    cmp r4, r0
    0xe0015c74    0x160    cmpeq sl, #1
    0xe0015c78    0x164    beq e0015b34 <cteDelete+0x20>
    0xe0015c7c    0x168    str r3, [r4]
    0xe0015c80    0x16c    str r1, [r4, #4]
    0xe0015c84    0x170    cmp r5, #0
    0xe0015c88    0x174    bne e0015b98 <cteDelete+0x84>
    0xe0015c8c    0x178    cmp ip, #14
    0xe0015c90    0x17c    andne r3, r3, #15
    0xe0015c94    0x180    uxtbeq r3, r3
    0xe0015c98    0x184    cmp r3, #46 
    0xe0015c9c    0x188    beq e0015b40 <cteDelete+0x2c>
    0xe0015ca0    0x18c    cmp r8, #32
    0xe0015ca4    0x190    beq e0015bc0 <cteDelete+0xac>
    0xe0015ca8    0x194    and r2, r2, #31
    0xe0015cac    0x198    add r2, r2, #1
    0xe0015cb0    0x19c    mvn r9, #0
    0xe0015cb4    0x1a0    and r9, r1, r9, lsl r2
    0xe0015cb8    0x1a4    cmp r5, #0
    0xe0015cbc    0x1a8    beq e0015bc4 <cteDelete+0xb0>
    0xe0015cc0    0x1ac    mvn sl, #0
    0xe0015cc4    0x1b0    bic sl, r1, sl, lsl r2
    0xe0015cc8    0x1b4    sub r0, sl, #-268435455 
    0xe0015ccc    0x1b8    mov r1, r6
    0xe0015cd0    0x1bc    add r0, r9, r0, lsl #4
    0xe0015cd4    0x1c0    bl e0015b14 <cteDelete>
    0xe0015cd8    0x1c4    cmp r0, #0
    0xe0015cdc    0x1c8    bne e0015b88 <cteDelete+0x74>
    0xe0015ce0    0x1cc    ldr r3, [r4]
    0xe0015ce4    0x1d0    and r2, r3, #14
    0xe0015ce8    0x1d4    cmp r2, #14
    0xe0015cec    0x1d8    andne r2, r3, #15
    0xe0015cf0    0x1dc    uxtbeq r2, r3
    0xe0015cf4    0x1e0    cmp r2, #0
    0xe0015cf8    0x1e4    beq e0015bd0 <cteDelete+0xbc>
    0xe0015cfc    0x1e8    cmp r2, #46 
    0xe0015d00    0x1ec    bne e0015b68 <cteDelete+0x54>
    0xe0015d04    0x1f0    ldr r2, [r4, #4]
    0xe0015d08    0x1f4    lsr r3, r3, #8
    0xe0015d0c    0x1f8    and r1, r3, #63 
    0xe0015d10    0x1fc    cmp r1, #32
    0xe0015d14    0x200    andne r3, r3, #31
    0xe0015d18    0x204    moveq r3, r7
    0xe0015d1c    0x208    add r3, r3, #1
    0xe0015d20    0x20c    mvn r0, #0
    0xe0015d24    0x210    and r0, r2, r0, lsl r3
    0xe0015d28    0x214    cmp r9, r0
    0xe0015d2c    0x218    bne e0015bd0 <cteDelete+0xbc>
    0xe0015d30    0x21c    mvn ip, #0
    0xe0015d34    0x220    mvn r3, ip, lsl r3
    0xe0015d38    0x224    and r2, r2, r3
    0xe0015d3c    0x228    cmp r2, sl
    0xe0015d40    0x22c    cmpeq r1, r8
    0xe0015d44    0x230    addeq r2, sl, ip
    0xe0015d48    0x234    andeq r3, r3, r2
    0xe0015d4c    0x238    orreq r0, r3, r0
    0xe0015d50    0x23c    streq r0, [r4, #4]
    0xe0015d54    0x240    b e0015bd0 <cteDelete+0xbc>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
145 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteDelete` has 245 nodes.

Section doFlush (285 of 293)
============================

Deriving specifications
-----------------------

Section `doFlush` consists of 51 instructions.
Switch found.
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

5 stack accesses found. Annotated code for `doFlush`:

    0xe0012554     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0012558     0x4    mov r4, r1
    0xe001255c     0x8    mov r5, r2
    0xe0012560     0xc    mov r6, r3
    0xe0012564    0x10    sub r0, r0, #30
    0xe0012568    0x14    cmp r0, #11
    0xe001256c    0x18    ldrls pc, [pc, r0, lsl #2]
    0xe0012570    0x1c    b e001261c <doFlush+0xc8>
    0xe0012574    0x20    .word 0xe00125a4
    0xe0012578    0x24    .word 0xe00125b8
    0xe001257c    0x28    .word 0xe00125cc
    0xe0012580    0x2c    .word 0xe00125e0
    0xe0012584    0x30    .word 0xe001261c
    0xe0012588    0x34    .word 0xe001261c
    0xe001258c    0x38    .word 0xe001261c
    0xe0012590    0x3c    .word 0xe001261c
    0xe0012594    0x40    .word 0xe00125a4
    0xe0012598    0x44    .word 0xe00125b8
    0xe001259c    0x48    .word 0xe00125cc
    0xe00125a0    0x4c    .word 0xe00125e0
    0xe00125a4    0x50    mov r2, r3
    0xe00125a8    0x54    mov r1, r5
    0xe00125ac    0x58    mov r0, r4
    0xe00125b0    0x5c    bl e0012030 <cleanCacheRange_RAM>
    0xe00125b4    0x60    pop {r4, r5, r6, pc}  ; stack access
    0xe00125b8    0x64    mov r2, r3
    0xe00125bc    0x68    mov r1, r5
    0xe00125c0    0x6c    mov r0, r4
    0xe00125c4    0x70    bl e0012414 <invalidateCacheRange_RAM>
    0xe00125c8    0x74    pop {r4, r5, r6, pc}  ; stack access
    0xe00125cc    0x78    mov r2, r3
    0xe00125d0    0x7c    mov r1, r5
    0xe00125d4    0x80    mov r0, r4
    0xe00125d8    0x84    bl e0011f64 <cleanInvalidateCacheRange_RAM>
    0xe00125dc    0x88    pop {r4, r5, r6, pc}  ; stack access
    0xe00125e0    0x8c    mov r2, r3
    0xe00125e4    0x90    mov r1, r5
    0xe00125e8    0x94    mov r0, r4
    0xe00125ec    0x98    bl e00120c8 <cleanCacheRange_PoU>
    0xe00125f0    0x9c    dsb sy
    0xe00125f4    0xa0    mov r2, r6
    0xe00125f8    0xa4    mov r1, r5
    0xe00125fc    0xa8    mov r0, r4
    0xe0012600    0xac    bl e00124f0 <invalidateCacheRange_I>
    0xe0012604    0xb0    mov r2, r6
    0xe0012608    0xb4    mov r1, r5
    0xe001260c    0xb8    mov r0, r4
    0xe0012610    0xbc    bl e0012524 <branchFlushRange>
    0xe0012614    0xc0    isb sy
    0xe0012618    0xc4    pop {r4, r5, r6, pc}  ; stack access
    0xe001261c    0xc8    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doFlush` has 90 nodes.

Section arm_vector_table (286 of 293)
=====================================

Deriving specifications
-----------------------

Section `arm_vector_table` consists of 15 instructions.
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre).+Skipping e59ff018 ldr pc, [pc, #24] ; e0010020 <ki_boot_end+0x20>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff018 ldr pc, [pc, #24] ; e0010024 <ki_boot_end+0x24>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff018 ldr pc, [pc, #24] ; e0010028 <ki_boot_end+0x28>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff018 ldr pc, [pc, #24] ; e001002c <ki_boot_end+0x2c>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff018 ldr pc, [pc, #24] ; e0010030 <ki_boot_end+0x30>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff004 ldr pc, [pc, #4] ; e0010020 <ki_boot_end+0x20>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff014 ldr pc, [pc, #20] ; e0010034 <ki_boot_end+0x34>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff014 ldr pc, [pc, #20] ; e0010038 <ki_boot_end+0x38>


Stack analysis
---------------

No stack accesses found. Code for `arm_vector_table`:

    0xe0010000     0x0    ldr pc, [pc, #24] 
    0xe0010004     0x4    ldr pc, [pc, #24] 
    0xe0010008     0x8    ldr pc, [pc, #24] 
    0xe001000c     0xc    ldr pc, [pc, #24] 
    0xe0010010    0x10    ldr pc, [pc, #24] 
    0xe0010014    0x14    ldr pc, [pc, #4] 
    0xe0010018    0x18    ldr pc, [pc, #20] 
    0xe001001c    0x1c    ldr pc, [pc, #20] 
    0xe0010020    0x20    .word 0xe0010110
    0xe0010024    0x24    .word 0xe001003c
    0xe0010028    0x28    .word 0xe001005c
    0xe001002c    0x2c    .word 0xe0010088
    0xe0010030    0x30    .word 0xe00100b8
    0xe0010034    0x34    .word 0xe00100ec
    0xe0010038    0x38    .word 0xe0010114

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_vector_table` has 16 nodes.

Section finaliseCap (287 of 293)
================================

Deriving specifications
-----------------------

Section `finaliseCap` consists of 164 instructions.
Switch found.
 EOR (reg-shift)...............+++++++++++++++
 EOR (reg)..........+++++


Stack analysis
---------------

Section `finaliseCap` expects pointer to stack in r0.
39 stack accesses found. Annotated code for `finaliseCap`:

    0xe0015884      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0015888      0x4    sub sp, sp, #8
    0xe001588c      0x8    mov r4, r0
    0xe0015890      0xc    add r0, sp, #8
    0xe0015894     0x10    stmdb r0, {r1, r2}    ; stack access
    0xe0015898     0x14    ldr r5, [sp]          ; stack access
    0xe001589c     0x18    and r2, r5, #14
    0xe00158a0     0x1c    cmp r2, #14
    0xe00158a4     0x20    andne r2, r5, #15
    0xe00158a8     0x24    uxtbeq r2, r5
    0xe00158ac     0x28    tst r2, #1
    0xe00158b0     0x2c    bne e00158f4 <finaliseCap+0x70>
    0xe00158b4     0x30    ldr r6, [sp, #4]      ; stack access
    0xe00158b8     0x34    cmp r2, #6
    0xe00158bc     0x38    beq e00159dc <finaliseCap+0x158>
    0xe00158c0     0x3c    bhi e0015910 <finaliseCap+0x8c>
    0xe00158c4     0x40    cmp r2, #0
    0xe00158c8     0x44    beq e0015a14 <finaliseCap+0x190>
    0xe00158cc     0x48    cmp r2, #4
    0xe00158d0     0x4c    bne e0015920 <finaliseCap+0x9c>
    0xe00158d4     0x50    cmp r3, #0
    0xe00158d8     0x54    bne e00159d0 <finaliseCap+0x14c>
    0xe00158dc     0x58    mov r3, #0
    0xe00158e0     0x5c    str r3, [r4]          ; stack access
    0xe00158e4     0x60    str r3, [r4, #4]      ; stack access
    0xe00158e8     0x64    str r3, [r4, #8]      ; stack access
    0xe00158ec     0x68    str r3, [r4, #12]     ; stack access
    0xe00158f0     0x6c    b e0015904 <finaliseCap+0x80>
    0xe00158f4     0x70    add r2, sp, #8
    0xe00158f8     0x74    ldmdb r2, {r1, r2}    ; stack access
    0xe00158fc     0x78    mov r0, r4
    0xe0015900     0x7c    bl e001274c <Arch_finaliseCap>
    0xe0015904     0x80    mov r0, r4
    0xe0015908     0x84    add sp, sp, #8
    0xe001590c     0x88    pop {r4, r5, r6, pc}  ; stack access
    0xe0015910     0x8c    cmp r2, #8
    0xe0015914     0x90    beq e0015a14 <finaliseCap+0x190>
    0xe0015918     0x94    cmp r2, #62 
    0xe001591c     0x98    beq e0015a14 <finaliseCap+0x190>
    0xe0015920     0x9c    ldr r1, [sp, #24]     ; stack access
    0xe0015924     0xa0    cmp r1, #0
    0xe0015928     0xa4    bne e0015a2c <finaliseCap+0x1a8>
    0xe001592c     0xa8    sub r2, r2, #10
    0xe0015930     0xac    cmp r2, #36 
    0xe0015934     0xb0    ldrls pc, [pc, r2, lsl #2]
    0xe0015938     0xb4    b e0015a80 <finaliseCap+0x1fc>
    0xe001593c     0xb8    .word 0xe0015a30
    0xe0015940     0xbc    .word 0xe0015a80
    0xe0015944     0xc0    .word 0xe0015a78
    0xe0015948     0xc4    .word 0xe0015a80
    0xe001594c     0xc8    .word 0xe0015a80
    0xe0015950     0xcc    .word 0xe0015a80
    0xe0015954     0xd0    .word 0xe0015a80
    0xe0015958     0xd4    .word 0xe0015a80
    0xe001595c     0xd8    .word 0xe0015a80
    0xe0015960     0xdc    .word 0xe0015a80
    0xe0015964     0xe0    .word 0xe0015a80
    0xe0015968     0xe4    .word 0xe0015a80
    0xe001596c     0xe8    .word 0xe0015a80
    0xe0015970     0xec    .word 0xe0015a80
    0xe0015974     0xf0    .word 0xe0015a80
    0xe0015978     0xf4    .word 0xe0015a80
    0xe001597c     0xf8    .word 0xe0015a80
    0xe0015980     0xfc    .word 0xe0015a80
    0xe0015984    0x100    .word 0xe0015a80
    0xe0015988    0x104    .word 0xe0015a80
    0xe001598c    0x108    .word 0xe0015aec
    0xe0015990    0x10c    .word 0xe0015a80
    0xe0015994    0x110    .word 0xe0015a80
    0xe0015998    0x114    .word 0xe0015a80
    0xe001599c    0x118    .word 0xe0015a80
    0xe00159a0    0x11c    .word 0xe0015a80
    0xe00159a4    0x120    .word 0xe0015a80
    0xe00159a8    0x124    .word 0xe0015a80
    0xe00159ac    0x128    .word 0xe0015a80
    0xe00159b0    0x12c    .word 0xe0015a80
    0xe00159b4    0x130    .word 0xe0015a80
    0xe00159b8    0x134    .word 0xe0015a80
    0xe00159bc    0x138    .word 0xe0015a80
    0xe00159c0    0x13c    .word 0xe0015a80
    0xe00159c4    0x140    .word 0xe0015a80
    0xe00159c8    0x144    .word 0xe0015a80
    0xe00159cc    0x148    .word 0xe0015ad4
    0xe00159d0    0x14c    bic r0, r6, #15
    0xe00159d4    0x150    bl e0014f30 <cancelAllIPC>
    0xe00159d8    0x154    b e00158dc <finaliseCap+0x58>
    0xe00159dc    0x158    cmp r3, #0
    0xe00159e0    0x15c    bne e00159fc <finaliseCap+0x178>
    0xe00159e4    0x160    mov r3, #0
    0xe00159e8    0x164    str r3, [r4]          ; stack access
    0xe00159ec    0x168    str r3, [r4, #4]      ; stack access
    0xe00159f0    0x16c    str r3, [r4, #8]      ; stack access
    0xe00159f4    0x170    str r3, [r4, #12]     ; stack access
    0xe00159f8    0x174    b e0015904 <finaliseCap+0x80>
    0xe00159fc    0x178    bic r5, r5, #15
    0xe0015a00    0x17c    mov r0, r5
    0xe0015a04    0x180    bl e00137e0 <unbindMaybeNotification>
    0xe0015a08    0x184    mov r0, r5
    0xe0015a0c    0x188    bl e0014f88 <cancelAllSignals>
    0xe0015a10    0x18c    b e00159e4 <finaliseCap+0x160>
    0xe0015a14    0x190    mov r3, #0
    0xe0015a18    0x194    str r3, [r4]          ; stack access
    0xe0015a1c    0x198    str r3, [r4, #4]      ; stack access
    0xe0015a20    0x19c    str r3, [r4, #8]      ; stack access
    0xe0015a24    0x1a0    str r3, [r4, #12]     ; stack access
    0xe0015a28    0x1a4    b e0015904 <finaliseCap+0x80>
    0xe0015a2c    0x1a8    bl e0010904 <halt>
    0xe0015a30    0x1ac    cmp r3, #0
    0xe0015a34    0x1b0    beq e0015a80 <finaliseCap+0x1fc>
    0xe0015a38    0x1b4    ubfx r6, r6, #18, #5
    0xe0015a3c    0x1b8    bic r5, r5, #31
    0xe0015a40    0x1bc    lsl r3, r6, #8
    0xe0015a44    0x1c0    orr r3, r3, #46 
    0xe0015a48    0x1c4    str r3, [r4]          ; stack access
    0xe0015a4c    0x1c8    add r2, r6, #1
    0xe0015a50    0x1cc    mov r3, #1
    0xe0015a54    0x1d0    eor r6, r5, r3, lsl r6
    0xe0015a58    0x1d4    mvn r3, #0
    0xe0015a5c    0x1d8    bic r6, r6, r3, lsl r2
    0xe0015a60    0x1dc    eor r5, r5, r6
    0xe0015a64    0x1e0    str r5, [r4, #4]      ; stack access
    0xe0015a68    0x1e4    mov r3, #0
    0xe0015a6c    0x1e8    str r3, [r4, #8]      ; stack access
    0xe0015a70    0x1ec    str r3, [r4, #12]     ; stack access
    0xe0015a74    0x1f0    b e0015904 <finaliseCap+0x80>
    0xe0015a78    0x1f4    cmp r3, #0
    0xe0015a7c    0x1f8    bne e0015a98 <finaliseCap+0x214>
    0xe0015a80    0x1fc    mov r3, #0
    0xe0015a84    0x200    str r3, [r4]          ; stack access
    0xe0015a88    0x204    str r3, [r4, #4]      ; stack access
    0xe0015a8c    0x208    str r3, [r4, #8]      ; stack access
    0xe0015a90    0x20c    str r3, [r4, #12]     ; stack access
    0xe0015a94    0x210    b e0015904 <finaliseCap+0x80>
    0xe0015a98    0x214    bic r6, r5, #15
    0xe0015a9c    0x218    mov r0, r6
    0xe0015aa0    0x21c    bl e00137fc <unbindNotification>
    0xe0015aa4    0x220    mov r0, r6
    0xe0015aa8    0x224    bl e001584c <suspend>
    0xe0015aac    0x228    movw r3, #8238 
    0xe0015ab0    0x22c    str r3, [r4]          ; stack access
    0xe0015ab4    0x230    bic r5, r5, #508 
    0xe0015ab8    0x234    bic r5, r5, #3
    0xe0015abc    0x238    eor r5, r5, #5
    0xe0015ac0    0x23c    str r5, [r4, #4]      ; stack access
    0xe0015ac4    0x240    mov r3, #0
    0xe0015ac8    0x244    str r3, [r4, #8]      ; stack access
    0xe0015acc    0x248    str r3, [r4, #12]     ; stack access
    0xe0015ad0    0x24c    b e0015904 <finaliseCap+0x80>
    0xe0015ad4    0x250    str r5, [r4]          ; stack access
    0xe0015ad8    0x254    str r6, [r4, #4]      ; stack access
    0xe0015adc    0x258    mov r3, #0
    0xe0015ae0    0x25c    str r3, [r4, #8]      ; stack access
    0xe0015ae4    0x260    str r3, [r4, #12]     ; stack access
    0xe0015ae8    0x264    b e0015904 <finaliseCap+0x80>
    0xe0015aec    0x268    cmp r3, #0
    0xe0015af0    0x26c    beq e0015a80 <finaliseCap+0x1fc>
    0xe0015af4    0x270    uxtb r0, r6
    0xe0015af8    0x274    bl e0016700 <deletingIRQHandler>
    0xe0015afc    0x278    mov r3, #0
    0xe0015b00    0x27c    str r3, [r4]          ; stack access
    0xe0015b04    0x280    str r3, [r4, #4]      ; stack access
    0xe0015b08    0x284    str r5, [r4, #8]      ; stack access
    0xe0015b0c    0x288    str r6, [r4, #12]     ; stack access
    0xe0015b10    0x28c    b e0015904 <finaliseCap+0x80>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
127 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `finaliseCap` has 316 nodes.

Section handleSyscall (288 of 293)
==================================

Deriving specifications
-----------------------

Section `handleSyscall` consists of 118 instructions.
Switch found.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleSyscall`:

    0xe001b11c      0x0    push {r4, lr}         ; stack access
    0xe001b120      0x4    add r0, r0, #8
    0xe001b124      0x8    cmp r0, #7
    0xe001b128      0xc    ldrls pc, [pc, r0, lsl #2]
    0xe001b12c     0x10    b e001b2f0 <handleSyscall+0x1d4>
    0xe001b130     0x14    .word 0xe001b2c4
    0xe001b134     0x18    .word 0xe001b2d0
    0xe001b138     0x1c    .word 0xe001b2ac
    0xe001b13c     0x20    .word 0xe001b294
    0xe001b140     0x24    .word 0xe001b1bc
    0xe001b144     0x28    .word 0xe001b150
    0xe001b148     0x2c    .word 0xe001b2b4
    0xe001b14c     0x30    .word 0xe001b228
    0xe001b150     0x34    mov r1, #1
    0xe001b154     0x38    mov r0, #0
    0xe001b158     0x3c    bl e001af90 <handleInvocation>
    0xe001b15c     0x40    cmp r0, #0
    0xe001b160     0x44    beq e001b29c <handleSyscall+0x180>
    0xe001b164     0x48    movw r3, #46524 
    0xe001b168     0x4c    movt r3, #57345 
    0xe001b16c     0x50    ldr r0, [r3]
    0xe001b170     0x54    ubfx r0, r0, #0, #10
    0xe001b174     0x58    cmp r0, #1020 
    0xe001b178     0x5c    bcc e001b1a0 <handleSyscall+0x84>
    0xe001b17c     0x60    movw r3, #8703 
    0xe001b180     0x64    movt r3, #65520 
    0xe001b184     0x68    ldr r0, [r3, #-243] 
    0xe001b188     0x6c    movw r3, #46524 
    0xe001b18c     0x70    movt r3, #57345 
    0xe001b190     0x74    str r0, [r3]
    0xe001b194     0x78    ubfx r0, r0, #0, #10
    0xe001b198     0x7c    cmp r0, #1020 
    0xe001b19c     0x80    bcs e001b29c <handleSyscall+0x180>
    0xe001b1a0     0x84    movw r3, #46524 
    0xe001b1a4     0x88    movt r3, #57345 
    0xe001b1a8     0x8c    ldr r3, [r3, #4]
    0xe001b1ac     0x90    cmp r3, r0
    0xe001b1b0     0x94    beq e001b29c <handleSyscall+0x180>
    0xe001b1b4     0x98    bl e0016898 <handleInterrupt>
    0xe001b1b8     0x9c    b e001b29c <handleSyscall+0x180>
    0xe001b1bc     0xa0    mov r1, #0
    0xe001b1c0     0xa4    mov r0, r1
    0xe001b1c4     0xa8    bl e001af90 <handleInvocation>
    0xe001b1c8     0xac    cmp r0, #0
    0xe001b1cc     0xb0    beq e001b29c <handleSyscall+0x180>
    0xe001b1d0     0xb4    movw r3, #46524 
    0xe001b1d4     0xb8    movt r3, #57345 
    0xe001b1d8     0xbc    ldr r0, [r3]
    0xe001b1dc     0xc0    ubfx r0, r0, #0, #10
    0xe001b1e0     0xc4    cmp r0, #1020 
    0xe001b1e4     0xc8    bcc e001b20c <handleSyscall+0xf0>
    0xe001b1e8     0xcc    movw r3, #8703 
    0xe001b1ec     0xd0    movt r3, #65520 
    0xe001b1f0     0xd4    ldr r0, [r3, #-243] 
    0xe001b1f4     0xd8    movw r3, #46524 
    0xe001b1f8     0xdc    movt r3, #57345 
    0xe001b1fc     0xe0    str r0, [r3]
    0xe001b200     0xe4    ubfx r0, r0, #0, #10
    0xe001b204     0xe8    cmp r0, #1020 
    0xe001b208     0xec    bcs e001b29c <handleSyscall+0x180>
    0xe001b20c     0xf0    movw r3, #46524 
    0xe001b210     0xf4    movt r3, #57345 
    0xe001b214     0xf8    ldr r3, [r3, #4]
    0xe001b218     0xfc    cmp r3, r0
    0xe001b21c    0x100    beq e001b29c <handleSyscall+0x180>
    0xe001b220    0x104    bl e0016898 <handleInterrupt>
    0xe001b224    0x108    b e001b29c <handleSyscall+0x180>
    0xe001b228    0x10c    mov r1, #1
    0xe001b22c    0x110    mov r0, r1
    0xe001b230    0x114    bl e001af90 <handleInvocation>
    0xe001b234    0x118    cmp r0, #0
    0xe001b238    0x11c    beq e001b29c <handleSyscall+0x180>
    0xe001b23c    0x120    movw r3, #46524 
    0xe001b240    0x124    movt r3, #57345 
    0xe001b244    0x128    ldr r0, [r3]
    0xe001b248    0x12c    ubfx r0, r0, #0, #10
    0xe001b24c    0x130    cmp r0, #1020 
    0xe001b250    0x134    bcc e001b278 <handleSyscall+0x15c>
    0xe001b254    0x138    movw r3, #8703 
    0xe001b258    0x13c    movt r3, #65520 
    0xe001b25c    0x140    ldr r0, [r3, #-243] 
    0xe001b260    0x144    movw r3, #46524 
    0xe001b264    0x148    movt r3, #57345 
    0xe001b268    0x14c    str r0, [r3]
    0xe001b26c    0x150    ubfx r0, r0, #0, #10
    0xe001b270    0x154    cmp r0, #1020 
    0xe001b274    0x158    bcs e001b29c <handleSyscall+0x180>
    0xe001b278    0x15c    movw r3, #46524 
    0xe001b27c    0x160    movt r3, #57345 
    0xe001b280    0x164    ldr r3, [r3, #4]
    0xe001b284    0x168    cmp r3, r0
    0xe001b288    0x16c    beq e001b29c <handleSyscall+0x180>
    0xe001b28c    0x170    bl e0016898 <handleInterrupt>
    0xe001b290    0x174    b e001b29c <handleSyscall+0x180>
    0xe001b294    0x178    mov r0, #1
    0xe001b298    0x17c    bl e001763c <handleRecv>
    0xe001b29c    0x180    bl e00152f8 <schedule>
    0xe001b2a0    0x184    bl e0014c6c <activateThread>
    0xe001b2a4    0x188    mov r0, #0
    0xe001b2a8    0x18c    pop {r4, pc}          ; stack access
    0xe001b2ac    0x190    bl e0016fec <handleReply>
    0xe001b2b0    0x194    b e001b29c <handleSyscall+0x180>
    0xe001b2b4    0x198    bl e0016fec <handleReply>
    0xe001b2b8    0x19c    mov r0, #1
    0xe001b2bc    0x1a0    bl e001763c <handleRecv>
    0xe001b2c0    0x1a4    b e001b29c <handleSyscall+0x180>
    0xe001b2c4    0x1a8    mov r0, #0
    0xe001b2c8    0x1ac    bl e001763c <handleRecv>
    0xe001b2cc    0x1b0    b e001b29c <handleSyscall+0x180>
    0xe001b2d0    0x1b4    movw r4, #13900 
    0xe001b2d4    0x1b8    movt r4, #57347 
    0xe001b2d8    0x1bc    ldr r0, [r4]
    0xe001b2dc    0x1c0    bl e00150f4 <tcbSchedDequeue>
    0xe001b2e0    0x1c4    ldr r0, [r4]
    0xe001b2e4    0x1c8    bl e0014fe4 <tcbSchedAppend>
    0xe001b2e8    0x1cc    bl e0014a4c <rescheduleRequired>
    0xe001b2ec    0x1d0    b e001b29c <handleSyscall+0x180>
    0xe001b2f0    0x1d4    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
110 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleSyscall` has 192 nodes.

Section decodeInvocation (289 of 293)
=====================================

Deriving specifications
-----------------------

Section `decodeInvocation` consists of 249 instructions.
Switch found.
 LDMIB;3,2...++


Stack analysis
---------------

53 stack accesses found. Annotated code for `decodeInvocation`:

    0xe001abac      0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe001abb0      0x4    sub sp, sp, #52 
    0xe001abb4      0x8    mov ip, r0
    0xe001abb8      0xc    mov lr, r1
    0xe001abbc     0x10    mov r7, r2
    0xe001abc0     0x14    mov r6, r3
    0xe001abc4     0x18    ldr r4, [sp, #72]     ; stack access
    0xe001abc8     0x1c    ldr r5, [sp, #76]     ; stack access
    0xe001abcc     0x20    and r3, r4, #14
    0xe001abd0     0x24    cmp r3, #14
    0xe001abd4     0x28    andne r3, r4, #15
    0xe001abd8     0x2c    uxtbeq r3, r4
    0xe001abdc     0x30    tst r3, #1
    0xe001abe0     0x34    bne e001acec <decodeInvocation+0x140>
    0xe001abe4     0x38    cmp r3, #62 
    0xe001abe8     0x3c    ldrls pc, [pc, r3, lsl #2]
    0xe001abec     0x40    b e001af8c <decodeInvocation+0x3e0>
    0xe001abf0     0x44    .word 0xe001ad40
    0xe001abf4     0x48    .word 0xe001af8c
    0xe001abf8     0x4c    .word 0xe001af08
    0xe001abfc     0x50    .word 0xe001af8c
    0xe001ac00     0x54    .word 0xe001ad80
    0xe001ac04     0x58    .word 0xe001af8c
    0xe001ac08     0x5c    .word 0xe001ade4
    0xe001ac0c     0x60    .word 0xe001af8c
    0xe001ac10     0x64    .word 0xe001ae34
    0xe001ac14     0x68    .word 0xe001af8c
    0xe001ac18     0x6c    .word 0xe001aedc
    0xe001ac1c     0x70    .word 0xe001af8c
    0xe001ac20     0x74    .word 0xe001ae84
    0xe001ac24     0x78    .word 0xe001af8c
    0xe001ac28     0x7c    .word 0xe001af44
    0xe001ac2c     0x80    .word 0xe001af8c
    0xe001ac30     0x84    .word 0xe001af8c
    0xe001ac34     0x88    .word 0xe001af8c
    0xe001ac38     0x8c    .word 0xe001af8c
    0xe001ac3c     0x90    .word 0xe001af8c
    0xe001ac40     0x94    .word 0xe001af8c
    0xe001ac44     0x98    .word 0xe001af8c
    0xe001ac48     0x9c    .word 0xe001af8c
    0xe001ac4c     0xa0    .word 0xe001af8c
    0xe001ac50     0xa4    .word 0xe001af8c
    0xe001ac54     0xa8    .word 0xe001af8c
    0xe001ac58     0xac    .word 0xe001af8c
    0xe001ac5c     0xb0    .word 0xe001af8c
    0xe001ac60     0xb4    .word 0xe001af8c
    0xe001ac64     0xb8    .word 0xe001af8c
    0xe001ac68     0xbc    .word 0xe001af70
    0xe001ac6c     0xc0    .word 0xe001af8c
    0xe001ac70     0xc4    .word 0xe001af8c
    0xe001ac74     0xc8    .word 0xe001af8c
    0xe001ac78     0xcc    .word 0xe001af8c
    0xe001ac7c     0xd0    .word 0xe001af8c
    0xe001ac80     0xd4    .word 0xe001af8c
    0xe001ac84     0xd8    .word 0xe001af8c
    0xe001ac88     0xdc    .word 0xe001af8c
    0xe001ac8c     0xe0    .word 0xe001af8c
    0xe001ac90     0xe4    .word 0xe001af8c
    0xe001ac94     0xe8    .word 0xe001af8c
    0xe001ac98     0xec    .word 0xe001af8c
    0xe001ac9c     0xf0    .word 0xe001af8c
    0xe001aca0     0xf4    .word 0xe001af8c
    0xe001aca4     0xf8    .word 0xe001af8c
    0xe001aca8     0xfc    .word 0xe001ad60
    0xe001acac    0x100    .word 0xe001af8c
    0xe001acb0    0x104    .word 0xe001af8c
    0xe001acb4    0x108    .word 0xe001af8c
    0xe001acb8    0x10c    .word 0xe001af8c
    0xe001acbc    0x110    .word 0xe001af8c
    0xe001acc0    0x114    .word 0xe001af8c
    0xe001acc4    0x118    .word 0xe001af8c
    0xe001acc8    0x11c    .word 0xe001af8c
    0xe001accc    0x120    .word 0xe001af8c
    0xe001acd0    0x124    .word 0xe001af8c
    0xe001acd4    0x128    .word 0xe001af8c
    0xe001acd8    0x12c    .word 0xe001af8c
    0xe001acdc    0x130    .word 0xe001af8c
    0xe001ace0    0x134    .word 0xe001af8c
    0xe001ace4    0x138    .word 0xe001af8c
    0xe001ace8    0x13c    .word 0xe001aebc
    0xe001acec    0x140    str r4, [sp, #28]     ; stack access
    0xe001acf0    0x144    str r5, [sp, #32]     ; stack access
    0xe001acf4    0x148    add r3, sp, #36 
    0xe001acf8    0x14c    add r2, sp, #80 
    0xe001acfc    0x150    ldm r2, {r0, r1, r2}  ; stack access
    0xe001ad00    0x154    stm r3, {r0, r1, r2}  ; stack access
    0xe001ad04    0x158    ldr r2, [sp, #100]    ; stack access
    0xe001ad08    0x15c    str r2, [sp, #20]     ; stack access
    0xe001ad0c    0x160    add r4, sp, #8
    0xe001ad10    0x164    ldm r3, {r0, r1, r2}  ; stack access
    0xe001ad14    0x168    stm r4, {r0, r1, r2}  ; stack access
    0xe001ad18    0x16c    add r3, sp, #28
    0xe001ad1c    0x170    ldm r3, {r0, r1}      ; stack access
    0xe001ad20    0x174    stm sp, {r0, r1}      ; stack access
    0xe001ad24    0x178    mov r3, r6
    0xe001ad28    0x17c    mov r2, r7
    0xe001ad2c    0x180    mov r1, lr
    0xe001ad30    0x184    mov r0, ip
    0xe001ad34    0x188    bl e001978c <decodeARMMMUInvocation>
    0xe001ad38    0x18c    add sp, sp, #52 
    0xe001ad3c    0x190    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe001ad40    0x194    movw r3, #36896 
    0xe001ad44    0x198    movt r3, #57346 
    0xe001ad48    0x19c    mov r2, #2
    0xe001ad4c    0x1a0    str r2, [r3, #24]
    0xe001ad50    0x1a4    mov r2, #0
    0xe001ad54    0x1a8    str r2, [r3, #4]
    0xe001ad58    0x1ac    mov r0, #3
    0xe001ad5c    0x1b0    b e001ad38 <decodeInvocation+0x18c>
    0xe001ad60    0x1b4    movw r3, #36896 
    0xe001ad64    0x1b8    movt r3, #57346 
    0xe001ad68    0x1bc    mov r2, #2
    0xe001ad6c    0x1c0    str r2, [r3, #24]
    0xe001ad70    0x1c4    mov r2, #0
    0xe001ad74    0x1c8    str r2, [r3, #4]
    0xe001ad78    0x1cc    mov r0, #3
    0xe001ad7c    0x1d0    b e001ad38 <decodeInvocation+0x18c>
    0xe001ad80    0x1d4    tst r5, #1
    0xe001ad84    0x1d8    beq e001adc4 <decodeInvocation+0x218>
    0xe001ad88    0x1dc    movw r3, #13900 
    0xe001ad8c    0x1e0    movt r3, #57347 
    0xe001ad90    0x1e4    mov r1, #2
    0xe001ad94    0x1e8    ldr r0, [r3]
    0xe001ad98    0x1ec    bl e0014ad8 <setThreadState>
    0xe001ad9c    0x1f0    ldr r3, [sp, #96]     ; stack access
    0xe001ada0    0x1f4    str r3, [sp, #4]      ; stack access
    0xe001ada4    0x1f8    ldr r3, [sp, #92]     ; stack access
    0xe001ada8    0x1fc    str r3, [sp]          ; stack access
    0xe001adac    0x200    ubfx r3, r5, #3, #1
    0xe001adb0    0x204    ubfx r2, r5, #2, #1
    0xe001adb4    0x208    lsr r1, r4, #4
    0xe001adb8    0x20c    bic r0, r5, #15
    0xe001adbc    0x210    bl e0017428 <performInvocation_Endpoint>
    0xe001adc0    0x214    b e001ad38 <decodeInvocation+0x18c>
    0xe001adc4    0x218    movw r3, #36896 
    0xe001adc8    0x21c    movt r3, #57346 
    0xe001adcc    0x220    mov r2, #2
    0xe001add0    0x224    str r2, [r3, #24]
    0xe001add4    0x228    mov r2, #0
    0xe001add8    0x22c    str r2, [r3, #4]
    0xe001addc    0x230    mov r0, #3
    0xe001ade0    0x234    b e001ad38 <decodeInvocation+0x18c>
    0xe001ade4    0x238    tst r5, #1
    0xe001ade8    0x23c    beq e001ae14 <decodeInvocation+0x268>
    0xe001adec    0x240    movw r3, #13900 
    0xe001adf0    0x244    movt r3, #57347 
    0xe001adf4    0x248    mov r1, #2
    0xe001adf8    0x24c    ldr r0, [r3]
    0xe001adfc    0x250    bl e0014ad8 <setThreadState>
    0xe001ae00    0x254    lsr r1, r5, #4
    0xe001ae04    0x258    bic r0, r4, #15
    0xe001ae08    0x25c    bl e0016764 <sendSignal>
    0xe001ae0c    0x260    mov r0, #0
    0xe001ae10    0x264    b e001ad38 <decodeInvocation+0x18c>
    0xe001ae14    0x268    movw r3, #36896 
    0xe001ae18    0x26c    movt r3, #57346 
    0xe001ae1c    0x270    mov r2, #2
    0xe001ae20    0x274    str r2, [r3, #24]
    0xe001ae24    0x278    mov r2, #0
    0xe001ae28    0x27c    str r2, [r3, #4]
    0xe001ae2c    0x280    mov r0, #3
    0xe001ae30    0x284    b e001ad38 <decodeInvocation+0x18c>
    0xe001ae34    0x288    tst r4, #16
    0xe001ae38    0x28c    bne e001ae64 <decodeInvocation+0x2b8>
    0xe001ae3c    0x290    movw r3, #13900 
    0xe001ae40    0x294    movt r3, #57347 
    0xe001ae44    0x298    mov r1, #2
    0xe001ae48    0x29c    ldr r0, [r3]
    0xe001ae4c    0x2a0    bl e0014ad8 <setThreadState>
    0xe001ae50    0x2a4    ubfx r2, r4, #5, #1
    0xe001ae54    0x2a8    mov r1, r6
    0xe001ae58    0x2ac    bic r0, r4, #63 
    0xe001ae5c    0x2b0    bl e0017048 <performInvocation_Reply>
    0xe001ae60    0x2b4    b e001ad38 <decodeInvocation+0x18c>
    0xe001ae64    0x2b8    movw r3, #36896 
    0xe001ae68    0x2bc    movt r3, #57346 
    0xe001ae6c    0x2c0    mov r2, #2
    0xe001ae70    0x2c4    str r2, [r3, #24]
    0xe001ae74    0x2c8    mov r2, #0
    0xe001ae78    0x2cc    str r2, [r3, #4]
    0xe001ae7c    0x2d0    mov r0, #3
    0xe001ae80    0x2d4    b e001ad38 <decodeInvocation+0x18c>
    0xe001ae84    0x2d8    ldr r3, [sp, #100]    ; stack access
    0xe001ae88    0x2dc    str r3, [sp, #20]     ; stack access
    0xe001ae8c    0x2e0    ldr r3, [sp, #96]     ; stack access
    0xe001ae90    0x2e4    str r3, [sp, #16]     ; stack access
    0xe001ae94    0x2e8    add r3, sp, #80 
    0xe001ae98    0x2ec    ldm r3, {r0, r1, r2}  ; stack access
    0xe001ae9c    0x2f0    stmib sp, {r0, r1, r2}  ; stack access
    0xe001aea0    0x2f4    str r6, [sp]          ; stack access
    0xe001aea4    0x2f8    add r3, sp, #68 
    0xe001aea8    0x2fc    ldmib r3, {r2, r3}    ; stack access
    0xe001aeac    0x300    mov r1, lr
    0xe001aeb0    0x304    mov r0, ip
    0xe001aeb4    0x308    bl e0018c7c <decodeTCBInvocation>
    0xe001aeb8    0x30c    b e001ad38 <decodeInvocation+0x18c>
    0xe001aebc    0x310    ldr r3, [sp, #100]    ; stack access
    0xe001aec0    0x314    str r3, [sp, #4]      ; stack access
    0xe001aec4    0x318    ldr r3, [sp, #88]     ; stack access
    0xe001aec8    0x31c    str r3, [sp]          ; stack access
    0xe001aecc    0x320    add r3, sp, #80 
    0xe001aed0    0x324    ldm r3, {r2, r3}      ; stack access
    0xe001aed4    0x328    bl e0017804 <decodeDomainInvocation>
    0xe001aed8    0x32c    b e001ad38 <decodeInvocation+0x18c>
    0xe001aedc    0x330    ldr r3, [sp, #100]    ; stack access
    0xe001aee0    0x334    str r3, [sp, #12]     ; stack access
    0xe001aee4    0x338    add r3, sp, #80 
    0xe001aee8    0x33c    ldm r3, {r0, r1, r2}  ; stack access
    0xe001aeec    0x340    stm sp, {r0, r1, r2}  ; stack access
    0xe001aef0    0x344    add r3, sp, #68 
    0xe001aef4    0x348    ldmib r3, {r2, r3}    ; stack access
    0xe001aef8    0x34c    mov r1, lr
    0xe001aefc    0x350    mov r0, ip
    0xe001af00    0x354    bl e0015dd8 <decodeCNodeInvocation>
    0xe001af04    0x358    b e001ad38 <decodeInvocation+0x18c>
    0xe001af08    0x35c    ldr r3, [sp, #100]    ; stack access
    0xe001af0c    0x360    str r3, [sp, #20]     ; stack access
    0xe001af10    0x364    ldr r3, [sp, #96]     ; stack access
    0xe001af14    0x368    str r3, [sp, #16]     ; stack access
    0xe001af18    0x36c    add r3, sp, #80 
    0xe001af1c    0x370    ldm r3, {r0, r1, r2}  ; stack access
    0xe001af20    0x374    stmib sp, {r0, r1, r2}  ; stack access
    0xe001af24    0x378    ldr r3, [sp, #76]     ; stack access
    0xe001af28    0x37c    str r3, [sp]          ; stack access
    0xe001af2c    0x380    ldr r3, [sp, #72]     ; stack access
    0xe001af30    0x384    mov r2, r6
    0xe001af34    0x388    mov r1, lr
    0xe001af38    0x38c    mov r0, ip
    0xe001af3c    0x390    bl e00193b8 <decodeUntypedInvocation>
    0xe001af40    0x394    b e001ad38 <decodeInvocation+0x18c>
    0xe001af44    0x398    ldr r3, [sp, #100]    ; stack access
    0xe001af48    0x39c    str r3, [sp, #8]      ; stack access
    0xe001af4c    0x3a0    add r3, sp, #84 
    0xe001af50    0x3a4    ldm r3, {r0, r1}      ; stack access
    0xe001af54    0x3a8    stm sp, {r0, r1}      ; stack access
    0xe001af58    0x3ac    ldr r3, [sp, #80]     ; stack access
    0xe001af5c    0x3b0    mov r2, r6
    0xe001af60    0x3b4    mov r1, lr
    0xe001af64    0x3b8    mov r0, ip
    0xe001af68    0x3bc    bl e0014cb4 <decodeIRQControlInvocation>
    0xe001af6c    0x3c0    b e001ad38 <decodeInvocation+0x18c>
    0xe001af70    0x3c4    ldr r3, [sp, #88]     ; stack access
    0xe001af74    0x3c8    str r3, [sp]          ; stack access
    0xe001af78    0x3cc    add r3, sp, #80 
    0xe001af7c    0x3d0    ldm r3, {r2, r3}      ; stack access
    0xe001af80    0x3d4    uxtb r1, r5
    0xe001af84    0x3d8    bl e00165b8 <decodeIRQHandlerInvocation>
    0xe001af88    0x3dc    b e001ad38 <decodeInvocation+0x18c>
    0xe001af8c    0x3e0    bl e0010904 <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
186 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeInvocation` has 468 nodes.

Section decodeTCBInvocation (290 of 293)
========================================

Deriving specifications
-----------------------

Section `decodeTCBInvocation` consists of 174 instructions.
Switch found.


Stack analysis
---------------

57 stack accesses found. Annotated code for `decodeTCBInvocation`:

    0xe0018c7c      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0018c80      0x4    sub sp, sp, #24
    0xe0018c84      0x8    mov ip, r1
    0xe0018c88      0xc    add r1, sp, #24
    0xe0018c8c     0x10    stmdb r1, {r2, r3}    ; stack access
    0xe0018c90     0x14    ldr r4, [sp, #16]     ; stack access
    0xe0018c94     0x18    sub r0, r0, #2
    0xe0018c98     0x1c    cmp r0, #13
    0xe0018c9c     0x20    ldrls pc, [pc, r0, lsl #2]
    0xe0018ca0     0x24    b e0018f20 <decodeTCBInvocation+0x2a4>
    0xe0018ca4     0x28    .word 0xe0018cdc
    0xe0018ca8     0x2c    .word 0xe0018d00
    0xe0018cac     0x30    .word 0xe0018d18
    0xe0018cb0     0x34    .word 0xe0018d8c
    0xe0018cb4     0x38    .word 0xe0018db8
    0xe0018cb8     0x3c    .word 0xe0018de4
    0xe0018cbc     0x40    .word 0xe0018e10
    0xe0018cc0     0x44    .word 0xe0018e3c
    0xe0018cc4     0x48    .word 0xe0018e68
    0xe0018cc8     0x4c    .word 0xe0018d44
    0xe0018ccc     0x50    .word 0xe0018d68
    0xe0018cd0     0x54    .word 0xe0018e94
    0xe0018cd4     0x58    .word 0xe0018eb4
    0xe0018cd8     0x5c    .word 0xe0018ec4
    0xe0018cdc     0x60    ldr r3, [sp, #60]     ; stack access
    0xe0018ce0     0x64    str r3, [sp]          ; stack access
    0xe0018ce4     0x68    ldr r3, [sp, #56]     ; stack access
    0xe0018ce8     0x6c    mov r2, ip
    0xe0018cec     0x70    add r1, sp, #24
    0xe0018cf0     0x74    ldmdb r1, {r0, r1}    ; stack access
    0xe0018cf4     0x78    bl e0018820 <decodeReadRegisters>
    0xe0018cf8     0x7c    add sp, sp, #24
    0xe0018cfc     0x80    pop {r4, r5, r6, pc}  ; stack access
    0xe0018d00     0x84    ldr r3, [sp, #60]     ; stack access
    0xe0018d04     0x88    mov r2, ip
    0xe0018d08     0x8c    add r1, sp, #24
    0xe0018d0c     0x90    ldmdb r1, {r0, r1}    ; stack access
    0xe0018d10     0x94    bl e0018a2c <decodeWriteRegisters>
    0xe0018d14     0x98    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018d18     0x9c    ldr r3, [sp, #60]     ; stack access
    0xe0018d1c     0xa0    str r3, [sp, #8]      ; stack access
    0xe0018d20     0xa4    add r3, sp, #48 
    0xe0018d24     0xa8    ldm r3, {r0, r1}      ; stack access
    0xe0018d28     0xac    stm sp, {r0, r1}      ; stack access
    0xe0018d2c     0xb0    ldr r3, [sp, #44]     ; stack access
    0xe0018d30     0xb4    mov r2, ip
    0xe0018d34     0xb8    add r1, sp, #24
    0xe0018d38     0xbc    ldmdb r1, {r0, r1}    ; stack access
    0xe0018d3c     0xc0    bl e00185e4 <decodeCopyRegisters>
    0xe0018d40     0xc4    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018d44     0xc8    movw r3, #13900 
    0xe0018d48     0xcc    movt r3, #57347 
    0xe0018d4c     0xd0    mov r1, #2
    0xe0018d50     0xd4    ldr r0, [r3]
    0xe0018d54     0xd8    bl e0014ad8 <setThreadState>
    0xe0018d58     0xdc    bic r0, r4, #15
    0xe0018d5c     0xe0    bl e001584c <suspend>
    0xe0018d60     0xe4    mov r0, #0
    0xe0018d64     0xe8    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018d68     0xec    movw r3, #13900 
    0xe0018d6c     0xf0    movt r3, #57347 
    0xe0018d70     0xf4    mov r1, #2
    0xe0018d74     0xf8    ldr r0, [r3]
    0xe0018d78     0xfc    bl e0014ad8 <setThreadState>
    0xe0018d7c    0x100    bic r0, r4, #15
    0xe0018d80    0x104    bl e0016718 <restart>
    0xe0018d84    0x108    mov r0, #0
    0xe0018d88    0x10c    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018d8c    0x110    ldr r3, [sp, #60]     ; stack access
    0xe0018d90    0x114    str r3, [sp, #12]     ; stack access
    0xe0018d94    0x118    add r3, sp, #44 
    0xe0018d98    0x11c    ldm r3, {r0, r1, r2}  ; stack access
    0xe0018d9c    0x120    stm sp, {r0, r1, r2}  ; stack access
    0xe0018da0    0x124    ldr r3, [sp, #40]     ; stack access
    0xe0018da4    0x128    mov r2, ip
    0xe0018da8    0x12c    add r1, sp, #24
    0xe0018dac    0x130    ldmdb r1, {r0, r1}    ; stack access
    0xe0018db0    0x134    bl e0017b0c <decodeTCBConfigure>
    0xe0018db4    0x138    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018db8    0x13c    ldr r3, [sp, #60]     ; stack access
    0xe0018dbc    0x140    str r3, [sp, #8]      ; stack access
    0xe0018dc0    0x144    add r3, sp, #48 
    0xe0018dc4    0x148    ldm r3, {r0, r1}      ; stack access
    0xe0018dc8    0x14c    stm sp, {r0, r1}      ; stack access
    0xe0018dcc    0x150    ldr r3, [sp, #44]     ; stack access
    0xe0018dd0    0x154    mov r2, ip
    0xe0018dd4    0x158    add r1, sp, #24
    0xe0018dd8    0x15c    ldmdb r1, {r0, r1}    ; stack access
    0xe0018ddc    0x160    bl e0017dd0 <decodeSetPriority>
    0xe0018de0    0x164    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018de4    0x168    ldr r3, [sp, #60]     ; stack access
    0xe0018de8    0x16c    str r3, [sp, #8]      ; stack access
    0xe0018dec    0x170    add r3, sp, #48 
    0xe0018df0    0x174    ldm r3, {r0, r1}      ; stack access
    0xe0018df4    0x178    stm sp, {r0, r1}      ; stack access
    0xe0018df8    0x17c    ldr r3, [sp, #44]     ; stack access
    0xe0018dfc    0x180    mov r2, ip
    0xe0018e00    0x184    add r1, sp, #24
    0xe0018e04    0x188    ldmdb r1, {r0, r1}    ; stack access
    0xe0018e08    0x18c    bl e0017f08 <decodeSetMCPriority>
    0xe0018e0c    0x190    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018e10    0x194    ldr r3, [sp, #60]     ; stack access
    0xe0018e14    0x198    str r3, [sp, #8]      ; stack access
    0xe0018e18    0x19c    add r3, sp, #48 
    0xe0018e1c    0x1a0    ldm r3, {r0, r1}      ; stack access
    0xe0018e20    0x1a4    stm sp, {r0, r1}      ; stack access
    0xe0018e24    0x1a8    ldr r3, [sp, #44]     ; stack access
    0xe0018e28    0x1ac    mov r2, ip
    0xe0018e2c    0x1b0    add r1, sp, #24
    0xe0018e30    0x1b4    ldmdb r1, {r0, r1}    ; stack access
    0xe0018e34    0x1b8    bl e0018040 <decodeSetSchedParams>
    0xe0018e38    0x1bc    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018e3c    0x1c0    ldr r3, [sp, #60]     ; stack access
    0xe0018e40    0x1c4    str r3, [sp, #12]     ; stack access
    0xe0018e44    0x1c8    add r3, sp, #44 
    0xe0018e48    0x1cc    ldm r3, {r0, r1, r2}  ; stack access
    0xe0018e4c    0x1d0    stm sp, {r0, r1, r2}  ; stack access
    0xe0018e50    0x1d4    ldr r3, [sp, #40]     ; stack access
    0xe0018e54    0x1d8    mov r2, ip
    0xe0018e58    0x1dc    add r1, sp, #24
    0xe0018e5c    0x1e0    ldmdb r1, {r0, r1}    ; stack access
    0xe0018e60    0x1e4    bl e00181a8 <decodeSetIPCBuffer>
    0xe0018e64    0x1e8    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018e68    0x1ec    ldr r3, [sp, #60]     ; stack access
    0xe0018e6c    0x1f0    str r3, [sp, #12]     ; stack access
    0xe0018e70    0x1f4    add r3, sp, #44 
    0xe0018e74    0x1f8    ldm r3, {r0, r1, r2}  ; stack access
    0xe0018e78    0x1fc    stm sp, {r0, r1, r2}  ; stack access
    0xe0018e7c    0x200    ldr r3, [sp, #40]     ; stack access
    0xe0018e80    0x204    mov r2, ip
    0xe0018e84    0x208    add r1, sp, #24
    0xe0018e88    0x20c    ldmdb r1, {r0, r1}    ; stack access
    0xe0018e8c    0x210    bl e00182d0 <decodeSetSpace>
    0xe0018e90    0x214    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018e94    0x218    ldr r3, [sp, #52]     ; stack access
    0xe0018e98    0x21c    str r3, [sp]          ; stack access
    0xe0018e9c    0x220    add r3, sp, #44 
    0xe0018ea0    0x224    ldm r3, {r2, r3}      ; stack access
    0xe0018ea4    0x228    add r1, sp, #24
    0xe0018ea8    0x22c    ldmdb r1, {r0, r1}    ; stack access
    0xe0018eac    0x230    bl e0018b04 <decodeBindNotification>
    0xe0018eb0    0x234    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018eb4    0x238    add r3, sp, #24
    0xe0018eb8    0x23c    ldmdb r3, {r0, r1}    ; stack access
    0xe0018ebc    0x240    bl e0018c1c <decodeUnbindNotification>
    0xe0018ec0    0x244    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018ec4    0x248    cmp ip, #0
    0xe0018ec8    0x24c    beq e0018f08 <decodeTCBInvocation+0x28c>
    0xe0018ecc    0x250    movw r5, #13900 
    0xe0018ed0    0x254    movt r5, #57347 
    0xe0018ed4    0x258    ldr r0, [r5]
    0xe0018ed8    0x25c    ldr r6, [r0, #8]
    0xe0018edc    0x260    mov r1, #2
    0xe0018ee0    0x264    bl e0014ad8 <setThreadState>
    0xe0018ee4    0x268    bic r4, r4, #15
    0xe0018ee8    0x26c    str r6, [r4, #72] 
    0xe0018eec    0x270    ldr r3, [r5]
    0xe0018ef0    0x274    cmp r4, r3
    0xe0018ef4    0x278    movne r0, #0
    0xe0018ef8    0x27c    bne e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018efc    0x280    bl e0014a4c <rescheduleRequired>
    0xe0018f00    0x284    mov r0, #0
    0xe0018f04    0x288    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018f08    0x28c    movw r3, #36896 
    0xe0018f0c    0x290    movt r3, #57346 
    0xe0018f10    0x294    mov r2, #7
    0xe0018f14    0x298    str r2, [r3, #24]
    0xe0018f18    0x29c    mov r0, #3
    0xe0018f1c    0x2a0    b e0018cf8 <decodeTCBInvocation+0x7c>
    0xe0018f20    0x2a4    movw r3, #36896 
    0xe0018f24    0x2a8    movt r3, #57346 
    0xe0018f28    0x2ac    mov r0, #3
    0xe0018f2c    0x2b0    str r0, [r3, #24]
    0xe0018f30    0x2b4    b e0018cf8 <decodeTCBInvocation+0x7c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
160 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeTCBInvocation` has 291 nodes.

Section decodeCNodeInvocation (291 of 293)
==========================================

Deriving specifications
-----------------------

Section `decodeCNodeInvocation` consists of 456 instructions.
Switch found.


Stack analysis
---------------

63 stack accesses found. Annotated code for `decodeCNodeInvocation`:

    0xe0015dd8      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0015ddc      0x4    sub sp, sp, #108 
    0xe0015de0      0x8    add ip, sp, #24
    0xe0015de4      0xc    stm ip, {r2, r3}      ; stack access
    0xe0015de8     0x10    sub r3, r0, #16
    0xe0015dec     0x14    cmp r3, #8
    0xe0015df0     0x18    bhi e0015e74 <decodeCNodeInvocation+0x9c>
    0xe0015df4     0x1c    cmp r1, #1
    0xe0015df8     0x20    bls e0015e90 <decodeCNodeInvocation+0xb8>
    0xe0015dfc     0x24    mov r9, r1
    0xe0015e00     0x28    mov r8, r0
    0xe0015e04     0x2c    ldr r5, [sp, #144]    ; stack access
    0xe0015e08     0x30    ldr r6, [sp, #148]    ; stack access
    0xe0015e0c     0x34    movw r3, #13900 
    0xe0015e10     0x38    movt r3, #57347 
    0xe0015e14     0x3c    ldr r2, [r3]
    0xe0015e18     0x40    ldr r3, [r2, #8]
    0xe0015e1c     0x44    ldr r2, [r2, #12]
    0xe0015e20     0x48    str r2, [sp]          ; stack access
    0xe0015e24     0x4c    add r2, sp, #24
    0xe0015e28     0x50    ldm r2, {r1, r2}      ; stack access
    0xe0015e2c     0x54    add r0, sp, #88 
    0xe0015e30     0x58    bl e0012e64 <lookupTargetSlot>
    0xe0015e34     0x5c    ldr r4, [sp, #88]     ; stack access
    0xe0015e38     0x60    cmp r4, #0
    0xe0015e3c     0x64    bne e0015e84 <decodeCNodeInvocation+0xac>
    0xe0015e40     0x68    ldr r7, [sp, #92]     ; stack access
    0xe0015e44     0x6c    sub r3, r8, #19
    0xe0015e48     0x70    cmp r3, #3
    0xe0015e4c     0x74    bhi e0016174 <decodeCNodeInvocation+0x39c>
    0xe0015e50     0x78    cmp r5, #0
    0xe0015e54     0x7c    cmpne r9, #3
    0xe0015e58     0x80    bhi e0015ea8 <decodeCNodeInvocation+0xd0>
    0xe0015e5c     0x84    movw r3, #36896 
    0xe0015e60     0x88    movt r3, #57346 
    0xe0015e64     0x8c    mov r2, #7
    0xe0015e68     0x90    str r2, [r3, #24]
    0xe0015e6c     0x94    mov r4, #3
    0xe0015e70     0x98    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0015e74     0x9c    movw r3, #36896 
    0xe0015e78     0xa0    movt r3, #57346 
    0xe0015e7c     0xa4    mov r4, #3
    0xe0015e80     0xa8    str r4, [r3, #24]
    0xe0015e84     0xac    mov r0, r4
    0xe0015e88     0xb0    add sp, sp, #108 
    0xe0015e8c     0xb4    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0015e90     0xb8    movw r3, #36896 
    0xe0015e94     0xbc    movt r3, #57346 
    0xe0015e98     0xc0    mov r2, #7
    0xe0015e9c     0xc4    str r2, [r3, #24]
    0xe0015ea0     0xc8    mov r4, #3
    0xe0015ea4     0xcc    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0015ea8     0xd0    movw r3, #13900 
    0xe0015eac     0xd4    movt r3, #57347 
    0xe0015eb0     0xd8    ldr r3, [r3]
    0xe0015eb4     0xdc    ldr r6, [r3, #16]
    0xe0015eb8     0xe0    ldr sl, [r3, #20]
    0xe0015ebc     0xe4    add r3, sp, #36 
    0xe0015ec0     0xe8    ldm r5, {r0, r1}
    0xe0015ec4     0xec    stm r3, {r0, r1}      ; stack access
    0xe0015ec8     0xf0    mov r0, r7
    0xe0015ecc     0xf4    bl e0013508 <ensureEmptySlot>
    0xe0015ed0     0xf8    subs r4, r0, #0
    0xe0015ed4     0xfc    bne e0015e84 <decodeCNodeInvocation+0xac>
    0xe0015ed8    0x100    str sl, [sp]          ; stack access
    0xe0015edc    0x104    mov r3, r6
    0xe0015ee0    0x108    add r2, sp, #36 
    0xe0015ee4    0x10c    ldm r2, {r1, r2}      ; stack access
    0xe0015ee8    0x110    add r0, sp, #88 
    0xe0015eec    0x114    bl e0012e2c <lookupSourceSlot>
    0xe0015ef0    0x118    ldr r4, [sp, #88]     ; stack access
    0xe0015ef4    0x11c    cmp r4, #0
    0xe0015ef8    0x120    bne e0015e84 <decodeCNodeInvocation+0xac>
    0xe0015efc    0x124    ldr r6, [sp, #92]     ; stack access
    0xe0015f00    0x128    ldr r5, [r6]
    0xe0015f04    0x12c    and r3, r5, #14
    0xe0015f08    0x130    cmp r3, #14
    0xe0015f0c    0x134    andne r3, r5, #15
    0xe0015f10    0x138    uxtbeq r3, r5
    0xe0015f14    0x13c    cmp r3, #0
    0xe0015f18    0x140    bne e0015f5c <decodeCNodeInvocation+0x184>
    0xe0015f1c    0x144    movw r3, #36896 
    0xe0015f20    0x148    movt r3, #57346 
    0xe0015f24    0x14c    mov r2, #6
    0xe0015f28    0x150    str r2, [r3, #24]
    0xe0015f2c    0x154    mov r2, #1
    0xe0015f30    0x158    str r2, [r3, #20]
    0xe0015f34    0x15c    movw r2, #36884 
    0xe0015f38    0x160    movt r2, #57346 
    0xe0015f3c    0x164    lsl r3, sl, #2
    0xe0015f40    0x168    uxtb r3, r3
    0xe0015f44    0x16c    orr r3, r3, #1
    0xe0015f48    0x170    str r3, [r2]
    0xe0015f4c    0x174    mov r3, #0
    0xe0015f50    0x178    str r3, [r2, #4]
    0xe0015f54    0x17c    mov r4, #3
    0xe0015f58    0x180    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0015f5c    0x184    sub r0, r8, #19
    0xe0015f60    0x188    cmp r0, #3
    0xe0015f64    0x18c    ldrls pc, [pc, r0, lsl #2]
    0xe0015f68    0x190    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0015f6c    0x194    .word 0xe0015f7c
    0xe0015f70    0x198    .word 0xe0015ff0
    0xe0015f74    0x19c    .word 0xe0016088
    0xe0015f78    0x1a0    .word 0xe00160c4
    0xe0015f7c    0x1a4    cmp r9, #4
    0xe0015f80    0x1a8    bhi e0015f9c <decodeCNodeInvocation+0x1c4>
    0xe0015f84    0x1ac    movw r3, #36896 
    0xe0015f88    0x1b0    movt r3, #57346 
    0xe0015f8c    0x1b4    mov r2, #7
    0xe0015f90    0x1b8    str r2, [r3, #24]
    0xe0015f94    0x1bc    mov r4, #3
    0xe0015f98    0x1c0    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0015f9c    0x1c4    add r5, sp, #52 
    0xe0015fa0    0x1c8    ldm r6, {r2, r3}
    0xe0015fa4    0x1cc    ldr r1, [sp, #156]    ; stack access
    0xe0015fa8    0x1d0    ldr r1, [r1, #20]
    0xe0015fac    0x1d4    mov r0, r5
    0xe0015fb0    0x1d8    bl e0014610 <maskCapRights>
    0xe0015fb4    0x1dc    ldm r5, {r2, r3}      ; stack access
    0xe0015fb8    0x1e0    mov r1, r6
    0xe0015fbc    0x1e4    add r0, sp, #76 
    0xe0015fc0    0x1e8    bl e00142e4 <deriveCap>
    0xe0015fc4    0x1ec    ldr r3, [sp, #76]     ; stack access
    0xe0015fc8    0x1f0    cmp r3, #0
    0xe0015fcc    0x1f4    movne r4, r3
    0xe0015fd0    0x1f8    bne e0015e84 <decodeCNodeInvocation+0xac>
    0xe0015fd4    0x1fc    add r3, sp, #44 
    0xe0015fd8    0x200    add r2, sp, #80 
    0xe0015fdc    0x204    ldm r2, {r0, r1}      ; stack access
    0xe0015fe0    0x208    stm r3, {r0, r1}      ; stack access
    0xe0015fe4    0x20c    mov r5, r0
    0xe0015fe8    0x210    mov r8, #0
    0xe0015fec    0x214    b e0016098 <decodeCNodeInvocation+0x2c0>
    0xe0015ff0    0x218    cmp r9, #5
    0xe0015ff4    0x21c    bhi e0016010 <decodeCNodeInvocation+0x238>
    0xe0015ff8    0x220    movw r3, #36896 
    0xe0015ffc    0x224    movt r3, #57346 
    0xe0016000    0x228    mov r2, #7
    0xe0016004    0x22c    str r2, [r3, #24]
    0xe0016008    0x230    mov r4, #3
    0xe001600c    0x234    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016010    0x238    ldr r3, [sp, #156]    ; stack access
    0xe0016014    0x23c    ldr r8, [r3, #24]
    0xe0016018    0x240    ldm r6, {r2, r3}
    0xe001601c    0x244    ldr r1, [sp, #156]    ; stack access
    0xe0016020    0x248    ldr r1, [r1, #20]
    0xe0016024    0x24c    add r0, sp, #52 
    0xe0016028    0x250    bl e0014610 <maskCapRights>
    0xe001602c    0x254    add r5, sp, #96 
    0xe0016030    0x258    ldr r3, [sp, #56]     ; stack access
    0xe0016034    0x25c    str r3, [sp]          ; stack access
    0xe0016038    0x260    ldr r3, [sp, #52]     ; stack access
    0xe001603c    0x264    mov r2, r8
    0xe0016040    0x268    mov r1, #0
    0xe0016044    0x26c    mov r0, r5
    0xe0016048    0x270    bl e0014500 <updateCapData>
    0xe001604c    0x274    ldm r5, {r2, r3}      ; stack access
    0xe0016050    0x278    mov r1, r6
    0xe0016054    0x27c    add r0, sp, #76 
    0xe0016058    0x280    bl e00142e4 <deriveCap>
    0xe001605c    0x284    ldr r3, [sp, #76]     ; stack access
    0xe0016060    0x288    cmp r3, #0
    0xe0016064    0x28c    movne r4, r3
    0xe0016068    0x290    bne e0015e84 <decodeCNodeInvocation+0xac>
    0xe001606c    0x294    add r3, sp, #44 
    0xe0016070    0x298    add r2, sp, #80 
    0xe0016074    0x29c    ldm r2, {r0, r1}      ; stack access
    0xe0016078    0x2a0    stm r3, {r0, r1}      ; stack access
    0xe001607c    0x2a4    mov r5, r0
    0xe0016080    0x2a8    mov r8, #0
    0xe0016084    0x2ac    b e0016098 <decodeCNodeInvocation+0x2c0>
    0xe0016088    0x2b0    add r3, sp, #44 
    0xe001608c    0x2b4    ldm r6, {r0, r1}
    0xe0016090    0x2b8    stm r3, {r0, r1}      ; stack access
    0xe0016094    0x2bc    mov r8, #1
    0xe0016098    0x2c0    and r3, r5, #14
    0xe001609c    0x2c4    cmp r3, #14
    0xe00160a0    0x2c8    andne r3, r5, #15
    0xe00160a4    0x2cc    uxtbeq r3, r5
    0xe00160a8    0x2d0    cmp r3, #0
    0xe00160ac    0x2d4    bne e0016110 <decodeCNodeInvocation+0x338>
    0xe00160b0    0x2d8    movw r3, #36896 
    0xe00160b4    0x2dc    movt r3, #57346 
    0xe00160b8    0x2e0    mov r4, #3
    0xe00160bc    0x2e4    str r4, [r3, #24]
    0xe00160c0    0x2e8    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe00160c4    0x2ec    cmp r9, #4
    0xe00160c8    0x2f0    bhi e00160e4 <decodeCNodeInvocation+0x30c>
    0xe00160cc    0x2f4    movw r3, #36896 
    0xe00160d0    0x2f8    movt r3, #57346 
    0xe00160d4    0x2fc    mov r2, #7
    0xe00160d8    0x300    str r2, [r3, #24]
    0xe00160dc    0x304    mov r4, #3
    0xe00160e0    0x308    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe00160e4    0x30c    ldr r3, [r6, #4]
    0xe00160e8    0x310    str r3, [sp]          ; stack access
    0xe00160ec    0x314    ldr r3, [r6]
    0xe00160f0    0x318    ldr r2, [sp, #156]    ; stack access
    0xe00160f4    0x31c    ldr r2, [r2, #20]
    0xe00160f8    0x320    mov r1, #1
    0xe00160fc    0x324    add r0, sp, #44 
    0xe0016100    0x328    bl e0014500 <updateCapData>
    0xe0016104    0x32c    ldr r5, [sp, #44]     ; stack access
    0xe0016108    0x330    mov r8, #1
    0xe001610c    0x334    b e0016098 <decodeCNodeInvocation+0x2c0>
    0xe0016110    0x338    movw r3, #13900 
    0xe0016114    0x33c    movt r3, #57347 
    0xe0016118    0x340    mov r1, #2
    0xe001611c    0x344    ldr r0, [r3]
    0xe0016120    0x348    bl e0014ad8 <setThreadState>
    0xe0016124    0x34c    cmp r8, #0
    0xe0016128    0x350    beq e0016150 <decodeCNodeInvocation+0x378>
    0xe001612c    0x354    str r5, [sp, #44]     ; stack access
    0xe0016130    0x358    add ip, sp, #60 
    0xe0016134    0x35c    add r3, sp, #44 
    0xe0016138    0x360    ldm r3, {r0, r1}      ; stack access
    0xe001613c    0x364    stm ip, {r0, r1}      ; stack access
    0xe0016140    0x368    mov r3, r7
    0xe0016144    0x36c    mov r2, r6
    0xe0016148    0x370    bl e00131b0 <cteMove>
    0xe001614c    0x374    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016150    0x378    str r5, [sp, #44]     ; stack access
    0xe0016154    0x37c    add ip, sp, #68 
    0xe0016158    0x380    add r3, sp, #44 
    0xe001615c    0x384    ldm r3, {r0, r1}      ; stack access
    0xe0016160    0x388    stm ip, {r0, r1}      ; stack access
    0xe0016164    0x38c    mov r3, r7
    0xe0016168    0x390    mov r2, r6
    0xe001616c    0x394    bl e0012fa8 <cteInsert>
    0xe0016170    0x398    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016174    0x39c    cmp r8, #16
    0xe0016178    0x3a0    beq e00161d8 <decodeCNodeInvocation+0x400>
    0xe001617c    0x3a4    cmp r8, #17
    0xe0016180    0x3a8    beq e00161fc <decodeCNodeInvocation+0x424>
    0xe0016184    0x3ac    cmp r8, #24
    0xe0016188    0x3b0    beq e0016220 <decodeCNodeInvocation+0x448>
    0xe001618c    0x3b4    cmp r8, #18
    0xe0016190    0x3b8    beq e0016254 <decodeCNodeInvocation+0x47c>
    0xe0016194    0x3bc    cmp r8, #23
    0xe0016198    0x3c0    bne e0015e84 <decodeCNodeInvocation+0xac>
    0xe001619c    0x3c4    clz r3, r5
    0xe00161a0    0x3c8    lsr r3, r3, #5
    0xe00161a4    0x3cc    cmp r6, #0
    0xe00161a8    0x3d0    movne r1, r3
    0xe00161ac    0x3d4    moveq r1, #1
    0xe00161b0    0x3d8    cmp r9, #7
    0xe00161b4    0x3dc    orrls r1, r1, #1
    0xe00161b8    0x3e0    cmp r1, #0
    0xe00161bc    0x3e4    beq e00162a8 <decodeCNodeInvocation+0x4d0>
    0xe00161c0    0x3e8    movw r3, #36896 
    0xe00161c4    0x3ec    movt r3, #57346 
    0xe00161c8    0x3f0    mov r2, #7
    0xe00161cc    0x3f4    str r2, [r3, #24]
    0xe00161d0    0x3f8    mov r4, #3
    0xe00161d4    0x3fc    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe00161d8    0x400    movw r3, #13900 
    0xe00161dc    0x404    movt r3, #57347 
    0xe00161e0    0x408    mov r1, #2
    0xe00161e4    0x40c    ldr r0, [r3]
    0xe00161e8    0x410    bl e0014ad8 <setThreadState>
    0xe00161ec    0x414    mov r0, r7
    0xe00161f0    0x418    bl e0015d68 <cteRevoke>
    0xe00161f4    0x41c    mov r4, r0
    0xe00161f8    0x420    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe00161fc    0x424    movw r3, #13900 
    0xe0016200    0x428    movt r3, #57347 
    0xe0016204    0x42c    mov r1, #2
    0xe0016208    0x430    ldr r0, [r3]
    0xe001620c    0x434    bl e0014ad8 <setThreadState>
    0xe0016210    0x438    mov r0, r7
    0xe0016214    0x43c    bl e0015d58 <invokeCNodeDelete>
    0xe0016218    0x440    mov r4, r0
    0xe001621c    0x444    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016220    0x448    mov r0, r7
    0xe0016224    0x44c    bl e0013508 <ensureEmptySlot>
    0xe0016228    0x450    subs r4, r0, #0
    0xe001622c    0x454    bne e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016230    0x458    movw r3, #13900 
    0xe0016234    0x45c    movt r3, #57347 
    0xe0016238    0x460    mov r1, #2
    0xe001623c    0x464    ldr r0, [r3]
    0xe0016240    0x468    bl e0014ad8 <setThreadState>
    0xe0016244    0x46c    mov r0, r7
    0xe0016248    0x470    bl e0013248 <invokeCNodeSaveCaller>
    0xe001624c    0x474    mov r4, r0
    0xe0016250    0x478    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016254    0x47c    add r3, sp, #76 
    0xe0016258    0x480    ldm r7, {r0, r1}
    0xe001625c    0x484    stm r3, {r0, r1}      ; stack access
    0xe0016260    0x488    bl e0013890 <hasCancelSendRights>
    0xe0016264    0x48c    cmp r0, #0
    0xe0016268    0x490    bne e0016280 <decodeCNodeInvocation+0x4a8>
    0xe001626c    0x494    movw r3, #36896 
    0xe0016270    0x498    movt r3, #57346 
    0xe0016274    0x49c    mov r4, #3
    0xe0016278    0x4a0    str r4, [r3, #24]
    0xe001627c    0x4a4    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016280    0x4a8    movw r3, #13900 
    0xe0016284    0x4ac    movt r3, #57347 
    0xe0016288    0x4b0    mov r1, #2
    0xe001628c    0x4b4    ldr r0, [r3]
    0xe0016290    0x4b8    bl e0014ad8 <setThreadState>
    0xe0016294    0x4bc    add r3, sp, #76 
    0xe0016298    0x4c0    ldm r3, {r0, r1}      ; stack access
    0xe001629c    0x4c4    bl e0015690 <invokeCNodeCancelBadgedSends>
    0xe00162a0    0x4c8    mov r4, r0
    0xe00162a4    0x4cc    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe00162a8    0x4d0    movw r3, #13900 
    0xe00162ac    0x4d4    movt r3, #57347 
    0xe00162b0    0x4d8    ldr r3, [r3]
    0xe00162b4    0x4dc    ldr r2, [r3, #16]
    0xe00162b8    0x4e0    str r2, [sp, #20]     ; stack access
    0xe00162bc    0x4e4    ldr fp, [r3, #20]
    0xe00162c0    0x4e8    ldr r3, [sp, #156]    ; stack access
    0xe00162c4    0x4ec    ldr r9, [r3, #20]
    0xe00162c8    0x4f0    ldr sl, [r3, #24]
    0xe00162cc    0x4f4    ldr r3, [r3, #28]
    0xe00162d0    0x4f8    ldr r2, [sp, #156]    ; stack access
    0xe00162d4    0x4fc    ldr r8, [r2, #32]
    0xe00162d8    0x500    add r2, sp, #52 
    0xe00162dc    0x504    ldm r5, {r0, r1}
    0xe00162e0    0x508    stm r2, {r0, r1}      ; stack access
    0xe00162e4    0x50c    add r2, sp, #60 
    0xe00162e8    0x510    ldm r6, {r0, r1}
    0xe00162ec    0x514    stm r2, {r0, r1}      ; stack access
    0xe00162f0    0x518    str r8, [sp]          ; stack access
    0xe00162f4    0x51c    ldm r2, {r1, r2}      ; stack access
    0xe00162f8    0x520    add r0, sp, #88 
    0xe00162fc    0x524    bl e0012e2c <lookupSourceSlot>
    0xe0016300    0x528    ldr r4, [sp, #88]     ; stack access
    0xe0016304    0x52c    cmp r4, #0
    0xe0016308    0x530    bne e0015e84 <decodeCNodeInvocation+0xac>
    0xe001630c    0x534    ldr r5, [sp, #92]     ; stack access
    0xe0016310    0x538    str r9, [sp]          ; stack access
    0xe0016314    0x53c    mov r3, fp
    0xe0016318    0x540    add r2, sp, #52 
    0xe001631c    0x544    ldm r2, {r1, r2}      ; stack access
    0xe0016320    0x548    add r0, sp, #88 
    0xe0016324    0x54c    bl e0012e9c <lookupPivotSlot>
    0xe0016328    0x550    ldr r4, [sp, #88]     ; stack access
    0xe001632c    0x554    cmp r4, #0
    0xe0016330    0x558    bne e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016334    0x55c    ldr r6, [sp, #92]     ; stack access
    0xe0016338    0x560    cmp r7, r6
    0xe001633c    0x564    cmpne r5, r6
    0xe0016340    0x568    bne e0016358 <decodeCNodeInvocation+0x580>
    0xe0016344    0x56c    movw r3, #36896 
    0xe0016348    0x570    movt r3, #57346 
    0xe001634c    0x574    mov r4, #3
    0xe0016350    0x578    str r4, [r3, #24]
    0xe0016354    0x57c    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016358    0x580    cmp r7, r5
    0xe001635c    0x584    beq e0016370 <decodeCNodeInvocation+0x598>
    0xe0016360    0x588    mov r0, r7
    0xe0016364    0x58c    bl e0013508 <ensureEmptySlot>
    0xe0016368    0x590    subs r4, r0, #0
    0xe001636c    0x594    bne e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016370    0x598    ldr r3, [r5]
    0xe0016374    0x59c    and r2, r3, #14
    0xe0016378    0x5a0    cmp r2, #14
    0xe001637c    0x5a4    andne r3, r3, #15
    0xe0016380    0x5a8    uxtbeq r3, r3
    0xe0016384    0x5ac    cmp r3, #0
    0xe0016388    0x5b0    bne e00163cc <decodeCNodeInvocation+0x5f4>
    0xe001638c    0x5b4    movw r3, #36896 
    0xe0016390    0x5b8    movt r3, #57346 
    0xe0016394    0x5bc    mov r2, #6
    0xe0016398    0x5c0    str r2, [r3, #24]
    0xe001639c    0x5c4    mov r2, #1
    0xe00163a0    0x5c8    str r2, [r3, #20]
    0xe00163a4    0x5cc    movw r2, #36884 
    0xe00163a8    0x5d0    movt r2, #57346 
    0xe00163ac    0x5d4    lsl r3, r8, #2
    0xe00163b0    0x5d8    uxtb r3, r3
    0xe00163b4    0x5dc    orr r3, r3, #1
    0xe00163b8    0x5e0    str r3, [r2]
    0xe00163bc    0x5e4    mov r3, #0
    0xe00163c0    0x5e8    str r3, [r2, #4]
    0xe00163c4    0x5ec    mov r4, #3
    0xe00163c8    0x5f0    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe00163cc    0x5f4    ldr r3, [r6]
    0xe00163d0    0x5f8    and r2, r3, #14
    0xe00163d4    0x5fc    cmp r2, #14
    0xe00163d8    0x600    andne r3, r3, #15
    0xe00163dc    0x604    uxtbeq r3, r3
    0xe00163e0    0x608    cmp r3, #0
    0xe00163e4    0x60c    bne e0016424 <decodeCNodeInvocation+0x64c>
    0xe00163e8    0x610    movw r3, #36896 
    0xe00163ec    0x614    movt r3, #57346 
    0xe00163f0    0x618    mov r2, #6
    0xe00163f4    0x61c    str r2, [r3, #24]
    0xe00163f8    0x620    mov r1, #0
    0xe00163fc    0x624    str r1, [r3, #20]
    0xe0016400    0x628    movw r2, #36884 
    0xe0016404    0x62c    movt r2, #57346 
    0xe0016408    0x630    lsl r3, r9, #2
    0xe001640c    0x634    uxtb r3, r3
    0xe0016410    0x638    orr r3, r3, #1
    0xe0016414    0x63c    str r3, [r2]
    0xe0016418    0x640    str r1, [r2, #4]
    0xe001641c    0x644    mov r4, #3
    0xe0016420    0x648    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe0016424    0x64c    ldr r3, [r5, #4]
    0xe0016428    0x650    str r3, [sp]          ; stack access
    0xe001642c    0x654    ldr r3, [r5]
    0xe0016430    0x658    mov r2, sl
    0xe0016434    0x65c    mov r1, #1
    0xe0016438    0x660    add r0, sp, #68 
    0xe001643c    0x664    bl e0014500 <updateCapData>
    0xe0016440    0x668    ldr r3, [r6, #4]
    0xe0016444    0x66c    str r3, [sp]          ; stack access
    0xe0016448    0x670    ldr r3, [r6]
    0xe001644c    0x674    ldr r2, [sp, #20]     ; stack access
    0xe0016450    0x678    mov r1, #1
    0xe0016454    0x67c    add r0, sp, #76 
    0xe0016458    0x680    bl e0014500 <updateCapData>
    0xe001645c    0x684    ldr r3, [sp, #68]     ; stack access
    0xe0016460    0x688    and r2, r3, #14
    0xe0016464    0x68c    cmp r2, #14
    0xe0016468    0x690    andne r3, r3, #15
    0xe001646c    0x694    uxtbeq r3, r3
    0xe0016470    0x698    cmp r3, #0
    0xe0016474    0x69c    bne e001648c <decodeCNodeInvocation+0x6b4>
    0xe0016478    0x6a0    movw r3, #36896 
    0xe001647c    0x6a4    movt r3, #57346 
    0xe0016480    0x6a8    mov r4, #3
    0xe0016484    0x6ac    str r4, [r3, #24]
    0xe0016488    0x6b0    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe001648c    0x6b4    ldr r3, [sp, #76]     ; stack access
    0xe0016490    0x6b8    and r2, r3, #14
    0xe0016494    0x6bc    cmp r2, #14
    0xe0016498    0x6c0    andne r3, r3, #15
    0xe001649c    0x6c4    uxtbeq r3, r3
    0xe00164a0    0x6c8    cmp r3, #0
    0xe00164a4    0x6cc    bne e00164bc <decodeCNodeInvocation+0x6e4>
    0xe00164a8    0x6d0    movw r3, #36896 
    0xe00164ac    0x6d4    movt r3, #57346 
    0xe00164b0    0x6d8    mov r4, #3
    0xe00164b4    0x6dc    str r4, [r3, #24]
    0xe00164b8    0x6e0    b e0015e84 <decodeCNodeInvocation+0xac>
    0xe00164bc    0x6e4    movw r3, #13900 
    0xe00164c0    0x6e8    movt r3, #57347 
    0xe00164c4    0x6ec    mov r1, #2
    0xe00164c8    0x6f0    ldr r0, [r3]
    0xe00164cc    0x6f4    bl e0014ad8 <setThreadState>
    0xe00164d0    0x6f8    str r7, [sp, #8]      ; stack access
    0xe00164d4    0x6fc    str r6, [sp, #4]      ; stack access
    0xe00164d8    0x700    str r5, [sp]          ; stack access
    0xe00164dc    0x704    add r3, sp, #76 
    0xe00164e0    0x708    ldm r3, {r2, r3}      ; stack access
    0xe00164e4    0x70c    add r1, sp, #68 
    0xe00164e8    0x710    ldm r1, {r0, r1}      ; stack access
    0xe00164ec    0x714    bl e0013384 <invokeCNodeRotate>
    0xe00164f0    0x718    mov r4, r0
    0xe00164f4    0x71c    b e0015e84 <decodeCNodeInvocation+0xac>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
452 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeCNodeInvocation` has 722 nodes.

Section decodeARMMMUInvocation (292 of 293)
===========================================

Deriving specifications
-----------------------

Section `decodeARMMMUInvocation` consists of 1268 instructions.
Switch found.
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy
Switch found.
Switch found.
Switch found.
 LDMIA;3,2,1,0.....++
 STMIA;3,2,1,0.....+
 ANDNE (reg)...........++++++
Switch found.
 CMN (reg).....++


Stack analysis
---------------

84 stack accesses found. Annotated code for `decodeARMMMUInvocation`:

    0xe001978c       0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0019790       0x4    sub sp, sp, #84 
    0xe0019794       0x8    mov r9, r0
    0xe0019798       0xc    mov r7, r3
    0xe001979c      0x10    ldr r4, [sp, #120]    ; stack access
    0xe00197a0      0x14    ldr r5, [sp, #124]    ; stack access
    0xe00197a4      0x18    ldr sl, [sp, #128]    ; stack access
    0xe00197a8      0x1c    and r3, r4, #14
    0xe00197ac      0x20    cmp r3, #14
    0xe00197b0      0x24    andne r8, r4, #15
    0xe00197b4      0x28    uxtbeq r8, r4
    0xe00197b8      0x2c    sub r3, r8, #1
    0xe00197bc      0x30    cmp r3, #10
    0xe00197c0      0x34    ldrls pc, [pc, r3, lsl #2]
    0xe00197c4      0x38    b e001aa8c <decodeARMMMUInvocation+0x1300>
    0xe00197c8      0x3c    .word 0xe0019cd0
    0xe00197cc      0x40    .word 0xe001aa8c
    0xe00197d0      0x44    .word 0xe0019cd0
    0xe00197d4      0x48    .word 0xe001aa8c
    0xe00197d8      0x4c    .word 0xe001a8f8
    0xe00197dc      0x50    .word 0xe001aa8c
    0xe00197e0      0x54    .word 0xe0019a44
    0xe00197e4      0x58    .word 0xe001aa8c
    0xe00197e8      0x5c    .word 0xe00197f4
    0xe00197ec      0x60    .word 0xe001aa8c
    0xe00197f0      0x64    .word 0xe001a708
    0xe00197f4      0x68    sub r3, r0, #30
    0xe00197f8      0x6c    cmp r3, #3
    0xe00197fc      0x70    bhi e0019a30 <decodeARMMMUInvocation+0x2a4>
    0xe0019800      0x74    cmp r1, #1
    0xe0019804      0x78    bls e0019840 <decodeARMMMUInvocation+0xb4>
    0xe0019808      0x7c    movw r3, #13900 
    0xe001980c      0x80    movt r3, #57347 
    0xe0019810      0x84    ldr r3, [r3]
    0xe0019814      0x88    ldr r7, [r3, #8]
    0xe0019818      0x8c    ldr r8, [r3, #12]
    0xe001981c      0x90    cmp r7, r8
    0xe0019820      0x94    bcc e0019858 <decodeARMMMUInvocation+0xcc>
    0xe0019824      0x98    movw r3, #36896 
    0xe0019828      0x9c    movt r3, #57346 
    0xe001982c      0xa0    mov r2, #1
    0xe0019830      0xa4    str r2, [r3, #24]
    0xe0019834      0xa8    str r2, [r3]
    0xe0019838      0xac    mov r6, #3
    0xe001983c      0xb0    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019840      0xb4    movw r3, #36896 
    0xe0019844      0xb8    movt r3, #57346 
    0xe0019848      0xbc    mov r2, #7
    0xe001984c      0xc0    str r2, [r3, #24]
    0xe0019850      0xc4    mov r6, #3
    0xe0019854      0xc8    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019858      0xcc    cmn r7, #536870913 
    0xe001985c      0xd0    cmpls r8, #-536870912 
    0xe0019860      0xd4    bls e0019878 <decodeARMMMUInvocation+0xec>
    0xe0019864      0xd8    movw r3, #36896 
    0xe0019868      0xdc    movt r3, #57346 
    0xe001986c      0xe0    mov r6, #3
    0xe0019870      0xe4    str r6, [r3, #24]
    0xe0019874      0xe8    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019878      0xec    tst r4, #16
    0xe001987c      0xf0    beq e001992c <decodeARMMMUInvocation+0x1a0>
    0xe0019880      0xf4    bic r4, r4, #16320 
    0xe0019884      0xf8    bic r4, r4, #63 
    0xe0019888      0xfc    ubfx r5, r5, #0, #17
    0xe001988c     0x100    mov r1, r5
    0xe0019890     0x104    add r0, sp, #56 
    0xe0019894     0x108    bl e0010a84 <findPDForASID>
    0xe0019898     0x10c    ldr r6, [sp, #56]     ; stack access
    0xe001989c     0x110    cmp r6, #0
    0xe00198a0     0x114    bne e001994c <decodeARMMMUInvocation+0x1c0>
    0xe00198a4     0x118    ldr r3, [sp, #60]     ; stack access
    0xe00198a8     0x11c    cmp r4, r3
    0xe00198ac     0x120    bne e001996c <decodeARMMMUInvocation+0x1e0>
    0xe00198b0     0x124    lsr r3, r7, #20
    0xe00198b4     0x128    ldr r3, [r4, r3, lsl #2]
    0xe00198b8     0x12c    and r2, r3, #3
    0xe00198bc     0x130    cmp r2, #1
    0xe00198c0     0x134    beq e001998c <decodeARMMMUInvocation+0x200>
    0xe00198c4     0x138    cmp r2, #2
    0xe00198c8     0x13c    bne e00199b4 <decodeARMMMUInvocation+0x228>
    0xe00198cc     0x140    lsr sl, r3, #20
    0xe00198d0     0x144    lsl sl, sl, #20
    0xe00198d4     0x148    ubfx r3, r3, #18, #1
    0xe00198d8     0x14c    cmp r3, #0
    0xe00198dc     0x150    movne fp, #24
    0xe00198e0     0x154    moveq fp, #20
    0xe00198e4     0x158    mov r3, #1
    0xe00198e8     0x15c    lsl r3, r3, fp
    0xe00198ec     0x160    rsb r2, r3, #0
    0xe00198f0     0x164    and r1, r7, r2
    0xe00198f4     0x168    sub r8, r8, #1
    0xe00198f8     0x16c    and r2, r2, r8
    0xe00198fc     0x170    cmp r1, r2
    0xe0019900     0x174    beq e00199cc <decodeARMMMUInvocation+0x240>
    0xe0019904     0x178    movw r2, #36896 
    0xe0019908     0x17c    movt r2, #57346 
    0xe001990c     0x180    mov r0, #4
    0xe0019910     0x184    str r0, [r2, #24]
    0xe0019914     0x188    str r7, [r2, #8]
    0xe0019918     0x18c    sub r3, r3, #1
    0xe001991c     0x190    add r3, r3, r1
    0xe0019920     0x194    str r3, [r2, #12]
    0xe0019924     0x198    mov r6, #3
    0xe0019928     0x19c    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001992c     0x1a0    movw r3, #36896 
    0xe0019930     0x1a4    movt r3, #57346 
    0xe0019934     0x1a8    mov r2, #2
    0xe0019938     0x1ac    str r2, [r3, #24]
    0xe001993c     0x1b0    mov r2, #0
    0xe0019940     0x1b4    str r2, [r3, #4]
    0xe0019944     0x1b8    mov r6, #3
    0xe0019948     0x1bc    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001994c     0x1c0    movw r3, #36896 
    0xe0019950     0x1c4    movt r3, #57346 
    0xe0019954     0x1c8    mov r2, #6
    0xe0019958     0x1cc    str r2, [r3, #24]
    0xe001995c     0x1d0    mov r2, #0
    0xe0019960     0x1d4    str r2, [r3, #20]
    0xe0019964     0x1d8    mov r6, #3
    0xe0019968     0x1dc    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001996c     0x1e0    movw r3, #36896 
    0xe0019970     0x1e4    movt r3, #57346 
    0xe0019974     0x1e8    mov r2, #2
    0xe0019978     0x1ec    str r2, [r3, #24]
    0xe001997c     0x1f0    mov r2, #0
    0xe0019980     0x1f4    str r2, [r3, #4]
    0xe0019984     0x1f8    mov r6, #3
    0xe0019988     0x1fc    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001998c     0x200    bic r3, r3, #1020 
    0xe0019990     0x204    bic r3, r3, #3
    0xe0019994     0x208    ubfx r2, r7, #12, #8
    0xe0019998     0x20c    add r3, r3, r2, lsl #2
    0xe001999c     0x210    add r3, r3, #-805306368 
    0xe00199a0     0x214    ldr sl, [r3]
    0xe00199a4     0x218    tst sl, #2
    0xe00199a8     0x21c    bne e001aa90 <decodeARMMMUInvocation+0x1304>
    0xe00199ac     0x220    tst sl, #1
    0xe00199b0     0x224    bne e001aaa0 <decodeARMMMUInvocation+0x1314>
    0xe00199b4     0x228    movw r3, #13900 
    0xe00199b8     0x22c    movt r3, #57347 
    0xe00199bc     0x230    mov r1, #2
    0xe00199c0     0x234    ldr r0, [r3]
    0xe00199c4     0x238    bl e0014ad8 <setThreadState>
    0xe00199c8     0x23c    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe00199cc     0x240    movw r3, #13900 
    0xe00199d0     0x244    movt r3, #57347 
    0xe00199d4     0x248    mov r1, #2
    0xe00199d8     0x24c    ldr r0, [r3]
    0xe00199dc     0x250    bl e0014ad8 <setThreadState>
    0xe00199e0     0x254    cmp r7, r8
    0xe00199e4     0x258    bcs e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe00199e8     0x25c    mov r1, r5
    0xe00199ec     0x260    mov r0, r4
    0xe00199f0     0x264    bl e00111c8 <setVMRootForFlush>
    0xe00199f4     0x268    mov r4, r0
    0xe00199f8     0x26c    mvn r3, #0
    0xe00199fc     0x270    bic r3, r7, r3, lsl fp
    0xe0019a00     0x274    add r3, r3, sl
    0xe0019a04     0x278    mov r2, r8
    0xe0019a08     0x27c    mov r1, r7
    0xe0019a0c     0x280    mov r0, r9
    0xe0019a10     0x284    bl e0012554 <doFlush>
    0xe0019a14     0x288    cmp r4, #0
    0xe0019a18     0x28c    beq e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019a1c     0x290    movw r3, #13900 
    0xe0019a20     0x294    movt r3, #57347 
    0xe0019a24     0x298    ldr r0, [r3]
    0xe0019a28     0x29c    bl e00110b8 <setVMRoot>
    0xe0019a2c     0x2a0    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019a30     0x2a4    movw r3, #36896 
    0xe0019a34     0x2a8    movt r3, #57346 
    0xe0019a38     0x2ac    mov r6, #3
    0xe0019a3c     0x2b0    str r6, [r3, #24]
    0xe0019a40     0x2b4    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019a44     0x2b8    cmp r0, #35 
    0xe0019a48     0x2bc    beq e0019b70 <decodeARMMMUInvocation+0x3e4>
    0xe0019a4c     0x2c0    cmp r0, #34 
    0xe0019a50     0x2c4    movwne r3, #36896 
    0xe0019a54     0x2c8    movtne r3, #57346 
    0xe0019a58     0x2cc    movne r6, #3
    0xe0019a5c     0x2d0    strne r6, [r3, #24]
    0xe0019a60     0x2d4    bne e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019a64     0x2d8    cmp sl, #0
    0xe0019a68     0x2dc    cmpne r1, #1
    0xe0019a6c     0x2e0    bls e0019c04 <decodeARMMMUInvocation+0x478>
    0xe0019a70     0x2e4    tst r5, #536870912 
    0xe0019a74     0x2e8    bne e0019c1c <decodeARMMMUInvocation+0x490>
    0xe0019a78     0x2ec    ldr r8, [sl]
    0xe0019a7c     0x2f0    and r3, r8, #14
    0xe0019a80     0x2f4    cmp r3, #14
    0xe0019a84     0x2f8    andne r3, r8, #15
    0xe0019a88     0x2fc    uxtbeq r3, r8
    0xe0019a8c     0x300    cmp r3, #9
    0xe0019a90     0x304    bne e0019c3c <decodeARMMMUInvocation+0x4b0>
    0xe0019a94     0x308    tst r8, #16
    0xe0019a98     0x30c    beq e0019c3c <decodeARMMMUInvocation+0x4b0>
    0xe0019a9c     0x310    movw r3, #13900 
    0xe0019aa0     0x314    movt r3, #57347 
    0xe0019aa4     0x318    ldr r3, [r3]
    0xe0019aa8     0x31c    ldr r9, [r3, #8]
    0xe0019aac     0x320    bic r8, r8, #16320 
    0xe0019ab0     0x324    bic r8, r8, #63 
    0xe0019ab4     0x328    ldr sl, [sl, #4]
    0xe0019ab8     0x32c    ubfx sl, sl, #0, #17
    0xe0019abc     0x330    cmn r9, #536870913 
    0xe0019ac0     0x334    bhi e0019c5c <decodeARMMMUInvocation+0x4d0>
    0xe0019ac4     0x338    ldr fp, [r3, #12]
    0xe0019ac8     0x33c    mov r1, sl
    0xe0019acc     0x340    add r0, sp, #56 
    0xe0019ad0     0x344    bl e0010a84 <findPDForASID>
    0xe0019ad4     0x348    ldr r6, [sp, #56]     ; stack access
    0xe0019ad8     0x34c    cmp r6, #0
    0xe0019adc     0x350    bne e0019c7c <decodeARMMMUInvocation+0x4f0>
    0xe0019ae0     0x354    ldr r3, [sp, #60]     ; stack access
    0xe0019ae4     0x358    cmp r8, r3
    0xe0019ae8     0x35c    bne e0019c9c <decodeARMMMUInvocation+0x510>
    0xe0019aec     0x360    lsr r9, r9, #20
    0xe0019af0     0x364    add r3, r8, r9, lsl #2
    0xe0019af4     0x368    str r3, [sp, #20]     ; stack access
    0xe0019af8     0x36c    ldr r3, [r8, r9, lsl #2]
    0xe0019afc     0x370    tst r3, #3
    0xe0019b00     0x374    bne e0019cb8 <decodeARMMMUInvocation+0x52c>
    0xe0019b04     0x378    lsl fp, fp, #8
    0xe0019b08     0x37c    and r2, fp, #512 
    0xe0019b0c     0x380    bic r3, r4, #1020 
    0xe0019b10     0x384    bic r3, r3, #3
    0xe0019b14     0x388    add fp, r3, #805306368 
    0xe0019b18     0x38c    orr fp, fp, #1
    0xe0019b1c     0x390    orr fp, r2, fp
    0xe0019b20     0x394    movw r3, #4095 
    0xe0019b24     0x398    movt r3, #49152 
    0xe0019b28     0x39c    and r3, r3, r5
    0xe0019b2c     0x3a0    orr r3, r3, #536870912 
    0xe0019b30     0x3a4    orr sl, r3, sl, lsl #12
    0xe0019b34     0x3a8    bic sl, sl, #4080 
    0xe0019b38     0x3ac    bic sl, sl, #15
    0xe0019b3c     0x3b0    orr sl, sl, r9
    0xe0019b40     0x3b4    movw r3, #13900 
    0xe0019b44     0x3b8    movt r3, #57347 
    0xe0019b48     0x3bc    mov r1, #2
    0xe0019b4c     0x3c0    ldr r0, [r3]
    0xe0019b50     0x3c4    bl e0014ad8 <setThreadState>
    0xe0019b54     0x3c8    str r4, [r7]
    0xe0019b58     0x3cc    str sl, [r7, #4]
    0xe0019b5c     0x3d0    str fp, [r8, r9, lsl #2]
    0xe0019b60     0x3d4    ldr r3, [sp, #20]     ; stack access
    0xe0019b64     0x3d8    mcr 15, 0, r3, cr7, cr11, {1}
    0xe0019b68     0x3dc    dmb sy
    0xe0019b6c     0x3e0    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019b70     0x3e4    mov r0, r7
    0xe0019b74     0x3e8    bl e0014448 <isFinalCapability>
    0xe0019b78     0x3ec    cmp r0, #0
    0xe0019b7c     0x3f0    beq e0019bb0 <decodeARMMMUInvocation+0x424>
    0xe0019b80     0x3f4    movw r3, #13900 
    0xe0019b84     0x3f8    movt r3, #57347 
    0xe0019b88     0x3fc    mov r1, #2
    0xe0019b8c     0x400    ldr r0, [r3]
    0xe0019b90     0x404    bl e0014ad8 <setThreadState>
    0xe0019b94     0x408    tst r5, #536870912 
    0xe0019b98     0x40c    bne e0019bc8 <decodeARMMMUInvocation+0x43c>
    0xe0019b9c     0x410    ldr r3, [r7, #4]
    0xe0019ba0     0x414    bic r3, r3, #536870912 
    0xe0019ba4     0x418    str r3, [r7, #4]
    0xe0019ba8     0x41c    mov r6, #0
    0xe0019bac     0x420    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019bb0     0x424    movw r3, #36896 
    0xe0019bb4     0x428    movt r3, #57346 
    0xe0019bb8     0x42c    mov r2, #9
    0xe0019bbc     0x430    str r2, [r3, #24]
    0xe0019bc0     0x434    mov r6, #3
    0xe0019bc4     0x438    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019bc8     0x43c    bic r4, r4, #1020 
    0xe0019bcc     0x440    bic r4, r4, #3
    0xe0019bd0     0x444    mov r2, r4
    0xe0019bd4     0x448    lsl r1, r5, #20
    0xe0019bd8     0x44c    ubfx r0, r5, #12, #17
    0xe0019bdc     0x450    bl e00113bc <unmapPageTable>
    0xe0019be0     0x454    mov r1, #1024 
    0xe0019be4     0x458    mov r0, r4
    0xe0019be8     0x45c    bl e0019244 <memzero>
    0xe0019bec     0x460    add r2, r4, #805306368 
    0xe0019bf0     0x464    add r1, r4, #1020 
    0xe0019bf4     0x468    add r1, r1, #3
    0xe0019bf8     0x46c    mov r0, r4
    0xe0019bfc     0x470    bl e00120c8 <cleanCacheRange_PoU>
    0xe0019c00     0x474    b e0019b9c <decodeARMMMUInvocation+0x410>
    0xe0019c04     0x478    movw r3, #36896 
    0xe0019c08     0x47c    movt r3, #57346 
    0xe0019c0c     0x480    mov r2, #7
    0xe0019c10     0x484    str r2, [r3, #24]
    0xe0019c14     0x488    mov r6, #3
    0xe0019c18     0x48c    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019c1c     0x490    movw r3, #36896 
    0xe0019c20     0x494    movt r3, #57346 
    0xe0019c24     0x498    mov r2, #2
    0xe0019c28     0x49c    str r2, [r3, #24]
    0xe0019c2c     0x4a0    mov r2, #0
    0xe0019c30     0x4a4    str r2, [r3, #4]
    0xe0019c34     0x4a8    mov r6, #3
    0xe0019c38     0x4ac    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019c3c     0x4b0    movw r3, #36896 
    0xe0019c40     0x4b4    movt r3, #57346 
    0xe0019c44     0x4b8    mov r2, #2
    0xe0019c48     0x4bc    str r2, [r3, #24]
    0xe0019c4c     0x4c0    mov r2, #1
    0xe0019c50     0x4c4    str r2, [r3, #4]
    0xe0019c54     0x4c8    mov r6, #3
    0xe0019c58     0x4cc    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019c5c     0x4d0    movw r3, #36896 
    0xe0019c60     0x4d4    movt r3, #57346 
    0xe0019c64     0x4d8    mov r2, #1
    0xe0019c68     0x4dc    str r2, [r3, #24]
    0xe0019c6c     0x4e0    mov r2, #0
    0xe0019c70     0x4e4    str r2, [r3]
    0xe0019c74     0x4e8    mov r6, #3
    0xe0019c78     0x4ec    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019c7c     0x4f0    movw r3, #36896 
    0xe0019c80     0x4f4    movt r3, #57346 
    0xe0019c84     0x4f8    mov r2, #6
    0xe0019c88     0x4fc    str r2, [r3, #24]
    0xe0019c8c     0x500    mov r2, #0
    0xe0019c90     0x504    str r2, [r3, #20]
    0xe0019c94     0x508    mov r6, #3
    0xe0019c98     0x50c    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019c9c     0x510    movw r3, #36896 
    0xe0019ca0     0x514    movt r3, #57346 
    0xe0019ca4     0x518    mov r2, #2
    0xe0019ca8     0x51c    str r2, [r3, #24]
    0xe0019cac     0x520    mov r2, #1
    0xe0019cb0     0x524    str r2, [r3, #4]
    0xe0019cb4     0x528    b e0019c94 <decodeARMMMUInvocation+0x508>
    0xe0019cb8     0x52c    movw r3, #36896 
    0xe0019cbc     0x530    movt r3, #57346 
    0xe0019cc0     0x534    mov r2, #8
    0xe0019cc4     0x538    str r2, [r3, #24]
    0xe0019cc8     0x53c    mov r6, #3
    0xe0019ccc     0x540    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019cd0     0x544    sub r3, r0, #36 
    0xe0019cd4     0x548    cmp r3, #6
    0xe0019cd8     0x54c    ldrls pc, [pc, r3, lsl #2]
    0xe0019cdc     0x550    b e001a6f4 <decodeARMMMUInvocation+0xf68>
    0xe0019ce0     0x554    .word 0xe0019cfc
    0xe0019ce4     0x558    .word 0xe001a3cc
    0xe0019ce8     0x55c    .word 0xe001a4b0
    0xe0019cec     0x560    .word 0xe001a4b0
    0xe0019cf0     0x564    .word 0xe001a4b0
    0xe0019cf4     0x568    .word 0xe001a4b0
    0xe0019cf8     0x56c    .word 0xe001a688
    0xe0019cfc     0x570    cmp sl, #0
    0xe0019d00     0x574    cmpne r1, #2
    0xe0019d04     0x578    bls e0019d40 <decodeARMMMUInvocation+0x5b4>
    0xe0019d08     0x57c    ldr r9, [sl]
    0xe0019d0c     0x580    cmp r8, #3
    0xe0019d10     0x584    lsreq fp, r5, #30
    0xe0019d14     0x588    beq e0019d34 <decodeARMMMUInvocation+0x5a8>
    0xe0019d18     0x58c    cmp r8, #1
    0xe0019d1c     0x590    beq e0019d58 <decodeARMMMUInvocation+0x5cc>
    0xe0019d20     0x594    cmp r8, #3
    0xe0019d24     0x598    movne fp, #0
    0xe0019d28     0x59c    strne fp, [sp, #24]   ; stack access
    0xe0019d2c     0x5a0    bne e0019d64 <decodeARMMMUInvocation+0x5d8>
    0xe0019d30     0x5a4    mov fp, #0
    0xe0019d34     0x5a8    ubfx r3, r5, #18, #2
    0xe0019d38     0x5ac    str r3, [sp, #24]     ; stack access
    0xe0019d3c     0x5b0    b e0019d64 <decodeARMMMUInvocation+0x5d8>
    0xe0019d40     0x5b4    movw r3, #36896 
    0xe0019d44     0x5b8    movt r3, #57346 
    0xe0019d48     0x5bc    mov r2, #7
    0xe0019d4c     0x5c0    str r2, [r3, #24]
    0xe0019d50     0x5c4    mov r6, #3
    0xe0019d54     0x5c8    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019d58     0x5cc    ubfx r3, r5, #20, #2
    0xe0019d5c     0x5d0    str r3, [sp, #24]     ; stack access
    0xe0019d60     0x5d4    mov fp, #0
    0xe0019d64     0x5d8    and r3, r9, #14
    0xe0019d68     0x5dc    cmp r3, #14
    0xe0019d6c     0x5e0    andne r3, r9, #15
    0xe0019d70     0x5e4    uxtbeq r3, r9
    0xe0019d74     0x5e8    cmp r3, #9
    0xe0019d78     0x5ec    bne e0019dfc <decodeARMMMUInvocation+0x670>
    0xe0019d7c     0x5f0    tst r9, #16
    0xe0019d80     0x5f4    beq e0019dfc <decodeARMMMUInvocation+0x670>
    0xe0019d84     0x5f8    ldr r3, [sl, #4]
    0xe0019d88     0x5fc    ubfx r3, r3, #0, #17
    0xe0019d8c     0x600    str r3, [sp, #20]     ; stack access
    0xe0019d90     0x604    uxtb r3, r8
    0xe0019d94     0x608    str r3, [sp, #28]     ; stack access
    0xe0019d98     0x60c    cmp r3, #1
    0xe0019d9c     0x610    lsreq r3, r4, #14
    0xe0019da0     0x614    andeq r3, r3, #130048 
    0xe0019da4     0x618    addeq r3, r3, r5, lsr #22
    0xe0019da8     0x61c    lsrne r3, r4, #12
    0xe0019dac     0x620    andne r3, r3, #130048 
    0xe0019db0     0x624    ubfxne r2, r5, #20, #10
    0xe0019db4     0x628    orrne r3, r3, r2
    0xe0019db8     0x62c    movw r2, #13900 
    0xe0019dbc     0x630    movt r2, #57347 
    0xe0019dc0     0x634    ldr r2, [r2]
    0xe0019dc4     0x638    ldr sl, [r2, #8]
    0xe0019dc8     0x63c    cmp r3, #0
    0xe0019dcc     0x640    beq e0019e54 <decodeARMMMUInvocation+0x6c8>
    0xe0019dd0     0x644    ldr r1, [sp, #20]     ; stack access
    0xe0019dd4     0x648    cmp r1, r3
    0xe0019dd8     0x64c    beq e0019e1c <decodeARMMMUInvocation+0x690>
    0xe0019ddc     0x650    movw r3, #36896 
    0xe0019de0     0x654    movt r3, #57346 
    0xe0019de4     0x658    mov r2, #2
    0xe0019de8     0x65c    str r2, [r3, #24]
    0xe0019dec     0x660    mov r2, #1
    0xe0019df0     0x664    str r2, [r3, #4]
    0xe0019df4     0x668    mov r6, #3
    0xe0019df8     0x66c    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019dfc     0x670    movw r3, #36896 
    0xe0019e00     0x674    movt r3, #57346 
    0xe0019e04     0x678    mov r2, #2
    0xe0019e08     0x67c    str r2, [r3, #24]
    0xe0019e0c     0x680    mov r2, #1
    0xe0019e10     0x684    str r2, [r3, #4]
    0xe0019e14     0x688    mov r6, #3
    0xe0019e18     0x68c    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019e1c     0x690    ldr r3, [sp, #28]     ; stack access
    0xe0019e20     0x694    cmp r3, #1
    0xe0019e24     0x698    lsleq r3, r5, #12
    0xe0019e28     0x69c    lslne r3, r5, #14
    0xe0019e2c     0x6a0    cmp sl, r3
    0xe0019e30     0x6a4    beq e0019e88 <decodeARMMMUInvocation+0x6fc>
    0xe0019e34     0x6a8    movw r3, #36896 
    0xe0019e38     0x6ac    movt r3, #57346 
    0xe0019e3c     0x6b0    mov r2, #1
    0xe0019e40     0x6b4    str r2, [r3, #24]
    0xe0019e44     0x6b8    mov r2, #0
    0xe0019e48     0x6bc    str r2, [r3]
    0xe0019e4c     0x6c0    mov r6, #3
    0xe0019e50     0x6c4    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019e54     0x6c8    cmp fp, #3
    0xe0019e58     0x6cc    ldrls pc, [pc, fp, lsl #2]
    0xe0019e5c     0x6d0    b e0019ef4 <decodeARMMMUInvocation+0x768>
    0xe0019e60     0x6d4    .word 0xe0019ef8
    0xe0019e64     0x6d8    .word 0xe0019e70
    0xe0019e68     0x6dc    .word 0xe0019f00
    0xe0019e6c     0x6e0    .word 0xe0019eec
    0xe0019e70     0x6e4    mov r1, #16
    0xe0019e74     0x6e8    sub r3, sl, #1
    0xe0019e78     0x6ec    mov r0, #1
    0xe0019e7c     0x6f0    add r3, r3, r0, lsl r1
    0xe0019e80     0x6f4    cmn r3, #536870913 
    0xe0019e84     0x6f8    bhi e0019f08 <decodeARMMMUInvocation+0x77c>
    0xe0019e88     0x6fc    ldr r3, [r2, #12]
    0xe0019e8c     0x700    str r3, [sp, #36]     ; stack access
    0xe0019e90     0x704    ldr r3, [r2, #16]
    0xe0019e94     0x708    str r3, [sp, #32]     ; stack access
    0xe0019e98     0x70c    ldr r1, [sp, #20]     ; stack access
    0xe0019e9c     0x710    add r0, sp, #56 
    0xe0019ea0     0x714    bl e0010a84 <findPDForASID>
    0xe0019ea4     0x718    ldr r6, [sp, #56]     ; stack access
    0xe0019ea8     0x71c    cmp r6, #0
    0xe0019eac     0x720    bne e0019f24 <decodeARMMMUInvocation+0x798>
    0xe0019eb0     0x724    bic r9, r9, #16320 
    0xe0019eb4     0x728    bic r9, r9, #63 
    0xe0019eb8     0x72c    ldr r3, [sp, #60]     ; stack access
    0xe0019ebc     0x730    cmp r9, r3
    0xe0019ec0     0x734    bne e0019f44 <decodeARMMMUInvocation+0x7b8>
    0xe0019ec4     0x738    ldr r1, [sp, #36]     ; stack access
    0xe0019ec8     0x73c    ldr r0, [sp, #24]     ; stack access
    0xe0019ecc     0x740    bl e0010a34 <maskVMRights>
    0xe0019ed0     0x744    cmp fp, #3
    0xe0019ed4     0x748    ldrls pc, [pc, fp, lsl #2]
    0xe0019ed8     0x74c    b e0019fa0 <decodeARMMMUInvocation+0x814>
    0xe0019edc     0x750    .word 0xe0019fa4
    0xe0019ee0     0x754    .word 0xe0019f60
    0xe0019ee4     0x758    .word 0xe0019fac
    0xe0019ee8     0x75c    .word 0xe0019f98
    0xe0019eec     0x760    mov r1, #24
    0xe0019ef0     0x764    b e0019e74 <decodeARMMMUInvocation+0x6e8>
    0xe0019ef4     0x768    bl e0010904 <halt>
    0xe0019ef8     0x76c    mov r1, #12
    0xe0019efc     0x770    b e0019e74 <decodeARMMMUInvocation+0x6e8>
    0xe0019f00     0x774    mov r1, #20
    0xe0019f04     0x778    b e0019e74 <decodeARMMMUInvocation+0x6e8>
    0xe0019f08     0x77c    movw r3, #36896 
    0xe0019f0c     0x780    movt r3, #57346 
    0xe0019f10     0x784    str r0, [r3, #24]
    0xe0019f14     0x788    mov r2, #0
    0xe0019f18     0x78c    str r2, [r3]
    0xe0019f1c     0x790    mov r6, #3
    0xe0019f20     0x794    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019f24     0x798    movw r3, #36896 
    0xe0019f28     0x79c    movt r3, #57346 
    0xe0019f2c     0x7a0    mov r2, #6
    0xe0019f30     0x7a4    str r2, [r3, #24]
    0xe0019f34     0x7a8    mov r2, #0
    0xe0019f38     0x7ac    str r2, [r3, #20]
    0xe0019f3c     0x7b0    mov r6, #3
    0xe0019f40     0x7b4    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019f44     0x7b8    movw r3, #36896 
    0xe0019f48     0x7bc    movt r3, #57346 
    0xe0019f4c     0x7c0    mov r2, #2
    0xe0019f50     0x7c4    str r2, [r3, #24]
    0xe0019f54     0x7c8    mov r2, #1
    0xe0019f58     0x7cc    str r2, [r3, #4]
    0xe0019f5c     0x7d0    b e0019f3c <decodeARMMMUInvocation+0x7b0>
    0xe0019f60     0x7d4    mov r2, #16
    0xe0019f64     0x7d8    mvn r3, #0
    0xe0019f68     0x7dc    bics r3, sl, r3, lsl r2
    0xe0019f6c     0x7e0    bne e0019fb4 <decodeARMMMUInvocation+0x828>
    0xe0019f70     0x7e4    cmp r8, #1
    0xe0019f74     0x7e8    beq e0019fcc <decodeARMMMUInvocation+0x840>
    0xe0019f78     0x7ec    cmp r8, #3
    0xe0019f7c     0x7f0    beq e001a004 <decodeARMMMUInvocation+0x878>
    0xe0019f80     0x7f4    ldr r3, [sp, #28]     ; stack access
    0xe0019f84     0x7f8    cmp r3, #1
    0xe0019f88     0x7fc    movne r8, #805306368 
    0xe0019f8c     0x800    bne e001a014 <decodeARMMMUInvocation+0x888>
    0xe0019f90     0x804    mov r8, #805306368 
    0xe0019f94     0x808    b e0019fdc <decodeARMMMUInvocation+0x850>
    0xe0019f98     0x80c    mov r2, #24
    0xe0019f9c     0x810    b e0019f64 <decodeARMMMUInvocation+0x7d8>
    0xe0019fa0     0x814    bl e0010904 <halt>
    0xe0019fa4     0x818    mov r2, #12
    0xe0019fa8     0x81c    b e0019f64 <decodeARMMMUInvocation+0x7d8>
    0xe0019fac     0x820    mov r2, #20
    0xe0019fb0     0x824    b e0019f64 <decodeARMMMUInvocation+0x7d8>
    0xe0019fb4     0x828    movw r3, #36896 
    0xe0019fb8     0x82c    movt r3, #57346 
    0xe0019fbc     0x830    mov r2, #5
    0xe0019fc0     0x834    str r2, [r3, #24]
    0xe0019fc4     0x838    mov r6, #3
    0xe0019fc8     0x83c    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe0019fcc     0x840    lsl r8, r4, #8
    0xe0019fd0     0x844    bic r8, r8, #4080 
    0xe0019fd4     0x848    bic r8, r8, #15
    0xe0019fd8     0x84c    add r8, r8, #805306368 
    0xe0019fdc     0x850    ldr r2, [sp, #20]     ; stack access
    0xe0019fe0     0x854    lsr r3, r2, #10
    0xe0019fe4     0x858    bic r4, r4, #2130706432 
    0xe0019fe8     0x85c    orr r4, r4, r3, lsl #24
    0xe0019fec     0x860    ubfx r5, r5, #0, #22
    0xe0019ff0     0x864    orr r5, r5, r2, lsl #22
    0xe0019ff4     0x868    lsr r5, r5, #20
    0xe0019ff8     0x86c    lsl r5, r5, #20
    0xe0019ffc     0x870    orr r5, r5, sl, lsr #12
    0xe001a000     0x874    b e001a044 <decodeARMMMUInvocation+0x8b8>
    0xe001a004     0x878    lsl r8, r4, #10
    0xe001a008     0x87c    bic r8, r8, #16320 
    0xe001a00c     0x880    bic r8, r8, #63 
    0xe001a010     0x884    add r8, r8, #805306368 
    0xe001a014     0x888    ldr r2, [sp, #20]     ; stack access
    0xe001a018     0x88c    lsr r3, r2, #10
    0xe001a01c     0x890    bic r4, r4, #532676608 
    0xe001a020     0x894    orr r4, r4, r3, lsl #22
    0xe001a024     0x898    mov r3, #0
    0xe001a028     0x89c    movt r3, #16368 
    0xe001a02c     0x8a0    and r2, r3, r2, lsl #20
    0xe001a030     0x8a4    mov r3, #0
    0xe001a034     0x8a8    movt r3, #49164 
    0xe001a038     0x8ac    and r3, r3, r5
    0xe001a03c     0x8b0    orr r3, r3, r2
    0xe001a040     0x8b4    orr r5, r3, sl, lsr #14
    0xe001a044     0x8b8    cmp fp, #1
    0xe001a048     0x8bc    bls e001a0a0 <decodeARMMMUInvocation+0x914>
    0xe001a04c     0x8c0    cmp fp, #2
    0xe001a050     0x8c4    beq e001a268 <decodeARMMMUInvocation+0xadc>
    0xe001a054     0x8c8    cmp fp, #3
    0xe001a058     0x8cc    bne e001a3c8 <decodeARMMMUInvocation+0xc3c>
    0xe001a05c     0x8d0    lsr sl, sl, #20
    0xe001a060     0x8d4    add r9, r9, sl, lsl #2
    0xe001a064     0x8d8    str r0, [sp, #8]      ; stack access
    0xe001a068     0x8dc    mov r3, #0
    0xe001a06c     0x8e0    str r3, [sp, #4]      ; stack access
    0xe001a070     0x8e4    ldr r2, [sp, #32]     ; stack access
    0xe001a074     0x8e8    ubfx r3, r2, #2, #1
    0xe001a078     0x8ec    str r3, [sp]          ; stack access
    0xe001a07c     0x8f0    and r3, r2, #1
    0xe001a080     0x8f4    ubfx r2, r2, #1, #1
    0xe001a084     0x8f8    mov r1, r8
    0xe001a088     0x8fc    mov r0, #3
    0xe001a08c     0x900    bl e0010954 <makeUserPDE>
    0xe001a090     0x904    str r0, [sp, #60]     ; stack access
    0xe001a094     0x908    sub r3, r9, #4
    0xe001a098     0x90c    add r1, r9, #60 
    0xe001a09c     0x910    b e001a36c <decodeARMMMUInvocation+0xbe0>
    0xe001a0a0     0x914    cmp fp, #0
    0xe001a0a4     0x918    beq e001a12c <decodeARMMMUInvocation+0x9a0>
    0xe001a0a8     0x91c    cmp fp, #1
    0xe001a0ac     0x920    bne e001a264 <decodeARMMMUInvocation+0xad8>
    0xe001a0b0     0x924    ldr r3, [sp, #32]     ; stack access
    0xe001a0b4     0x928    ubfx fp, r3, #2, #1
    0xe001a0b8     0x92c    bl e0010910 <APFromVMRights>
    0xe001a0bc     0x930    ldr r3, [sp, #32]     ; stack access
    0xe001a0c0     0x934    tst r3, #1
    0xe001a0c4     0x938    movwne r3, #22533 
    0xe001a0c8     0x93c    movweq r3, #3073 
    0xe001a0cc     0x940    orr fp, r3, fp, lsl #15
    0xe001a0d0     0x944    lsr r8, r8, #16
    0xe001a0d4     0x948    lsl r8, r8, #16
    0xe001a0d8     0x94c    orr r8, fp, r8
    0xe001a0dc     0x950    lsl r3, r0, #4
    0xe001a0e0     0x954    and r3, r3, #48 
    0xe001a0e4     0x958    orr r8, r8, r3
    0xe001a0e8     0x95c    mov r2, sl
    0xe001a0ec     0x960    mov r1, r9
    0xe001a0f0     0x964    add r0, sp, #40 
    0xe001a0f4     0x968    bl e0010ea0 <lookupPTSlot>
    0xe001a0f8     0x96c    ldr r0, [sp, #44]     ; stack access
    0xe001a0fc     0x970    ldr r3, [sp, #40]     ; stack access
    0xe001a100     0x974    cmp r3, #0
    0xe001a104     0x978    subeq r3, r0, #4
    0xe001a108     0x97c    addeq r1, r0, #60 
    0xe001a10c     0x980    beq e001a22c <decodeARMMMUInvocation+0xaa0>
    0xe001a110     0x984    movw r3, #36896 
    0xe001a114     0x988    movt r3, #57346 
    0xe001a118     0x98c    mov r2, #6
    0xe001a11c     0x990    str r2, [r3, #24]
    0xe001a120     0x994    mov r2, #0
    0xe001a124     0x998    str r2, [r3, #20]
    0xe001a128     0x99c    b e001a248 <decodeARMMMUInvocation+0xabc>
    0xe001a12c     0x9a0    ldr r3, [sp, #32]     ; stack access
    0xe001a130     0x9a4    ubfx fp, r3, #2, #1
    0xe001a134     0x9a8    bl e0010910 <APFromVMRights>
    0xe001a138     0x9ac    ldr r3, [sp, #32]     ; stack access
    0xe001a13c     0x9b0    tst r3, #1
    0xe001a140     0x9b4    beq e001a1ec <decodeARMMMUInvocation+0xa60>
    0xe001a144     0x9b8    orr fp, fp, #2368 
    0xe001a148     0x9bc    orr fp, fp, #6
    0xe001a14c     0x9c0    orr fp, fp, r8
    0xe001a150     0x9c4    lsl r8, r0, #4
    0xe001a154     0x9c8    and r8, r8, #48 
    0xe001a158     0x9cc    orr r8, fp, r8
    0xe001a15c     0x9d0    mov r2, sl
    0xe001a160     0x9d4    mov r1, r9
    0xe001a164     0x9d8    add r0, sp, #40 
    0xe001a168     0x9dc    bl e0010ea0 <lookupPTSlot>
    0xe001a16c     0x9e0    ldr r3, [sp, #44]     ; stack access
    0xe001a170     0x9e4    ldr r2, [sp, #40]     ; stack access
    0xe001a174     0x9e8    cmp r2, #0
    0xe001a178     0x9ec    bne e001a208 <decodeARMMMUInvocation+0xa7c>
    0xe001a17c     0x9f0    ldr r2, [r3]
    0xe001a180     0x9f4    tst r2, #2
    0xe001a184     0x9f8    bne e001a190 <decodeARMMMUInvocation+0xa04>
    0xe001a188     0x9fc    tst r2, #1
    0xe001a18c     0xa00    bne e001aab0 <decodeARMMMUInvocation+0x1324>
    0xe001a190     0xa04    str r8, [sp, #60]     ; stack access
    0xe001a194     0xa08    str r3, [sp, #64]     ; stack access
    0xe001a198     0xa0c    mov r3, #1
    0xe001a19c     0xa10    str r3, [sp, #68]     ; stack access
    0xe001a1a0     0xa14    movw r3, #13900 
    0xe001a1a4     0xa18    movt r3, #57347 
    0xe001a1a8     0xa1c    mov r1, #2
    0xe001a1ac     0xa20    ldr r0, [r3]
    0xe001a1b0     0xa24    bl e0014ad8 <setThreadState>
    0xe001a1b4     0xa28    ldr r1, [sp, #60]     ; stack access
    0xe001a1b8     0xa2c    ldr r0, [sp, #64]     ; stack access
    0xe001a1bc     0xa30    ldr r2, [sp, #68]     ; stack access
    0xe001a1c0     0xa34    str r4, [r7]
    0xe001a1c4     0xa38    str r5, [r7, #4]
    0xe001a1c8     0xa3c    ldr r3, [r0]
    0xe001a1cc     0xa40    tst r3, #2
    0xe001a1d0     0xa44    bne e001aae0 <decodeARMMMUInvocation+0x1354>
    0xe001a1d4     0xa48    tst r3, #1
    0xe001a1d8     0xa4c    bne e001aad8 <decodeARMMMUInvocation+0x134c>
    0xe001a1dc     0xa50    cmp r2, #0
    0xe001a1e0     0xa54    beq e001ab24 <decodeARMMMUInvocation+0x1398>
    0xe001a1e4     0xa58    mov r4, #2
    0xe001a1e8     0xa5c    b e001aaec <decodeARMMMUInvocation+0x1360>
    0xe001a1ec     0xa60    lsl r3, r0, #4
    0xe001a1f0     0xa64    and r3, r3, #48 
    0xe001a1f4     0xa68    orr fp, fp, #3072 
    0xe001a1f8     0xa6c    orr fp, fp, #2
    0xe001a1fc     0xa70    orr r8, fp, r8
    0xe001a200     0xa74    orr r8, r3, r8
    0xe001a204     0xa78    b e001a15c <decodeARMMMUInvocation+0x9d0>
    0xe001a208     0xa7c    movw r3, #36896 
    0xe001a20c     0xa80    movt r3, #57346 
    0xe001a210     0xa84    mov r2, #6
    0xe001a214     0xa88    str r2, [r3, #24]
    0xe001a218     0xa8c    mov r2, #0
    0xe001a21c     0xa90    str r2, [r3, #20]
    0xe001a220     0xa94    b e001a248 <decodeARMMMUInvocation+0xabc>
    0xe001a224     0xa98    cmp r1, r3
    0xe001a228     0xa9c    beq e001a250 <decodeARMMMUInvocation+0xac4>
    0xe001a22c     0xaa0    ldr r2, [r3, #4]!
    0xe001a230     0xaa4    tst r2, #2
    0xe001a234     0xaa8    beq e001a224 <decodeARMMMUInvocation+0xa98>
    0xe001a238     0xaac    movw r3, #36896 
    0xe001a23c     0xab0    movt r3, #57346 
    0xe001a240     0xab4    mov r2, #8
    0xe001a244     0xab8    str r2, [r3, #24]
    0xe001a248     0xabc    mov r6, #3
    0xe001a24c     0xac0    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a250     0xac4    str r8, [sp, #60]     ; stack access
    0xe001a254     0xac8    str r0, [sp, #64]     ; stack access
    0xe001a258     0xacc    mov r3, #16
    0xe001a25c     0xad0    str r3, [sp, #68]     ; stack access
    0xe001a260     0xad4    b e001a1a0 <decodeARMMMUInvocation+0xa14>
    0xe001a264     0xad8    bl e0010904 <halt>
    0xe001a268     0xadc    lsr sl, sl, #20
    0xe001a26c     0xae0    add fp, r9, sl, lsl #2
    0xe001a270     0xae4    str r0, [sp, #8]      ; stack access
    0xe001a274     0xae8    mov r3, #0
    0xe001a278     0xaec    str r3, [sp, #4]      ; stack access
    0xe001a27c     0xaf0    ldr r2, [sp, #32]     ; stack access
    0xe001a280     0xaf4    ubfx r3, r2, #2, #1
    0xe001a284     0xaf8    str r3, [sp]          ; stack access
    0xe001a288     0xafc    and r3, r2, #1
    0xe001a28c     0xb00    ubfx r2, r2, #1, #1
    0xe001a290     0xb04    mov r1, r8
    0xe001a294     0xb08    mov r0, #2
    0xe001a298     0xb0c    bl e0010954 <makeUserPDE>
    0xe001a29c     0xb10    str r0, [sp, #60]     ; stack access
    0xe001a2a0     0xb14    ldr r3, [r9, sl, lsl #2]
    0xe001a2a4     0xb18    ands r2, r3, #3
    0xe001a2a8     0xb1c    bne e001a340 <decodeARMMMUInvocation+0xbb4>
    0xe001a2ac     0xb20    mov r3, #0
    0xe001a2b0     0xb24    str r3, [sp, #56]     ; stack access
    0xe001a2b4     0xb28    str fp, [sp, #64]     ; stack access
    0xe001a2b8     0xb2c    mov r3, #1
    0xe001a2bc     0xb30    str r3, [sp, #68]     ; stack access
    0xe001a2c0     0xb34    add ip, sp, #40 
    0xe001a2c4     0xb38    add r3, sp, #56 
    0xe001a2c8     0xb3c    ldm r3, {r0, r1, r2, r3}  ; stack access
    0xe001a2cc     0xb40    stm ip, {r0, r1, r2, r3}  ; stack access
    0xe001a2d0     0xb44    movw r3, #13900 
    0xe001a2d4     0xb48    movt r3, #57347 
    0xe001a2d8     0xb4c    mov r1, #2
    0xe001a2dc     0xb50    ldr r0, [r3]
    0xe001a2e0     0xb54    bl e0014ad8 <setThreadState>
    0xe001a2e4     0xb58    ldr r2, [sp, #44]     ; stack access
    0xe001a2e8     0xb5c    ldr r0, [sp, #48]     ; stack access
    0xe001a2ec     0xb60    ldr ip, [sp, #52]     ; stack access
    0xe001a2f0     0xb64    str r4, [r7]
    0xe001a2f4     0xb68    str r5, [r7, #4]
    0xe001a2f8     0xb6c    ldr r4, [r0]
    0xe001a2fc     0xb70    and r4, r4, #3
    0xe001a300     0xb74    cmp ip, #0
    0xe001a304     0xb78    movne r3, r0
    0xe001a308     0xb7c    addne r1, r0, ip, lsl #2
    0xe001a30c     0xb80    beq e001a31c <decodeARMMMUInvocation+0xb90>
    0xe001a310     0xb84    str r2, [r3], #4
    0xe001a314     0xb88    cmp r3, r1
    0xe001a318     0xb8c    bne e001a310 <decodeARMMMUInvocation+0xb84>
    0xe001a31c     0xb90    add r1, r0, ip, lsl #2
    0xe001a320     0xb94    add r2, r0, #805306368 
    0xe001a324     0xb98    sub r1, r1, #1
    0xe001a328     0xb9c    bl e00120c8 <cleanCacheRange_PoU>
    0xe001a32c     0xba0    cmp r4, #0
    0xe001a330     0xba4    beq e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a334     0xba8    ldr r0, [sp, #20]     ; stack access
    0xe001a338     0xbac    bl e0011404 <invalidateTLBByASID>
    0xe001a33c     0xbb0    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a340     0xbb4    cmp r2, #2
    0xe001a344     0xbb8    bne e001a350 <decodeARMMMUInvocation+0xbc4>
    0xe001a348     0xbbc    tst r3, #262144 
    0xe001a34c     0xbc0    beq e001a2ac <decodeARMMMUInvocation+0xb20>
    0xe001a350     0xbc4    movw r3, #36896 
    0xe001a354     0xbc8    movt r3, #57346 
    0xe001a358     0xbcc    mov r2, #8
    0xe001a35c     0xbd0    str r2, [r3, #24]
    0xe001a360     0xbd4    b e001a398 <decodeARMMMUInvocation+0xc0c>
    0xe001a364     0xbd8    cmp r3, r1
    0xe001a368     0xbdc    beq e001a3a0 <decodeARMMMUInvocation+0xc14>
    0xe001a36c     0xbe0    ldr r2, [r3, #4]!
    0xe001a370     0xbe4    ands r0, r2, #3
    0xe001a374     0xbe8    beq e001a364 <decodeARMMMUInvocation+0xbd8>
    0xe001a378     0xbec    cmp r0, #2
    0xe001a37c     0xbf0    bne e001a388 <decodeARMMMUInvocation+0xbfc>
    0xe001a380     0xbf4    tst r2, #262144 
    0xe001a384     0xbf8    bne e001a364 <decodeARMMMUInvocation+0xbd8>
    0xe001a388     0xbfc    movw r3, #36896 
    0xe001a38c     0xc00    movt r3, #57346 
    0xe001a390     0xc04    mov r2, #8
    0xe001a394     0xc08    str r2, [r3, #24]
    0xe001a398     0xc0c    mov r6, #3
    0xe001a39c     0xc10    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a3a0     0xc14    mov r3, #0
    0xe001a3a4     0xc18    str r3, [sp, #56]     ; stack access
    0xe001a3a8     0xc1c    str r9, [sp, #64]     ; stack access
    0xe001a3ac     0xc20    mov r3, #16
    0xe001a3b0     0xc24    str r3, [sp, #68]     ; stack access
    0xe001a3b4     0xc28    add ip, sp, #40 
    0xe001a3b8     0xc2c    add r3, sp, #56 
    0xe001a3bc     0xc30    ldm r3, {r0, r1, r2, r3}  ; stack access
    0xe001a3c0     0xc34    stm ip, {r0, r1, r2, r3}  ; stack access
    0xe001a3c4     0xc38    b e001a2d0 <decodeARMMMUInvocation+0xb44>
    0xe001a3c8     0xc3c    bl e0010904 <halt>
    0xe001a3cc     0xc40    movw r3, #13900 
    0xe001a3d0     0xc44    movt r3, #57347 
    0xe001a3d4     0xc48    mov r1, #2
    0xe001a3d8     0xc4c    ldr r0, [r3]
    0xe001a3dc     0xc50    bl e0014ad8 <setThreadState>
    0xe001a3e0     0xc54    uxtb r3, r8
    0xe001a3e4     0xc58    cmp r3, #1
    0xe001a3e8     0xc5c    lsreq r1, r4, #14
    0xe001a3ec     0xc60    andeq r1, r1, #130048 
    0xe001a3f0     0xc64    addeq r1, r1, r5, lsr #22
    0xe001a3f4     0xc68    lsrne r1, r4, #12
    0xe001a3f8     0xc6c    andne r1, r1, #130048 
    0xe001a3fc     0xc70    ubfxne r2, r5, #20, #10
    0xe001a400     0xc74    orrne r1, r1, r2
    0xe001a404     0xc78    cmp r1, #0
    0xe001a408     0xc7c    beq e001a458 <decodeARMMMUInvocation+0xccc>
    0xe001a40c     0xc80    cmp r8, #3
    0xe001a410     0xc84    lsreq r0, r5, #30
    0xe001a414     0xc88    beq e001a42c <decodeARMMMUInvocation+0xca0>
    0xe001a418     0xc8c    cmp r3, #1
    0xe001a41c     0xc90    lsleq r2, r5, #12
    0xe001a420     0xc94    moveq r0, #0
    0xe001a424     0xc98    beq e001a430 <decodeARMMMUInvocation+0xca4>
    0xe001a428     0xc9c    mov r0, #0
    0xe001a42c     0xca0    lsl r2, r5, #14
    0xe001a430     0xca4    cmp r8, #1
    0xe001a434     0xca8    beq e001a448 <decodeARMMMUInvocation+0xcbc>
    0xe001a438     0xcac    cmp r8, #3
    0xe001a43c     0xcb0    beq e001a4a0 <decodeARMMMUInvocation+0xd14>
    0xe001a440     0xcb4    mov r3, #0
    0xe001a444     0xcb8    b e001a454 <decodeARMMMUInvocation+0xcc8>
    0xe001a448     0xcbc    lsl r3, r4, #8
    0xe001a44c     0xcc0    bic r3, r3, #4080 
    0xe001a450     0xcc4    bic r3, r3, #15
    0xe001a454     0xcc8    bl e00120fc <unmapPage>
    0xe001a458     0xccc    ldr r3, [r7]
    0xe001a45c     0xcd0    ldr r1, [r7, #4]
    0xe001a460     0xcd4    and r2, r3, #14
    0xe001a464     0xcd8    cmp r2, #14
    0xe001a468     0xcdc    andne r2, r3, #15
    0xe001a46c     0xce0    uxtbeq r2, r3
    0xe001a470     0xce4    uxtb r2, r2
    0xe001a474     0xce8    cmp r2, #1
    0xe001a478     0xcec    biceq r3, r3, #2130706432 
    0xe001a47c     0xcf0    andeq r2, r1, #3145728 
    0xe001a480     0xcf4    bicne r3, r3, #532676608 
    0xe001a484     0xcf8    movne r2, #0
    0xe001a488     0xcfc    movtne r2, #49164 
    0xe001a48c     0xd00    andne r2, r2, r1
    0xe001a490     0xd04    str r3, [r7]
    0xe001a494     0xd08    str r2, [r7, #4]
    0xe001a498     0xd0c    mov r6, #0
    0xe001a49c     0xd10    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a4a0     0xd14    lsl r3, r4, #10
    0xe001a4a4     0xd18    bic r3, r3, #16320 
    0xe001a4a8     0xd1c    bic r3, r3, #63 
    0xe001a4ac     0xd20    b e001a454 <decodeARMMMUInvocation+0xcc8>
    0xe001a4b0     0xd24    cmp r1, #1
    0xe001a4b4     0xd28    bls e001a550 <decodeARMMMUInvocation+0xdc4>
    0xe001a4b8     0xd2c    uxtb r3, r8
    0xe001a4bc     0xd30    cmp r3, #1
    0xe001a4c0     0xd34    lsreq r7, r4, #14
    0xe001a4c4     0xd38    andeq r7, r7, #130048 
    0xe001a4c8     0xd3c    addeq r7, r7, r5, lsr #22
    0xe001a4cc     0xd40    lsleq r3, r5, #12
    0xe001a4d0     0xd44    lsrne r7, r4, #12
    0xe001a4d4     0xd48    andne r7, r7, #130048 
    0xe001a4d8     0xd4c    ubfxne r3, r5, #20, #10
    0xe001a4dc     0xd50    orrne r7, r7, r3
    0xe001a4e0     0xd54    lslne r3, r5, #14
    0xe001a4e4     0xd58    str r3, [sp, #20]     ; stack access
    0xe001a4e8     0xd5c    cmp r7, #0
    0xe001a4ec     0xd60    movweq r3, #36896 
    0xe001a4f0     0xd64    movteq r3, #57346 
    0xe001a4f4     0xd68    moveq r6, #3
    0xe001a4f8     0xd6c    streq r6, [r3, #24]
    0xe001a4fc     0xd70    beq e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a500     0xd74    mov r1, r7
    0xe001a504     0xd78    add r0, sp, #56 
    0xe001a508     0xd7c    bl e0010a84 <findPDForASID>
    0xe001a50c     0xd80    ldr r6, [sp, #56]     ; stack access
    0xe001a510     0xd84    cmp r6, #0
    0xe001a514     0xd88    bne e001a568 <decodeARMMMUInvocation+0xddc>
    0xe001a518     0xd8c    movw r3, #13900 
    0xe001a51c     0xd90    movt r3, #57347 
    0xe001a520     0xd94    ldr r0, [r3]
    0xe001a524     0xd98    ldr fp, [r0, #8]
    0xe001a528     0xd9c    ldr sl, [r0, #12]
    0xe001a52c     0xda0    cmp fp, sl
    0xe001a530     0xda4    bcc e001a588 <decodeARMMMUInvocation+0xdfc>
    0xe001a534     0xda8    movw r3, #36896 
    0xe001a538     0xdac    movt r3, #57346 
    0xe001a53c     0xdb0    mov r2, #1
    0xe001a540     0xdb4    str r2, [r3, #24]
    0xe001a544     0xdb8    str r2, [r3]
    0xe001a548     0xdbc    mov r6, #3
    0xe001a54c     0xdc0    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a550     0xdc4    movw r3, #36896 
    0xe001a554     0xdc8    movt r3, #57346 
    0xe001a558     0xdcc    mov r2, #7
    0xe001a55c     0xdd0    str r2, [r3, #24]
    0xe001a560     0xdd4    mov r6, #3
    0xe001a564     0xdd8    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a568     0xddc    movw r3, #36896 
    0xe001a56c     0xde0    movt r3, #57346 
    0xe001a570     0xde4    mov r2, #6
    0xe001a574     0xde8    str r2, [r3, #24]
    0xe001a578     0xdec    mov r2, #0
    0xe001a57c     0xdf0    str r2, [r3, #20]
    0xe001a580     0xdf4    mov r6, #3
    0xe001a584     0xdf8    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a588     0xdfc    cmp r8, #3
    0xe001a58c     0xe00    bne e001a5b4 <decodeARMMMUInvocation+0xe28>
    0xe001a590     0xe04    lsr r5, r5, #30
    0xe001a594     0xe08    cmp r5, #3
    0xe001a598     0xe0c    ldrls pc, [pc, r5, lsl #2]
    0xe001a59c     0xe10    b e001a5b0 <decodeARMMMUInvocation+0xe24>
    0xe001a5a0     0xe14    .word 0xe001a618
    0xe001a5a4     0xe18    .word 0xe001ab38
    0xe001a5a8     0xe1c    .word 0xe001a5d8
    0xe001a5ac     0xe20    .word 0xe001ab54
    0xe001a5b0     0xe24    bl e0010904 <halt>
    0xe001a5b4     0xe28    mov r2, #12
    0xe001a5b8     0xe2c    mov r3, #1
    0xe001a5bc     0xe30    lsl r3, r3, r2
    0xe001a5c0     0xe34    cmp r8, #1
    0xe001a5c4     0xe38    beq e001a5e0 <decodeARMMMUInvocation+0xe54>
    0xe001a5c8     0xe3c    cmp r8, #3
    0xe001a5cc     0xe40    movne r4, #0
    0xe001a5d0     0xe44    bne e001a5ec <decodeARMMMUInvocation+0xe60>
    0xe001a5d4     0xe48    b e001ab44 <decodeARMMMUInvocation+0x13b8>
    0xe001a5d8     0xe4c    mov r2, #20
    0xe001a5dc     0xe50    b e001a5b8 <decodeARMMMUInvocation+0xe2c>
    0xe001a5e0     0xe54    lsl r4, r4, #8
    0xe001a5e4     0xe58    bic r4, r4, #4080 
    0xe001a5e8     0xe5c    bic r4, r4, #15
    0xe001a5ec     0xe60    cmp sl, r3
    0xe001a5f0     0xe64    cmpls fp, r3
    0xe001a5f4     0xe68    bcc e001a620 <decodeARMMMUInvocation+0xe94>
    0xe001a5f8     0xe6c    movw r3, #36896 
    0xe001a5fc     0xe70    movt r3, #57346 
    0xe001a600     0xe74    mov r2, #1
    0xe001a604     0xe78    str r2, [r3, #24]
    0xe001a608     0xe7c    mov r2, #0
    0xe001a60c     0xe80    str r2, [r3]
    0xe001a610     0xe84    mov r6, #3
    0xe001a614     0xe88    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a618     0xe8c    mov r3, #4096 
    0xe001a61c     0xe90    b e001ab44 <decodeARMMMUInvocation+0x13b8>
    0xe001a620     0xe94    ldr r3, [sp, #20]     ; stack access
    0xe001a624     0xe98    add r5, fp, r3
    0xe001a628     0xe9c    mov r1, #2
    0xe001a62c     0xea0    bl e0014ad8 <setThreadState>
    0xe001a630     0xea4    sub r8, sl, #1
    0xe001a634     0xea8    ldr r3, [sp, #20]     ; stack access
    0xe001a638     0xeac    add r8, r8, r3
    0xe001a63c     0xeb0    cmp r5, r8
    0xe001a640     0xeb4    bcs e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a644     0xeb8    mov r1, r7
    0xe001a648     0xebc    ldr r0, [sp, #60]     ; stack access
    0xe001a64c     0xec0    bl e00111c8 <setVMRootForFlush>
    0xe001a650     0xec4    mov r7, r0
    0xe001a654     0xec8    add r3, fp, #805306368 
    0xe001a658     0xecc    add r3, r3, r4
    0xe001a65c     0xed0    mov r2, r8
    0xe001a660     0xed4    mov r1, r5
    0xe001a664     0xed8    mov r0, r9
    0xe001a668     0xedc    bl e0012554 <doFlush>
    0xe001a66c     0xee0    cmp r7, #0
    0xe001a670     0xee4    beq e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a674     0xee8    movw r3, #13900 
    0xe001a678     0xeec    movt r3, #57347 
    0xe001a67c     0xef0    ldr r0, [r3]
    0xe001a680     0xef4    bl e00110b8 <setVMRoot>
    0xe001a684     0xef8    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a688     0xefc    movw r3, #13900 
    0xe001a68c     0xf00    movt r3, #57347 
    0xe001a690     0xf04    mov r1, #2
    0xe001a694     0xf08    ldr r0, [r3]
    0xe001a698     0xf0c    bl e0014ad8 <setThreadState>
    0xe001a69c     0xf10    cmp r8, #1
    0xe001a6a0     0xf14    beq e001a6b4 <decodeARMMMUInvocation+0xf28>
    0xe001a6a4     0xf18    cmp r8, #3
    0xe001a6a8     0xf1c    beq e001a6e4 <decodeARMMMUInvocation+0xf58>
    0xe001a6ac     0xf20    mov r3, #0
    0xe001a6b0     0xf24    b e001a6c0 <decodeARMMMUInvocation+0xf34>
    0xe001a6b4     0xf28    lsl r3, r4, #8
    0xe001a6b8     0xf2c    bic r3, r3, #4080 
    0xe001a6bc     0xf30    bic r3, r3, #15
    0xe001a6c0     0xf34    movw r2, #13900 
    0xe001a6c4     0xf38    movt r2, #57347 
    0xe001a6c8     0xf3c    ldr r2, [r2]
    0xe001a6cc     0xf40    add r3, r3, #805306368 
    0xe001a6d0     0xf44    str r3, [r2, #8]
    0xe001a6d4     0xf48    mov r3, #1
    0xe001a6d8     0xf4c    str r3, [r2, #4]
    0xe001a6dc     0xf50    mov r6, #0
    0xe001a6e0     0xf54    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a6e4     0xf58    lsl r3, r4, #10
    0xe001a6e8     0xf5c    bic r3, r3, #16320 
    0xe001a6ec     0xf60    bic r3, r3, #63 
    0xe001a6f0     0xf64    b e001a6c0 <decodeARMMMUInvocation+0xf34>
    0xe001a6f4     0xf68    movw r3, #36896 
    0xe001a6f8     0xf6c    movt r3, #57346 
    0xe001a6fc     0xf70    mov r6, #3
    0xe001a700     0xf74    str r6, [r3, #24]
    0xe001a704     0xf78    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a708     0xf7c    cmp r0, #43 
    0xe001a70c     0xf80    movwne r3, #36896 
    0xe001a710     0xf84    movtne r3, #57346 
    0xe001a714     0xf88    movne r6, #3
    0xe001a718     0xf8c    strne r6, [r3, #24]
    0xe001a71c     0xf90    bne e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a720     0xf94    ldr r2, [sp, #132]    ; stack access
    0xe001a724     0xf98    clz r3, sl
    0xe001a728     0xf9c    lsr r3, r3, #5
    0xe001a72c     0xfa0    cmp r2, #0
    0xe001a730     0xfa4    moveq r3, #1
    0xe001a734     0xfa8    cmp r1, #1
    0xe001a738     0xfac    movhi r1, r3
    0xe001a73c     0xfb0    orrls r1, r3, #1
    0xe001a740     0xfb4    cmp r1, #0
    0xe001a744     0xfb8    bne e001a7c0 <decodeARMMMUInvocation+0x1034>
    0xe001a748     0xfbc    movw r3, #13900 
    0xe001a74c     0xfc0    movt r3, #57347 
    0xe001a750     0xfc4    ldr r3, [r3]
    0xe001a754     0xfc8    ldr r7, [r3, #8]
    0xe001a758     0xfcc    ldr r8, [r3, #12]
    0xe001a75c     0xfd0    ldr r5, [sl]
    0xe001a760     0xfd4    ldr ip, [sl, #4]
    0xe001a764     0xfd8    add r3, sp, #40 
    0xe001a768     0xfdc    ldm r2, {r0, r1}
    0xe001a76c     0xfe0    stm r3, {r0, r1}      ; stack access
    0xe001a770     0xfe4    movw r3, #37576 
    0xe001a774     0xfe8    movt r3, #57346 
    0xe001a778     0xfec    ldr r3, [r3]
    0xe001a77c     0xff0    cmp r3, #0
    0xe001a780     0xff4    beq e001a82c <decodeARMMMUInvocation+0x10a0>
    0xe001a784     0xff8    movw r3, #37576 
    0xe001a788     0xffc    movt r3, #57346 
    0xe001a78c    0x1000    mov r4, #1
    0xe001a790    0x1004    ldr r2, [r3, #4]!
    0xe001a794    0x1008    cmp r2, #0
    0xe001a798    0x100c    beq e001a7d8 <decodeARMMMUInvocation+0x104c>
    0xe001a79c    0x1010    add r4, r4, #1
    0xe001a7a0    0x1014    cmp r4, #128 
    0xe001a7a4    0x1018    bne e001a790 <decodeARMMMUInvocation+0x1004>
    0xe001a7a8    0x101c    movw r3, #36896 
    0xe001a7ac    0x1020    movt r3, #57346 
    0xe001a7b0    0x1024    mov r2, #8
    0xe001a7b4    0x1028    str r2, [r3, #24]
    0xe001a7b8    0x102c    mov r6, #3
    0xe001a7bc    0x1030    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a7c0    0x1034    movw r3, #36896 
    0xe001a7c4    0x1038    movt r3, #57346 
    0xe001a7c8    0x103c    mov r2, #7
    0xe001a7cc    0x1040    str r2, [r3, #24]
    0xe001a7d0    0x1044    mov r6, #3
    0xe001a7d4    0x1048    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a7d8    0x104c    cmp r4, #128 
    0xe001a7dc    0x1050    beq e001a7a8 <decodeARMMMUInvocation+0x101c>
    0xe001a7e0    0x1054    and r3, r5, #14
    0xe001a7e4    0x1058    cmp r3, #14
    0xe001a7e8    0x105c    andne r3, r5, #15
    0xe001a7ec    0x1060    uxtbeq r3, r5
    0xe001a7f0    0x1064    cmp r3, #2
    0xe001a7f4    0x1068    bne e001a80c <decodeARMMMUInvocation+0x1080>
    0xe001a7f8    0x106c    and r3, ip, #31
    0xe001a7fc    0x1070    cmp r3, #12
    0xe001a800    0x1074    bne e001a80c <decodeARMMMUInvocation+0x1080>
    0xe001a804    0x1078    tst ip, #32
    0xe001a808    0x107c    beq e001a834 <decodeARMMMUInvocation+0x10a8>
    0xe001a80c    0x1080    movw r3, #36896 
    0xe001a810    0x1084    movt r3, #57346 
    0xe001a814    0x1088    mov r2, #2
    0xe001a818    0x108c    str r2, [r3, #24]
    0xe001a81c    0x1090    mov r2, #1
    0xe001a820    0x1094    str r2, [r3, #4]
    0xe001a824    0x1098    mov r6, #3
    0xe001a828    0x109c    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a82c    0x10a0    mov r4, #0
    0xe001a830    0x10a4    b e001a7e0 <decodeARMMMUInvocation+0x1054>
    0xe001a834    0x10a8    mov r0, sl
    0xe001a838    0x10ac    bl e00142a0 <ensureNoChildren>
    0xe001a83c    0x10b0    subs r6, r0, #0
    0xe001a840    0x10b4    bne e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a844    0x10b8    bic r5, r5, #15
    0xe001a848    0x10bc    str r8, [sp]          ; stack access
    0xe001a84c    0x10c0    mov r3, r7
    0xe001a850    0x10c4    add r2, sp, #40 
    0xe001a854    0x10c8    ldm r2, {r1, r2}      ; stack access
    0xe001a858    0x10cc    add r0, sp, #56 
    0xe001a85c    0x10d0    bl e0012e64 <lookupTargetSlot>
    0xe001a860    0x10d4    ldr r6, [sp, #56]     ; stack access
    0xe001a864    0x10d8    cmp r6, #0
    0xe001a868    0x10dc    bne e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a86c    0x10e0    ldr r7, [sp, #60]     ; stack access
    0xe001a870    0x10e4    mov r0, r7
    0xe001a874    0x10e8    bl e0013508 <ensureEmptySlot>
    0xe001a878    0x10ec    subs r6, r0, #0
    0xe001a87c    0x10f0    bne e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a880    0x10f4    movw r3, #13900 
    0xe001a884    0x10f8    movt r3, #57347 
    0xe001a888    0x10fc    mov r1, #2
    0xe001a88c    0x1100    ldr r0, [r3]
    0xe001a890    0x1104    bl e0014ad8 <setThreadState>
    0xe001a894    0x1108    ldr r3, [sl, #4]
    0xe001a898    0x110c    and r2, r3, #31
    0xe001a89c    0x1110    sub r2, r2, #4
    0xe001a8a0    0x1114    and r3, r3, #63 
    0xe001a8a4    0x1118    mov r1, #64 
    0xe001a8a8    0x111c    orr r3, r3, r1, lsl r2
    0xe001a8ac    0x1120    str r3, [sl, #4]
    0xe001a8b0    0x1124    mov r1, #4096 
    0xe001a8b4    0x1128    mov r0, r5
    0xe001a8b8    0x112c    bl e0019244 <memzero>
    0xe001a8bc    0x1130    orr r3, r5, #5
    0xe001a8c0    0x1134    str r3, [sp, #72]     ; stack access
    0xe001a8c4    0x1138    lsl r3, r4, #10
    0xe001a8c8    0x113c    ubfx r3, r3, #0, #17
    0xe001a8cc    0x1140    str r3, [sp, #76]     ; stack access
    0xe001a8d0    0x1144    mov r3, r7
    0xe001a8d4    0x1148    mov r2, sl
    0xe001a8d8    0x114c    add r1, sp, #80 
    0xe001a8dc    0x1150    ldmdb r1, {r0, r1}    ; stack access
    0xe001a8e0    0x1154    bl e0012fa8 <cteInsert>
    0xe001a8e4    0x1158    movw r3, #37576 
    0xe001a8e8    0x115c    movt r3, #57346 
    0xe001a8ec    0x1160    ubfx r4, r4, #0, #22
    0xe001a8f0    0x1164    str r5, [r3, r4, lsl #2]
    0xe001a8f4    0x1168    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a8f8    0x116c    cmp r0, #44 
    0xe001a8fc    0x1170    movwne r3, #36896 
    0xe001a900    0x1174    movtne r3, #57346 
    0xe001a904    0x1178    movne r6, #3
    0xe001a908    0x117c    strne r6, [r3, #24]
    0xe001a90c    0x1180    bne e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a910    0x1184    cmp sl, #0
    0xe001a914    0x1188    beq e001a988 <decodeARMMMUInvocation+0x11fc>
    0xe001a918    0x118c    ldr r3, [sl]
    0xe001a91c    0x1190    and r2, r3, #14
    0xe001a920    0x1194    cmp r2, #14
    0xe001a924    0x1198    andne r2, r3, #15
    0xe001a928    0x119c    uxtbeq r2, r3
    0xe001a92c    0x11a0    cmp r2, #9
    0xe001a930    0x11a4    bne e001a9a0 <decodeARMMMUInvocation+0x1214>
    0xe001a934    0x11a8    tst r3, #16
    0xe001a938    0x11ac    bne e001a9a0 <decodeARMMMUInvocation+0x1214>
    0xe001a93c    0x11b0    ubfx r5, r5, #0, #17
    0xe001a940    0x11b4    movw r3, #37576 
    0xe001a944    0x11b8    movt r3, #57346 
    0xe001a948    0x11bc    lsr r2, r5, #10
    0xe001a94c    0x11c0    ldr r6, [r3, r2, lsl #2]
    0xe001a950    0x11c4    cmp r6, #0
    0xe001a954    0x11c8    beq e001a9c0 <decodeARMMMUInvocation+0x1234>
    0xe001a958    0x11cc    bic r4, r4, #15
    0xe001a95c    0x11d0    cmp r6, r4
    0xe001a960    0x11d4    moveq r3, #0
    0xe001a964    0x11d8    beq e001a9fc <decodeARMMMUInvocation+0x1270>
    0xe001a968    0x11dc    movw r3, #36896 
    0xe001a96c    0x11e0    movt r3, #57346 
    0xe001a970    0x11e4    mov r2, #2
    0xe001a974    0x11e8    str r2, [r3, #24]
    0xe001a978    0x11ec    mov r2, #0
    0xe001a97c    0x11f0    str r2, [r3, #4]
    0xe001a980    0x11f4    mov r6, #3
    0xe001a984    0x11f8    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a988    0x11fc    movw r3, #36896 
    0xe001a98c    0x1200    movt r3, #57346 
    0xe001a990    0x1204    mov r2, #7
    0xe001a994    0x1208    str r2, [r3, #24]
    0xe001a998    0x120c    mov r6, #3
    0xe001a99c    0x1210    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a9a0    0x1214    movw r3, #36896 
    0xe001a9a4    0x1218    movt r3, #57346 
    0xe001a9a8    0x121c    mov r2, #2
    0xe001a9ac    0x1220    str r2, [r3, #24]
    0xe001a9b0    0x1224    mov r2, #1
    0xe001a9b4    0x1228    str r2, [r3, #4]
    0xe001a9b8    0x122c    mov r6, #3
    0xe001a9bc    0x1230    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a9c0    0x1234    movw r3, #36896 
    0xe001a9c4    0x1238    movt r3, #57346 
    0xe001a9c8    0x123c    mov r2, #6
    0xe001a9cc    0x1240    str r2, [r3, #24]
    0xe001a9d0    0x1244    mov r2, #0
    0xe001a9d4    0x1248    str r2, [r3, #20]
    0xe001a9d8    0x124c    movw r3, #36884 
    0xe001a9dc    0x1250    movt r3, #57346 
    0xe001a9e0    0x1254    str r2, [r3]
    0xe001a9e4    0x1258    str r2, [r3, #4]
    0xe001a9e8    0x125c    mov r6, #3
    0xe001a9ec    0x1260    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001a9f0    0x1264    add r3, r3, #1
    0xe001a9f4    0x1268    cmp r3, #1024 
    0xe001a9f8    0x126c    beq e001aa74 <decodeARMMMUInvocation+0x12e8>
    0xe001a9fc    0x1270    cmn r5, r3
    0xe001aa00    0x1274    beq e001a9f0 <decodeARMMMUInvocation+0x1264>
    0xe001aa04    0x1278    ldr r2, [r6, r3, lsl #2]
    0xe001aa08    0x127c    cmp r2, #0
    0xe001aa0c    0x1280    bne e001a9f0 <decodeARMMMUInvocation+0x1264>
    0xe001aa10    0x1284    cmp r3, #1024 
    0xe001aa14    0x1288    beq e001aa74 <decodeARMMMUInvocation+0x12e8>
    0xe001aa18    0x128c    add r5, r5, r3
    0xe001aa1c    0x1290    movw r3, #13900 
    0xe001aa20    0x1294    movt r3, #57347 
    0xe001aa24    0x1298    mov r1, #2
    0xe001aa28    0x129c    ldr r0, [r3]
    0xe001aa2c    0x12a0    bl e0014ad8 <setThreadState>
    0xe001aa30    0x12a4    ldr r3, [sl, #4]
    0xe001aa34    0x12a8    lsr r3, r3, #17
    0xe001aa38    0x12ac    lsl r3, r3, #17
    0xe001aa3c    0x12b0    ubfx r2, r5, #0, #17
    0xe001aa40    0x12b4    orr r3, r3, r2
    0xe001aa44    0x12b8    str r3, [sl, #4]
    0xe001aa48    0x12bc    ldr r2, [sl]
    0xe001aa4c    0x12c0    orr r3, r2, #16
    0xe001aa50    0x12c4    str r3, [sl]
    0xe001aa54    0x12c8    ubfx r5, r5, #0, #10
    0xe001aa58    0x12cc    bic r2, r2, #16320 
    0xe001aa5c    0x12d0    bic r2, r2, #63 
    0xe001aa60    0x12d4    str r2, [r6, r5, lsl #2]
    0xe001aa64    0x12d8    mov r6, #0
    0xe001aa68    0x12dc    mov r0, r6
    0xe001aa6c    0x12e0    add sp, sp, #84 
    0xe001aa70    0x12e4    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe001aa74    0x12e8    movw r3, #36896 
    0xe001aa78    0x12ec    movt r3, #57346 
    0xe001aa7c    0x12f0    mov r2, #8
    0xe001aa80    0x12f4    str r2, [r3, #24]
    0xe001aa84    0x12f8    mov r6, #3
    0xe001aa88    0x12fc    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001aa8c    0x1300    bl e0010904 <halt>
    0xe001aa90    0x1304    bic sl, sl, #4080 
    0xe001aa94    0x1308    bic sl, sl, #15
    0xe001aa98    0x130c    mov fp, #12
    0xe001aa9c    0x1310    b e00198e4 <decodeARMMMUInvocation+0x158>
    0xe001aaa0    0x1314    lsr sl, sl, #16
    0xe001aaa4    0x1318    lsl sl, sl, #16
    0xe001aaa8    0x131c    mov fp, #16
    0xe001aaac    0x1320    b e00198e4 <decodeARMMMUInvocation+0x158>
    0xe001aab0    0x1324    movw r3, #36896 
    0xe001aab4    0x1328    movt r3, #57346 
    0xe001aab8    0x132c    mov r2, #8
    0xe001aabc    0x1330    str r2, [r3, #24]
    0xe001aac0    0x1334    b e001a248 <decodeARMMMUInvocation+0xabc>
    0xe001aac4    0x1338    add r1, r0, r2, lsl #2
    0xe001aac8    0x133c    add r2, r0, #805306368 
    0xe001aacc    0x1340    sub r1, r1, #1
    0xe001aad0    0x1344    bl e00120c8 <cleanCacheRange_PoU>
    0xe001aad4    0x1348    b e001ab18 <decodeARMMMUInvocation+0x138c>
    0xe001aad8    0x134c    mov r4, #0
    0xe001aadc    0x1350    b e001aae4 <decodeARMMMUInvocation+0x1358>
    0xe001aae0    0x1354    mov r4, #1
    0xe001aae4    0x1358    cmp r2, #0
    0xe001aae8    0x135c    beq e001aac4 <decodeARMMMUInvocation+0x1338>
    0xe001aaec    0x1360    mov r3, r0
    0xe001aaf0    0x1364    add ip, r0, r2, lsl #2
    0xe001aaf4    0x1368    str r1, [r3], #4
    0xe001aaf8    0x136c    cmp r3, ip
    0xe001aafc    0x1370    bne e001aaf4 <decodeARMMMUInvocation+0x1368>
    0xe001ab00    0x1374    add r1, r0, r2, lsl #2
    0xe001ab04    0x1378    add r2, r0, #805306368 
    0xe001ab08    0x137c    sub r1, r1, #1
    0xe001ab0c    0x1380    bl e00120c8 <cleanCacheRange_PoU>
    0xe001ab10    0x1384    cmp r4, #2
    0xe001ab14    0x1388    beq e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001ab18    0x138c    ldr r0, [sp, #20]     ; stack access
    0xe001ab1c    0x1390    bl e0011404 <invalidateTLBByASID>
    0xe001ab20    0x1394    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001ab24    0x1398    add r1, r0, r2, lsl #2
    0xe001ab28    0x139c    add r2, r0, #805306368 
    0xe001ab2c    0x13a0    sub r1, r1, #1
    0xe001ab30    0x13a4    bl e00120c8 <cleanCacheRange_PoU>
    0xe001ab34    0x13a8    b e001aa68 <decodeARMMMUInvocation+0x12dc>
    0xe001ab38    0x13ac    mov r2, #16
    0xe001ab3c    0x13b0    mov r3, #1
    0xe001ab40    0x13b4    lsl r3, r3, r2
    0xe001ab44    0x13b8    lsl r4, r4, #10
    0xe001ab48    0x13bc    bic r4, r4, #16320 
    0xe001ab4c    0x13c0    bic r4, r4, #63 
    0xe001ab50    0x13c4    b e001a5ec <decodeARMMMUInvocation+0xe60>
    0xe001ab54    0x13c8    mov r2, #24
    0xe001ab58    0x13cc    b e001ab3c <decodeARMMMUInvocation+0x13b0>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
1238 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeARMMMUInvocation` has 2004 nodes.

Section init_kernel (293 of 293)
================================

Deriving specifications
-----------------------

Section `init_kernel` consists of 523 instructions.
Skipping ee0d3f90 mcr 15, 0, r3, cr13, cr0, {4}
Switch found.
Skipping eef83a10 vmrs r3, fpexc
Skipping eee83a10 vmsr fpexc, r3
Switch found.
Skipping f57ff04f dsb sy
Skipping ee084f17 mcr 15, 0, r4, cr8, cr7, {0}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

104 stack accesses found. Annotated code for `init_kernel`:

    0xe0003b14      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0003b18      0x4    sub sp, sp, #156 
    0xe0003b1c      0x8    mov r7, r0
    0xe0003b20      0xc    str r2, [sp, #28]     ; stack access
    0xe0003b24     0x10    str r3, [sp, #52]     ; stack access
    0xe0003b28     0x14    ldr r6, [sp, #192]    ; stack access
    0xe0003b2c     0x18    cmp r6, #0
    0xe0003b30     0x1c    beq e00042d4 <init_kernel+0x7c0>
    0xe0003b34     0x20    movw r3, #46284 
    0xe0003b38     0x24    movt r3, #57345 
    0xe0003b3c     0x28    ldr fp, [r3, #216] 
    0xe0003b40     0x2c    add r9, r0, #-805306368 
    0xe0003b44     0x30    add r8, r1, #-805306368 
    0xe0003b48     0x34    str r9, [sp, #88]     ; stack access
    0xe0003b4c     0x38    str r8, [sp, #92]     ; stack access
    0xe0003b50     0x3c    str r2, [sp, #32]     ; stack access
    0xe0003b54     0x40    sub r4, r1, r2
    0xe0003b58     0x44    add sl, r4, #8192 
    0xe0003b5c     0x48    ldr r3, [sp, #196]    ; stack access
    0xe0003b60     0x4c    add r3, r6, r3
    0xe0003b64     0x50    sub r3, r3, #1
    0xe0003b68     0x54    bic r3, r3, #4080 
    0xe0003b6c     0x58    bic r3, r3, #15
    0xe0003b70     0x5c    add r3, r3, #4096 
    0xe0003b74     0x60    str r3, [sp, #44]     ; stack access
    0xe0003b78     0x64    add r2, r6, #-805306368 
    0xe0003b7c     0x68    str r2, [sp, #40]     ; stack access
    0xe0003b80     0x6c    add r1, r3, #-805306368 
    0xe0003b84     0x70    str r1, [sp, #48]     ; stack access
    0xe0003b88     0x74    rsb r3, r2, #8
    0xe0003b8c     0x78    add r3, r3, r1
    0xe0003b90     0x7c    str r3, [sp, #24]     ; stack access
    0xe0003b94     0x80    b e0004314 <init_kernel+0x800>
    0xe0003b98     0x84    bl e000302c <map_kernel_window>
    0xe0003b9c     0x88    bl e00009bc <activate_global_pd>
    0xe0003ba0     0x8c    ldr r3, [pc, #1932] 
    0xe0003ba4     0x90    mcr 15, 0, r3, cr13, cr0, {4}
    0xe0003ba8     0x94    bl e000097c <fpsimd_HWCapTest>
    0xe0003bac     0x98    cmp r0, #0
    0xe0003bb0     0x9c    bne e0003e08 <init_kernel+0x2f4>
    0xe0003bb4     0xa0    ldr r3, [sp, #32]     ; stack access
    0xe0003bb8     0xa4    sub r3, r7, r3
    0xe0003bbc     0xa8    str r3, [sp, #32]     ; stack access
    0xe0003bc0     0xac    bl e00001fc <cpu_iface_init>
    0xe0003bc4     0xb0    bl e0011f44 <armv_init_user_access>
    0xe0003bc8     0xb4    bl e0000b40 <initTimer>
    0xe0003bcc     0xb8    bl e0000060 <dist_init>
    0xe0003bd0     0xbc    bl e0000a38 <initL2Cache>
    0xe0003bd4     0xc0    ldr r3, [sp, #32]     ; stack access
    0xe0003bd8     0xc4    str r3, [sp, #104]    ; stack access
    0xe0003bdc     0xc8    str r5, [sp, #108]    ; stack access
    0xe0003be0     0xcc    movw r3, #17280 
    0xe0003be4     0xd0    movt r3, #57344 
    0xe0003be8     0xd4    mov r2, #-536870912 
    0xe0003bec     0xd8    str r2, [r3, #32]
    0xe0003bf0     0xdc    movw r2, #16384 
    0xe0003bf4     0xe0    movt r2, #57347 
    0xe0003bf8     0xe4    str r2, [r3, #36] 
    0xe0003bfc     0xe8    cmp r6, #0
    0xe0003c00     0xec    movwne r3, #17280 
    0xe0003c04     0xf0    movtne r3, #57344 
    0xe0003c08     0xf4    addne r6, r6, #-805306368 
    0xe0003c0c     0xf8    strne r6, [r3, #40] 
    0xe0003c10     0xfc    ldrne r2, [sp, #44]   ; stack access
    0xe0003c14    0x100    addne r2, r2, #-805306368 
    0xe0003c18    0x104    strne r2, [r3, #44] 
    0xe0003c1c    0x108    movne r3, #2
    0xe0003c20    0x10c    moveq r3, #1
    0xe0003c24    0x110    movw r2, #65535 
    0xe0003c28    0x114    movt r2, #12271 
    0xe0003c2c    0x118    cmp r7, r2
    0xe0003c30    0x11c    bhi e0003e58 <init_kernel+0x344>
    0xe0003c34    0x120    cmp r8, #-16777216 
    0xe0003c38    0x124    bls e0003e28 <init_kernel+0x314>
    0xe0003c3c    0x128    movw r2, #17280 
    0xe0003c40    0x12c    movt r2, #57344 
    0xe0003c44    0x130    add ip, r2, r3, lsl #3
    0xe0003c48    0x134    add ip, ip, #32
    0xe0003c4c    0x138    ldr r1, [pc, #1764] 
    0xe0003c50    0x13c    ldm r1, {r0, r1}
    0xe0003c54    0x140    stm ip, {r0, r1}
    0xe0003c58    0x144    add r3, r3, #1
    0xe0003c5c    0x148    add r2, r2, r3, lsl #3
    0xe0003c60    0x14c    str r9, [r2, #32]
    0xe0003c64    0x150    str r8, [r2, #36] 
    0xe0003c68    0x154    add r2, r3, #1
    0xe0003c6c    0x158    ldr r3, [sp, #36]     ; stack access
    0xe0003c70    0x15c    str r3, [sp, #8]      ; stack access
    0xe0003c74    0x160    add r3, sp, #104 
    0xe0003c78    0x164    ldm r3, {r0, r1}      ; stack access
    0xe0003c7c    0x168    stm sp, {r0, r1}      ; stack access
    0xe0003c80    0x16c    ldr r3, [pc, #1716] 
    0xe0003c84    0x170    movw r1, #17216 
    0xe0003c88    0x174    movt r1, #57344 
    0xe0003c8c    0x178    mov r0, #1
    0xe0003c90    0x17c    bl e0003310 <init_freemem>
    0xe0003c94    0x180    add r0, sp, #56 
    0xe0003c98    0x184    bl e0000eb4 <create_root_cnode>
    0xe0003c9c    0x188    ldr r8, [sp, #56]     ; stack access
    0xe0003ca0    0x18c    and r9, r8, #14
    0xe0003ca4    0x190    cmp r9, #14
    0xe0003ca8    0x194    andne r3, r8, #15
    0xe0003cac    0x198    uxtbeq r3, r8
    0xe0003cb0    0x19c    cmp r3, #0
    0xe0003cb4    0x1a0    beq e0004330 <init_kernel+0x81c>
    0xe0003cb8    0x1a4    add r3, sp, #56 
    0xe0003cbc    0x1a8    ldm r3, {r0, r1}      ; stack access
    0xe0003cc0    0x1ac    bl e0000f00 <create_domain_cap>
    0xe0003cc4    0x1b0    ldr r3, [sp, #60]     ; stack access
    0xe0003cc8    0x1b4    str r3, [sp, #36]     ; stack access
    0xe0003ccc    0x1b8    mov r6, #0
    0xe0003cd0    0x1bc    mov r7, r6
    0xe0003cd4    0x1c0    mov r1, r6
    0xe0003cd8    0x1c4    mov r0, r7
    0xe0003cdc    0x1c8    bl e0013648 <setIRQState>
    0xe0003ce0    0x1cc    add r6, r6, #1
    0xe0003ce4    0x1d0    cmp r6, #160 
    0xe0003ce8    0x1d4    bne e0003cd4 <init_kernel+0x1c0>
    0xe0003cec    0x1d8    mov r1, #29
    0xe0003cf0    0x1dc    mov r0, #2
    0xe0003cf4    0x1e0    bl e0013648 <setIRQState>
    0xe0003cf8    0x1e4    cmp r9, #14
    0xe0003cfc    0x1e8    andne r2, r8, #15
    0xe0003d00    0x1ec    uxtbeq r2, r8
    0xe0003d04    0x1f0    sub r3, r2, #2
    0xe0003d08    0x1f4    cmp r3, #60 
    0xe0003d0c    0x1f8    ldrls pc, [pc, r3, lsl #2]
    0xe0003d10    0x1fc    b e0003ed4 <init_kernel+0x3c0>
    0xe0003d14    0x200    .word 0xe0003e7c
    0xe0003d18    0x204    .word 0xe0003ed4
    0xe0003d1c    0x208    .word 0xe0003e84
    0xe0003d20    0x20c    .word 0xe0003ed4
    0xe0003d24    0x210    .word 0xe0003e90
    0xe0003d28    0x214    .word 0xe0003ed4
    0xe0003d2c    0x218    .word 0xe0003f60
    0xe0003d30    0x21c    .word 0xe0003ed4
    0xe0003d34    0x220    .word 0xe0003e98
    0xe0003d38    0x224    .word 0xe0003ed4
    0xe0003d3c    0x228    .word 0xe0003ea0
    0xe0003d40    0x22c    .word 0xe0003ed4
    0xe0003d44    0x230    .word 0xe0003f60
    0xe0003d48    0x234    .word 0xe0003ed4
    0xe0003d4c    0x238    .word 0xe0003ed4
    0xe0003d50    0x23c    .word 0xe0003ed4
    0xe0003d54    0x240    .word 0xe0003ed4
    0xe0003d58    0x244    .word 0xe0003ed4
    0xe0003d5c    0x248    .word 0xe0003ed4
    0xe0003d60    0x24c    .word 0xe0003ed4
    0xe0003d64    0x250    .word 0xe0003ed4
    0xe0003d68    0x254    .word 0xe0003ed4
    0xe0003d6c    0x258    .word 0xe0003ed4
    0xe0003d70    0x25c    .word 0xe0003ed4
    0xe0003d74    0x260    .word 0xe0003ed4
    0xe0003d78    0x264    .word 0xe0003ed4
    0xe0003d7c    0x268    .word 0xe0003ed4
    0xe0003d80    0x26c    .word 0xe0003ed4
    0xe0003d84    0x270    .word 0xe0003f60
    0xe0003d88    0x274    .word 0xe0003ed4
    0xe0003d8c    0x278    .word 0xe0003ed4
    0xe0003d90    0x27c    .word 0xe0003ed4
    0xe0003d94    0x280    .word 0xe0003ed4
    0xe0003d98    0x284    .word 0xe0003ed4
    0xe0003d9c    0x288    .word 0xe0003ed4
    0xe0003da0    0x28c    .word 0xe0003ed4
    0xe0003da4    0x290    .word 0xe0003ed4
    0xe0003da8    0x294    .word 0xe0003ed4
    0xe0003dac    0x298    .word 0xe0003ed4
    0xe0003db0    0x29c    .word 0xe0003ed4
    0xe0003db4    0x2a0    .word 0xe0003ed4
    0xe0003db8    0x2a4    .word 0xe0003ed4
    0xe0003dbc    0x2a8    .word 0xe0003ed4
    0xe0003dc0    0x2ac    .word 0xe0003ed4
    0xe0003dc4    0x2b0    .word 0xe0003eac
    0xe0003dc8    0x2b4    .word 0xe0003ed4
    0xe0003dcc    0x2b8    .word 0xe0003ed4
    0xe0003dd0    0x2bc    .word 0xe0003ed4
    0xe0003dd4    0x2c0    .word 0xe0003ed4
    0xe0003dd8    0x2c4    .word 0xe0003ed4
    0xe0003ddc    0x2c8    .word 0xe0003ed4
    0xe0003de0    0x2cc    .word 0xe0003ed4
    0xe0003de4    0x2d0    .word 0xe0003ed4
    0xe0003de8    0x2d4    .word 0xe0003ed4
    0xe0003dec    0x2d8    .word 0xe0003ed4
    0xe0003df0    0x2dc    .word 0xe0003ed4
    0xe0003df4    0x2e0    .word 0xe0003ed4
    0xe0003df8    0x2e4    .word 0xe0003ed4
    0xe0003dfc    0x2e8    .word 0xe0003ed4
    0xe0003e00    0x2ec    .word 0xe0003ed4
    0xe0003e04    0x2f0    .word 0xe0003f60
    0xe0003e08    0x2f4    vmrs r3, fpexc
    0xe0003e0c    0x2f8    bic r3, r3, #1073741824 
    0xe0003e10    0x2fc    vmsr fpexc, r3
    0xe0003e14    0x300    movw r3, #13908 
    0xe0003e18    0x304    movt r3, #57347 
    0xe0003e1c    0x308    mov r2, #0
    0xe0003e20    0x30c    str r2, [r3]
    0xe0003e24    0x310    b e0003bb4 <init_kernel+0xa0>
    0xe0003e28    0x314    movw r2, #17280 
    0xe0003e2c    0x318    movt r2, #57344 
    0xe0003e30    0x31c    add r1, r2, r3, lsl #3
    0xe0003e34    0x320    str r9, [r1, #32]
    0xe0003e38    0x324    str r8, [r1, #36] 
    0xe0003e3c    0x328    add r3, r3, #1
    0xe0003e40    0x32c    add r2, r2, r3, lsl #3
    0xe0003e44    0x330    add r2, r2, #32
    0xe0003e48    0x334    ldr r1, [pc, #1256] 
    0xe0003e4c    0x338    ldm r1, {r0, r1}
    0xe0003e50    0x33c    stm r2, {r0, r1}
    0xe0003e54    0x340    b e0003c68 <init_kernel+0x154>
    0xe0003e58    0x344    movw r2, #17280 
    0xe0003e5c    0x348    movt r2, #57344 
    0xe0003e60    0x34c    add r2, r2, r3, lsl #3
    0xe0003e64    0x350    add r2, r2, #32
    0xe0003e68    0x354    ldr r1, [pc, #1224] 
    0xe0003e6c    0x358    ldm r1, {r0, r1}
    0xe0003e70    0x35c    stm r2, {r0, r1}
    0xe0003e74    0x360    add r2, r3, #1
    0xe0003e78    0x364    b e0003c6c <init_kernel+0x158>
    0xe0003e7c    0x368    bic r8, r8, #15
    0xe0003e80    0x36c    b e0003f64 <init_kernel+0x450>
    0xe0003e84    0x370    ldr r3, [sp, #36]     ; stack access
    0xe0003e88    0x374    bic r8, r3, #15
    0xe0003e8c    0x378    b e0003f64 <init_kernel+0x450>
    0xe0003e90    0x37c    bic r8, r8, #15
    0xe0003e94    0x380    b e0003f64 <init_kernel+0x450>
    0xe0003e98    0x384    bic r8, r8, #31
    0xe0003e9c    0x388    b e0003f64 <init_kernel+0x450>
    0xe0003ea0    0x38c    bic r8, r8, #508 
    0xe0003ea4    0x390    bic r8, r8, #3
    0xe0003ea8    0x394    b e0003f64 <init_kernel+0x450>
    0xe0003eac    0x398    lsr r3, r8, #8
    0xe0003eb0    0x39c    and r2, r3, #63 
    0xe0003eb4    0x3a0    cmp r2, #32
    0xe0003eb8    0x3a4    andne r3, r3, #31
    0xe0003ebc    0x3a8    moveq r3, #4
    0xe0003ec0    0x3ac    add r3, r3, #1
    0xe0003ec4    0x3b0    mvn r8, #0
    0xe0003ec8    0x3b4    ldr r2, [sp, #36]     ; stack access
    0xe0003ecc    0x3b8    and r8, r2, r8, lsl r3
    0xe0003ed0    0x3bc    b e0003f64 <init_kernel+0x450>
    0xe0003ed4    0x3c0    sub r3, r2, #1
    0xe0003ed8    0x3c4    cmp r3, #8
    0xe0003edc    0x3c8    ldrls pc, [pc, r3, lsl #2]
    0xe0003ee0    0x3cc    b e000428c <init_kernel+0x778>
    0xe0003ee4    0x3d0    .word 0xe0003f08
    0xe0003ee8    0x3d4    .word 0xe000428c
    0xe0003eec    0x3d8    .word 0xe0003f08
    0xe0003ef0    0x3dc    .word 0xe000428c
    0xe0003ef4    0x3e0    .word 0xe0003f58
    0xe0003ef8    0x3e4    .word 0xe000428c
    0xe0003efc    0x3e8    .word 0xe0003f40
    0xe0003f00    0x3ec    .word 0xe000428c
    0xe0003f04    0x3f0    .word 0xe0003f4c
    0xe0003f08    0x3f4    cmp r2, #1
    0xe0003f0c    0x3f8    beq e0003f20 <init_kernel+0x40c>
    0xe0003f10    0x3fc    cmp r2, #3
    0xe0003f14    0x400    beq e0003f30 <init_kernel+0x41c>
    0xe0003f18    0x404    mov r8, #0
    0xe0003f1c    0x408    b e0003f64 <init_kernel+0x450>
    0xe0003f20    0x40c    lsl r8, r8, #8
    0xe0003f24    0x410    bic r8, r8, #4080 
    0xe0003f28    0x414    bic r8, r8, #15
    0xe0003f2c    0x418    b e0003f64 <init_kernel+0x450>
    0xe0003f30    0x41c    lsl r8, r8, #10
    0xe0003f34    0x420    bic r8, r8, #16320 
    0xe0003f38    0x424    bic r8, r8, #63 
    0xe0003f3c    0x428    b e0003f64 <init_kernel+0x450>
    0xe0003f40    0x42c    bic r8, r8, #1020 
    0xe0003f44    0x430    bic r8, r8, #3
    0xe0003f48    0x434    b e0003f64 <init_kernel+0x450>
    0xe0003f4c    0x438    bic r8, r8, #16320 
    0xe0003f50    0x43c    bic r8, r8, #63 
    0xe0003f54    0x440    b e0003f64 <init_kernel+0x450>
    0xe0003f58    0x444    bic r8, r8, #15
    0xe0003f5c    0x448    b e0003f64 <init_kernel+0x450>
    0xe0003f60    0x44c    mov r8, #0
    0xe0003f64    0x450    mov r3, #14
    0xe0003f68    0x454    str r3, [r8, #64] 
    0xe0003f6c    0x458    mov r0, #0
    0xe0003f70    0x45c    str r0, [r8, #68] 
    0xe0003f74    0x460    str r0, [r8, #72] 
    0xe0003f78    0x464    mov r3, #3
    0xe0003f7c    0x468    str r3, [r8, #76] 
    0xe0003f80    0x46c    ldr r3, [sp, #24]     ; stack access
    0xe0003f84    0x470    mov r2, r4
    0xe0003f88    0x474    mov r1, #1
    0xe0003f8c    0x478    bl e0003a20 <populate_bi_frame>
    0xe0003f90    0x47c    ldr r3, [sp, #40]     ; stack access
    0xe0003f94    0x480    cmp r3, #0
    0xe0003f98    0x484    bne e0004294 <init_kernel+0x780>
    0xe0003f9c    0x488    ldr ip, [sp, #24]     ; stack access
    0xe0003fa0    0x48c    ldr r0, [sp, #40]     ; stack access
    0xe0003fa4    0x490    cmp ip, r0
    0xe0003fa8    0x494    bls e0003fcc <init_kernel+0x4b8>
    0xe0003fac    0x498    movw r3, #47104 
    0xe0003fb0    0x49c    movt r3, #57345 
    0xe0003fb4    0x4a0    ldr r3, [r3, #156] 
    0xe0003fb8    0x4a4    add r2, r0, r3
    0xe0003fbc    0x4a8    mov r1, #0
    0xe0003fc0    0x4ac    str r1, [r0, r3]
    0xe0003fc4    0x4b0    sub r3, ip, r0
    0xe0003fc8    0x4b4    str r3, [r2, #4]
    0xe0003fcc    0x4b8    movw r3, #47104 
    0xe0003fd0    0x4bc    movt r3, #57345 
    0xe0003fd4    0x4c0    ldr r3, [r3, #124] 
    0xe0003fd8    0x4c4    mov r2, #0
    0xe0003fdc    0x4c8    str r2, [r3, #52] 
    0xe0003fe0    0x4cc    str r2, [r3, #56] 
    0xe0003fe4    0x4d0    ldr r3, [sp, #32]     ; stack access
    0xe0003fe8    0x4d4    str r3, [sp, #96]     ; stack access
    0xe0003fec    0x4d8    str r5, [sp, #100]    ; stack access
    0xe0003ff0    0x4dc    str r5, [sp]          ; stack access
    0xe0003ff4    0x4e0    add r2, sp, #56 
    0xe0003ff8    0x4e4    ldm r2, {r1, r2}      ; stack access
    0xe0003ffc    0x4e8    add r0, sp, #72 
    0xe0004000    0x4ec    bl e0001660 <create_it_address_space>
    0xe0004004    0x4f0    ldr r3, [sp, #72]     ; stack access
    0xe0004008    0x4f4    and r2, r3, #14
    0xe000400c    0x4f8    cmp r2, #14
    0xe0004010    0x4fc    andne r3, r3, #15
    0xe0004014    0x500    uxtbeq r3, r3
    0xe0004018    0x504    cmp r3, #0
    0xe000401c    0x508    beq e0004330 <init_kernel+0x81c>
    0xe0004020    0x50c    add r5, r4, #4096 
    0xe0004024    0x510    str r5, [sp]          ; stack access
    0xe0004028    0x514    add r3, sp, #72 
    0xe000402c    0x518    ldm r3, {r2, r3}      ; stack access
    0xe0004030    0x51c    add r1, sp, #56 
    0xe0004034    0x520    ldm r1, {r0, r1}      ; stack access
    0xe0004038    0x524    bl e0001134 <create_bi_frame_cap>
    0xe000403c    0x528    ldr r2, [sp, #24]     ; stack access
    0xe0004040    0x52c    cmp r2, #0
    0xe0004044    0x530    beq e00040c4 <init_kernel+0x5b0>
    0xe0004048    0x534    movw r3, #47104 
    0xe000404c    0x538    movt r3, #57345 
    0xe0004050    0x53c    ldr r3, [r3, #156] 
    0xe0004054    0x540    add r2, r2, r3
    0xe0004058    0x544    str r2, [sp, #132]    ; stack access
    0xe000405c    0x548    str r3, [sp, #128]    ; stack access
    0xe0004060    0x54c    add r3, r3, #805306368 
    0xe0004064    0x550    sub sl, r3, sl
    0xe0004068    0x554    str sl, [sp, #16]     ; stack access
    0xe000406c    0x558    mov r3, #1
    0xe0004070    0x55c    str r3, [sp, #12]     ; stack access
    0xe0004074    0x560    add r3, sp, #128 
    0xe0004078    0x564    ldm r3, {r0, r1}      ; stack access
    0xe000407c    0x568    stmib sp, {r0, r1}    ; stack access
    0xe0004080    0x56c    ldr r3, [sp, #76]     ; stack access
    0xe0004084    0x570    str r3, [sp]          ; stack access
    0xe0004088    0x574    ldr r3, [sp, #72]     ; stack access
    0xe000408c    0x578    add r2, sp, #56 
    0xe0004090    0x57c    ldm r2, {r1, r2}      ; stack access
    0xe0004094    0x580    add r0, sp, #140 
    0xe0004098    0x584    bl e00019a8 <create_frames_of_region>
    0xe000409c    0x588    ldr r3, [sp, #148]    ; stack access
    0xe00040a0    0x58c    cmp r3, #0
    0xe00040a4    0x590    beq e0004330 <init_kernel+0x81c>
    0xe00040a8    0x594    movw r3, #47104 
    0xe00040ac    0x598    movt r3, #57345 
    0xe00040b0    0x59c    ldr r3, [r3, #124] 
    0xe00040b4    0x5a0    add r3, r3, #60 
    0xe00040b8    0x5a4    add r2, sp, #140 
    0xe00040bc    0x5a8    ldm r2, {r0, r1}      ; stack access
    0xe00040c0    0x5ac    stm r3, {r0, r1}
    0xe00040c4    0x5b0    str r4, [sp, #4]      ; stack access
    0xe00040c8    0x5b4    ldr r3, [sp, #76]     ; stack access
    0xe00040cc    0x5b8    str r3, [sp]          ; stack access
    0xe00040d0    0x5bc    ldr r3, [sp, #72]     ; stack access
    0xe00040d4    0x5c0    add r2, sp, #56 
    0xe00040d8    0x5c4    ldm r2, {r1, r2}      ; stack access
    0xe00040dc    0x5c8    add r0, sp, #80 
    0xe00040e0    0x5cc    bl e0003770 <create_ipcbuf_frame_cap>
    0xe00040e4    0x5d0    ldr r3, [sp, #80]     ; stack access
    0xe00040e8    0x5d4    and r2, r3, #14
    0xe00040ec    0x5d8    cmp r2, #14
    0xe00040f0    0x5dc    andne r3, r3, #15
    0xe00040f4    0x5e0    uxtbeq r3, r3
    0xe00040f8    0x5e4    cmp r3, #0
    0xe00040fc    0x5e8    beq e0004330 <init_kernel+0x81c>
    0xe0004100    0x5ec    ldr r3, [sp, #28]     ; stack access
    0xe0004104    0x5f0    str r3, [sp, #16]     ; stack access
    0xe0004108    0x5f4    mov r3, #1
    0xe000410c    0x5f8    str r3, [sp, #12]     ; stack access
    0xe0004110    0x5fc    add r3, sp, #88 
    0xe0004114    0x600    ldm r3, {r0, r1}      ; stack access
    0xe0004118    0x604    stmib sp, {r0, r1}    ; stack access
    0xe000411c    0x608    ldr r3, [sp, #76]     ; stack access
    0xe0004120    0x60c    str r3, [sp]          ; stack access
    0xe0004124    0x610    ldr r3, [sp, #72]     ; stack access
    0xe0004128    0x614    add r2, sp, #56 
    0xe000412c    0x618    ldm r2, {r1, r2}      ; stack access
    0xe0004130    0x61c    add r0, sp, #128 
    0xe0004134    0x620    bl e00019a8 <create_frames_of_region>
    0xe0004138    0x624    ldr r3, [sp, #136]    ; stack access
    0xe000413c    0x628    cmp r3, #0
    0xe0004140    0x62c    beq e0004330 <init_kernel+0x81c>
    0xe0004144    0x630    movw r3, #47104 
    0xe0004148    0x634    movt r3, #57345 
    0xe000414c    0x638    ldr r3, [r3, #124] 
    0xe0004150    0x63c    add r3, r3, #36 
    0xe0004154    0x640    add r2, sp, #128 
    0xe0004158    0x644    ldm r2, {r0, r1}      ; stack access
    0xe000415c    0x648    stm r3, {r0, r1}
    0xe0004160    0x64c    add r3, sp, #56 
    0xe0004164    0x650    ldm r3, {r1, r2}      ; stack access
    0xe0004168    0x654    add r0, sp, #64 
    0xe000416c    0x658    bl e0001ab8 <create_it_asid_pool>
    0xe0004170    0x65c    ldr r3, [sp, #64]     ; stack access
    0xe0004174    0x660    and r2, r3, #14
    0xe0004178    0x664    cmp r2, #14
    0xe000417c    0x668    andne r3, r3, #15
    0xe0004180    0x66c    uxtbeq r3, r3
    0xe0004184    0x670    cmp r3, #0
    0xe0004188    0x674    beq e0004330 <init_kernel+0x81c>
    0xe000418c    0x678    add r3, sp, #72 
    0xe0004190    0x67c    ldm r3, {r2, r3}      ; stack access
    0xe0004194    0x680    add r1, sp, #64 
    0xe0004198    0x684    ldm r1, {r0, r1}      ; stack access
    0xe000419c    0x688    bl e0000544 <write_it_asid_pool>
    0xe00041a0    0x68c    bl e0003008 <create_idle_thread>
    0xe00041a4    0x690    cmp r0, #0
    0xe00041a8    0x694    beq e0004330 <init_kernel+0x81c>
    0xe00041ac    0x698    bl e001288c <cleanInvalidateL1Caches>
    0xe00041b0    0x69c    add r3, sp, #12
    0xe00041b4    0x6a0    add r2, sp, #80 
    0xe00041b8    0x6a4    ldm r2, {r0, r1}      ; stack access
    0xe00041bc    0x6a8    stm r3, {r0, r1}      ; stack access
    0xe00041c0    0x6ac    str r4, [sp, #8]      ; stack access
    0xe00041c4    0x6b0    str r5, [sp, #4]      ; stack access
    0xe00041c8    0x6b4    ldr r3, [sp, #52]     ; stack access
    0xe00041cc    0x6b8    str r3, [sp]          ; stack access
    0xe00041d0    0x6bc    add r3, sp, #72 
    0xe00041d4    0x6c0    ldm r3, {r2, r3}      ; stack access
    0xe00041d8    0x6c4    add r1, sp, #56 
    0xe00041dc    0x6c8    ldm r1, {r0, r1}      ; stack access
    0xe00041e0    0x6cc    bl e0002354 <create_initial_thread>
    0xe00041e4    0x6d0    cmp r0, #0
    0xe00041e8    0x6d4    beq e0004330 <init_kernel+0x81c>
    0xe00041ec    0x6d8    bl e0002058 <init_core_state>
    0xe00041f0    0x6dc    add r5, sp, #112 
    0xe00041f4    0x6e0    add r3, sp, #56 
    0xe00041f8    0x6e4    ldm r3, {r0, r1}      ; stack access
    0xe00041fc    0x6e8    stm r5, {r0, r1}      ; stack access
    0xe0004200    0x6ec    mov r3, #-536870912 
    0xe0004204    0x6f0    str r3, [sp, #120]    ; stack access
    0xe0004208    0x6f4    str fp, [sp, #124]    ; stack access
    0xe000420c    0x6f8    movw r4, #47104 
    0xe0004210    0x6fc    movt r4, #57345 
    0xe0004214    0x700    ldr r6, [r4, #128] 
    0xe0004218    0x704    mov r2, r6
    0xe000421c    0x708    bl e00021b4 <create_device_untypeds>
    0xe0004220    0x70c    str r6, [sp]          ; stack access
    0xe0004224    0x710    add r3, sp, #120 
    0xe0004228    0x714    ldm r3, {r2, r3}      ; stack access
    0xe000422c    0x718    ldm r5, {r0, r1}      ; stack access
    0xe0004230    0x71c    bl e000228c <create_kernel_untypeds>
    0xe0004234    0x720    ldr r2, [r4, #128] 
    0xe0004238    0x724    ldr r3, [r4, #124] 
    0xe000423c    0x728    str r6, [r3, #76] 
    0xe0004240    0x72c    str r2, [r3, #80] 
    0xe0004244    0x730    ldr r3, [r4, #124] 
    0xe0004248    0x734    mov r4, #0
    0xe000424c    0x738    str r4, [r3, #28]
    0xe0004250    0x73c    str r4, [r3, #32]
    0xe0004254    0x740    bl e0002334 <bi_finalise>
    0xe0004258    0x744    bl e001288c <cleanInvalidateL1Caches>
    0xe000425c    0x748    dsb sy
    0xe0004260    0x74c    mcr 15, 0, r4, cr8, cr7, {0}
    0xe0004264    0x750    dsb sy
    0xe0004268    0x754    isb sy
    0xe000426c    0x758    movw r3, #38088 
    0xe0004270    0x75c    movt r3, #57346 
    0xe0004274    0x760    mov r2, #1
    0xe0004278    0x764    str r2, [r3]
    0xe000427c    0x768    bl e00152f8 <schedule>
    0xe0004280    0x76c    bl e0014c6c <activateThread>
    0xe0004284    0x770    add sp, sp, #156 
    0xe0004288    0x774    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe000428c    0x778    mov r8, #0
    0xe0004290    0x77c    b e0003f64 <init_kernel+0x450>
    0xe0004294    0x780    ldr r3, [sp, #48]     ; stack access
    0xe0004298    0x784    ldr ip, [sp, #40]     ; stack access
    0xe000429c    0x788    sub r2, r3, ip
    0xe00042a0    0x78c    add r6, r2, #8
    0xe00042a4    0x790    movw r3, #47104 
    0xe00042a8    0x794    movt r3, #57345 
    0xe00042ac    0x798    ldr r1, [r3, #156] 
    0xe00042b0    0x79c    mov r0, #6
    0xe00042b4    0x7a0    str r0, [r1]
    0xe00042b8    0x7a4    str r6, [r1, #4]
    0xe00042bc    0x7a8    ldr r0, [r3, #156] 
    0xe00042c0    0x7ac    mov r1, ip
    0xe00042c4    0x7b0    add r0, r0, #8
    0xe00042c8    0x7b4    bl e001b35c <memcpy>
    0xe00042cc    0x7b8    str r6, [sp, #40]     ; stack access
    0xe00042d0    0x7bc    b e0003f9c <init_kernel+0x488>
    0xe00042d4    0x7c0    movw r3, #46284 
    0xe00042d8    0x7c4    movt r3, #57345 
    0xe00042dc    0x7c8    ldr fp, [r3, #216] 
    0xe00042e0    0x7cc    add r9, r0, #-805306368 
    0xe00042e4    0x7d0    add r8, r1, #-805306368 
    0xe00042e8    0x7d4    str r9, [sp, #88]     ; stack access
    0xe00042ec    0x7d8    str r8, [sp, #92]     ; stack access
    0xe00042f0    0x7dc    ldr r3, [sp, #28]     ; stack access
    0xe00042f4    0x7e0    str r3, [sp, #32]     ; stack access
    0xe00042f8    0x7e4    sub r4, r1, r3
    0xe00042fc    0x7e8    add sl, r4, #8192 
    0xe0004300    0x7ec    str r6, [sp, #44]     ; stack access
    0xe0004304    0x7f0    mov r3, #0
    0xe0004308    0x7f4    str r3, [sp, #48]     ; stack access
    0xe000430c    0x7f8    str r3, [sp, #40]     ; stack access
    0xe0004310    0x7fc    str r3, [sp, #24]     ; stack access
    0xe0004314    0x800    ldr r0, [sp, #24]     ; stack access
    0xe0004318    0x804    bl e00013ac <calculate_extra_bi_size_bits>
    0xe000431c    0x808    str r0, [sp, #36]     ; stack access
    0xe0004320    0x80c    mov r5, #1
    0xe0004324    0x810    add r5, sl, r5, lsl r0
    0xe0004328    0x814    cmn r5, #536870913 
    0xe000432c    0x818    bls e0003b98 <init_kernel+0x84>
    0xe0004330    0x81c    bl e0010904 <halt>
    0xe0004334    0x820    .word 0xe0029010
    0xe0004338    0x824    .word 0xe0004378
    0xe000433c    0x828    .word 0xe00043a0

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
450 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_kernel` has 933 nodes.

Completing graph
-----------------

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0012A08` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_7_E001253C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E001250C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_1_E0012508` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E00120E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00120E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_ip_cr7_cr10_1_E001204C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012064` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E001209C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0012050` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_lr_cr7_cr10_1_E0011F84` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr14_1_E0012010` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011F9C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012014` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012028` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0011FC8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0011F88` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0011FDC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr14_cr1_0_E0011F58` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr0_cr1_1_E0011F48` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr0_cr1_2_E0011F44` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr7_cr14_2_E0011EDC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r3_cr0_cr0_0_E0011EA0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r2_cr0_cr0_0_E0011E98` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_r0_cr0_cr0_0_E0011E9C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_2_r3_cr0_cr0_0_E0011E90` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr7_cr14_2_E0011DDC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r3_cr0_cr0_0_E0011E4C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r9_cr0_cr0_0_E0011E44` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_r0_cr0_cr0_0_E0011E48` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_fp_cr0_cr0_1_E0011DB4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_2_r3_cr0_cr0_0_E0011E3C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr7_cr10_2_E0011CFC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r3_cr0_cr0_0_E0011D6C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r9_cr0_cr0_0_E0011D64` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_r0_cr0_cr0_0_E0011D68` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_fp_cr0_cr0_1_E0011CD4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_2_r3_cr0_cr0_0_E0011D5C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011030` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr8_cr7_2_E0011028` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E001102C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011024` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'wfi_E0010860` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr10_cr0_1_E0010844` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr10_cr0_0_E0010850` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr10_cr1_1_E0010848` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr10_cr1_0_E0010854` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr8_cr7_1_E0010840` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr10_cr0_1_E001084C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr10_cr0_0_E0010858` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sl_cr6_cr0_0_E00100E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r9_cr5_cr0_0_E00100E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r9_cr5_cr0_1_E00100B0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0000988` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr1_cr0_2_E0000984` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr1_cr0_2_E000097C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'vmsr_fpexc_r3_E00009A4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'vmrs_r3_fpexc_E00009A8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'vmrs_r3_fpexc_E000099C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012980` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012988` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_0_E001297C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012994` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012984` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012964` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00128A4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_0_E00128A0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00128A8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012890` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012898` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012638` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_0_E0012634` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E001263C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E001262C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012624` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr6_1_E00124AC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00124C4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00124B0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E001246C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011424` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr8_cr7_2_E001141C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011414` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011420` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr5_cr0_1_E00112B4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr5_cr0_0_E00112E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r1_cr6_cr0_0_E00112E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011230` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011238` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011250` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr2_cr0_0_E001122C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr13_cr0_1_E0011234` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr2_cr0_0_E001124C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011220` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'strex_r0_r1_r3_E00111A4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cpsid_aif_E0010908` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r1_cr13_cr0_3_E0010828` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r1_cr13_cr0_2_E0010820` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_19_E00100F0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'stmdb_sp_r0_r1_r2_r3_r4_r5_r6_r7_r8_r9_sl_fp_ip_sp_lr_E00100F4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'srsia_sp_19_E00100EC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sp_cr13_cr0_4_E0010108` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_19_E0010040` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'stmdb_sp_r0_r1_r2_r3_r4_r5_r6_r7_r8_r9_sl_fp_ip_sp_lr_E0010044` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'srsia_sp_19_E001003C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sp_cr13_cr0_4_E0010054` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012954` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0012928` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00128DC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E001266C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r4_cr8_cr7_2_E0012664` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E001265C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012668` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr7_cr11_1_E00113E8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00113EC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E001115C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011154` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011188` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E001116C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00110F0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr2_cr0_0_E0011150` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr2_cr0_0_E0011184` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr2_cr0_0_E0011168` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr2_cr0_0_E00110EC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr13_cr0_1_E0011158` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011178` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011144` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00110E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_3_E00101BC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_2_E00101B4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_3_E0010190` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_2_E0010188` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_3_E0010160` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_2_E0010158` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_3_E0010138` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_2_E0010130` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_19_E00100BC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'stmdb_sp_r0_r1_r2_r3_r4_r5_r6_r7_r8_r9_sl_fp_ip_sp_lr_E00100C0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'srsia_sp_19_E00100B8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sp_cr13_cr0_4_E00100D8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_19_E001008C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'stmdb_sp_r0_r1_r2_r3_r4_r5_r6_r7_r8_r9_sl_fp_ip_sp_lr_E0010090` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'srsia_sp_19_E0010088` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sp_cr13_cr0_4_E00100A8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00009E8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00009D4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr8_cr7_0_E00009E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr2_cr0_0_E00009D0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00009C4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00009E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00009D8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E001139C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr8_cr7_2_E0011394` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011398` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E001138C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E001134C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr8_cr7_1_E0011344` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011334` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011348` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'stmdb_sp_r0_r1_r2_r3_r4_r5_r6_r7_r8_r9_sl_fp_ip_sp_lr_E0010068` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'srsia_sp_19_E001005C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sp_cr13_cr0_4_E001006C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_19_E000003C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_23_E0000034` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r4_cr1_cr0_0_E0000020` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r4_cr1_cr0_0_E000000C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr7_cr11_1_E0012254` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr7_cr11_1_E001218C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0012190` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0012258` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012614` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00125F0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_4_e0010020_ki_boot_end_0x20_E0010014` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_20_e0010038_ki_boot_end_0x38_E001001C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_20_e0010034_ki_boot_end_0x34_E0010018` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_24_e0010030_ki_boot_end_0x30_E0010010` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_24_e001002c_ki_boot_end_0x2c_E001000C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_24_e0010020_ki_boot_end_0x20_E0010000` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_24_e0010028_ki_boot_end_0x28_E0010008` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_24_e0010024_ki_boot_end_0x24_E0010004` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E0019B64` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0019B68` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0004268` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr13_cr0_4_E0003BA4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r4_cr8_cr7_0_E0004260` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E000425C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0004264` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'vmsr_fpexc_r3_E0003E10` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'vmrs_r3_fpexc_E0003E08` has 0 nodes.

Proving correctness of call offsets
===================================

Offsets proved correct.

Summary
=======

No stack intro failures.
Graph spec failed in _start for pos 0xe0000008.
Graph spec failed in _start for pos 0xe0000008.
No export failures.
No call offset failures.
> 