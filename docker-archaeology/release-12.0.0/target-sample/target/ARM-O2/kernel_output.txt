
---------------------------------------------------------------------
       HOL-4 [Kananaskis 13 (stdknl, built Mon Dec 11 07:11:08 2023)]

       For introductory HOL help, type: help "hol";
       To exit type <Control>-D
---------------------------------------------------------------------
** Load path (see loadPath variable) now contains 18 entries
** after consulting Holmakefiles

[In non-standard heap: /work/HOL4/examples/machine-code/graph/local-hol-heap]
> > 
Resetting specifications database.

Specializing fetch: 4 -> 1(1)
Specializing decode ARM (cond = 14): 95 -> 95(95)
Specializing decode ARM (cond = 15): 5 -> 5(5)
Specializing decode ARM (cond not in {14, 15}): 95 -> 95(95)
Specializing decode ARM (fallback): 1 -> 1(1)
Specializing eval: 374 -> 348(348)
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
val it = (): unit
> ======================================================================
  Base name: /work/graph-refine/seL4-example/target/ARM-O2/kernel
  Poly/ML: 581
  HOL: Kananaskis 13 (stdknl) commit 6c0c2409e
======================================================================
  Reading /work/graph-refine/seL4-example/target/ARM-O2/kernel.elf.txt, done.
  Reading /work/graph-refine/seL4-example/target/ARM-O2/kernel.elf.txt, done.
  Reading /work/graph-refine/seL4-example/target/ARM-O2/kernel.sigs, done.
No signature info for section: _start
No signature info for section: avail_p_regs
No signature info for section: kernel_devices
No signature info for section: mode_reserved_region
No signature info for section: avail_reg
No signature info for section: reserved
No signature info for section: arm_vector_table
No signature info for section: arm_undefined_inst_exception
No signature info for section: arm_swi_syscall
No signature info for section: arm_prefetch_abort_exception
No signature info for section: kernel_prefetch_fault
No signature info for section: arm_data_abort_exception
No signature info for section: kernel_data_fault
No signature info for section: arm_irq_exception
No signature info for section: arm_reset_exception
No signature info for section: arm_fiq_exception
======================================================================
  Total: 299 functions, 15510 ARM instructions
  Longest function: decodeARMMMUInvocation (1047 instructions)
  0 deps: 108 functions (avail_p_regs, kernel_devices, ...)
  1 deps: 95 functions (initIRQController, ...)
  2 deps: 43 functions (replyFromKernel_error, ...)
  3 deps: 24 functions (slowpath, invokeUntyped_Retype, ...)
  4 deps: 9 functions (decodeSetIPCBuffer, handleVMFaultEvent, ...)
  5 deps: 8 functions (decodeUntypedInvocation, decodeSetSpace, ...)
  6 deps: 3 functions (decodeTCBConfigure, finaliseCap, ...)
  7 deps: 3 functions (handleInvocation, cteDelete, ...)
  10 deps: 1 functions (handleSyscall)
  12 deps: 1 functions (decodeInvocation)
  13 deps: 1 functions (decodeCNodeInvocation)
  14 deps: 1 functions (decodeARMMMUInvocation)
  15 deps: 1 functions (decodeTCBInvocation)
  25 deps: 1 functions (init_kernel)
======================================================================

Section avail_p_regs (1 of 299)
===============================

Deriving specifications
-----------------------

Section `avail_p_regs` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `avail_p_regs` has 0 nodes.

Section kernel_devices (2 of 299)
=================================

Deriving specifications
-----------------------

Section `kernel_devices` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `kernel_devices` has 0 nodes.

Section mode_reserved_region (3 of 299)
=======================================

Deriving specifications
-----------------------

Section `mode_reserved_region` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `mode_reserved_region` has 0 nodes.

Section avail_reg (4 of 299)
============================

Deriving specifications
-----------------------

Section `avail_reg` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `avail_reg` has 0 nodes.

Section reserved (5 of 299)
===========================

Deriving specifications
-----------------------

Section `reserved` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `reserved` has 0 nodes.

Section c_handle_fastpath_call (6 of 299)
=========================================

Deriving specifications
-----------------------

Section `c_handle_fastpath_call` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_fastpath_call` has 0 nodes.

Section c_handle_fastpath_reply_recv (7 of 299)
===============================================

Deriving specifications
-----------------------

Section `c_handle_fastpath_reply_recv` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_fastpath_reply_recv` has 0 nodes.

Section restore_user_context (8 of 299)
=======================================

Deriving specifications
-----------------------

Section `restore_user_context` consists of 0 instructions.

Proving inst theorems
---------------------

0 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `restore_user_context` has 0 nodes.

Section char_to_long (9 of 299)
===============================

Deriving specifications
-----------------------

Section `char_to_long` consists of 16 instructions.
 SUB (imm)...++
 SXT{A}B,UXT{A}B.......+++++++
 CMP (imm)..+
 BLS..++
 SUBLS (imm)....+++
 MVNHI (imm)..++
 BX.+
 MOV (reg)...++


Stack analysis
---------------

No stack accesses found. Code for `char_to_long`:

    0xe001b30c     0x0    sub r3, r0, #48 
    0xe001b310     0x4    uxtb r2, r3
    0xe001b314     0x8    cmp r2, #9
    0xe001b318     0xc    bls e001b344 <char_to_long+0x38>
    0xe001b31c    0x10    sub r3, r0, #65 
    0xe001b320    0x14    cmp r3, #5
    0xe001b324    0x18    bls e001b33c <char_to_long+0x30>
    0xe001b328    0x1c    sub r3, r0, #97 
    0xe001b32c    0x20    cmp r3, #5
    0xe001b330    0x24    subls r0, r0, #87 
    0xe001b334    0x28    mvnhi r0, #0
    0xe001b338    0x2c    bx lr
    0xe001b33c    0x30    sub r0, r0, #55 
    0xe001b340    0x34    bx lr
    0xe001b344    0x38    mov r0, r3
    0xe001b348    0x3c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `char_to_long` has 27 nodes.

Section strncmp (10 of 299)
===========================

Deriving specifications
-----------------------

Section `strncmp` consists of 29 instructions.
 BEQ..++
 LDRB (+imm,pre)..++
 SUBS (reg)..........+++++
 BNE..++
 STR (-imm,pre,wb)..+
 ADD (reg)..........+++++
 B.+
 LDRB (+imm,pre,wb).+
 LDRNE (imm,post).. LDRNE (pc,imm,post)..++++
 LDREQ (imm,post).. LDREQ (pc,imm,post)..++++
 CMP (reg).....++
 MOV (imm).+
 LDR (imm,post). LDR (pc,imm,post).++


Stack analysis
---------------

4 stack accesses found. Annotated code for `strncmp`:

    0xe001b298     0x0    cmp r2, #0
    0xe001b29c     0x4    beq e001b2f4 <strncmp+0x5c>
    0xe001b2a0     0x8    ldrb ip, [r0]
    0xe001b2a4     0xc    ldrb r3, [r1]
    0xe001b2a8    0x10    subs r3, ip, r3
    0xe001b2ac    0x14    bne e001b2fc <strncmp+0x64>
    0xe001b2b0    0x18    cmp ip, #0
    0xe001b2b4    0x1c    beq e001b304 <strncmp+0x6c>
    0xe001b2b8    0x20    push {lr}             ; stack access
    0xe001b2bc    0x24    sub lr, r0, #1
    0xe001b2c0    0x28    mov ip, r0
    0xe001b2c4    0x2c    add lr, lr, r2
    0xe001b2c8    0x30    b e001b2e4 <strncmp+0x4c>
    0xe001b2cc    0x34    ldrb r3, [ip, #1]!
    0xe001b2d0    0x38    ldrb r2, [r1, #1]!
    0xe001b2d4    0x3c    subs r0, r3, r2
    0xe001b2d8    0x40    popne {pc}            ; stack access
    0xe001b2dc    0x44    cmp r3, #0
    0xe001b2e0    0x48    popeq {pc}            ; stack access
    0xe001b2e4    0x4c    cmp ip, lr
    0xe001b2e8    0x50    bne e001b2cc <strncmp+0x34>
    0xe001b2ec    0x54    mov r0, #0
    0xe001b2f0    0x58    pop {pc}              ; stack access
    0xe001b2f4    0x5c    mov r0, r2
    0xe001b2f8    0x60    bx lr
    0xe001b2fc    0x64    mov r0, r3
    0xe001b300    0x68    bx lr
    0xe001b304    0x6c    mov r0, ip
    0xe001b308    0x70    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
29 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strncmp` has 52 nodes.

Section memcpy (11 of 299)
==========================

Deriving specifications
-----------------------

Section `memcpy` consists of 10 instructions.
 BXEQ..++
 STRB (imm,post).+


Stack analysis
---------------

No stack accesses found. Code for `memcpy`:

    0xe001b270     0x0    cmp r2, #0
    0xe001b274     0x4    bxeq lr
    0xe001b278     0x8    sub r1, r1, #1
    0xe001b27c     0xc    add r2, r0, r2
    0xe001b280    0x10    mov r3, r0
    0xe001b284    0x14    ldrb ip, [r1, #1]!
    0xe001b288    0x18    strb ip, [r3], #1
    0xe001b28c    0x1c    cmp r3, r2
    0xe001b290    0x20    bne e001b284 <memcpy+0x14>
    0xe001b294    0x24    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memcpy` has 18 nodes.

Section memset (12 of 299)
==========================

Deriving specifications
-----------------------

Section `memset` consists of 21 instructions.
 ORR (reg)..........+++++
 ANDS (imm)...++
 SUBS (imm)...++
 STR (imm,post)..+


Stack analysis
---------------

No stack accesses found. Code for `memset`:

    0xe001b21c     0x0    cmp r1, #0
    0xe001b220     0x4    bne e001b24c <memset+0x30>
    0xe001b224     0x8    orr r3, r0, r2
    0xe001b228     0xc    ands r3, r3, #3
    0xe001b22c    0x10    bne e001b24c <memset+0x30>
    0xe001b230    0x14    cmp r2, #0
    0xe001b234    0x18    bxeq lr
    0xe001b238    0x1c    mov r1, r0
    0xe001b23c    0x20    subs r2, r2, #4
    0xe001b240    0x24    str r3, [r1], #4
    0xe001b244    0x28    bne e001b23c <memset+0x20>
    0xe001b248    0x2c    bx lr
    0xe001b24c    0x30    cmp r2, #0
    0xe001b250    0x34    bxeq lr
    0xe001b254    0x38    uxtb r1, r1
    0xe001b258    0x3c    add r2, r0, r2
    0xe001b25c    0x40    mov r3, r0
    0xe001b260    0x44    strb r1, [r3], #1
    0xe001b264    0x48    cmp r2, r3
    0xe001b268    0x4c    bne e001b260 <memset+0x44>
    0xe001b26c    0x50    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memset` has 39 nodes.

Section memzero (13 of 299)
===========================

Deriving specifications
-----------------------

Section `memzero` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `memzero`:

    0xe001b200     0x0    cmp r1, #0
    0xe001b204     0x4    bxeq lr
    0xe001b208     0x8    mov r3, #0
    0xe001b20c     0xc    subs r1, r1, #4
    0xe001b210    0x10    str r3, [r0], #4
    0xe001b214    0x14    bne e001b20c <memzero+0xc>
    0xe001b218    0x18    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `memzero` has 14 nodes.

Section strlcat (14 of 299)
===========================

Deriving specifications
-----------------------

Section `strlcat` consists of 50 instructions.
 STMDB (wb);14,5,4..+
 ADD (imm)...++
 LDMIA (wb);15,5,4.+
 STRB (+reg,pre).....+++++
 STRB (+imm,pre)..++


Stack analysis
---------------

3 stack accesses found. Annotated code for `strlcat`:

    0xe001b138     0x0    cmp r2, #0
    0xe001b13c     0x4    beq e001b1e4 <strlcat+0xac>
    0xe001b140     0x8    push {r4, r5, lr}     ; stack access
    0xe001b144     0xc    ldrb r5, [r0]
    0xe001b148    0x10    cmp r5, #0
    0xe001b14c    0x14    beq e001b1f4 <strlcat+0xbc>
    0xe001b150    0x18    add lr, r0, #1
    0xe001b154    0x1c    mov r4, #0
    0xe001b158    0x20    b e001b16c <strlcat+0x34>
    0xe001b15c    0x24    ldrb r5, [ip]
    0xe001b160    0x28    cmp r5, #0
    0xe001b164    0x2c    beq e001b188 <strlcat+0x50>
    0xe001b168    0x30    mov r4, r3
    0xe001b16c    0x34    add r3, r4, #1
    0xe001b170    0x38    mov ip, lr
    0xe001b174    0x3c    cmp r2, r3
    0xe001b178    0x40    add lr, lr, #1
    0xe001b17c    0x44    bne e001b15c <strlcat+0x24>
    0xe001b180    0x48    mov r0, r3
    0xe001b184    0x4c    pop {r4, r5, pc}      ; stack access
    0xe001b188    0x50    mov r5, r3
    0xe001b18c    0x54    add r3, r4, #2
    0xe001b190    0x58    cmp r2, r3
    0xe001b194    0x5c    bls e001b1ec <strlcat+0xb4>
    0xe001b198    0x60    ldrb lr, [r1]
    0xe001b19c    0x64    cmp lr, #0
    0xe001b1a0    0x68    beq e001b1ec <strlcat+0xb4>
    0xe001b1a4    0x6c    sub r2, r2, #1
    0xe001b1a8    0x70    b e001b1c0 <strlcat+0x88>
    0xe001b1ac    0x74    ldrb lr, [r1, #1]!
    0xe001b1b0    0x78    mov r5, r3
    0xe001b1b4    0x7c    cmp lr, #0
    0xe001b1b8    0x80    beq e001b1d4 <strlcat+0x9c>
    0xe001b1bc    0x84    mov r3, r4
    0xe001b1c0    0x88    cmp r3, r2
    0xe001b1c4    0x8c    strb lr, [r0, r5]
    0xe001b1c8    0x90    add ip, r0, r3
    0xe001b1cc    0x94    add r4, r3, #1
    0xe001b1d0    0x98    bne e001b1ac <strlcat+0x74>
    0xe001b1d4    0x9c    mov r2, #0
    0xe001b1d8    0xa0    mov r0, r3
    0xe001b1dc    0xa4    strb r2, [ip]
    0xe001b1e0    0xa8    pop {r4, r5, pc}      ; stack access
    0xe001b1e4    0xac    mov r0, r2
    0xe001b1e8    0xb0    bx lr
    0xe001b1ec    0xb4    mov r3, r5
    0xe001b1f0    0xb8    b e001b1d4 <strlcat+0x9c>
    0xe001b1f4    0xbc    mov ip, r0
    0xe001b1f8    0xc0    mov r3, #1
    0xe001b1fc    0xc4    b e001b190 <strlcat+0x58>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
50 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strlcat` has 76 nodes.

Section strlcpy (15 of 299)
===========================

Deriving specifications
-----------------------

Section `strlcpy` consists of 27 instructions.
 STMDB (wb);14,4..+
 LDRB (imm,post).+
 SUB (reg)..........+++++
 LDMIA (wb);15,4.+


Stack analysis
---------------

2 stack accesses found. Annotated code for `strlcpy`:

    0xe001b0cc     0x0    cmp r2, #1
    0xe001b0d0     0x4    push {r4, lr}         ; stack access
    0xe001b0d4     0x8    mov r4, r0
    0xe001b0d8     0xc    bls e001b128 <strlcpy+0x5c>
    0xe001b0dc    0x10    ldrb ip, [r1]
    0xe001b0e0    0x14    cmp ip, #0
    0xe001b0e4    0x18    beq e001b130 <strlcpy+0x64>
    0xe001b0e8    0x1c    add r2, r1, r2
    0xe001b0ec    0x20    add r3, r1, #1
    0xe001b0f0    0x24    sub lr, r2, #1
    0xe001b0f4    0x28    mov r2, r0
    0xe001b0f8    0x2c    b e001b108 <strlcpy+0x3c>
    0xe001b0fc    0x30    ldrb ip, [r3], #1
    0xe001b100    0x34    cmp ip, #0
    0xe001b104    0x38    beq e001b11c <strlcpy+0x50>
    0xe001b108    0x3c    cmp r3, lr
    0xe001b10c    0x40    strb ip, [r2], #1
    0xe001b110    0x44    sub r0, r3, r1
    0xe001b114    0x48    mov r4, r2
    0xe001b118    0x4c    bne e001b0fc <strlcpy+0x30>
    0xe001b11c    0x50    mov r3, #0
    0xe001b120    0x54    strb r3, [r4]
    0xe001b124    0x58    pop {r4, pc}          ; stack access
    0xe001b128    0x5c    mov r0, #0
    0xe001b12c    0x60    b e001b11c <strlcpy+0x50>
    0xe001b130    0x64    mov r0, ip
    0xe001b134    0x68    b e001b11c <strlcpy+0x50>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strlcpy` has 41 nodes.

Section strnlen (16 of 299)
===========================

Deriving specifications
-----------------------

Section `strnlen` consists of 18 instructions.


Stack analysis
---------------

No stack accesses found. Code for `strnlen`:

    0xe001b084     0x0    cmp r1, #0
    0xe001b088     0x4    beq e001b0bc <strnlen+0x38>
    0xe001b08c     0x8    ldrb r3, [r0]
    0xe001b090     0xc    cmp r3, #0
    0xe001b094    0x10    beq e001b0c4 <strnlen+0x40>
    0xe001b098    0x14    mov r3, r0
    0xe001b09c    0x18    mov r0, #0
    0xe001b0a0    0x1c    add r0, r0, #1
    0xe001b0a4    0x20    cmp r1, r0
    0xe001b0a8    0x24    bxeq lr
    0xe001b0ac    0x28    ldrb r2, [r3, #1]!
    0xe001b0b0    0x2c    cmp r2, #0
    0xe001b0b4    0x30    bne e001b0a0 <strnlen+0x1c>
    0xe001b0b8    0x34    bx lr
    0xe001b0bc    0x38    mov r0, r1
    0xe001b0c0    0x3c    bx lr
    0xe001b0c4    0x40    mov r0, r3
    0xe001b0c8    0x44    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `strnlen` has 32 nodes.

Section copyMRs (17 of 299)
===========================

Deriving specifications
-----------------------

Section `copyMRs` consists of 37 instructions.
 STMDB (wb);14,7,6,5,4..+
 LDR (+imm,pre)..++
 LDR (+imm,pre) LDR (+lit).+
 LDR (+reg,pre).....+++++
 MOVHI (imm)..++
 MOVLS (imm)..++
 STR (+reg,pre).......+++++
 LDRNE (+reg,pre)......++++++
 CMPNE (imm)...++
 LDMIA (wb);15,7,6,5,4.+
 LDR (+imm,pre,wb).+
 STR (+imm,pre,wb)..+


Stack analysis
---------------

4 stack accesses found. Annotated code for `copyMRs`:

    0xe00189fc     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0018a00     0x4    ldr r4, [sp, #20]     ; stack access
    0xe0018a04     0x8    cmp r4, #0
    0xe0018a08     0xc    beq e0018a54 <copyMRs+0x58>
    0xe0018a0c    0x10    ldr r7, [pc, #120] 
    0xe0018a10    0x14    mov lr, #2
    0xe0018a14    0x18    mov ip, #0
    0xe0018a18    0x1c    add ip, ip, #1
    0xe0018a1c    0x20    ldr r5, [r0, lr, lsl #2]
    0xe0018a20    0x24    cmp r4, ip
    0xe0018a24    0x28    movhi r6, #1
    0xe0018a28    0x2c    movls r6, #0
    0xe0018a2c    0x30    cmp ip, #3
    0xe0018a30    0x34    str r5, [r2, lr, lsl #2]
    0xe0018a34    0x38    movhi r6, #0
    0xe0018a38    0x3c    cmp r6, #0
    0xe0018a3c    0x40    ldrne lr, [r7, ip, lsl #2]
    0xe0018a40    0x44    bne e0018a18 <copyMRs+0x1c>
    0xe0018a44    0x48    cmp r1, #0
    0xe0018a48    0x4c    cmpne r3, #0
    0xe0018a4c    0x50    bne e0018a5c <copyMRs+0x60>
    0xe0018a50    0x54    mov r4, ip
    0xe0018a54    0x58    mov r0, r4
    0xe0018a58    0x5c    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0018a5c    0x60    cmp r4, ip
    0xe0018a60    0x64    bls e0018a50 <copyMRs+0x54>
    0xe0018a64    0x68    lsl ip, ip, #2
    0xe0018a68    0x6c    add r0, r1, r4, lsl #2
    0xe0018a6c    0x70    add r3, r3, ip
    0xe0018a70    0x74    add ip, r1, ip
    0xe0018a74    0x78    ldr r2, [ip, #4]!
    0xe0018a78    0x7c    cmp ip, r0
    0xe0018a7c    0x80    str r2, [r3, #4]!
    0xe0018a80    0x84    bne e0018a74 <copyMRs+0x78>
    0xe0018a84    0x88    mov r0, r4
    0xe0018a88    0x8c    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0018a8c    0x90    .word 0xe001b428

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
36 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `copyMRs` has 65 nodes.

Section setExtraBadge (18 of 299)
=================================

Deriving specifications
-----------------------

Section `setExtraBadge` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setExtraBadge`:

    0xe0017be4    0x0    add r2, r2, #122 
    0xe0017be8    0x4    str r1, [r0, r2, lsl #2]
    0xe0017bec    0x8    bx lr

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setExtraBadge` has 5 nodes.

Section getExtraCPtr (19 of 299)
================================

Deriving specifications
-----------------------

Section `getExtraCPtr` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `getExtraCPtr`:

    0xe0017bd8    0x0    add r1, r1, #122 
    0xe0017bdc    0x4    ldr r0, [r0, r1, lsl #2]
    0xe0017be0    0x8    bx lr

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getExtraCPtr` has 5 nodes.

Section tcbEPDequeue (20 of 299)
================================

Deriving specifications
-----------------------

Section `tcbEPDequeue` consists of 21 instructions.
 STMDB;3,2...+
 STRNE (+imm,pre)....+++
 MOVEQ (reg)....+++
 LDRNE (+imm,pre)...+++
 STR (+imm,pre)...++


Stack analysis
---------------

Section `tcbEPDequeue` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `tcbEPDequeue`:

    0xe0017b84     0x0    push {lr}             ; stack access
    0xe0017b88     0x4    sub sp, sp, #12
    0xe0017b8c     0x8    add ip, sp, #8
    0xe0017b90     0xc    stmdb ip, {r2, r3}    ; stack access
    0xe0017b94    0x10    mov r2, r0
    0xe0017b98    0x14    ldr ip, [r1, #148] 
    0xe0017b9c    0x18    ldr r3, [r1, #144] 
    0xe0017ba0    0x1c    cmp ip, #0
    0xe0017ba4    0x20    ldr lr, [sp, #4]      ; stack access
    0xe0017ba8    0x24    strne r3, [ip, #144] 
    0xe0017bac    0x28    moveq r0, r3
    0xe0017bb0    0x2c    ldrne r3, [r1, #144] 
    0xe0017bb4    0x30    ldrne r0, [sp]        ; stack access
    0xe0017bb8    0x34    cmp r3, #0
    0xe0017bbc    0x38    strne ip, [r3, #148] 
    0xe0017bc0    0x3c    moveq lr, ip
    0xe0017bc4    0x40    str r0, [r2]          ; stack access
    0xe0017bc8    0x44    str lr, [r2, #4]      ; stack access
    0xe0017bcc    0x48    mov r0, r2
    0xe0017bd0    0x4c    add sp, sp, #12
    0xe0017bd4    0x50    pop {pc}              ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbEPDequeue` has 45 nodes.

Section tcbEPAppend (21 of 299)
===============================

Deriving specifications
-----------------------

Section `tcbEPAppend` consists of 17 instructions.


Stack analysis
---------------

Section `tcbEPAppend` expects pointer to stack in r0.
5 stack accesses found. Annotated code for `tcbEPAppend`:

    0xe0017b40     0x0    sub sp, sp, #8
    0xe0017b44     0x4    add ip, sp, #8
    0xe0017b48     0x8    stmdb ip, {r2, r3}    ; stack access
    0xe0017b4c     0xc    mov r3, r0
    0xe0017b50    0x10    ldr r2, [sp]          ; stack access
    0xe0017b54    0x14    ldr r0, [sp, #4]      ; stack access
    0xe0017b58    0x18    cmp r2, #0
    0xe0017b5c    0x1c    str r1, [r3, #4]      ; stack access
    0xe0017b60    0x20    strne r1, [r0, #144] 
    0xe0017b64    0x24    moveq r2, r1
    0xe0017b68    0x28    str r0, [r1, #148] 
    0xe0017b6c    0x2c    mov r0, r3
    0xe0017b70    0x30    str r2, [r3]          ; stack access
    0xe0017b74    0x34    mov r2, #0
    0xe0017b78    0x38    str r2, [r1, #144] 
    0xe0017b7c    0x3c    add sp, sp, #8
    0xe0017b80    0x40    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbEPAppend` has 30 nodes.

Section tcbSchedDequeue (22 of 299)
===================================

Deriving specifications
-----------------------

Section `tcbSchedDequeue` consists of 52 instructions.
 TST (imm)..+
 STMDB (wb);14,9,8,7,6,5,4..+
 MOVW.+
 MOVT.+
 BIC (imm)...++
 LDMIA (wb);15,9,8,7,6,5,4.+
 RSB (imm)...++
 AND (imm)...++
 BIC (reg-shift)...............+++++++++++++++


Stack analysis
---------------

2 stack accesses found. Annotated code for `tcbSchedDequeue`:

    0xe0016384     0x0    ldr r3, [r0, #84] 
    0xe0016388     0x4    tst r3, #1
    0xe001638c     0x8    bxeq lr
    0xe0016390     0xc    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe0016394    0x10    movw r5, #38092 
    0xe0016398    0x14    ldr lr, [r0, #112] 
    0xe001639c    0x18    movt r5, #57346 
    0xe00163a0    0x1c    ldr ip, [r0, #120] 
    0xe00163a4    0x20    ldr r1, [r0, #140] 
    0xe00163a8    0x24    add r6, ip, lr, lsl #8
    0xe00163ac    0x28    ldr r2, [r0, #136] 
    0xe00163b0    0x2c    cmp r1, #0
    0xe00163b4    0x30    add r7, r5, r6, lsl #3
    0xe00163b8    0x34    ldr r4, [r7, #4]
    0xe00163bc    0x38    beq e00163f0 <tcbSchedDequeue+0x6c>
    0xe00163c0    0x3c    ldr ip, [r5, r6, lsl #3]
    0xe00163c4    0x40    str r2, [r1, #136] 
    0xe00163c8    0x44    ldr r2, [r0, #136] 
    0xe00163cc    0x48    cmp r2, #0
    0xe00163d0    0x4c    moveq r4, r1
    0xe00163d4    0x50    beq e00163dc <tcbSchedDequeue+0x58>
    0xe00163d8    0x54    str r1, [r2, #140] 
    0xe00163dc    0x58    str ip, [r5, r6, lsl #3]
    0xe00163e0    0x5c    bic r3, r3, #1
    0xe00163e4    0x60    str r4, [r7, #4]
    0xe00163e8    0x64    str r3, [r0, #84] 
    0xe00163ec    0x68    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe00163f0    0x6c    cmp r2, #0
    0xe00163f4    0x70    bne e0016434 <tcbSchedDequeue+0xb0>
    0xe00163f8    0x74    lsr r8, ip, #5
    0xe00163fc    0x78    movw r1, #12292 
    0xe0016400    0x7c    rsb r4, r8, #7
    0xe0016404    0x80    movt r1, #57347 
    0xe0016408    0x84    add r4, r4, lr, lsl #3
    0xe001640c    0x88    and ip, ip, #31
    0xe0016410    0x8c    mov r9, #1
    0xe0016414    0x90    ldr r2, [r1, r4, lsl #2]
    0xe0016418    0x94    bic ip, r2, r9, lsl ip
    0xe001641c    0x98    str ip, [r1, r4, lsl #2]
    0xe0016420    0x9c    cmp ip, #0
    0xe0016424    0xa0    beq e001643c <tcbSchedDequeue+0xb8>
    0xe0016428    0xa4    mov ip, #0
    0xe001642c    0xa8    mov r4, ip
    0xe0016430    0xac    b e00163dc <tcbSchedDequeue+0x58>
    0xe0016434    0xb0    mov ip, r2
    0xe0016438    0xb4    b e00163d8 <tcbSchedDequeue+0x54>
    0xe001643c    0xb8    movw r2, #12808 
    0xe0016440    0xbc    movt r2, #57347 
    0xe0016444    0xc0    ldr r1, [r2, lr, lsl #2]
    0xe0016448    0xc4    bic r8, r1, r9, lsl r8
    0xe001644c    0xc8    str r8, [r2, lr, lsl #2]
    0xe0016450    0xcc    b e0016428 <tcbSchedDequeue+0xa4>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
52 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedDequeue` has 85 nodes.

Section updateCapData (23 of 299)
=================================

Deriving specifications
-----------------------

Section `updateCapData` consists of 56 instructions.
 ANDNE (imm)....+++
 SXT{A}B,UXT{A}BEQ........++++++++
 STMIA;14,12...+
 LDMIA (wb);14,4.+
 MOVS (reg)...++
 ORREQ (reg)...........++++++
 STMIAEQ;14,2....++
 SBFX,UBFX..++
 BHI..++
 MVN (imm).+
 AND (reg)..........+++++


Stack analysis
---------------

Section `updateCapData` expects pointer to stack in r0.
12 stack accesses found. Annotated code for `updateCapData`:

    0xe0015e7c     0x0    sub sp, sp, #8
    0xe0015e80     0x4    mov ip, r3
    0xe0015e84     0x8    push {r4, lr}         ; stack access
    0xe0015e88     0xc    and lr, r3, #14
    0xe0015e8c    0x10    cmp lr, #14
    0xe0015e90    0x14    str r3, [sp, #12]     ; stack access
    0xe0015e94    0x18    andne r3, r3, #15
    0xe0015e98    0x1c    uxtbeq r3, ip
    0xe0015e9c    0x20    tst r3, #1
    0xe0015ea0    0x24    ldr lr, [sp, #16]     ; stack access
    0xe0015ea4    0x28    bne e0015ec0 <updateCapData+0x44>
    0xe0015ea8    0x2c    cmp r3, #6
    0xe0015eac    0x30    beq e0015ed0 <updateCapData+0x54>
    0xe0015eb0    0x34    cmp r3, #10
    0xe0015eb4    0x38    beq e0015f1c <updateCapData+0xa0>
    0xe0015eb8    0x3c    cmp r3, #4
    0xe0015ebc    0x40    beq e0015eec <updateCapData+0x70>
    0xe0015ec0    0x44    stm r0, {ip, lr}      ; stack access
    0xe0015ec4    0x48    pop {r4, lr}          ; stack access
    0xe0015ec8    0x4c    add sp, sp, #8
    0xe0015ecc    0x50    bx lr
    0xe0015ed0    0x54    cmp r1, #0
    0xe0015ed4    0x58    bne e0015f04 <updateCapData+0x88>
    0xe0015ed8    0x5c    lsrs r3, lr, #4
    0xe0015edc    0x60    bne e0015f04 <updateCapData+0x88>
    0xe0015ee0    0x64    orr lr, lr, r2, lsl #4
    0xe0015ee4    0x68    stm r0, {ip, lr}      ; stack access
    0xe0015ee8    0x6c    b e0015ec4 <updateCapData+0x48>
    0xe0015eec    0x70    cmp r1, #0
    0xe0015ef0    0x74    bne e0015f04 <updateCapData+0x88>
    0xe0015ef4    0x78    lsrs r3, ip, #4
    0xe0015ef8    0x7c    orreq r2, ip, r2, lsl #4
    0xe0015efc    0x80    stmeq r0, {r2, lr}    ; stack access
    0xe0015f00    0x84    beq e0015ec4 <updateCapData+0x48>
    0xe0015f04    0x88    pop {r4, lr}          ; stack access
    0xe0015f08    0x8c    mov r3, #0
    0xe0015f0c    0x90    str r3, [r0]          ; stack access
    0xe0015f10    0x94    str r3, [r0, #4]      ; stack access
    0xe0015f14    0x98    add sp, sp, #8
    0xe0015f18    0x9c    bx lr
    0xe0015f1c    0xa0    ubfx r4, r2, #3, #5
    0xe0015f20    0xa4    ubfx r1, lr, #18, #5
    0xe0015f24    0xa8    add r1, r1, r4
    0xe0015f28    0xac    cmp r1, #32
    0xe0015f2c    0xb0    bhi e0015f04 <updateCapData+0x88>
    0xe0015f30    0xb4    mvn r3, #0
    0xe0015f34    0xb8    ubfx r2, r2, #8, #18
    0xe0015f38    0xbc    bic r2, r2, r3, lsl r4
    0xe0015f3c    0xc0    mov r3, #0
    0xe0015f40    0xc4    movt r3, #61564 
    0xe0015f44    0xc8    str ip, [r0]          ; stack access
    0xe0015f48    0xcc    and r3, r3, lr
    0xe0015f4c    0xd0    orr r2, r3, r2
    0xe0015f50    0xd4    orr r2, r2, r4, lsl #23
    0xe0015f54    0xd8    str r2, [r0, #4]      ; stack access
    0xe0015f58    0xdc    b e0015ec4 <updateCapData+0x48>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
56 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `updateCapData` has 96 nodes.

Section hasCancelSendRights (24 of 299)
=======================================

Deriving specifications
-----------------------

Section `hasCancelSendRights` consists of 23 instructions.
 STMDB;1,0...+
 CLZ..++


Stack analysis
---------------

3 stack accesses found. Annotated code for `hasCancelSendRights`:

    0xe00142a4     0x0    sub sp, sp, #8
    0xe00142a8     0x4    add r3, sp, #8
    0xe00142ac     0x8    stmdb r3, {r0, r1}    ; stack access
    0xe00142b0     0xc    ldr r3, [sp]          ; stack access
    0xe00142b4    0x10    ldr r0, [sp, #4]      ; stack access
    0xe00142b8    0x14    and r2, r3, #14
    0xe00142bc    0x18    cmp r2, #14
    0xe00142c0    0x1c    andne r3, r3, #15
    0xe00142c4    0x20    uxtbeq r3, r3
    0xe00142c8    0x24    cmp r3, #4
    0xe00142cc    0x28    bne e00142dc <hasCancelSendRights+0x38>
    0xe00142d0    0x2c    and r3, r0, #3
    0xe00142d4    0x30    cmp r3, #3
    0xe00142d8    0x34    beq e00142e8 <hasCancelSendRights+0x44>
    0xe00142dc    0x38    mov r0, #0
    0xe00142e0    0x3c    add sp, sp, #8
    0xe00142e4    0x40    bx lr
    0xe00142e8    0x44    and r0, r0, #12
    0xe00142ec    0x48    sub r0, r0, #12
    0xe00142f0    0x4c    clz r0, r0
    0xe00142f4    0x50    lsr r0, r0, #5
    0xe00142f8    0x54    add sp, sp, #8
    0xe00142fc    0x58    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `hasCancelSendRights` has 36 nodes.

Section bindNotification (25 of 299)
====================================

Deriving specifications
-----------------------

Section `bindNotification` consists of 7 instructions.


Stack analysis
---------------

No stack accesses found. Code for `bindNotification`:

    0xe001423c     0x0    ldr r3, [r1, #12]
    0xe0014240     0x4    bic r2, r0, #15
    0xe0014244     0x8    and r3, r3, #15
    0xe0014248     0xc    orr r3, r3, r2
    0xe001424c    0x10    str r3, [r1, #12]
    0xe0014250    0x14    str r1, [r0, #92] 
    0xe0014254    0x18    bx lr

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `bindNotification` has 11 nodes.

Section unbindNotification (26 of 299)
======================================

Deriving specifications
-----------------------

Section `unbindNotification` consists of 8 instructions.
 MOVNE (imm)..++


Stack analysis
---------------

No stack accesses found. Code for `unbindNotification`:

    0xe001421c     0x0    ldr r3, [r0, #92] 
    0xe0014220     0x4    cmp r3, #0
    0xe0014224     0x8    ldrne r2, [r3, #12]
    0xe0014228     0xc    movne r1, #0
    0xe001422c    0x10    andne r2, r2, #15
    0xe0014230    0x14    strne r2, [r3, #12]
    0xe0014234    0x18    strne r1, [r0, #92] 
    0xe0014238    0x1c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unbindNotification` has 23 nodes.

Section unbindMaybeNotification (27 of 299)
===========================================

Deriving specifications
-----------------------

Section `unbindMaybeNotification` consists of 7 instructions.
 BICS (imm)...++


Stack analysis
---------------

No stack accesses found. Code for `unbindMaybeNotification`:

    0xe0014200     0x0    ldr r3, [r0, #12]
    0xe0014204     0x4    bics r2, r3, #15
    0xe0014208     0x8    andne r3, r3, #15
    0xe001420c     0xc    strne r3, [r0, #12]
    0xe0014210    0x10    movne r1, #0
    0xe0014214    0x14    strne r1, [r2, #92] 
    0xe0014218    0x18    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unbindMaybeNotification` has 19 nodes.

Section setIRQState (28 of 299)
===============================

Deriving specifications
-----------------------

Section `setIRQState` consists of 15 instructions.
 MOVWEQ..++
 MOVWNE..++
 MOV (reg-shift).....+++++
 STR (-imm,pre)...++


Stack analysis
---------------

No stack accesses found. Code for `setIRQState`:

    0xe0013f90     0x0    movw r3, #36936 
    0xe0013f94     0x4    movt r3, #57346 
    0xe0013f98     0x8    cmp r0, #0
    0xe0013f9c     0xc    and ip, r1, #31
    0xe0013fa0    0x10    str r0, [r3, r1, lsl #2]
    0xe0013fa4    0x14    lsr r1, r1, #5
    0xe0013fa8    0x18    movweq r3, #4735 
    0xe0013fac    0x1c    movwne r3, #4607 
    0xe0013fb0    0x20    lsl r1, r1, #2
    0xe0013fb4    0x24    movt r3, #65520 
    0xe0013fb8    0x28    add r3, r1, r3
    0xe0013fbc    0x2c    mov r2, #1
    0xe0013fc0    0x30    lsl r2, r2, ip
    0xe0013fc4    0x34    str r2, [r3, #-255] 
    0xe0013fc8    0x38    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setIRQState` has 22 nodes.

Section isIRQActive (29 of 299)
===============================

Deriving specifications
-----------------------

Section `isIRQActive` consists of 6 instructions.
 ADDS (imm)...++


Stack analysis
---------------

No stack accesses found. Code for `isIRQActive`:

    0xe0013f78     0x0    movw r3, #36936 
    0xe0013f7c     0x4    movt r3, #57346 
    0xe0013f80     0x8    ldr r0, [r3, r0, lsl #2]
    0xe0013f84     0xc    adds r0, r0, #0
    0xe0013f88    0x10    movne r0, #1
    0xe0013f8c    0x14    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isIRQActive` has 10 nodes.

Section deletedIRQHandler (30 of 299)
=====================================

Deriving specifications
-----------------------

Section `deletedIRQHandler` consists of 15 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `deletedIRQHandler`:

    0xe0013f3c     0x0    lsr r2, r0, #5
    0xe0013f40     0x4    movw r3, #4735 
    0xe0013f44     0x8    movt r3, #65520 
    0xe0013f48     0xc    movw r1, #36936 
    0xe0013f4c    0x10    lsl r2, r2, #2
    0xe0013f50    0x14    movt r1, #57346 
    0xe0013f54    0x18    add r3, r2, r3
    0xe0013f58    0x1c    and ip, r0, #31
    0xe0013f5c    0x20    mov r2, #1
    0xe0013f60    0x24    push {lr}             ; stack access
    0xe0013f64    0x28    lsl r2, r2, ip
    0xe0013f68    0x2c    mov lr, #0
    0xe0013f6c    0x30    str lr, [r1, r0, lsl #2]
    0xe0013f70    0x34    str r2, [r3, #-255] 
    0xe0013f74    0x38    pop {pc}              ; stack access

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deletedIRQHandler` has 19 nodes.

Section invokeIRQHandler_AckIRQ (31 of 299)
===========================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_AckIRQ` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `invokeIRQHandler_AckIRQ`:

    0xe0013f14     0x0    lsr r1, r0, #5
    0xe0013f18     0x4    movw r3, #4607 
    0xe0013f1c     0x8    movt r3, #65520 
    0xe0013f20     0xc    and r0, r0, #31
    0xe0013f24    0x10    lsl r1, r1, #2
    0xe0013f28    0x14    mov r2, #1
    0xe0013f2c    0x18    add r3, r1, r3
    0xe0013f30    0x1c    lsl r0, r2, r0
    0xe0013f34    0x20    str r0, [r3, #-255] 
    0xe0013f38    0x24    bx lr

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_AckIRQ` has 12 nodes.

Section replyFromKernel_success_empty (32 of 299)
=================================================

Deriving specifications
-----------------------

Section `replyFromKernel_success_empty` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `replyFromKernel_success_empty`:

    0xe0013934    0x0    mov r3, #0
    0xe0013938    0x4    str r3, [r0]
    0xe001393c    0x8    str r3, [r0, #4]
    0xe0013940    0xc    bx lr

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `replyFromKernel_success_empty` has 7 nodes.

Section loadCapTransfer (33 of 299)
===================================

Deriving specifications
-----------------------

Section `loadCapTransfer` consists of 7 instructions.


Stack analysis
---------------

Section `loadCapTransfer` expects pointer to stack in r0.
4 stack accesses found. Annotated code for `loadCapTransfer`:

    0xe0013918     0x0    push {lr}             ; stack access
    0xe001391c     0x4    ldr ip, [r1, #500] 
    0xe0013920     0x8    ldr lr, [r1, #504] 
    0xe0013924     0xc    ldr r2, [r1, #508] 
    0xe0013928    0x10    stm r0, {ip, lr}      ; stack access
    0xe001392c    0x14    str r2, [r0, #8]      ; stack access
    0xe0013930    0x18    pop {pc}              ; stack access

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `loadCapTransfer` has 14 nodes.

Section ensureEmptySlot (34 of 299)
===================================

Deriving specifications
-----------------------

Section `ensureEmptySlot` consists of 12 instructions.
 MOVTNE..++


Stack analysis
---------------

No stack accesses found. Code for `ensureEmptySlot`:

    0xe0013848     0x0    ldr r0, [r0]
    0xe001384c     0x4    and r3, r0, #14
    0xe0013850     0x8    cmp r3, #14
    0xe0013854     0xc    andne r0, r0, #15
    0xe0013858    0x10    uxtbeq r0, r0
    0xe001385c    0x14    cmp r0, #0
    0xe0013860    0x18    movwne r3, #36896 
    0xe0013864    0x1c    movtne r3, #57346 
    0xe0013868    0x20    movne r2, #8
    0xe001386c    0x24    movne r0, #3
    0xe0013870    0x28    strne r2, [r3, #24]
    0xe0013874    0x2c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `ensureEmptySlot` has 29 nodes.

Section setupReplyMaster (35 of 299)
====================================

Deriving specifications
-----------------------

Section `setupReplyMaster` consists of 18 instructions.
 BXNE..++
 ORR (imm)...++


Stack analysis
---------------

No stack accesses found. Code for `setupReplyMaster`:

    0xe0013800     0x0    bic r2, r0, #508 
    0xe0013804     0x4    bic r2, r2, #3
    0xe0013808     0x8    add r1, r2, #32
    0xe001380c     0xc    ldr r3, [r2, #32]
    0xe0013810    0x10    and ip, r3, #14
    0xe0013814    0x14    cmp ip, #14
    0xe0013818    0x18    andne r3, r3, #15
    0xe001381c    0x1c    uxtbeq r3, r3
    0xe0013820    0x20    cmp r3, #0
    0xe0013824    0x24    bxne lr
    0xe0013828    0x28    bic r0, r0, #63 
    0xe001382c    0x2c    mov ip, #3
    0xe0013830    0x30    orr r0, r0, #56 
    0xe0013834    0x34    str r0, [r2, #32]
    0xe0013838    0x38    str r3, [r1, #4]
    0xe001383c    0x3c    str r3, [r1, #8]
    0xe0013840    0x40    str ip, [r1, #12]
    0xe0013844    0x44    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setupReplyMaster` has 31 nodes.

Section insertNewCap (36 of 299)
================================

Deriving specifications
-----------------------

Section `insertNewCap` consists of 23 instructions.
 STMIA;3,2...+
 ORRNE (reg)...........++++++


Stack analysis
---------------

3 stack accesses found. Annotated code for `insertNewCap`:

    0xe00137a4     0x0    ldr ip, [r0, #12]
    0xe00137a8     0x4    push {r4, lr}         ; stack access
    0xe00137ac     0x8    bic ip, ip, #7
    0xe00137b0     0xc    sub sp, sp, #8
    0xe00137b4    0x10    cmp ip, #0
    0xe00137b8    0x14    add r4, sp, #8
    0xe00137bc    0x18    stm r1, {r2, r3}
    0xe00137c0    0x1c    bic lr, r0, #7
    0xe00137c4    0x20    str lr, [r1, #8]
    0xe00137c8    0x24    stmdb r4, {r2, r3}    ; stack access
    0xe00137cc    0x28    orr r3, ip, #3
    0xe00137d0    0x2c    str r3, [r1, #12]
    0xe00137d4    0x30    bic lr, r1, #7
    0xe00137d8    0x34    ldrne r2, [ip, #8]
    0xe00137dc    0x38    andne r2, r2, #7
    0xe00137e0    0x3c    orrne r2, r2, lr
    0xe00137e4    0x40    strne r2, [ip, #8]
    0xe00137e8    0x44    ldr r3, [r0, #12]
    0xe00137ec    0x48    and r3, r3, #7
    0xe00137f0    0x4c    orr r3, r3, lr
    0xe00137f4    0x50    str r3, [r0, #12]
    0xe00137f8    0x54    add sp, sp, #8
    0xe00137fc    0x58    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `insertNewCap` has 42 nodes.

Section cteSwap (37 of 299)
===========================

Deriving specifications
-----------------------

Section `cteSwap` consists of 48 instructions.
 STMIA;1,0...+
 LDMIA;1,0...+
 BICNE (imm)....+++


Stack analysis
---------------

7 stack accesses found. Annotated code for `cteSwap`:

    0xe0013610     0x0    sub sp, sp, #8
    0xe0013614     0x4    push {r4, lr}         ; stack access
    0xe0013618     0x8    sub sp, sp, #8
    0xe001361c     0xc    add lr, sp, #20
    0xe0013620    0x10    mov ip, sp
    0xe0013624    0x14    str r3, [sp, #20]     ; stack access
    0xe0013628    0x18    stm ip, {r0, r1}      ; stack access
    0xe001362c    0x1c    ldm lr, {r0, r1}      ; stack access
    0xe0013630    0x20    ldr r3, [sp, #28]     ; stack access
    0xe0013634    0x24    stm r2, {r0, r1}
    0xe0013638    0x28    ldm ip, {r0, r1}      ; stack access
    0xe001363c    0x2c    stm r3, {r0, r1}
    0xe0013640    0x30    ldr ip, [r2, #8]
    0xe0013644    0x34    ldr r0, [r2, #12]
    0xe0013648    0x38    bics r4, ip, #7
    0xe001364c    0x3c    bicne r1, r3, #7
    0xe0013650    0x40    ldrne lr, [r4, #12]
    0xe0013654    0x44    andne lr, lr, #7
    0xe0013658    0x48    orrne r1, lr, r1
    0xe001365c    0x4c    strne r1, [r4, #12]
    0xe0013660    0x50    bics r4, r0, #7
    0xe0013664    0x54    bicne r1, r3, #7
    0xe0013668    0x58    ldrne lr, [r4, #8]
    0xe001366c    0x5c    andne lr, lr, #7
    0xe0013670    0x60    orrne r1, lr, r1
    0xe0013674    0x64    strne r1, [r4, #8]
    0xe0013678    0x68    ldr lr, [r3, #8]
    0xe001367c    0x6c    ldr r1, [r3, #12]
    0xe0013680    0x70    bics r4, lr, #7
    0xe0013684    0x74    str lr, [r2, #8]
    0xe0013688    0x78    str r1, [r2, #12]
    0xe001368c    0x7c    str r0, [r3, #12]
    0xe0013690    0x80    str ip, [r3, #8]
    0xe0013694    0x84    bicne r3, r2, #7
    0xe0013698    0x88    ldrne r0, [r4, #12]
    0xe001369c    0x8c    andne r0, r0, #7
    0xe00136a0    0x90    orrne r3, r0, r3
    0xe00136a4    0x94    strne r3, [r4, #12]
    0xe00136a8    0x98    bics r1, r1, #7
    0xe00136ac    0x9c    bicne r2, r2, #7
    0xe00136b0    0xa0    ldrne r3, [r1, #8]
    0xe00136b4    0xa4    andne r3, r3, #7
    0xe00136b8    0xa8    orrne r2, r3, r2
    0xe00136bc    0xac    strne r2, [r1, #8]
    0xe00136c0    0xb0    add sp, sp, #8
    0xe00136c4    0xb4    pop {r4, lr}          ; stack access
    0xe00136c8    0xb8    add sp, sp, #8
    0xe00136cc    0xbc    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
48 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteSwap` has 114 nodes.

Section cteMove (38 of 299)
===========================

Deriving specifications
-----------------------

Section `cteMove` consists of 29 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `cteMove`:

    0xe00134f8     0x0    push {r4, r5, lr}     ; stack access
    0xe00134fc     0x4    sub sp, sp, #12
    0xe0013500     0x8    ldr r4, [r2, #8]
    0xe0013504     0xc    mov lr, #0
    0xe0013508    0x10    mov ip, sp
    0xe001350c    0x14    stm ip, {r0, r1}      ; stack access
    0xe0013510    0x18    bics r5, r4, #7
    0xe0013514    0x1c    ldm ip, {r0, r1}      ; stack access
    0xe0013518    0x20    ldr ip, [r2, #12]
    0xe001351c    0x24    stm r3, {r0, r1}
    0xe0013520    0x28    str lr, [r2]
    0xe0013524    0x2c    str lr, [r2, #4]
    0xe0013528    0x30    str ip, [r3, #12]
    0xe001352c    0x34    str r4, [r3, #8]
    0xe0013530    0x38    str lr, [r2, #8]
    0xe0013534    0x3c    str lr, [r2, #12]
    0xe0013538    0x40    bicne r2, r3, #7
    0xe001353c    0x44    ldrne r1, [r5, #12]
    0xe0013540    0x48    andne r1, r1, #7
    0xe0013544    0x4c    orrne r2, r1, r2
    0xe0013548    0x50    strne r2, [r5, #12]
    0xe001354c    0x54    bics ip, ip, #7
    0xe0013550    0x58    bicne r3, r3, #7
    0xe0013554    0x5c    ldrne r2, [ip, #8]
    0xe0013558    0x60    andne r2, r2, #7
    0xe001355c    0x64    orrne r3, r2, r3
    0xe0013560    0x68    strne r3, [ip, #8]
    0xe0013564    0x6c    add sp, sp, #12
    0xe0013568    0x70    pop {r4, r5, pc}      ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
29 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteMove` has 66 nodes.

Section cteInsert (39 of 299)
=============================

Deriving specifications
-----------------------

Section `cteInsert` consists of 115 instructions.
 STMDB (wb);14,10,9,8,7,6,5,4..+
 LDMIA;7,1...+
Switch found.
 LDRLS (+reg,pre)...... LDRLS (+reg,pre,pc)... LDRLS (pc,+reg,pre)... LDRLS (pc,+reg,pre,pc)..++++++++++++++
 LDMIA (wb);15,10,9,8,7,6,5,4.+
 SUBEQ (imm)....+++
 ANDEQ (imm)....+++
 MOVEQ (imm)..++
 ORREQ (reg-shift)................++++++++++++++++
 STREQ (+imm,pre)....+++


Stack analysis
---------------

4 stack accesses found. Annotated code for `cteInsert`:

    0xe0013308      0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe001330c      0x4    sub sp, sp, #8
    0xe0013310      0x8    mov r6, r1
    0xe0013314      0xc    ldr lr, [r2, #8]
    0xe0013318     0x10    mov r4, sp
    0xe001331c     0x14    ldr ip, [r2, #12]
    0xe0013320     0x18    stm r4, {r0, r1}      ; stack access
    0xe0013324     0x1c    and r1, r0, #14
    0xe0013328     0x20    cmp r1, #14
    0xe001332c     0x24    ldm r2, {r1, r7}
    0xe0013330     0x28    andne r5, r0, #15
    0xe0013334     0x2c    uxtbeq r5, r0
    0xe0013338     0x30    tst r5, #1
    0xe001333c     0x34    and sl, r1, #14
    0xe0013340     0x38    bne e00133c8 <cteInsert+0xc0>
    0xe0013344     0x3c    sub r8, r5, #2
    0xe0013348     0x40    cmp r8, #28
    0xe001334c     0x44    ldrls pc, [pc, r8, lsl #2]
    0xe0013350     0x48    b e00133c8 <cteInsert+0xc0>
    0xe0013354     0x4c    .word 0xe0013478
    0xe0013358     0x50    .word 0xe00133c8
    0xe001335c     0x54    .word 0xe00134a4
    0xe0013360     0x58    .word 0xe00133c8
    0xe0013364     0x5c    .word 0xe00134bc
    0xe0013368     0x60    .word 0xe00133c8
    0xe001336c     0x64    .word 0xe00133c8
    0xe0013370     0x68    .word 0xe00133c8
    0xe0013374     0x6c    .word 0xe00133c8
    0xe0013378     0x70    .word 0xe00133c8
    0xe001337c     0x74    .word 0xe00133c8
    0xe0013380     0x78    .word 0xe00133c8
    0xe0013384     0x7c    .word 0xe00133c8
    0xe0013388     0x80    .word 0xe00133c8
    0xe001338c     0x84    .word 0xe00133c8
    0xe0013390     0x88    .word 0xe00133c8
    0xe0013394     0x8c    .word 0xe00133c8
    0xe0013398     0x90    .word 0xe00133c8
    0xe001339c     0x94    .word 0xe00133c8
    0xe00133a0     0x98    .word 0xe00133c8
    0xe00133a4     0x9c    .word 0xe00133c8
    0xe00133a8     0xa0    .word 0xe00133c8
    0xe00133ac     0xa4    .word 0xe00133c8
    0xe00133b0     0xa8    .word 0xe00133c8
    0xe00133b4     0xac    .word 0xe00133c8
    0xe00133b8     0xb0    .word 0xe00133c8
    0xe00133bc     0xb4    .word 0xe00133c8
    0xe00133c0     0xb8    .word 0xe00133c8
    0xe00133c4     0xbc    .word 0xe0013484
    0xe00133c8     0xc0    mov r8, #0
    0xe00133cc     0xc4    mov r9, r8
    0xe00133d0     0xc8    bic ip, ip, #3
    0xe00133d4     0xcc    cmp sl, #14
    0xe00133d8     0xd0    orr ip, ip, r8
    0xe00133dc     0xd4    and lr, lr, #7
    0xe00133e0     0xd8    bic r8, r2, #7
    0xe00133e4     0xdc    orr ip, ip, r9
    0xe00133e8     0xe0    orr lr, lr, r8
    0xe00133ec     0xe4    andne r8, r1, #15
    0xe00133f0     0xe8    uxtbeq r8, r1
    0xe00133f4     0xec    cmp r8, #2
    0xe00133f8     0xf0    beq e001343c <cteInsert+0x134>
    0xe00133fc     0xf4    ldm r4, {r0, r1}      ; stack access
    0xe0013400     0xf8    str lr, [r3, #8]
    0xe0013404     0xfc    bics lr, ip, #7
    0xe0013408    0x100    str ip, [r3, #12]
    0xe001340c    0x104    bic ip, r3, #7
    0xe0013410    0x108    stm r3, {r0, r1}
    0xe0013414    0x10c    ldr r3, [r2, #12]
    0xe0013418    0x110    and r3, r3, #7
    0xe001341c    0x114    orr r3, r3, ip
    0xe0013420    0x118    str r3, [r2, #12]
    0xe0013424    0x11c    ldrne r3, [lr, #8]
    0xe0013428    0x120    andne r3, r3, #7
    0xe001342c    0x124    orrne r3, r3, ip
    0xe0013430    0x128    strne r3, [lr, #8]
    0xe0013434    0x12c    add sp, sp, #8
    0xe0013438    0x130    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe001343c    0x134    cmp r5, #2
    0xe0013440    0x138    bne e00133fc <cteInsert+0xf4>
    0xe0013444    0x13c    bic r1, r1, #15
    0xe0013448    0x140    bic r0, r0, #15
    0xe001344c    0x144    cmp r1, r0
    0xe0013450    0x148    bne e00133fc <cteInsert+0xf4>
    0xe0013454    0x14c    and r6, r6, #31
    0xe0013458    0x150    and r1, r7, #31
    0xe001345c    0x154    cmp r6, r1
    0xe0013460    0x158    subeq r6, r6, #4
    0xe0013464    0x15c    andeq r7, r7, #63 
    0xe0013468    0x160    moveq r1, #64 
    0xe001346c    0x164    orreq r6, r7, r1, lsl r6
    0xe0013470    0x168    streq r6, [r2, #4]
    0xe0013474    0x16c    b e00133fc <cteInsert+0xf4>
    0xe0013478    0x170    mov r8, #2
    0xe001347c    0x174    mov r9, #1
    0xe0013480    0x178    b e00133d0 <cteInsert+0xc8>
    0xe0013484    0x17c    cmp sl, #14
    0xe0013488    0x180    andne r9, r1, #15
    0xe001348c    0x184    uxtbeq r9, r1
    0xe0013490    0x188    sub r9, r9, #14
    0xe0013494    0x18c    clz r9, r9
    0xe0013498    0x190    lsr r9, r9, #5
    0xe001349c    0x194    lsl r8, r9, #1
    0xe00134a0    0x198    b e00133d0 <cteInsert+0xc8>
    0xe00134a4    0x19c    lsr r8, r1, #4
    0xe00134a8    0x1a0    cmp r8, r0, lsr #4
    0xe00134ac    0x1a4    movne r9, #1
    0xe00134b0    0x1a8    moveq r9, #0
    0xe00134b4    0x1ac    lsl r8, r9, #1
    0xe00134b8    0x1b0    b e00133d0 <cteInsert+0xc8>
    0xe00134bc    0x1b4    lsr r8, r7, #4
    0xe00134c0    0x1b8    cmp r8, r6, lsr #4
    0xe00134c4    0x1bc    movne r9, #1
    0xe00134c8    0x1c0    moveq r9, #0
    0xe00134cc    0x1c4    lsl r8, r9, #1
    0xe00134d0    0x1c8    b e00133d0 <cteInsert+0xc8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
86 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteInsert` has 235 nodes.

Section setMCPriority (40 of 299)
=================================

Deriving specifications
-----------------------

Section `setMCPriority` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setMCPriority`:

    0xe0013090    0x0    str r1, [r0, #116] 
    0xe0013094    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMCPriority` has 4 nodes.

Section doNBRecvFailedTransfer (41 of 299)
==========================================

Deriving specifications
-----------------------

Section `doNBRecvFailedTransfer` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `doNBRecvFailedTransfer`:

    0xe001305c    0x0    mov r3, #0
    0xe0013060    0x4    str r3, [r0]
    0xe0013064    0x8    bx lr

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doNBRecvFailedTransfer` has 5 nodes.

Section resolveAddressBits (42 of 299)
======================================

Deriving specifications
-----------------------

Section `resolveAddressBits` consists of 90 instructions.
 STMDB;2,1...+
 LDREQ (+imm,pre)...+++
 MVNEQ (imm)..++
 MVN (reg-shift).....+++++
 AND (reg-shift)...............+++++++++++++++
 CMPCS (reg)......+++
 BCC..++
 STMIA;4,2...+
 STMIA;2,1...+
 STMIA;6,4...+
 STRD (+imm,pre).+


Stack analysis
---------------

Section `resolveAddressBits` expects pointer to stack in r0.
22 stack accesses found. Annotated code for `resolveAddressBits`:

    0xe0012bd0      0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe0012bd4      0x4    sub sp, sp, #12
    0xe0012bd8      0x8    add ip, sp, #8
    0xe0012bdc      0xc    stmdb ip, {r1, r2}    ; stack access
    0xe0012be0     0x10    ldr ip, [sp]          ; stack access
    0xe0012be4     0x14    ldr lr, [sp, #4]      ; stack access
    0xe0012be8     0x18    and r2, ip, #14
    0xe0012bec     0x1c    cmp r2, #14
    0xe0012bf0     0x20    andne r2, ip, #15
    0xe0012bf4     0x24    uxtbeq r2, ip
    0xe0012bf8     0x28    cmp r2, #10
    0xe0012bfc     0x2c    ldreq r1, [sp, #40]   ; stack access
    0xe0012c00     0x30    mvneq r7, #0
    0xe0012c04     0x34    bne e0012c6c <resolveAddressBits+0x9c>
    0xe0012c08     0x38    ubfx r4, lr, #23, #5
    0xe0012c0c     0x3c    ubfx r6, lr, #0, #18
    0xe0012c10     0x40    sub r2, r1, r4
    0xe0012c14     0x44    ubfx lr, lr, #18, #5
    0xe0012c18     0x48    and r5, r2, #31
    0xe0012c1c     0x4c    mvn r2, r7, lsl r4
    0xe0012c20     0x50    and r2, r2, r3, lsr r5
    0xe0012c24     0x54    add r8, r4, lr
    0xe0012c28     0x58    cmp r1, r4
    0xe0012c2c     0x5c    cmpcs r2, r6
    0xe0012c30     0x60    sub r9, r1, r8
    0xe0012c34     0x64    bic ip, ip, #31
    0xe0012c38     0x68    lsr r5, r3, r9
    0xe0012c3c     0x6c    movne r2, #1
    0xe0012c40     0x70    moveq r2, #0
    0xe0012c44     0x74    bne e0012c98 <resolveAddressBits+0xc8>
    0xe0012c48     0x78    cmp r1, r8
    0xe0012c4c     0x7c    bic lr, r5, r7, lsl lr
    0xe0012c50     0x80    bcc e0012ccc <resolveAddressBits+0xfc>
    0xe0012c54     0x84    add r4, ip, lr, lsl #4
    0xe0012c58     0x88    bhi e0012d00 <resolveAddressBits+0x130>
    0xe0012c5c     0x8c    stm r0, {r2, r4}      ; stack access
    0xe0012c60     0x90    str r2, [r0, #8]      ; stack access
    0xe0012c64     0x94    add sp, sp, #12
    0xe0012c68     0x98    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0012c6c     0x9c    ldr r2, [sp, #40]     ; stack access
    0xe0012c70     0xa0    movw r3, #36884 
    0xe0012c74     0xa4    movt r3, #57346 
    0xe0012c78     0xa8    mov r1, #2
    0xe0012c7c     0xac    str r2, [r0, #8]      ; stack access
    0xe0012c80     0xb0    mov r2, #0
    0xe0012c84     0xb4    str r2, [r3]
    0xe0012c88     0xb8    str r2, [r3, #4]
    0xe0012c8c     0xbc    stm r0, {r1, r2}      ; stack access
    0xe0012c90     0xc0    add sp, sp, #12
    0xe0012c94     0xc4    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0012c98     0xc8    lsl r3, r1, #8
    0xe0012c9c     0xcc    movw r2, #36884 
    0xe0012ca0     0xd0    and r3, r3, #16128 
    0xe0012ca4     0xd4    movt r2, #57346 
    0xe0012ca8     0xd8    orr r4, r3, r4, lsl #2
    0xe0012cac     0xdc    ldr r3, [sp, #40]     ; stack access
    0xe0012cb0     0xe0    orr r4, r4, #3
    0xe0012cb4     0xe4    stm r2, {r4, r6}
    0xe0012cb8     0xe8    mov r2, #2
    0xe0012cbc     0xec    str r3, [r0, #8]      ; stack access
    0xe0012cc0     0xf0    mov r3, #0
    0xe0012cc4     0xf4    strd r2, [r0]         ; stack access
    0xe0012cc8     0xf8    b e0012c64 <resolveAddressBits+0x94>
    0xe0012ccc     0xfc    ldr ip, [sp, #40]     ; stack access
    0xe0012cd0    0x100    lsl r3, r1, #2
    0xe0012cd4    0x104    movw r1, #36884 
    0xe0012cd8    0x108    movt r1, #57346 
    0xe0012cdc    0x10c    orr r3, r3, r8, lsl #8
    0xe0012ce0    0x110    str r2, [r0, #4]      ; stack access
    0xe0012ce4    0x114    orr r3, r3, #2
    0xe0012ce8    0x118    str ip, [r0, #8]      ; stack access
    0xe0012cec    0x11c    str r3, [r1]
    0xe0012cf0    0x120    mov ip, #2
    0xe0012cf4    0x124    str r2, [r1, #4]
    0xe0012cf8    0x128    str ip, [r0]          ; stack access
    0xe0012cfc    0x12c    b e0012c64 <resolveAddressBits+0x94>
    0xe0012d00    0x130    ldr ip, [ip, lr, lsl #4]
    0xe0012d04    0x134    ldr lr, [r4, #4]
    0xe0012d08    0x138    and r1, ip, #14
    0xe0012d0c    0x13c    and r2, ip, #15
    0xe0012d10    0x140    cmp r1, #14
    0xe0012d14    0x144    mov r1, r9
    0xe0012d18    0x148    uxtbeq r2, ip
    0xe0012d1c    0x14c    cmp r2, #10
    0xe0012d20    0x150    beq e0012c08 <resolveAddressBits+0x38>
    0xe0012d24    0x154    mov r3, #0
    0xe0012d28    0x158    str r4, [r0, #4]      ; stack access
    0xe0012d2c    0x15c    str r9, [r0, #8]      ; stack access
    0xe0012d30    0x160    str r3, [r0]          ; stack access
    0xe0012d34    0x164    b e0012c64 <resolveAddressBits+0x94>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
90 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `resolveAddressBits` has 145 nodes.

Section Arch_performTransfer (43 of 299)
========================================

Deriving specifications
-----------------------

Section `Arch_performTransfer` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_performTransfer`:

    0xe0012bc8    0x0    mov r0, #0
    0xe0012bcc    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_performTransfer` has 3 nodes.

Section Arch_decodeTransfer (44 of 299)
=======================================

Deriving specifications
-----------------------

Section `Arch_decodeTransfer` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_decodeTransfer`:

    0xe0012bc0    0x0    mov r0, #0
    0xe0012bc4    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeTransfer` has 3 nodes.

Section plat_cleanCache (45 of 299)
===================================

Deriving specifications
-----------------------

Section `plat_cleanCache` consists of 17 instructions.
 SXT{A}H,UXT{A}H.......+++++++
Skipping f57ff05f dmb sy


Stack analysis
---------------

No stack accesses found. Code for `plat_cleanCache`:

    0xe0012b7c     0x0    movw r3, #12543 
    0xe0012b80     0x4    movt r3, #65520 
    0xe0012b84     0x8    movw r1, #65535 
    0xe0012b88     0xc    mov r2, r3
    0xe0012b8c    0x10    str r1, [r3, #1725] 
    0xe0012b90    0x14    ldr r3, [r2, #1725] 
    0xe0012b94    0x18    uxth r3, r3
    0xe0012b98    0x1c    cmp r3, #0
    0xe0012b9c    0x20    bne e0012b90 <plat_cleanCache+0x14>
    0xe0012ba0    0x24    dmb sy
    0xe0012ba4    0x28    movw r1, #12543 
    0xe0012ba8    0x2c    movt r1, #65520 
    0xe0012bac    0x30    str r3, [r2, #1585] 
    0xe0012bb0    0x34    ldr r3, [r1, #1585] 
    0xe0012bb4    0x38    tst r3, #1
    0xe0012bb8    0x3c    bne e0012bb0 <plat_cleanCache+0x34>
    0xe0012bbc    0x40    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `plat_cleanCache` has 27 nodes.

Section setNextPC (46 of 299)
=============================

Deriving specifications
-----------------------

Section `setNextPC` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setNextPC`:

    0xe0012b74    0x0    str r1, [r0, #60] 
    0xe0012b78    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setNextPC` has 4 nodes.

Section getRestartPC (47 of 299)
================================

Deriving specifications
-----------------------

Section `getRestartPC` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `getRestartPC`:

    0xe0012b6c    0x0    ldr r0, [r0, #68] 
    0xe0012b70    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getRestartPC` has 4 nodes.

Section setIRQTrigger (48 of 299)
=================================

Deriving specifications
-----------------------

Section `setIRQTrigger` consists of 14 instructions.
 BICEQ (reg)...........++++++


Stack analysis
---------------

No stack accesses found. Code for `setIRQTrigger`:

    0xe0012b34     0x0    and r3, r0, #15
    0xe0012b38     0x4    lsr r0, r0, #4
    0xe0012b3c     0x8    mov r2, #1
    0xe0012b40     0xc    cmp r1, #0
    0xe0012b44    0x10    lsl r0, r0, #2
    0xe0012b48    0x14    lsl r3, r3, r2
    0xe0012b4c    0x18    sub r0, r0, #1044480 
    0xe0012b50    0x1c    add r3, r3, r2
    0xe0012b54    0x20    lsl r3, r2, r3
    0xe0012b58    0x24    ldr r2, [r0, #3072] 
    0xe0012b5c    0x28    orrne r3, r2, r3
    0xe0012b60    0x2c    biceq r3, r2, r3
    0xe0012b64    0x30    str r3, [r0, #3072] 
    0xe0012b68    0x34    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setIRQTrigger` has 21 nodes.

Section arch_clean_invalidate_L1_caches (49 of 299)
===================================================

Deriving specifications
-----------------------

Section `arch_clean_invalidate_L1_caches` consists of 44 instructions.
Skipping f57ff04f dsb sy
 LDMIAEQ (wb);15,7,6,5,4..++
Skipping ee073f15 mcr 15, 0, r3, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy
Skipping ee503f10 mrc 15, 2, r3, cr0, cr0, {0}
Skipping ee40cf10 mcr 15, 2, ip, cr0, cr0, {0}
Skipping ee30ef10 mrc 15, 1, lr, cr0, cr0, {0}
Skipping ee403f10 mcr 15, 2, r3, cr0, cr0, {0}
Skipping ee071f5e mcr 15, 0, r1, cr7, cr14, {2}
 BGT..++
Skipping f57ff04f dsb sy


Stack analysis
---------------

4 stack accesses found. Annotated code for `arch_clean_invalidate_L1_caches`:

    0xe0012a84     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0012a88     0x4    dsb sy
    0xe0012a8c     0x8    tst r0, #2
    0xe0012a90     0xc    bne e0012ab4 <arch_clean_invalidate_L1_caches+0x30>
    0xe0012a94    0x10    tst r0, #1
    0xe0012a98    0x14    popeq {r4, r5, r6, r7, pc}  ; stack access
    0xe0012a9c    0x18    mov r3, #0
    0xe0012aa0    0x1c    mcr 15, 0, r3, cr7, cr5, {0}
    0xe0012aa4    0x20    isb sy
    0xe0012aa8    0x24    dsb sy
    0xe0012aac    0x28    isb sy
    0xe0012ab0    0x2c    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0012ab4    0x30    mrc 15, 2, r3, cr0, cr0, {0}
    0xe0012ab8    0x34    mov ip, #0
    0xe0012abc    0x38    mcr 15, 2, ip, cr0, cr0, {0}
    0xe0012ac0    0x3c    mrc 15, 1, lr, cr0, cr0, {0}
    0xe0012ac4    0x40    mcr 15, 2, r3, cr0, cr0, {0}
    0xe0012ac8    0x44    ubfx r6, lr, #3, #10
    0xe0012acc    0x48    and r3, lr, #7
    0xe0012ad0    0x4c    mov r4, #1
    0xe0012ad4    0x50    clz r7, r6
    0xe0012ad8    0x54    add r3, r3, #4
    0xe0012adc    0x58    ubfx lr, lr, #13, #15
    0xe0012ae0    0x5c    add r6, r6, r4
    0xe0012ae4    0x60    lsl r7, r4, r7
    0xe0012ae8    0x64    add lr, lr, #1
    0xe0012aec    0x68    lsl r4, r4, r3
    0xe0012af0    0x6c    mov r5, ip
    0xe0012af4    0x70    mov r3, #0
    0xe0012af8    0x74    mov r2, r3
    0xe0012afc    0x78    orr r1, r3, ip
    0xe0012b00    0x7c    mcr 15, 0, r1, cr7, cr14, {2}
    0xe0012b04    0x80    add r2, r2, #1
    0xe0012b08    0x84    add r3, r3, r4
    0xe0012b0c    0x88    cmp lr, r2
    0xe0012b10    0x8c    bgt e0012afc <arch_clean_invalidate_L1_caches+0x78>
    0xe0012b14    0x90    add r5, r5, #1
    0xe0012b18    0x94    add ip, ip, r7
    0xe0012b1c    0x98    cmp r6, r5
    0xe0012b20    0x9c    bgt e0012af4 <arch_clean_invalidate_L1_caches+0x70>
    0xe0012b24    0xa0    dsb sy
    0xe0012b28    0xa4    tst r0, #1
    0xe0012b2c    0xa8    bne e0012a9c <arch_clean_invalidate_L1_caches+0x18>
    0xe0012b30    0xac    pop {r4, r5, r6, r7, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
44 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arch_clean_invalidate_L1_caches` has 69 nodes.

Section branchFlushRange (50 of 299)
====================================

Deriving specifications
-----------------------

Section `branchFlushRange` consists of 12 instructions.
 BXCS..++
Skipping ee070ff5 mcr 15, 0, r0, cr7, cr5, {7}


Stack analysis
---------------

No stack accesses found. Code for `branchFlushRange`:

    0xe0012958     0x0    lsr r1, r1, #5
    0xe001295c     0x4    lsr r0, r0, #5
    0xe0012960     0x8    add r1, r1, #1
    0xe0012964     0xc    cmp r0, r1
    0xe0012968    0x10    bxcs lr
    0xe001296c    0x14    lsl r0, r0, #5
    0xe0012970    0x18    lsl r1, r1, #5
    0xe0012974    0x1c    mcr 15, 0, r0, cr7, cr5, {7}
    0xe0012978    0x20    add r0, r0, #32
    0xe001297c    0x24    cmp r0, r1
    0xe0012980    0x28    bne e0012974 <branchFlushRange+0x1c>
    0xe0012984    0x2c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `branchFlushRange` has 19 nodes.

Section invalidateCacheRange_I (51 of 299)
==========================================

Deriving specifications
-----------------------

Section `invalidateCacheRange_I` consists of 13 instructions.
Skipping ee070f35 mcr 15, 0, r0, cr7, cr5, {1}
Skipping f57ff06f isb sy


Stack analysis
---------------

No stack accesses found. Code for `invalidateCacheRange_I`:

    0xe0012924     0x0    lsr r1, r1, #5
    0xe0012928     0x4    lsr r0, r0, #5
    0xe001292c     0x8    add r1, r1, #1
    0xe0012930     0xc    cmp r0, r1
    0xe0012934    0x10    bxcs lr
    0xe0012938    0x14    lsl r0, r0, #5
    0xe001293c    0x18    lsl r1, r1, #5
    0xe0012940    0x1c    mcr 15, 0, r0, cr7, cr5, {1}
    0xe0012944    0x20    isb sy
    0xe0012948    0x24    add r0, r0, #32
    0xe001294c    0x28    cmp r0, r1
    0xe0012950    0x2c    bne e0012940 <invalidateCacheRange_I+0x1c>
    0xe0012954    0x30    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invalidateCacheRange_I` has 21 nodes.

Section cleanCacheRange_PoU (52 of 299)
=======================================

Deriving specifications
-----------------------

Section `cleanCacheRange_PoU` consists of 13 instructions.
Skipping ee070f3b mcr 15, 0, r0, cr7, cr11, {1}
Skipping f57ff05f dmb sy


Stack analysis
---------------

No stack accesses found. Code for `cleanCacheRange_PoU`:

    0xe00126dc     0x0    lsr r1, r1, #5
    0xe00126e0     0x4    lsr r0, r0, #5
    0xe00126e4     0x8    add r1, r1, #1
    0xe00126e8     0xc    cmp r0, r1
    0xe00126ec    0x10    bxcs lr
    0xe00126f0    0x14    lsl r0, r0, #5
    0xe00126f4    0x18    lsl r1, r1, #5
    0xe00126f8    0x1c    mcr 15, 0, r0, cr7, cr11, {1}
    0xe00126fc    0x20    dmb sy
    0xe0012700    0x24    add r0, r0, #32
    0xe0012704    0x28    cmp r0, r1
    0xe0012708    0x2c    bne e00126f8 <cleanCacheRange_PoU+0x1c>
    0xe001270c    0x30    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanCacheRange_PoU` has 21 nodes.

Section cleanCacheRange_RAM (53 of 299)
=======================================

Deriving specifications
-----------------------

Section `cleanCacheRange_RAM` consists of 36 instructions.
 BCS..++
Skipping ee073f3a mcr 15, 0, r3, cr7, cr10, {1}
Skipping f57ff05f dmb sy
Skipping f57ff04f dsb sy
Skipping f57ff05f dmb sy


Stack analysis
---------------

No stack accesses found. Code for `cleanCacheRange_RAM`:

    0xe001264c     0x0    lsr ip, r1, #5
    0xe0012650     0x4    lsr r3, r0, #5
    0xe0012654     0x8    add ip, ip, #1
    0xe0012658     0xc    cmp r3, ip
    0xe001265c    0x10    bcs e001267c <cleanCacheRange_RAM+0x30>
    0xe0012660    0x14    lsl r3, r3, #5
    0xe0012664    0x18    lsl ip, ip, #5
    0xe0012668    0x1c    mcr 15, 0, r3, cr7, cr10, {1}
    0xe001266c    0x20    dmb sy
    0xe0012670    0x24    add r3, r3, #32
    0xe0012674    0x28    cmp ip, r3
    0xe0012678    0x2c    bne e0012668 <cleanCacheRange_RAM+0x1c>
    0xe001267c    0x30    dsb sy
    0xe0012680    0x34    add r3, r2, #32
    0xe0012684    0x38    bic r2, r2, #31
    0xe0012688    0x3c    add r1, r3, r1
    0xe001268c    0x40    sub r0, r1, r0
    0xe0012690    0x44    bic r0, r0, #31
    0xe0012694    0x48    cmp r2, r0
    0xe0012698    0x4c    beq e00126b4 <cleanCacheRange_RAM+0x68>
    0xe001269c    0x50    movw r3, #12543 
    0xe00126a0    0x54    movt r3, #65520 
    0xe00126a4    0x58    str r2, [r3, #1713] 
    0xe00126a8    0x5c    add r2, r2, #32
    0xe00126ac    0x60    cmp r2, r0
    0xe00126b0    0x64    bne e00126a4 <cleanCacheRange_RAM+0x58>
    0xe00126b4    0x68    dmb sy
    0xe00126b8    0x6c    movw r3, #12543 
    0xe00126bc    0x70    movt r3, #65520 
    0xe00126c0    0x74    mov r1, #0
    0xe00126c4    0x78    mov r2, r3
    0xe00126c8    0x7c    str r1, [r3, #1585] 
    0xe00126cc    0x80    ldr r3, [r2, #1585] 
    0xe00126d0    0x84    tst r3, #1
    0xe00126d4    0x88    bne e00126cc <cleanCacheRange_RAM+0x80>
    0xe00126d8    0x8c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
36 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanCacheRange_RAM` has 54 nodes.

Section cleanInvalidateCacheRange_RAM (54 of 299)
=================================================

Deriving specifications
-----------------------

Section `cleanInvalidateCacheRange_RAM` consists of 49 instructions.
Skipping ee07cf3a mcr 15, 0, ip, cr7, cr10, {1}
Skipping f57ff05f dmb sy
Skipping f57ff04f dsb sy
Skipping f57ff05f dmb sy
Skipping f57ff05f dmb sy
Skipping ee073f3e mcr 15, 0, r3, cr7, cr14, {1}
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `cleanInvalidateCacheRange_RAM`:

    0xe0012588     0x0    push {r4, lr}         ; stack access
    0xe001258c     0x4    lsr lr, r1, #5
    0xe0012590     0x8    lsr r3, r0, #5
    0xe0012594     0xc    add lr, lr, #1
    0xe0012598    0x10    cmp r3, lr
    0xe001259c    0x14    bcs e00125bc <cleanInvalidateCacheRange_RAM+0x34>
    0xe00125a0    0x18    lsl ip, r3, #5
    0xe00125a4    0x1c    lsl r4, lr, #5
    0xe00125a8    0x20    mcr 15, 0, ip, cr7, cr10, {1}
    0xe00125ac    0x24    dmb sy
    0xe00125b0    0x28    add ip, ip, #32
    0xe00125b4    0x2c    cmp ip, r4
    0xe00125b8    0x30    bne e00125a8 <cleanInvalidateCacheRange_RAM+0x20>
    0xe00125bc    0x34    dsb sy
    0xe00125c0    0x38    add ip, r2, #32
    0xe00125c4    0x3c    bic r2, r2, #31
    0xe00125c8    0x40    add r1, ip, r1
    0xe00125cc    0x44    sub r0, r1, r0
    0xe00125d0    0x48    bic r0, r0, #31
    0xe00125d4    0x4c    cmp r2, r0
    0xe00125d8    0x50    beq e00125fc <cleanInvalidateCacheRange_RAM+0x74>
    0xe00125dc    0x54    movw r1, #12543 
    0xe00125e0    0x58    movt r1, #65520 
    0xe00125e4    0x5c    str r2, [r1, #1713] 
    0xe00125e8    0x60    dmb sy
    0xe00125ec    0x64    str r2, [r1, #1649] 
    0xe00125f0    0x68    add r2, r2, #32
    0xe00125f4    0x6c    cmp r2, r0
    0xe00125f8    0x70    bne e00125e4 <cleanInvalidateCacheRange_RAM+0x5c>
    0xe00125fc    0x74    dmb sy
    0xe0012600    0x78    movw r2, #12543 
    0xe0012604    0x7c    movt r2, #65520 
    0xe0012608    0x80    mov r0, #0
    0xe001260c    0x84    mov r1, r2
    0xe0012610    0x88    str r0, [r2, #1585] 
    0xe0012614    0x8c    ldr r2, [r1, #1585] 
    0xe0012618    0x90    tst r2, #1
    0xe001261c    0x94    bne e0012614 <cleanInvalidateCacheRange_RAM+0x8c>
    0xe0012620    0x98    cmp r3, lr
    0xe0012624    0x9c    bcs e0012644 <cleanInvalidateCacheRange_RAM+0xbc>
    0xe0012628    0xa0    lsl r3, r3, #5
    0xe001262c    0xa4    lsl r2, lr, #5
    0xe0012630    0xa8    mcr 15, 0, r3, cr7, cr14, {1}
    0xe0012634    0xac    dsb sy
    0xe0012638    0xb0    add r3, r3, #32
    0xe001263c    0xb4    cmp r2, r3
    0xe0012640    0xb8    bne e0012630 <cleanInvalidateCacheRange_RAM+0xa8>
    0xe0012644    0xbc    dsb sy
    0xe0012648    0xc0    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
49 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanInvalidateCacheRange_RAM` has 77 nodes.

Section Arch_postModifyRegisters (55 of 299)
============================================

Deriving specifications
-----------------------

Section `Arch_postModifyRegisters` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_postModifyRegisters`:

    0xe0012584    0x0    bx lr

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_postModifyRegisters` has 2 nodes.

Section armv_init_user_access (56 of 299)
=========================================

Deriving specifications
-----------------------

Section `armv_init_user_access` consists of 7 instructions.
Skipping ee103f51 mrc 15, 0, r3, cr0, cr1, {2}
Skipping ee103f31 mrc 15, 0, r3, cr0, cr1, {1}
Skipping ee0e3f11 mcr 15, 0, r3, cr14, cr1, {0}


Stack analysis
---------------

No stack accesses found. Code for `armv_init_user_access`:

    0xe0012568     0x0    mrc 15, 0, r3, cr0, cr1, {2}
    0xe001256c     0x4    mrc 15, 0, r3, cr0, cr1, {1}
    0xe0012570     0x8    tst r3, #65536 
    0xe0012574     0xc    bxeq lr
    0xe0012578    0x10    mov r3, #0
    0xe001257c    0x14    mcr 15, 0, r3, cr14, cr1, {0}
    0xe0012580    0x18    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `armv_init_user_access` has 14 nodes.

Section cleanInvalidate_L1D (57 of 299)
=======================================

Deriving specifications
-----------------------

Section `cleanInvalidate_L1D` consists of 30 instructions.
 STMDB (wb);14,6,5,4..+
Skipping ee503f10 mrc 15, 2, r3, cr0, cr0, {0}
Skipping ee400f10 mcr 15, 2, r0, cr0, cr0, {0}
Skipping ee30cf10 mrc 15, 1, ip, cr0, cr0, {0}
Skipping ee403f10 mcr 15, 2, r3, cr0, cr0, {0}
Skipping ee071f5e mcr 15, 0, r1, cr7, cr14, {2}
 LDMIA (wb);15,6,5,4.+


Stack analysis
---------------

2 stack accesses found. Annotated code for `cleanInvalidate_L1D`:

    0xe00124cc     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00124d0     0x4    mrc 15, 2, r3, cr0, cr0, {0}
    0xe00124d4     0x8    mov r0, #0
    0xe00124d8     0xc    mcr 15, 2, r0, cr0, cr0, {0}
    0xe00124dc    0x10    mrc 15, 1, ip, cr0, cr0, {0}
    0xe00124e0    0x14    mcr 15, 2, r3, cr0, cr0, {0}
    0xe00124e4    0x18    ubfx r5, ip, #3, #10
    0xe00124e8    0x1c    and r3, ip, #7
    0xe00124ec    0x20    mov lr, #1
    0xe00124f0    0x24    clz r6, r5
    0xe00124f4    0x28    add r3, r3, #4
    0xe00124f8    0x2c    ubfx ip, ip, #13, #15
    0xe00124fc    0x30    add r5, r5, lr
    0xe0012500    0x34    lsl r6, lr, r6
    0xe0012504    0x38    add ip, ip, #1
    0xe0012508    0x3c    lsl lr, lr, r3
    0xe001250c    0x40    mov r4, r0
    0xe0012510    0x44    mov r3, #0
    0xe0012514    0x48    mov r2, r3
    0xe0012518    0x4c    orr r1, r3, r0
    0xe001251c    0x50    mcr 15, 0, r1, cr7, cr14, {2}
    0xe0012520    0x54    add r2, r2, #1
    0xe0012524    0x58    add r3, r3, lr
    0xe0012528    0x5c    cmp ip, r2
    0xe001252c    0x60    bgt e0012518 <cleanInvalidate_L1D+0x4c>
    0xe0012530    0x64    add r4, r4, #1
    0xe0012534    0x68    add r0, r0, r6
    0xe0012538    0x6c    cmp r5, r4
    0xe001253c    0x70    bgt e0012510 <cleanInvalidate_L1D+0x44>
    0xe0012540    0x74    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanInvalidate_L1D` has 41 nodes.

Section cleanInvalidate_D_PoC (58 of 299)
=========================================

Deriving specifications
-----------------------

Section `cleanInvalidate_D_PoC` consists of 47 instructions.
 STMDB (wb);14,11,10,9,8,7,6,5,4..+
Skipping ee30bf30 mrc 15, 1, fp, cr0, cr0, {1}
 LDMIAEQ (wb);15,11,10,9,8,7,6,5,4..++
Skipping ee503f10 mrc 15, 2, r3, cr0, cr0, {0}
Skipping ee406f10 mcr 15, 2, r6, cr0, cr0, {0}
Skipping ee300f10 mrc 15, 1, r0, cr0, cr0, {0}
Skipping ee403f10 mcr 15, 2, r3, cr0, cr0, {0}
Skipping ee071f5e mcr 15, 0, r1, cr7, cr14, {2}


Stack analysis
---------------

3 stack accesses found. Annotated code for `cleanInvalidate_D_PoC`:

    0xe0012410     0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0012414     0x4    mrc 15, 1, fp, cr0, cr0, {1}
    0xe0012418     0x8    ubfx sl, fp, #24, #3
    0xe001241c     0xc    cmp sl, #0
    0xe0012420    0x10    popeq {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0012424    0x14    mov r6, #0
    0xe0012428    0x18    lsl sl, sl, #1
    0xe001242c    0x1c    mov r9, r6
    0xe0012430    0x20    b e0012444 <cleanInvalidate_D_PoC+0x34>
    0xe0012434    0x24    add r6, r6, #2
    0xe0012438    0x28    add r9, r9, #3
    0xe001243c    0x2c    cmp sl, r6
    0xe0012440    0x30    popeq {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0012444    0x34    asr r3, fp, r9
    0xe0012448    0x38    and r3, r3, #7
    0xe001244c    0x3c    cmp r3, #1
    0xe0012450    0x40    bls e0012434 <cleanInvalidate_D_PoC+0x24>
    0xe0012454    0x44    mrc 15, 2, r3, cr0, cr0, {0}
    0xe0012458    0x48    mcr 15, 2, r6, cr0, cr0, {0}
    0xe001245c    0x4c    mrc 15, 1, r0, cr0, cr0, {0}
    0xe0012460    0x50    mcr 15, 2, r3, cr0, cr0, {0}
    0xe0012464    0x54    ubfx r5, r0, #3, #10
    0xe0012468    0x58    and lr, r0, #7
    0xe001246c    0x5c    mov r3, #1
    0xe0012470    0x60    clz r7, r5
    0xe0012474    0x64    add lr, lr, #4
    0xe0012478    0x68    ubfx r0, r0, #13, #15
    0xe001247c    0x6c    mov r4, #0
    0xe0012480    0x70    lsl r7, r3, r7
    0xe0012484    0x74    add r5, r5, r3
    0xe0012488    0x78    lsl lr, r3, lr
    0xe001248c    0x7c    add r0, r0, r3
    0xe0012490    0x80    mov r8, r4
    0xe0012494    0x84    mov r3, #0
    0xe0012498    0x88    orr ip, r4, r6
    0xe001249c    0x8c    mov r2, r3
    0xe00124a0    0x90    orr r1, r3, ip
    0xe00124a4    0x94    mcr 15, 0, r1, cr7, cr14, {2}
    0xe00124a8    0x98    add r2, r2, #1
    0xe00124ac    0x9c    add r3, r3, lr
    0xe00124b0    0xa0    cmp r0, r2
    0xe00124b4    0xa4    bgt e00124a0 <cleanInvalidate_D_PoC+0x90>
    0xe00124b8    0xa8    add r8, r8, #1
    0xe00124bc    0xac    add r4, r4, r7
    0xe00124c0    0xb0    cmp r5, r8
    0xe00124c4    0xb4    bgt e0012494 <cleanInvalidate_D_PoC+0x84>
    0xe00124c8    0xb8    b e0012434 <cleanInvalidate_D_PoC+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
47 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanInvalidate_D_PoC` has 66 nodes.

Section clean_D_PoU (59 of 299)
===============================

Deriving specifications
-----------------------

Section `clean_D_PoU` consists of 46 instructions.
Skipping ee30bf30 mrc 15, 1, fp, cr0, cr0, {1}
Skipping ee503f10 mrc 15, 2, r3, cr0, cr0, {0}
Skipping ee406f10 mcr 15, 2, r6, cr0, cr0, {0}
Skipping ee300f10 mrc 15, 1, r0, cr0, cr0, {0}
Skipping ee403f10 mcr 15, 2, r3, cr0, cr0, {0}
Skipping ee071f5a mcr 15, 0, r1, cr7, cr10, {2}
 LDMIA (wb);15,11,10,9,8,7,6,5,4.+


Stack analysis
---------------

3 stack accesses found. Annotated code for `clean_D_PoU`:

    0xe00120a8     0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00120ac     0x4    mrc 15, 1, fp, cr0, cr0, {1}
    0xe00120b0     0x8    ubfx sl, fp, #27, #3
    0xe00120b4     0xc    cmp sl, #0
    0xe00120b8    0x10    popeq {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe00120bc    0x14    mov r6, #0
    0xe00120c0    0x18    lsl sl, sl, #1
    0xe00120c4    0x1c    mov r9, r6
    0xe00120c8    0x20    asr r3, fp, r9
    0xe00120cc    0x24    and r3, r3, #7
    0xe00120d0    0x28    cmp r3, #1
    0xe00120d4    0x2c    bls e001214c <clean_D_PoU+0xa4>
    0xe00120d8    0x30    mrc 15, 2, r3, cr0, cr0, {0}
    0xe00120dc    0x34    mcr 15, 2, r6, cr0, cr0, {0}
    0xe00120e0    0x38    mrc 15, 1, r0, cr0, cr0, {0}
    0xe00120e4    0x3c    mcr 15, 2, r3, cr0, cr0, {0}
    0xe00120e8    0x40    ubfx r5, r0, #3, #10
    0xe00120ec    0x44    and lr, r0, #7
    0xe00120f0    0x48    mov r3, #1
    0xe00120f4    0x4c    clz r7, r5
    0xe00120f8    0x50    add lr, lr, #4
    0xe00120fc    0x54    ubfx r0, r0, #13, #15
    0xe0012100    0x58    mov r4, #0
    0xe0012104    0x5c    lsl r7, r3, r7
    0xe0012108    0x60    add r5, r5, r3
    0xe001210c    0x64    lsl lr, r3, lr
    0xe0012110    0x68    add r0, r0, r3
    0xe0012114    0x6c    mov r8, r4
    0xe0012118    0x70    mov r3, #0
    0xe001211c    0x74    orr ip, r4, r6
    0xe0012120    0x78    mov r2, r3
    0xe0012124    0x7c    orr r1, r3, ip
    0xe0012128    0x80    mcr 15, 0, r1, cr7, cr10, {2}
    0xe001212c    0x84    add r2, r2, #1
    0xe0012130    0x88    add r3, r3, lr
    0xe0012134    0x8c    cmp r0, r2
    0xe0012138    0x90    bgt e0012124 <clean_D_PoU+0x7c>
    0xe001213c    0x94    add r8, r8, #1
    0xe0012140    0x98    add r4, r4, r7
    0xe0012144    0x9c    cmp r5, r8
    0xe0012148    0xa0    bgt e0012118 <clean_D_PoU+0x70>
    0xe001214c    0xa4    add r6, r6, #2
    0xe0012150    0xa8    add r9, r9, #3
    0xe0012154    0xac    cmp r6, sl
    0xe0012158    0xb0    bne e00120c8 <clean_D_PoU+0x20>
    0xe001215c    0xb4    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
46 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `clean_D_PoU` has 65 nodes.

Section Arch_prepareThreadDelete (60 of 299)
============================================

Deriving specifications
-----------------------

Section `Arch_prepareThreadDelete` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_prepareThreadDelete`:

    0xe001204c    0x0    bx lr

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_prepareThreadDelete` has 2 nodes.

Section Arch_sameRegionAs (61 of 299)
=====================================

Deriving specifications
-----------------------

Section `Arch_sameRegionAs` consists of 201 instructions.
Switch found.
 ANDEQ (reg)...........++++++
 CMPLS (reg)......+++


Stack analysis
---------------

13 stack accesses found. Annotated code for `Arch_sameRegionAs`:

    0xe0011a14      0x0    push {r4, r5, lr}     ; stack access
    0xe0011a18      0x4    sub sp, sp, #20
    0xe0011a1c      0x8    add ip, sp, #16
    0xe0011a20      0xc    stmdb ip, {r0, r1}    ; stack access
    0xe0011a24     0x10    mov r0, sp
    0xe0011a28     0x14    ldr r1, [sp, #8]      ; stack access
    0xe0011a2c     0x18    stm r0, {r2, r3}      ; stack access
    0xe0011a30     0x1c    mov r0, r2
    0xe0011a34     0x20    and r3, r1, #14
    0xe0011a38     0x24    cmp r3, #14
    0xe0011a3c     0x28    andne r2, r1, #15
    0xe0011a40     0x2c    uxtbeq r2, r1
    0xe0011a44     0x30    sub r3, r2, #1
    0xe0011a48     0x34    cmp r3, #10
    0xe0011a4c     0x38    ldrls pc, [pc, r3, lsl #2]
    0xe0011a50     0x3c    b e0011a80 <Arch_sameRegionAs+0x6c>
    0xe0011a54     0x40    .word 0xe0011ab0
    0xe0011a58     0x44    .word 0xe0011a80
    0xe0011a5c     0x48    .word 0xe0011ab0
    0xe0011a60     0x4c    .word 0xe0011a80
    0xe0011a64     0x50    .word 0xe0011b94
    0xe0011a68     0x54    .word 0xe0011a80
    0xe0011a6c     0x58    .word 0xe0011bc4
    0xe0011a70     0x5c    .word 0xe0011a80
    0xe0011a74     0x60    .word 0xe0011c00
    0xe0011a78     0x64    .word 0xe0011a80
    0xe0011a7c     0x68    .word 0xe0011a8c
    0xe0011a80     0x6c    mov r0, #0
    0xe0011a84     0x70    add sp, sp, #20
    0xe0011a88     0x74    pop {r4, r5, pc}      ; stack access
    0xe0011a8c     0x78    and r3, r0, #14
    0xe0011a90     0x7c    cmp r3, #14
    0xe0011a94     0x80    andne r0, r0, #15
    0xe0011a98     0x84    uxtbeq r0, r0
    0xe0011a9c     0x88    sub r0, r0, #11
    0xe0011aa0     0x8c    clz r0, r0
    0xe0011aa4     0x90    lsr r0, r0, #5
    0xe0011aa8     0x94    add sp, sp, #20
    0xe0011aac     0x98    pop {r4, r5, pc}      ; stack access
    0xe0011ab0     0x9c    and r3, r0, #14
    0xe0011ab4     0xa0    cmp r3, #14
    0xe0011ab8     0xa4    andne ip, r0, #15
    0xe0011abc     0xa8    uxtbeq ip, r0
    0xe0011ac0     0xac    bic lr, ip, #2
    0xe0011ac4     0xb0    cmp lr, #1
    0xe0011ac8     0xb4    bne e0011a80 <Arch_sameRegionAs+0x6c>
    0xe0011acc     0xb8    cmp r2, #1
    0xe0011ad0     0xbc    beq e0011c58 <Arch_sameRegionAs+0x244>
    0xe0011ad4     0xc0    cmp r2, #3
    0xe0011ad8     0xc4    bne e0011c20 <Arch_sameRegionAs+0x20c>
    0xe0011adc     0xc8    cmp ip, #1
    0xe0011ae0     0xcc    mov r3, #49152 
    0xe0011ae4     0xd0    movt r3, #65535 
    0xe0011ae8     0xd4    ldr r4, [sp, #12]     ; stack access
    0xe0011aec     0xd8    and r1, r3, r1, lsl #10
    0xe0011af0     0xdc    beq e0011c94 <Arch_sameRegionAs+0x280>
    0xe0011af4     0xe0    cmp ip, #3
    0xe0011af8     0xe4    andeq r2, r3, r0, lsl #10
    0xe0011afc     0xe8    beq e0011ca0 <Arch_sameRegionAs+0x28c>
    0xe0011b00     0xec    clz r0, r1
    0xe0011b04     0xf0    ldr lr, [sp, #4]      ; stack access
    0xe0011b08     0xf4    mvn r5, #0
    0xe0011b0c     0xf8    mov r2, #0
    0xe0011b10     0xfc    lsr r0, r0, #5
    0xe0011b14    0x100    lsr r4, r4, #30
    0xe0011b18    0x104    cmp r4, #2
    0xe0011b1c    0x108    moveq r3, #1048576 
    0xe0011b20    0x10c    beq e0011b3c <Arch_sameRegionAs+0x128>
    0xe0011b24    0x110    cmp r4, #3
    0xe0011b28    0x114    moveq r3, #16777216 
    0xe0011b2c    0x118    beq e0011b3c <Arch_sameRegionAs+0x128>
    0xe0011b30    0x11c    cmp r4, #1
    0xe0011b34    0x120    moveq r3, #65536 
    0xe0011b38    0x124    movne r3, #4096 
    0xe0011b3c    0x128    cmp ip, #3
    0xe0011b40    0x12c    add r1, r1, r3
    0xe0011b44    0x130    sub r1, r1, #1
    0xe0011b48    0x134    movne r3, #4096 
    0xe0011b4c    0x138    bne e0011b78 <Arch_sameRegionAs+0x164>
    0xe0011b50    0x13c    lsr ip, lr, #30
    0xe0011b54    0x140    cmp ip, #2
    0xe0011b58    0x144    moveq r3, #1048576 
    0xe0011b5c    0x148    beq e0011b78 <Arch_sameRegionAs+0x164>
    0xe0011b60    0x14c    cmp ip, #3
    0xe0011b64    0x150    moveq r3, #16777216 
    0xe0011b68    0x154    beq e0011b78 <Arch_sameRegionAs+0x164>
    0xe0011b6c    0x158    cmp ip, #1
    0xe0011b70    0x15c    moveq r3, #65536 
    0xe0011b74    0x160    movne r3, #4096 
    0xe0011b78    0x164    add r3, r3, r5
    0xe0011b7c    0x168    cmp r3, r1
    0xe0011b80    0x16c    cmpls r2, r3
    0xe0011b84    0x170    movls r3, #1
    0xe0011b88    0x174    movhi r3, #0
    0xe0011b8c    0x178    and r0, r0, r3
    0xe0011b90    0x17c    b e0011a84 <Arch_sameRegionAs+0x70>
    0xe0011b94    0x180    and r3, r0, #14
    0xe0011b98    0x184    cmp r3, #14
    0xe0011b9c    0x188    andne r3, r0, #15
    0xe0011ba0    0x18c    uxtbeq r3, r0
    0xe0011ba4    0x190    cmp r3, #5
    0xe0011ba8    0x194    bne e0011a80 <Arch_sameRegionAs+0x6c>
    0xe0011bac    0x198    bic r0, r0, #15
    0xe0011bb0    0x19c    bic r1, r1, #15
    0xe0011bb4    0x1a0    sub r0, r0, r1
    0xe0011bb8    0x1a4    clz r0, r0
    0xe0011bbc    0x1a8    lsr r0, r0, #5
    0xe0011bc0    0x1ac    b e0011a84 <Arch_sameRegionAs+0x70>
    0xe0011bc4    0x1b0    and r3, r0, #14
    0xe0011bc8    0x1b4    cmp r3, #14
    0xe0011bcc    0x1b8    uxtbeq r3, r0
    0xe0011bd0    0x1bc    andne r3, r0, #15
    0xe0011bd4    0x1c0    cmp r3, #7
    0xe0011bd8    0x1c4    moveq r3, #64512 
    0xe0011bdc    0x1c8    bne e0011a80 <Arch_sameRegionAs+0x6c>
    0xe0011be0    0x1cc    movt r3, #65535 
    0xe0011be4    0x1d0    and r0, r0, r3
    0xe0011be8    0x1d4    and r1, r1, r3
    0xe0011bec    0x1d8    sub r0, r0, r1
    0xe0011bf0    0x1dc    clz r0, r0
    0xe0011bf4    0x1e0    lsr r0, r0, #5
    0xe0011bf8    0x1e4    add sp, sp, #20
    0xe0011bfc    0x1e8    pop {r4, r5, pc}      ; stack access
    0xe0011c00    0x1ec    and r3, r0, #14
    0xe0011c04    0x1f0    cmp r3, #14
    0xe0011c08    0x1f4    andne r3, r0, #15
    0xe0011c0c    0x1f8    uxtbeq r3, r0
    0xe0011c10    0x1fc    cmp r3, #9
    0xe0011c14    0x200    bne e0011a80 <Arch_sameRegionAs+0x6c>
    0xe0011c18    0x204    mov r3, #49152 
    0xe0011c1c    0x208    b e0011be0 <Arch_sameRegionAs+0x1cc>
    0xe0011c20    0x20c    cmp ip, #1
    0xe0011c24    0x210    beq e0011cb8 <Arch_sameRegionAs+0x2a4>
    0xe0011c28    0x214    cmp ip, #3
    0xe0011c2c    0x218    bne e0011d1c <Arch_sameRegionAs+0x308>
    0xe0011c30    0x21c    mov r3, #49152 
    0xe0011c34    0x220    movt r3, #65535 
    0xe0011c38    0x224    and r2, r3, r0, lsl #10
    0xe0011c3c    0x228    mov r0, lr
    0xe0011c40    0x22c    ldr lr, [sp, #4]      ; stack access
    0xe0011c44    0x230    sub r5, r2, #1
    0xe0011c48    0x234    mov r1, #0
    0xe0011c4c    0x238    add r1, r1, #4080 
    0xe0011c50    0x23c    add r1, r1, #15
    0xe0011c54    0x240    b e0011b50 <Arch_sameRegionAs+0x13c>
    0xe0011c58    0x244    cmp ip, #1
    0xe0011c5c    0x248    mov r3, #61440 
    0xe0011c60    0x24c    movt r3, #65535 
    0xe0011c64    0x250    and r1, r3, r1, lsl #8
    0xe0011c68    0x254    beq e0011d04 <Arch_sameRegionAs+0x2f0>
    0xe0011c6c    0x258    cmp ip, #3
    0xe0011c70    0x25c    beq e0011ce0 <Arch_sameRegionAs+0x2cc>
    0xe0011c74    0x260    clz r0, r1
    0xe0011c78    0x264    add r1, r1, #4080 
    0xe0011c7c    0x268    add r1, r1, #15
    0xe0011c80    0x26c    mvn r5, #0
    0xe0011c84    0x270    lsr r0, r0, #5
    0xe0011c88    0x274    mov r3, #4096 
    0xe0011c8c    0x278    mov r2, #0
    0xe0011c90    0x27c    b e0011b78 <Arch_sameRegionAs+0x164>
    0xe0011c94    0x280    mov r3, #61440 
    0xe0011c98    0x284    movt r3, #65535 
    0xe0011c9c    0x288    and r2, r3, r0, lsl #8
    0xe0011ca0    0x28c    cmp r1, r2
    0xe0011ca4    0x290    ldr lr, [sp, #4]      ; stack access
    0xe0011ca8    0x294    sub r5, r2, #1
    0xe0011cac    0x298    movhi r0, #0
    0xe0011cb0    0x29c    movls r0, #1
    0xe0011cb4    0x2a0    b e0011b14 <Arch_sameRegionAs+0x100>
    0xe0011cb8    0x2a4    mov r3, #61440 
    0xe0011cbc    0x2a8    movt r3, #65535 
    0xe0011cc0    0x2ac    and r2, r3, r0, lsl #8
    0xe0011cc4    0x2b0    mov r1, #0
    0xe0011cc8    0x2b4    sub r5, r2, #1
    0xe0011ccc    0x2b8    mov r0, ip
    0xe0011cd0    0x2bc    add r1, r1, #4080 
    0xe0011cd4    0x2c0    mov r3, #4096 
    0xe0011cd8    0x2c4    add r1, r1, #15
    0xe0011cdc    0x2c8    b e0011b78 <Arch_sameRegionAs+0x164>
    0xe0011ce0    0x2cc    mov r3, #49152 
    0xe0011ce4    0x2d0    movt r3, #65535 
    0xe0011ce8    0x2d4    and r2, r3, r0, lsl #10
    0xe0011cec    0x2d8    ldr lr, [sp, #4]      ; stack access
    0xe0011cf0    0x2dc    cmp r1, r2
    0xe0011cf4    0x2e0    sub r5, r2, #1
    0xe0011cf8    0x2e4    movhi r0, #0
    0xe0011cfc    0x2e8    movls r0, #1
    0xe0011d00    0x2ec    b e0011c4c <Arch_sameRegionAs+0x238>
    0xe0011d04    0x2f0    and r2, r3, r0, lsl #8
    0xe0011d08    0x2f4    cmp r1, r2
    0xe0011d0c    0x2f8    sub r5, r2, #1
    0xe0011d10    0x2fc    movhi r0, #0
    0xe0011d14    0x300    movls r0, #1
    0xe0011d18    0x304    b e0011cd0 <Arch_sameRegionAs+0x2bc>
    0xe0011d1c    0x308    mov r1, #0
    0xe0011d20    0x30c    mov r0, lr
    0xe0011d24    0x310    mov r2, r1
    0xe0011d28    0x314    ldr lr, [sp, #4]      ; stack access
    0xe0011d2c    0x318    mvn r5, #0
    0xe0011d30    0x31c    mov r3, #4096 
    0xe0011d34    0x320    b e0011b3c <Arch_sameRegionAs+0x128>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
190 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_sameRegionAs` has 335 nodes.

Section Arch_updateCapData (62 of 299)
======================================

Deriving specifications
-----------------------

Section `Arch_updateCapData` consists of 9 instructions.


Stack analysis
---------------

Section `Arch_updateCapData` expects pointer to stack in r0.
3 stack accesses found. Annotated code for `Arch_updateCapData`:

    0xe0011950     0x0    sub sp, sp, #8
    0xe0011954     0x4    mov ip, r0
    0xe0011958     0x8    sub r2, sp, #4
    0xe001195c     0xc    add sp, sp, #8
    0xe0011960    0x10    str r3, [r2, #8]!     ; stack access
    0xe0011964    0x14    ldm r2, {r0, r1}      ; stack access
    0xe0011968    0x18    stm ip, {r0, r1}      ; stack access
    0xe001196c    0x1c    mov r0, ip
    0xe0011970    0x20    bx lr

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_updateCapData` has 13 nodes.

Section Arch_isFrameType (63 of 299)
====================================

Deriving specifications
-----------------------

Section `Arch_isFrameType` consists of 5 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_isFrameType`:

    0xe001182c     0x0    sub r0, r0, #5
    0xe0011830     0x4    cmp r0, #3
    0xe0011834     0x8    movhi r0, #0
    0xe0011838     0xc    movls r0, #1
    0xe001183c    0x10    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
5 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_isFrameType` has 10 nodes.

Section invalidateTLBByASID (64 of 299)
=======================================

Deriving specifications
-----------------------

Section `invalidateTLBByASID` consists of 16 instructions.
Skipping f57ff04f dsb sy
Skipping ee083f57 mcr 15, 0, r3, cr8, cr7, {2}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

No stack accesses found. Code for `invalidateTLBByASID`:

    0xe00117ec     0x0    lsr r2, r0, #10
    0xe00117f0     0x4    movw r3, #37576 
    0xe00117f4     0x8    movt r3, #57346 
    0xe00117f8     0xc    ubfx r0, r0, #0, #10
    0xe00117fc    0x10    ldr r3, [r3, r2, lsl #2]
    0xe0011800    0x14    ldr r3, [r3, r0, lsl #2]
    0xe0011804    0x18    add r3, r3, #12288 
    0xe0011808    0x1c    ldr r3, [r3, #4032] 
    0xe001180c    0x20    tst r3, #8388608 
    0xe0011810    0x24    bxeq lr
    0xe0011814    0x28    dsb sy
    0xe0011818    0x2c    lsr r3, r3, #24
    0xe001181c    0x30    mcr 15, 0, r3, cr8, cr7, {2}
    0xe0011820    0x34    dsb sy
    0xe0011824    0x38    isb sy
    0xe0011828    0x3c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invalidateTLBByASID` has 27 nodes.

Section copyGlobalMappings (65 of 299)
======================================

Deriving specifications
-----------------------

Section `copyGlobalMappings` consists of 12 instructions.


Stack analysis
---------------

No stack accesses found. Code for `copyGlobalMappings`:

    0xe001141c     0x0    movw r1, #16384 
    0xe0011420     0x4    movt r1, #57346 
    0xe0011424     0x8    mov r3, #3584 
    0xe0011428     0xc    movw ip, #4095 
    0xe001142c    0x10    cmp r3, #4080 
    0xe0011430    0x14    beq e0011444 <copyGlobalMappings+0x28>
    0xe0011434    0x18    ldr r2, [r1, r3, lsl #2]
    0xe0011438    0x1c    cmp r3, ip
    0xe001143c    0x20    str r2, [r0, r3, lsl #2]
    0xe0011440    0x24    bxeq lr
    0xe0011444    0x28    add r3, r3, #1
    0xe0011448    0x2c    b e001142c <copyGlobalMappings+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `copyGlobalMappings` has 19 nodes.

Section findFreeHWASID (66 of 299)
==================================

Deriving specifications
-----------------------

Section `findFreeHWASID` consists of 35 instructions.
 LDMIAEQ (wb);15,4..++
Skipping f57ff04f dsb sy
Skipping ee08cf57 mcr 15, 0, ip, cr8, cr7, {2}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

3 stack accesses found. Annotated code for `findFreeHWASID`:

    0xe00111a4     0x0    push {r4, lr}         ; stack access
    0xe00111a8     0x4    movw lr, #13896 
    0xe00111ac     0x8    movt lr, #57347 
    0xe00111b0     0xc    movw r1, #12872 
    0xe00111b4    0x10    movt r1, #57347 
    0xe00111b8    0x14    mov r3, #0
    0xe00111bc    0x18    ldrb ip, [lr]
    0xe00111c0    0x1c    add r0, ip, r3
    0xe00111c4    0x20    add r3, r3, #1
    0xe00111c8    0x24    uxtb r0, r0
    0xe00111cc    0x28    ldr r2, [r1, r0, lsl #2]
    0xe00111d0    0x2c    cmp r2, #0
    0xe00111d4    0x30    popeq {r4, pc}        ; stack access
    0xe00111d8    0x34    cmp r3, #256 
    0xe00111dc    0x38    bne e00111c0 <findFreeHWASID+0x1c>
    0xe00111e0    0x3c    ldr r3, [r1, ip, lsl #2]
    0xe00111e4    0x40    movw r2, #37576 
    0xe00111e8    0x44    movt r2, #57346 
    0xe00111ec    0x48    mov r4, #0
    0xe00111f0    0x4c    ubfx r0, r3, #0, #10
    0xe00111f4    0x50    lsr r3, r3, #10
    0xe00111f8    0x54    ldr r3, [r2, r3, lsl #2]
    0xe00111fc    0x58    ldr r3, [r3, r0, lsl #2]
    0xe0011200    0x5c    add r3, r3, #12288 
    0xe0011204    0x60    str r4, [r3, #4032] 
    0xe0011208    0x64    dsb sy
    0xe001120c    0x68    mcr 15, 0, ip, cr8, cr7, {2}
    0xe0011210    0x6c    dsb sy
    0xe0011214    0x70    isb sy
    0xe0011218    0x74    ldrb r3, [lr]
    0xe001121c    0x78    mov r0, ip
    0xe0011220    0x7c    str r4, [r1, ip, lsl #2]
    0xe0011224    0x80    add r3, r3, #1
    0xe0011228    0x84    strb r3, [lr]
    0xe001122c    0x88    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `findFreeHWASID` has 55 nodes.

Section isIOSpaceFrameCap (67 of 299)
=====================================

Deriving specifications
-----------------------

Section `isIOSpaceFrameCap` consists of 6 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `isIOSpaceFrameCap`:

    0xe001111c     0x0    sub sp, sp, #8
    0xe0011120     0x4    add r3, sp, #8
    0xe0011124     0x8    stmdb r3, {r0, r1}    ; stack access
    0xe0011128     0xc    mov r0, #0
    0xe001112c    0x10    add sp, sp, #8
    0xe0011130    0x14    bx lr

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isIOSpaceFrameCap` has 8 nodes.

Section isValidVTableRoot (68 of 299)
=====================================

Deriving specifications
-----------------------

Section `isValidVTableRoot` consists of 13 instructions.
 SBFX,UBFXEQ...+++


Stack analysis
---------------

2 stack accesses found. Annotated code for `isValidVTableRoot`:

    0xe00110e8     0x0    sub sp, sp, #8
    0xe00110ec     0x4    add r3, sp, #8
    0xe00110f0     0x8    stmdb r3, {r0, r1}    ; stack access
    0xe00110f4     0xc    ldr r0, [sp]          ; stack access
    0xe00110f8    0x10    and r3, r0, #14
    0xe00110fc    0x14    cmp r3, #14
    0xe0011100    0x18    andne r3, r0, #15
    0xe0011104    0x1c    uxtbeq r3, r0
    0xe0011108    0x20    cmp r3, #9
    0xe001110c    0x24    ubfxeq r0, r0, #4, #1
    0xe0011110    0x28    movne r0, #0
    0xe0011114    0x2c    add sp, sp, #8
    0xe0011118    0x30    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isValidVTableRoot` has 24 nodes.

Section lookupPTSlot (69 of 299)
================================

Deriving specifications
-----------------------

Section `lookupPTSlot` consists of 23 instructions.


Stack analysis
---------------

Section `lookupPTSlot` expects pointer to stack in r0.
3 stack accesses found. Annotated code for `lookupPTSlot`:

    0xe001108c     0x0    lsr r3, r2, #20
    0xe0011090     0x4    ldr r3, [r1, r3, lsl #2]
    0xe0011094     0x8    and r1, r3, #3
    0xe0011098     0xc    cmp r1, #1
    0xe001109c    0x10    bne e00110c4 <lookupPTSlot+0x38>
    0xe00110a0    0x14    bic r3, r3, #1020 
    0xe00110a4    0x18    ubfx r2, r2, #12, #8
    0xe00110a8    0x1c    bic r3, r3, #3
    0xe00110ac    0x20    mov r1, #0
    0xe00110b0    0x24    add r3, r3, #-805306368 
    0xe00110b4    0x28    str r1, [r0]          ; stack access
    0xe00110b8    0x2c    add r3, r3, r2, lsl #2
    0xe00110bc    0x30    str r3, [r0, #4]      ; stack access
    0xe00110c0    0x34    bx lr
    0xe00110c4    0x38    movw r3, #36884 
    0xe00110c8    0x3c    movt r3, #57346 
    0xe00110cc    0x40    mov r2, #0
    0xe00110d0    0x44    mov r1, #81 
    0xe00110d4    0x48    str r2, [r3, #4]
    0xe00110d8    0x4c    str r1, [r3]
    0xe00110dc    0x50    mov r1, #2
    0xe00110e0    0x54    stm r0, {r1, r2}      ; stack access
    0xe00110e4    0x58    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupPTSlot` has 33 nodes.

Section lookupPDSlot (70 of 299)
================================

Deriving specifications
-----------------------

Section `lookupPDSlot` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lookupPDSlot`:

    0xe0011080    0x0    lsr r1, r1, #20
    0xe0011084    0x4    add r0, r0, r1, lsl #2
    0xe0011088    0x8    bx lr

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupPDSlot` has 4 nodes.

Section checkValidIPCBuffer (71 of 299)
=======================================

Deriving specifications
-----------------------

Section `checkValidIPCBuffer` consists of 33 instructions.
 SBFX,UBFXNE...+++


Stack analysis
---------------

2 stack accesses found. Annotated code for `checkValidIPCBuffer`:

    0xe0010ffc     0x0    sub sp, sp, #8
    0xe0011000     0x4    add r3, sp, #8
    0xe0011004     0x8    stmdb r3, {r1, r2}    ; stack access
    0xe0011008     0xc    ldr r3, [sp]          ; stack access
    0xe001100c    0x10    and r2, r3, #14
    0xe0011010    0x14    cmp r2, #14
    0xe0011014    0x18    andne r2, r3, #15
    0xe0011018    0x1c    uxtbeq r2, r3
    0xe001101c    0x20    bic r1, r2, #2
    0xe0011020    0x24    cmp r1, #1
    0xe0011024    0x28    bne e0011064 <checkValidIPCBuffer+0x68>
    0xe0011028    0x2c    cmp r2, #1
    0xe001102c    0x30    lsreq r3, r3, #31
    0xe0011030    0x34    ubfxne r3, r3, #29, #1
    0xe0011034    0x38    cmp r3, #0
    0xe0011038    0x3c    bne e0011064 <checkValidIPCBuffer+0x68>
    0xe001103c    0x40    ubfx r0, r0, #0, #9
    0xe0011040    0x44    cmp r0, #0
    0xe0011044    0x48    movwne r3, #36896 
    0xe0011048    0x4c    movtne r3, #57346 
    0xe001104c    0x50    movne r2, #5
    0xe0011050    0x54    movne r0, #3
    0xe0011054    0x58    moveq r0, r3
    0xe0011058    0x5c    strne r2, [r3, #24]
    0xe001105c    0x60    add sp, sp, #8
    0xe0011060    0x64    bx lr
    0xe0011064    0x68    movw r3, #36896 
    0xe0011068    0x6c    movt r3, #57346 
    0xe001106c    0x70    mov r2, #3
    0xe0011070    0x74    mov r0, r2
    0xe0011074    0x78    str r2, [r3, #24]
    0xe0011078    0x7c    add sp, sp, #8
    0xe001107c    0x80    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
33 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `checkValidIPCBuffer` has 63 nodes.

Section lookupIPCBuffer (72 of 299)
===================================

Deriving specifications
-----------------------

Section `lookupIPCBuffer` consists of 66 instructions.
 CMPEQ (imm)...++
 BLT..++


Stack analysis
---------------

3 stack accesses found. Annotated code for `lookupIPCBuffer`:

    0xe0010d50      0x0    bic r2, r1, #508 
    0xe0010d54      0x4    bic r2, r2, #3
    0xe0010d58      0x8    push {lr}             ; stack access
    0xe0010d5c      0xc    ldr lr, [r1, #132] 
    0xe0010d60     0x10    ldr r1, [r2, #64] 
    0xe0010d64     0x14    ldr ip, [r2, #68] 
    0xe0010d68     0x18    and r3, r1, #14
    0xe0010d6c     0x1c    cmp r3, #14
    0xe0010d70     0x20    andne r3, r1, #15
    0xe0010d74     0x24    uxtbeq r3, r1
    0xe0010d78     0x28    bic r2, r3, #2
    0xe0010d7c     0x2c    cmp r2, #1
    0xe0010d80     0x30    bne e0010df8 <lookupIPCBuffer+0xa8>
    0xe0010d84     0x34    cmp r3, #1
    0xe0010d88     0x38    beq e0010e00 <lookupIPCBuffer+0xb0>
    0xe0010d8c     0x3c    ubfx r2, r1, #29, #1
    0xe0010d90     0x40    cmp r2, #0
    0xe0010d94     0x44    bne e0010df8 <lookupIPCBuffer+0xa8>
    0xe0010d98     0x48    cmp r3, #3
    0xe0010d9c     0x4c    bne e0010df8 <lookupIPCBuffer+0xa8>
    0xe0010da0     0x50    ubfx r2, ip, #18, #2
    0xe0010da4     0x54    cmp r2, #3
    0xe0010da8     0x58    bne e0010dec <lookupIPCBuffer+0x9c>
    0xe0010dac     0x5c    lsr ip, ip, #30
    0xe0010db0     0x60    mov r0, #49152 
    0xe0010db4     0x64    cmp ip, #2
    0xe0010db8     0x68    movt r0, #65535 
    0xe0010dbc     0x6c    and r1, r0, r1, lsl #10
    0xe0010dc0     0x70    beq e0010e28 <lookupIPCBuffer+0xd8>
    0xe0010dc4     0x74    cmp ip, #3
    0xe0010dc8     0x78    mvneq r3, #-16777216 
    0xe0010dcc     0x7c    beq e0010de0 <lookupIPCBuffer+0x90>
    0xe0010dd0     0x80    cmp ip, #1
    0xe0010dd4     0x84    movw r2, #65535 
    0xe0010dd8     0x88    movw r3, #4095 
    0xe0010ddc     0x8c    moveq r3, r2
    0xe0010de0     0x90    and r0, r3, lr
    0xe0010de4     0x94    add r0, r0, r1
    0xe0010de8     0x98    pop {pc}              ; stack access
    0xe0010dec     0x9c    cmp r2, #2
    0xe0010df0     0xa0    cmpeq r0, #0
    0xe0010df4     0xa4    beq e0010dac <lookupIPCBuffer+0x5c>
    0xe0010df8     0xa8    mov r0, #0
    0xe0010dfc     0xac    pop {pc}              ; stack access
    0xe0010e00     0xb0    cmp r1, #0
    0xe0010e04     0xb4    blt e0010df8 <lookupIPCBuffer+0xa8>
    0xe0010e08     0xb8    ubfx ip, ip, #20, #2
    0xe0010e0c     0xbc    cmp ip, #3
    0xe0010e10     0xc0    bne e0010e34 <lookupIPCBuffer+0xe4>
    0xe0010e14     0xc4    mov r0, #61440 
    0xe0010e18     0xc8    movt r0, #65535 
    0xe0010e1c     0xcc    and r1, r0, r1, lsl #8
    0xe0010e20     0xd0    movw r3, #4095 
    0xe0010e24     0xd4    b e0010de0 <lookupIPCBuffer+0x90>
    0xe0010e28     0xd8    movw r3, #65535 
    0xe0010e2c     0xdc    movt r3, #15
    0xe0010e30     0xe0    b e0010de0 <lookupIPCBuffer+0x90>
    0xe0010e34     0xe4    sub ip, ip, #2
    0xe0010e38     0xe8    cmp r0, #0
    0xe0010e3c     0xec    clz ip, ip
    0xe0010e40     0xf0    movne r2, #0
    0xe0010e44     0xf4    lsr ip, ip, #5
    0xe0010e48     0xf8    moveq r2, ip
    0xe0010e4c     0xfc    cmp r2, #0
    0xe0010e50    0x100    bne e0010e14 <lookupIPCBuffer+0xc4>
    0xe0010e54    0x104    b e0010df8 <lookupIPCBuffer+0xa8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
66 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupIPCBuffer` has 108 nodes.

Section findPDForASID (73 of 299)
=================================

Deriving specifications
-----------------------

Section `findPDForASID` consists of 22 instructions.


Stack analysis
---------------

Section `findPDForASID` expects pointer to stack in r0.
3 stack accesses found. Annotated code for `findPDForASID`:

    0xe0010cf8     0x0    movw r3, #37576 
    0xe0010cfc     0x4    lsr r2, r1, #10
    0xe0010d00     0x8    movt r3, #57346 
    0xe0010d04     0xc    ldr r3, [r3, r2, lsl #2]
    0xe0010d08    0x10    cmp r3, #0
    0xe0010d0c    0x14    beq e0010d30 <findPDForASID+0x38>
    0xe0010d10    0x18    ubfx r1, r1, #0, #10
    0xe0010d14    0x1c    ldr r3, [r3, r1, lsl #2]
    0xe0010d18    0x20    cmp r3, #0
    0xe0010d1c    0x24    beq e0010d30 <findPDForASID+0x38>
    0xe0010d20    0x28    str r3, [r0, #4]      ; stack access
    0xe0010d24    0x2c    mov r3, #0
    0xe0010d28    0x30    str r3, [r0]          ; stack access
    0xe0010d2c    0x34    bx lr
    0xe0010d30    0x38    movw r3, #36884 
    0xe0010d34    0x3c    movt r3, #57346 
    0xe0010d38    0x40    mov r2, #0
    0xe0010d3c    0x44    mov r1, #2
    0xe0010d40    0x48    str r2, [r3]
    0xe0010d44    0x4c    str r2, [r3, #4]
    0xe0010d48    0x50    stm r0, {r1, r2}      ; stack access
    0xe0010d4c    0x54    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `findPDForASID` has 35 nodes.

Section maskVMRights (74 of 299)
================================

Deriving specifications
-----------------------

Section `maskVMRights` consists of 16 instructions.


Stack analysis
---------------

No stack accesses found. Code for `maskVMRights`:

    0xe0010cb8     0x0    cmp r0, #0
    0xe0010cbc     0x4    bxeq lr
    0xe0010cc0     0x8    cmp r0, #2
    0xe0010cc4     0xc    beq e0010cd8 <maskVMRights+0x20>
    0xe0010cc8    0x10    cmp r0, #3
    0xe0010ccc    0x14    beq e0010ce4 <maskVMRights+0x2c>
    0xe0010cd0    0x18    mov r0, #1
    0xe0010cd4    0x1c    bx lr
    0xe0010cd8    0x20    tst r1, #2
    0xe0010cdc    0x24    moveq r0, #1
    0xe0010ce0    0x28    bx lr
    0xe0010ce4    0x2c    tst r1, #2
    0xe0010ce8    0x30    beq e0010cd0 <maskVMRights+0x18>
    0xe0010cec    0x34    tst r1, #1
    0xe0010cf0    0x38    moveq r0, #2
    0xe0010cf4    0x3c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maskVMRights` has 32 nodes.

Section Arch_activateIdleThread (75 of 299)
===========================================

Deriving specifications
-----------------------

Section `Arch_activateIdleThread` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_activateIdleThread`:

    0xe0010cb4    0x0    bx lr

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_activateIdleThread` has 2 nodes.

Section halt (76 of 299)
========================

Deriving specifications
-----------------------

Section `halt` consists of 3 instructions.
Skipping f10c01c0 cpsid aif
 MSR (cpsr, imm).+Skipping e320f003 wfi


Stack analysis
---------------

No stack accesses found. Code for `halt`:

    0xe0010a3c    0x0    cpsid aif
    0xe0010a40    0x4    wfi
    0xe0010a44    0x8    b e0010a40 <halt+0x4>

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `halt` has 5 nodes.

Section emptySlot (77 of 299)
=============================

Deriving specifications
-----------------------

Section `emptySlot` consists of 58 instructions.
 LDRD (+imm,pre)...++


Stack analysis
---------------

8 stack accesses found. Annotated code for `emptySlot`:

    0xe0010928     0x0    push {lr}             ; stack access
    0xe001092c     0x4    sub sp, sp, #12
    0xe0010930     0x8    add r3, sp, #8
    0xe0010934     0xc    stmdb r3, {r1, r2}    ; stack access
    0xe0010938    0x10    ldr r3, [r0]
    0xe001093c    0x14    and r2, r3, #14
    0xe0010940    0x18    cmp r2, #14
    0xe0010944    0x1c    andne r3, r3, #15
    0xe0010948    0x20    uxtbeq r3, r3
    0xe001094c    0x24    cmp r3, #0
    0xe0010950    0x28    beq e00109c0 <emptySlot+0x98>
    0xe0010954    0x2c    ldrd r2, [r0, #8]
    0xe0010958    0x30    bics r2, r2, #7
    0xe001095c    0x34    bic r1, r3, #7
    0xe0010960    0x38    ldrne ip, [r2, #12]
    0xe0010964    0x3c    andne ip, ip, #7
    0xe0010968    0x40    orrne ip, ip, r1
    0xe001096c    0x44    strne ip, [r2, #12]
    0xe0010970    0x48    cmp r1, #0
    0xe0010974    0x4c    beq e001099c <emptySlot+0x74>
    0xe0010978    0x50    ldr lr, [r1, #12]
    0xe001097c    0x54    ldr ip, [r1, #8]
    0xe0010980    0x58    orr r3, r3, lr
    0xe0010984    0x5c    bic lr, lr, #1
    0xe0010988    0x60    and r3, r3, #1
    0xe001098c    0x64    and ip, ip, #7
    0xe0010990    0x68    orr r3, r3, lr
    0xe0010994    0x6c    orr r2, ip, r2
    0xe0010998    0x70    strd r2, [r1, #8]
    0xe001099c    0x74    ldr r2, [sp]          ; stack access
    0xe00109a0    0x78    mov r3, #0
    0xe00109a4    0x7c    str r3, [r0]
    0xe00109a8    0x80    and r1, r2, #14
    0xe00109ac    0x84    str r3, [r0, #4]
    0xe00109b0    0x88    cmp r1, #14
    0xe00109b4    0x8c    str r3, [r0, #8]
    0xe00109b8    0x90    str r3, [r0, #12]
    0xe00109bc    0x94    beq e00109c8 <emptySlot+0xa0>
    0xe00109c0    0x98    add sp, sp, #12
    0xe00109c4    0x9c    pop {pc}              ; stack access
    0xe00109c8    0xa0    uxtb r2, r2
    0xe00109cc    0xa4    cmp r2, #30
    0xe00109d0    0xa8    bne e00109c0 <emptySlot+0x98>
    0xe00109d4    0xac    ldrb ip, [sp, #4]     ; stack access
    0xe00109d8    0xb0    movw r2, #4735 
    0xe00109dc    0xb4    movw r0, #36936 
    0xe00109e0    0xb8    movt r2, #65520 
    0xe00109e4    0xbc    movt r0, #57346 
    0xe00109e8    0xc0    and lr, ip, #31
    0xe00109ec    0xc4    lsr r1, ip, #5
    0xe00109f0    0xc8    str r3, [r0, ip, lsl #2]  ; stack access
    0xe00109f4    0xcc    mov r3, #1
    0xe00109f8    0xd0    lsl r1, r1, #2
    0xe00109fc    0xd4    lsl r3, r3, lr
    0xe0010a00    0xd8    add r2, r1, r2
    0xe0010a04    0xdc    str r3, [r2, #-255]   ; stack access
    0xe0010a08    0xe0    add sp, sp, #12
    0xe0010a0c    0xe4    pop {pc}              ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
58 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `emptySlot` has 97 nodes.

Section invokeTCB_NotificationControl_part_179 (78 of 299)
==========================================================

Deriving specifications
-----------------------

Section `invokeTCB_NotificationControl_part_179` consists of 8 instructions.


Stack analysis
---------------

No stack accesses found. Code for `invokeTCB_NotificationControl_part_179`:

    0xe0010908     0x0    ldr r3, [r0, #92] 
    0xe001090c     0x4    cmp r3, #0
    0xe0010910     0x8    ldrne r2, [r3, #12]
    0xe0010914     0xc    movne r1, #0
    0xe0010918    0x10    andne r2, r2, #15
    0xe001091c    0x14    strne r2, [r3, #12]
    0xe0010920    0x18    strne r1, [r0, #92] 
    0xe0010924    0x1c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_NotificationControl_part_179` has 23 nodes.

Section tcbSchedAppend_part_171 (79 of 299)
===========================================

Deriving specifications
-----------------------

Section `tcbSchedAppend_part_171` consists of 38 instructions.
 ORR (reg-shift)...............+++++++++++++++


Stack analysis
---------------

2 stack accesses found. Annotated code for `tcbSchedAppend_part_171`:

    0xe0010870     0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0010874     0x4    movw r3, #38092 
    0xe0010878     0x8    ldr r4, [r0, #112] 
    0xe001087c     0xc    movt r3, #57346 
    0xe0010880    0x10    ldr r2, [r0, #120] 
    0xe0010884    0x14    add r1, r2, r4, lsl #8
    0xe0010888    0x18    add lr, r3, r1, lsl #3
    0xe001088c    0x1c    ldr ip, [r3, r1, lsl #3]
    0xe0010890    0x20    ldr r5, [lr, #4]
    0xe0010894    0x24    cmp ip, #0
    0xe0010898    0x28    strne r0, [r5, #136] 
    0xe001089c    0x2c    beq e00108c4 <tcbSchedAppend.part.171+0x54>
    0xe00108a0    0x30    ldr r2, [r0, #84] 
    0xe00108a4    0x34    mov r4, #0
    0xe00108a8    0x38    str r5, [r0, #140] 
    0xe00108ac    0x3c    str r4, [r0, #136] 
    0xe00108b0    0x40    orr r2, r2, #1
    0xe00108b4    0x44    str ip, [r3, r1, lsl #3]
    0xe00108b8    0x48    str r0, [lr, #4]
    0xe00108bc    0x4c    str r2, [r0, #84] 
    0xe00108c0    0x50    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe00108c4    0x54    lsr r9, r2, #5
    0xe00108c8    0x58    movw ip, #12292 
    0xe00108cc    0x5c    rsb r7, r9, #7
    0xe00108d0    0x60    movt ip, #57347 
    0xe00108d4    0x64    add r7, r7, r4, lsl #3
    0xe00108d8    0x68    movw r6, #12808 
    0xe00108dc    0x6c    movt r6, #57347 
    0xe00108e0    0x70    mov sl, #1
    0xe00108e4    0x74    ldr fp, [ip, r7, lsl #2]
    0xe00108e8    0x78    and r2, r2, #31
    0xe00108ec    0x7c    ldr r8, [r6, r4, lsl #2]
    0xe00108f0    0x80    orr r2, fp, sl, lsl r2
    0xe00108f4    0x84    str r2, [ip, r7, lsl #2]
    0xe00108f8    0x88    orr r2, r8, sl, lsl r9
    0xe00108fc    0x8c    mov ip, r0
    0xe0010900    0x90    str r2, [r6, r4, lsl #2]
    0xe0010904    0x94    b e00108a0 <tcbSchedAppend.part.171+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedAppend_part_171` has 59 nodes.

Section tcbSchedEnqueue_part_164 (80 of 299)
============================================

Deriving specifications
-----------------------

Section `tcbSchedEnqueue_part_164` consists of 38 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `tcbSchedEnqueue_part_164`:

    0xe00107d8     0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00107dc     0x4    movw r3, #38092 
    0xe00107e0     0x8    ldr r4, [r0, #112] 
    0xe00107e4     0xc    movt r3, #57346 
    0xe00107e8    0x10    ldr r2, [r0, #120] 
    0xe00107ec    0x14    add r1, r2, r4, lsl #8
    0xe00107f0    0x18    add lr, r3, r1, lsl #3
    0xe00107f4    0x1c    ldr r5, [r3, r1, lsl #3]
    0xe00107f8    0x20    ldr ip, [lr, #4]
    0xe00107fc    0x24    cmp ip, #0
    0xe0010800    0x28    strne r0, [r5, #140] 
    0xe0010804    0x2c    beq e001082c <tcbSchedEnqueue.part.164+0x54>
    0xe0010808    0x30    ldr r2, [r0, #84] 
    0xe001080c    0x34    mov r4, #0
    0xe0010810    0x38    str r5, [r0, #136] 
    0xe0010814    0x3c    str r4, [r0, #140] 
    0xe0010818    0x40    orr r2, r2, #1
    0xe001081c    0x44    str r0, [r3, r1, lsl #3]
    0xe0010820    0x48    str ip, [lr, #4]
    0xe0010824    0x4c    str r2, [r0, #84] 
    0xe0010828    0x50    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe001082c    0x54    lsr r9, r2, #5
    0xe0010830    0x58    movw ip, #12292 
    0xe0010834    0x5c    rsb r7, r9, #7
    0xe0010838    0x60    movt ip, #57347 
    0xe001083c    0x64    add r7, r7, r4, lsl #3
    0xe0010840    0x68    movw r6, #12808 
    0xe0010844    0x6c    movt r6, #57347 
    0xe0010848    0x70    mov sl, #1
    0xe001084c    0x74    ldr fp, [ip, r7, lsl #2]
    0xe0010850    0x78    and r2, r2, #31
    0xe0010854    0x7c    ldr r8, [r6, r4, lsl #2]
    0xe0010858    0x80    orr r2, fp, sl, lsl r2
    0xe001085c    0x84    str r2, [ip, r7, lsl #2]
    0xe0010860    0x88    orr r2, r8, sl, lsl r9
    0xe0010864    0x8c    mov ip, r0
    0xe0010868    0x90    str r2, [r6, r4, lsl #2]
    0xe001086c    0x94    b e0010808 <tcbSchedEnqueue.part.164+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedEnqueue_part_164` has 59 nodes.

Section preemptionPoint_part_161 (81 of 299)
============================================

Deriving specifications
-----------------------

Section `preemptionPoint_part_161` consists of 12 instructions.
 LDR (-imm,pre)..++
 MOVCC (imm)..++
 MOVCS (reg)....+++


Stack analysis
---------------

No stack accesses found. Code for `preemptionPoint_part_161`:

    0xe00107a8     0x0    movw r3, #8703 
    0xe00107ac     0x4    movt r3, #65520 
    0xe00107b0     0x8    movw r2, #12804 
    0xe00107b4     0xc    movt r2, #57347 
    0xe00107b8    0x10    ldr r3, [r3, #-231] 
    0xe00107bc    0x14    mov r1, #0
    0xe00107c0    0x18    str r1, [r2]
    0xe00107c4    0x1c    ubfx r3, r3, #0, #10
    0xe00107c8    0x20    cmp r3, #1020 
    0xe00107cc    0x24    movcc r0, #4
    0xe00107d0    0x28    movcs r0, r1
    0xe00107d4    0x2c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `preemptionPoint_part_161` has 19 nodes.

Section idle_thread (82 of 299)
===============================

Deriving specifications
-----------------------

Section `idle_thread` consists of 2 instructions.
 MSR (cpsr, imm)Skipping e320f003 wfi


Stack analysis
---------------

No stack accesses found. Code for `idle_thread`:

    0xe00107a0    0x0    wfi
    0xe00107a4    0x4    b e00107a0 <idle_thread>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `idle_thread` has 3 nodes.

Section lockTLBEntryCritical (83 of 299)
========================================

Deriving specifications
-----------------------

Section `lockTLBEntryCritical` consists of 8 instructions.
Skipping ee080f37 mcr 15, 0, r0, cr8, cr7, {1}
Skipping ee0a1f30 mcr 15, 0, r1, cr10, cr0, {1}
Skipping ee0a0f31 mcr 15, 0, r0, cr10, cr1, {1}
Skipping ee0a2f30 mcr 15, 0, r2, cr10, cr0, {1}
Skipping ee0a1f10 mcr 15, 0, r1, cr10, cr0, {0}
Skipping ee0a0f11 mcr 15, 0, r0, cr10, cr1, {0}
Skipping ee0a2f10 mcr 15, 0, r2, cr10, cr0, {0}


Stack analysis
---------------

No stack accesses found. Code for `lockTLBEntryCritical`:

    0xe0010780     0x0    mcr 15, 0, r0, cr8, cr7, {1}
    0xe0010784     0x4    mcr 15, 0, r1, cr10, cr0, {1}
    0xe0010788     0x8    mcr 15, 0, r0, cr10, cr1, {1}
    0xe001078c     0xc    mcr 15, 0, r2, cr10, cr0, {1}
    0xe0010790    0x10    mcr 15, 0, r1, cr10, cr0, {0}
    0xe0010794    0x14    mcr 15, 0, r0, cr10, cr1, {0}
    0xe0010798    0x18    mcr 15, 0, r2, cr10, cr0, {0}
    0xe001079c    0x1c    bx lr

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lockTLBEntryCritical` has 16 nodes.

Section kernel_data_fault (84 of 299)
=====================================

Deriving specifications
-----------------------

Section `kernel_data_fault` consists of 3 instructions.
Skipping ee159f10 mrc 15, 0, r9, cr5, cr0, {0}
Skipping ee16af10 mrc 15, 0, sl, cr6, cr0, {0}


Stack analysis
---------------

No stack accesses found. Code for `kernel_data_fault`:

    0xe00100e0    0x0    mrc 15, 0, r9, cr5, cr0, {0}
    0xe00100e4    0x4    mrc 15, 0, sl, cr6, cr0, {0}
    0xe00100e8    0x8    b e00100e8 <kernel_data_fault+0x8>

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `kernel_data_fault` has 5 nodes.

Section kernel_prefetch_fault (85 of 299)
=========================================

Deriving specifications
-----------------------

Section `kernel_prefetch_fault` consists of 2 instructions.
Skipping ee159f30 mrc 15, 0, r9, cr5, cr0, {1}


Stack analysis
---------------

No stack accesses found. Code for `kernel_prefetch_fault`:

    0xe00100b0    0x0    mrc 15, 0, r9, cr5, cr0, {1}
    0xe00100b4    0x4    b e00100b4 <kernel_prefetch_fault+0x4>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `kernel_prefetch_fault` has 3 nodes.

Section bi_finalise (86 of 299)
===============================

Deriving specifications
-----------------------

Section `bi_finalise` consists of 7 instructions.
+


Stack analysis
---------------

No stack accesses found. Code for `bi_finalise`:

    0xe0002aec     0x0    movw r3, #46848 
    0xe0002af0     0x4    movt r3, #57345 
    0xe0002af4     0x8    ldr r1, [r3, #132] 
    0xe0002af8     0xc    ldrd r2, [r3, #124] 
    0xe0002afc    0x10    str r1, [r2, #24]
    0xe0002b00    0x14    str r3, [r2, #20]
    0xe0002b04    0x18    bx lr

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `bi_finalise` has 12 nodes.

Section init_core_state (87 of 299)
===================================

Deriving specifications
-----------------------

Section `init_core_state` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `init_core_state`:

    0xe000281c     0x0    movw r1, #36880 
    0xe0002820     0x4    movt r1, #57346 
    0xe0002824     0x8    movw r2, #13900 
    0xe0002828     0xc    movw r3, #36892 
    0xe000282c    0x10    ldr r1, [r1]
    0xe0002830    0x14    movt r2, #57347 
    0xe0002834    0x18    movt r3, #57346 
    0xe0002838    0x1c    str r1, [r2]
    0xe000283c    0x20    str r0, [r3]
    0xe0002840    0x24    bx lr

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_core_state` has 14 nodes.

Section create_it_asid_pool (88 of 299)
=======================================

Deriving specifications
-----------------------

Section `create_it_asid_pool` consists of 309 instructions.
Switch found.
Skipping e7f000f0 udf #0
Switch found.
Skipping e7f000f0 udf #0
Switch found.
Switch found.
Switch found.
Switch found.
 ADDNE (imm)....+++
 MVNNE (imm)..++
 MOVNE (reg-shift)......++++++


Stack analysis
---------------

Section `create_it_asid_pool` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `create_it_asid_pool`:

    0xe0002348      0x0    push {r4, lr}         ; stack access
    0xe000234c      0x4    sub sp, sp, #8
    0xe0002350      0x8    add r3, sp, #8
    0xe0002354      0xc    stmdb r3, {r1, r2}    ; stack access
    0xe0002358     0x10    movw r2, #46848 
    0xe000235c     0x14    ldr r3, [sp]          ; stack access
    0xe0002360     0x18    movt r2, #57345 
    0xe0002364     0x1c    ldr ip, [sp, #4]      ; stack access
    0xe0002368     0x20    ldr r1, [r2, #152] 
    0xe000236c     0x24    and lr, r3, #14
    0xe0002370     0x28    cmp lr, #14
    0xe0002374     0x2c    bic r1, r1, #15
    0xe0002378     0x30    orr r1, r1, #5
    0xe000237c     0x34    beq e000247c <create_it_asid_pool+0x134>
    0xe0002380     0x38    and r2, r3, #15
    0xe0002384     0x3c    sub r4, r2, #2
    0xe0002388     0x40    cmp r4, #12
    0xe000238c     0x44    ldrls pc, [pc, r4, lsl #2]
    0xe0002390     0x48    b e00026f8 <create_it_asid_pool+0x3b0>
    0xe0002394     0x4c    .word 0xe00023d4
    0xe0002398     0x50    .word 0xe00026f8
    0xe000239c     0x54    .word 0xe00026a8
    0xe00023a0     0x58    .word 0xe00026f8
    0xe00023a4     0x5c    .word 0xe00023d4
    0xe00023a8     0x60    .word 0xe00026f8
    0xe00023ac     0x64    .word 0xe00023c8
    0xe00023b0     0x68    .word 0xe00026f8
    0xe00023b4     0x6c    .word 0xe00026bc
    0xe00023b8     0x70    .word 0xe00026f8
    0xe00023bc     0x74    .word 0xe00026b0
    0xe00023c0     0x78    .word 0xe00026f8
    0xe00023c4     0x7c    .word 0xe00023c8
    0xe00023c8     0x80    mov r3, #0
    0xe00023cc     0x84    str r3, [r3, #96] 
    0xe00023d0     0x88    udf #0
    0xe00023d4     0x8c    bic r2, r3, #15
    0xe00023d8     0x90    cmp lr, #14
    0xe00023dc     0x94    str r1, [r2, #96] 
    0xe00023e0     0x98    mov lr, #0
    0xe00023e4     0x9c    str lr, [r2, #100] 
    0xe00023e8     0xa0    str lr, [r2, #104] 
    0xe00023ec     0xa4    mov lr, #3
    0xe00023f0     0xa8    str lr, [r2, #108] 
    0xe00023f4     0xac    beq e0002584 <create_it_asid_pool+0x23c>
    0xe00023f8     0xb0    and r2, r3, #15
    0xe00023fc     0xb4    sub lr, r2, #2
    0xe0002400     0xb8    cmp lr, #12
    0xe0002404     0xbc    ldrls pc, [pc, lr, lsl #2]
    0xe0002408     0xc0    b e00026c4 <create_it_asid_pool+0x37c>
    0xe000240c     0xc4    .word 0xe0002440
    0xe0002410     0xc8    .word 0xe00026c4
    0xe0002414     0xcc    .word 0xe00026a0
    0xe0002418     0xd0    .word 0xe00026c4
    0xe000241c     0xd4    .word 0xe0002440
    0xe0002420     0xd8    .word 0xe00026c4
    0xe0002424     0xdc    .word 0xe0002470
    0xe0002428     0xe0    .word 0xe00026c4
    0xe000242c     0xe4    .word 0xe000268c
    0xe0002430     0xe8    .word 0xe00026c4
    0xe0002434     0xec    .word 0xe0002694
    0xe0002438     0xf0    .word 0xe00026c4
    0xe000243c     0xf4    .word 0xe0002470
    0xe0002440     0xf8    bic r3, r3, #15
    0xe0002444     0xfc    mov r2, #0
    0xe0002448    0x100    str r1, [r0]          ; stack access
    0xe000244c    0x104    str r2, [r3, #84] 
    0xe0002450    0x108    mov r1, #11
    0xe0002454    0x10c    str r2, [r3, #88] 
    0xe0002458    0x110    str r1, [r3, #80] 
    0xe000245c    0x114    mov r1, #3
    0xe0002460    0x118    str r2, [r0, #4]      ; stack access
    0xe0002464    0x11c    str r1, [r3, #92] 
    0xe0002468    0x120    add sp, sp, #8
    0xe000246c    0x124    pop {r4, pc}          ; stack access
    0xe0002470    0x128    mov r3, #0
    0xe0002474    0x12c    str r3, [r3, #80] 
    0xe0002478    0x130    udf #0
    0xe000247c    0x134    uxtb r2, r3
    0xe0002480    0x138    sub r4, r2, #2
    0xe0002484    0x13c    cmp r4, #60 
    0xe0002488    0x140    ldrls pc, [pc, r4, lsl #2]
    0xe000248c    0x144    b e00026f8 <create_it_asid_pool+0x3b0>
    0xe0002490    0x148    .word 0xe00023d4
    0xe0002494    0x14c    .word 0xe00026f8
    0xe0002498    0x150    .word 0xe00026a8
    0xe000249c    0x154    .word 0xe00026f8
    0xe00024a0    0x158    .word 0xe00023d4
    0xe00024a4    0x15c    .word 0xe00026f8
    0xe00024a8    0x160    .word 0xe00023c8
    0xe00024ac    0x164    .word 0xe00026f8
    0xe00024b0    0x168    .word 0xe00026bc
    0xe00024b4    0x16c    .word 0xe00026f8
    0xe00024b8    0x170    .word 0xe00026b0
    0xe00024bc    0x174    .word 0xe00026f8
    0xe00024c0    0x178    .word 0xe00023c8
    0xe00024c4    0x17c    .word 0xe00026f8
    0xe00024c8    0x180    .word 0xe00026f8
    0xe00024cc    0x184    .word 0xe00026f8
    0xe00024d0    0x188    .word 0xe00026f8
    0xe00024d4    0x18c    .word 0xe00026f8
    0xe00024d8    0x190    .word 0xe00026f8
    0xe00024dc    0x194    .word 0xe00026f8
    0xe00024e0    0x198    .word 0xe00026f8
    0xe00024e4    0x19c    .word 0xe00026f8
    0xe00024e8    0x1a0    .word 0xe00026f8
    0xe00024ec    0x1a4    .word 0xe00026f8
    0xe00024f0    0x1a8    .word 0xe00026f8
    0xe00024f4    0x1ac    .word 0xe00026f8
    0xe00024f8    0x1b0    .word 0xe00026f8
    0xe00024fc    0x1b4    .word 0xe00026f8
    0xe0002500    0x1b8    .word 0xe00023c8
    0xe0002504    0x1bc    .word 0xe00026f8
    0xe0002508    0x1c0    .word 0xe00026f8
    0xe000250c    0x1c4    .word 0xe00026f8
    0xe0002510    0x1c8    .word 0xe00026f8
    0xe0002514    0x1cc    .word 0xe00026f8
    0xe0002518    0x1d0    .word 0xe00026f8
    0xe000251c    0x1d4    .word 0xe00026f8
    0xe0002520    0x1d8    .word 0xe00026f8
    0xe0002524    0x1dc    .word 0xe00026f8
    0xe0002528    0x1e0    .word 0xe00026f8
    0xe000252c    0x1e4    .word 0xe00026f8
    0xe0002530    0x1e8    .word 0xe00026f8
    0xe0002534    0x1ec    .word 0xe00026f8
    0xe0002538    0x1f0    .word 0xe00026f8
    0xe000253c    0x1f4    .word 0xe00026f8
    0xe0002540    0x1f8    .word 0xe0002754
    0xe0002544    0x1fc    .word 0xe00026f8
    0xe0002548    0x200    .word 0xe00026f8
    0xe000254c    0x204    .word 0xe00026f8
    0xe0002550    0x208    .word 0xe00026f8
    0xe0002554    0x20c    .word 0xe00026f8
    0xe0002558    0x210    .word 0xe00026f8
    0xe000255c    0x214    .word 0xe00026f8
    0xe0002560    0x218    .word 0xe00026f8
    0xe0002564    0x21c    .word 0xe00026f8
    0xe0002568    0x220    .word 0xe00026f8
    0xe000256c    0x224    .word 0xe00026f8
    0xe0002570    0x228    .word 0xe00026f8
    0xe0002574    0x22c    .word 0xe00026f8
    0xe0002578    0x230    .word 0xe00026f8
    0xe000257c    0x234    .word 0xe00026f8
    0xe0002580    0x238    .word 0xe00023c8
    0xe0002584    0x23c    uxtb r2, r3
    0xe0002588    0x240    sub lr, r2, #2
    0xe000258c    0x244    cmp lr, #60 
    0xe0002590    0x248    ldrls pc, [pc, lr, lsl #2]
    0xe0002594    0x24c    b e00026c4 <create_it_asid_pool+0x37c>
    0xe0002598    0x250    .word 0xe0002440
    0xe000259c    0x254    .word 0xe00026c4
    0xe00025a0    0x258    .word 0xe00026a0
    0xe00025a4    0x25c    .word 0xe00026c4
    0xe00025a8    0x260    .word 0xe0002440
    0xe00025ac    0x264    .word 0xe00026c4
    0xe00025b0    0x268    .word 0xe0002470
    0xe00025b4    0x26c    .word 0xe00026c4
    0xe00025b8    0x270    .word 0xe000268c
    0xe00025bc    0x274    .word 0xe00026c4
    0xe00025c0    0x278    .word 0xe0002694
    0xe00025c4    0x27c    .word 0xe00026c4
    0xe00025c8    0x280    .word 0xe0002470
    0xe00025cc    0x284    .word 0xe00026c4
    0xe00025d0    0x288    .word 0xe00026c4
    0xe00025d4    0x28c    .word 0xe00026c4
    0xe00025d8    0x290    .word 0xe00026c4
    0xe00025dc    0x294    .word 0xe00026c4
    0xe00025e0    0x298    .word 0xe00026c4
    0xe00025e4    0x29c    .word 0xe00026c4
    0xe00025e8    0x2a0    .word 0xe00026c4
    0xe00025ec    0x2a4    .word 0xe00026c4
    0xe00025f0    0x2a8    .word 0xe00026c4
    0xe00025f4    0x2ac    .word 0xe00026c4
    0xe00025f8    0x2b0    .word 0xe00026c4
    0xe00025fc    0x2b4    .word 0xe00026c4
    0xe0002600    0x2b8    .word 0xe00026c4
    0xe0002604    0x2bc    .word 0xe00026c4
    0xe0002608    0x2c0    .word 0xe0002470
    0xe000260c    0x2c4    .word 0xe00026c4
    0xe0002610    0x2c8    .word 0xe00026c4
    0xe0002614    0x2cc    .word 0xe00026c4
    0xe0002618    0x2d0    .word 0xe00026c4
    0xe000261c    0x2d4    .word 0xe00026c4
    0xe0002620    0x2d8    .word 0xe00026c4
    0xe0002624    0x2dc    .word 0xe00026c4
    0xe0002628    0x2e0    .word 0xe00026c4
    0xe000262c    0x2e4    .word 0xe00026c4
    0xe0002630    0x2e8    .word 0xe00026c4
    0xe0002634    0x2ec    .word 0xe00026c4
    0xe0002638    0x2f0    .word 0xe00026c4
    0xe000263c    0x2f4    .word 0xe00026c4
    0xe0002640    0x2f8    .word 0xe00026c4
    0xe0002644    0x2fc    .word 0xe00026c4
    0xe0002648    0x300    .word 0xe000272c
    0xe000264c    0x304    .word 0xe00026c4
    0xe0002650    0x308    .word 0xe00026c4
    0xe0002654    0x30c    .word 0xe00026c4
    0xe0002658    0x310    .word 0xe00026c4
    0xe000265c    0x314    .word 0xe00026c4
    0xe0002660    0x318    .word 0xe00026c4
    0xe0002664    0x31c    .word 0xe00026c4
    0xe0002668    0x320    .word 0xe00026c4
    0xe000266c    0x324    .word 0xe00026c4
    0xe0002670    0x328    .word 0xe00026c4
    0xe0002674    0x32c    .word 0xe00026c4
    0xe0002678    0x330    .word 0xe00026c4
    0xe000267c    0x334    .word 0xe00026c4
    0xe0002680    0x338    .word 0xe00026c4
    0xe0002684    0x33c    .word 0xe00026c4
    0xe0002688    0x340    .word 0xe0002470
    0xe000268c    0x344    bic r3, r3, #31
    0xe0002690    0x348    b e0002444 <create_it_asid_pool+0xfc>
    0xe0002694    0x34c    bic r3, r3, #508 
    0xe0002698    0x350    bic r3, r3, #3
    0xe000269c    0x354    b e0002444 <create_it_asid_pool+0xfc>
    0xe00026a0    0x358    bic r3, ip, #15
    0xe00026a4    0x35c    b e0002444 <create_it_asid_pool+0xfc>
    0xe00026a8    0x360    bic r2, ip, #15
    0xe00026ac    0x364    b e00023d8 <create_it_asid_pool+0x90>
    0xe00026b0    0x368    bic r2, r3, #508 
    0xe00026b4    0x36c    bic r2, r2, #3
    0xe00026b8    0x370    b e00023d8 <create_it_asid_pool+0x90>
    0xe00026bc    0x374    bic r2, r3, #31
    0xe00026c0    0x378    b e00023d8 <create_it_asid_pool+0x90>
    0xe00026c4    0x37c    sub ip, r2, #1
    0xe00026c8    0x380    cmp ip, #8
    0xe00026cc    0x384    ldrls pc, [pc, ip, lsl #2]
    0xe00026d0    0x388    b e0002470 <create_it_asid_pool+0x128>
    0xe00026d4    0x38c    .word 0xe00027cc
    0xe00026d8    0x390    .word 0xe0002470
    0xe00026dc    0x394    .word 0xe00027cc
    0xe00026e0    0x398    .word 0xe0002470
    0xe00026e4    0x39c    .word 0xe0002440
    0xe00026e8    0x3a0    .word 0xe0002470
    0xe00026ec    0x3a4    .word 0xe00027c0
    0xe00026f0    0x3a8    .word 0xe0002470
    0xe00026f4    0x3ac    .word 0xe00027b4
    0xe00026f8    0x3b0    sub r4, r2, #1
    0xe00026fc    0x3b4    cmp r4, #8
    0xe0002700    0x3b8    ldrls pc, [pc, r4, lsl #2]
    0xe0002704    0x3bc    b e00023c8 <create_it_asid_pool+0x80>
    0xe0002708    0x3c0    .word 0xe0002794
    0xe000270c    0x3c4    .word 0xe00023c8
    0xe0002710    0x3c8    .word 0xe0002794
    0xe0002714    0x3cc    .word 0xe00023c8
    0xe0002718    0x3d0    .word 0xe00023d4
    0xe000271c    0x3d4    .word 0xe00023c8
    0xe0002720    0x3d8    .word 0xe0002788
    0xe0002724    0x3dc    .word 0xe00023c8
    0xe0002728    0x3e0    .word 0xe000277c
    0xe000272c    0x3e4    lsr r3, r3, #8
    0xe0002730    0x3e8    and r2, r3, #63 
    0xe0002734    0x3ec    cmp r2, #32
    0xe0002738    0x3f0    andne r3, r3, #31
    0xe000273c    0x3f4    addne r3, r3, #1
    0xe0002740    0x3f8    mvnne r2, #0
    0xe0002744    0x3fc    lslne r3, r2, r3
    0xe0002748    0x400    mvneq r3, #31
    0xe000274c    0x404    and r3, r3, ip
    0xe0002750    0x408    b e0002444 <create_it_asid_pool+0xfc>
    0xe0002754    0x40c    lsr r2, r3, #8
    0xe0002758    0x410    and r4, r2, #63 
    0xe000275c    0x414    cmp r4, #32
    0xe0002760    0x418    andne r4, r2, #31
    0xe0002764    0x41c    addne r4, r4, #1
    0xe0002768    0x420    mvnne r2, #0
    0xe000276c    0x424    lslne r2, r2, r4
    0xe0002770    0x428    mvneq r2, #31
    0xe0002774    0x42c    and r2, r2, ip
    0xe0002778    0x430    b e00023d8 <create_it_asid_pool+0x90>
    0xe000277c    0x434    bic r2, r3, #16320 
    0xe0002780    0x438    bic r2, r2, #63 
    0xe0002784    0x43c    b e00023d8 <create_it_asid_pool+0x90>
    0xe0002788    0x440    bic r2, r3, #1020 
    0xe000278c    0x444    bic r2, r2, #3
    0xe0002790    0x448    b e00023d8 <create_it_asid_pool+0x90>
    0xe0002794    0x44c    cmp r2, #1
    0xe0002798    0x450    beq e00027f4 <create_it_asid_pool+0x4ac>
    0xe000279c    0x454    cmp r2, #3
    0xe00027a0    0x458    bne e00027ec <create_it_asid_pool+0x4a4>
    0xe00027a4    0x45c    mov r2, #49152 
    0xe00027a8    0x460    movt r2, #65535 
    0xe00027ac    0x464    and r2, r2, r3, lsl #10
    0xe00027b0    0x468    b e00023d8 <create_it_asid_pool+0x90>
    0xe00027b4    0x46c    bic r3, r3, #16320 
    0xe00027b8    0x470    bic r3, r3, #63 
    0xe00027bc    0x474    b e0002444 <create_it_asid_pool+0xfc>
    0xe00027c0    0x478    bic r3, r3, #1020 
    0xe00027c4    0x47c    bic r3, r3, #3
    0xe00027c8    0x480    b e0002444 <create_it_asid_pool+0xfc>
    0xe00027cc    0x484    cmp r2, #1
    0xe00027d0    0x488    beq e000280c <create_it_asid_pool+0x4c4>
    0xe00027d4    0x48c    cmp r2, #3
    0xe00027d8    0x490    bne e0002804 <create_it_asid_pool+0x4bc>
    0xe00027dc    0x494    mov r2, #49152 
    0xe00027e0    0x498    movt r2, #65535 
    0xe00027e4    0x49c    and r3, r2, r3, lsl #10
    0xe00027e8    0x4a0    b e0002444 <create_it_asid_pool+0xfc>
    0xe00027ec    0x4a4    mov r2, #0
    0xe00027f0    0x4a8    b e00023d8 <create_it_asid_pool+0x90>
    0xe00027f4    0x4ac    mov r2, #61440 
    0xe00027f8    0x4b0    movt r2, #65535 
    0xe00027fc    0x4b4    and r2, r2, r3, lsl #8
    0xe0002800    0x4b8    b e00023d8 <create_it_asid_pool+0x90>
    0xe0002804    0x4bc    mov r3, #0
    0xe0002808    0x4c0    b e0002444 <create_it_asid_pool+0xfc>
    0xe000280c    0x4c4    mov r2, #61440 
    0xe0002810    0x4c8    movt r2, #65535 
    0xe0002814    0x4cc    and r3, r2, r3, lsl #8
    0xe0002818    0x4d0    b e0002444 <create_it_asid_pool+0xfc>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
143 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_it_asid_pool` has 699 nodes.

Section provide_cap (89 of 299)
===============================

Deriving specifications
-----------------------

Section `provide_cap` consists of 167 instructions.
 MOVCS (imm)..++
Switch found.
Switch found.
Switch found.


Stack analysis
---------------

8 stack accesses found. Annotated code for `provide_cap`:

    0xe0001ba8      0x0    push {r4, lr}         ; stack access
    0xe0001bac      0x4    sub sp, sp, #16
    0xe0001bb0      0x8    movw ip, #46848 
    0xe0001bb4      0xc    add r4, sp, #16
    0xe0001bb8     0x10    movt ip, #57345 
    0xe0001bbc     0x14    mov lr, sp
    0xe0001bc0     0x18    stmdb r4, {r0, r1}    ; stack access
    0xe0001bc4     0x1c    ldr r0, [ip, #132] 
    0xe0001bc8     0x20    ldr r1, [ip, #128] 
    0xe0001bcc     0x24    stm lr, {r2, r3}      ; stack access
    0xe0001bd0     0x28    cmp r1, r0
    0xe0001bd4     0x2c    movcs r0, #0
    0xe0001bd8     0x30    bcs e0001c6c <provide_cap+0xc4>
    0xe0001bdc     0x34    ldr r3, [sp, #8]      ; stack access
    0xe0001be0     0x38    ldr lr, [sp, #12]     ; stack access
    0xe0001be4     0x3c    and r2, r3, #14
    0xe0001be8     0x40    cmp r2, #14
    0xe0001bec     0x44    beq e0001c74 <provide_cap+0xcc>
    0xe0001bf0     0x48    and r2, r3, #15
    0xe0001bf4     0x4c    sub r0, r2, #2
    0xe0001bf8     0x50    cmp r0, #12
    0xe0001bfc     0x54    ldrls pc, [pc, r0, lsl #2]
    0xe0001c00     0x58    b e0001da0 <provide_cap+0x1f8>
    0xe0001c04     0x5c    .word 0xe0001c38
    0xe0001c08     0x60    .word 0xe0001da0
    0xe0001c0c     0x64    .word 0xe0001d98
    0xe0001c10     0x68    .word 0xe0001da0
    0xe0001c14     0x6c    .word 0xe0001c38
    0xe0001c18     0x70    .word 0xe0001da0
    0xe0001c1c     0x74    .word 0xe0001d7c
    0xe0001c20     0x78    .word 0xe0001da0
    0xe0001c24     0x7c    .word 0xe0001d84
    0xe0001c28     0x80    .word 0xe0001da0
    0xe0001c2c     0x84    .word 0xe0001d8c
    0xe0001c30     0x88    .word 0xe0001da0
    0xe0001c34     0x8c    .word 0xe0001d7c
    0xe0001c38     0x90    bic r3, r3, #15
    0xe0001c3c     0x94    ldr r0, [sp, #4]      ; stack access
    0xe0001c40     0x98    add r2, r3, r1, lsl #4
    0xe0001c44     0x9c    ldr r4, [sp]          ; stack access
    0xe0001c48     0xa0    add lr, r1, #1
    0xe0001c4c     0xa4    str r4, [r3, r1, lsl #4]
    0xe0001c50     0xa8    mov r1, #0
    0xe0001c54     0xac    str r0, [r2, #4]
    0xe0001c58     0xb0    mov r0, #1
    0xe0001c5c     0xb4    mov r3, #3
    0xe0001c60     0xb8    str r1, [r2, #8]
    0xe0001c64     0xbc    str r3, [r2, #12]
    0xe0001c68     0xc0    str lr, [ip, #128] 
    0xe0001c6c     0xc4    add sp, sp, #16
    0xe0001c70     0xc8    pop {r4, pc}          ; stack access
    0xe0001c74     0xcc    uxtb r2, r3
    0xe0001c78     0xd0    sub r0, r2, #2
    0xe0001c7c     0xd4    cmp r0, #60 
    0xe0001c80     0xd8    ldrls pc, [pc, r0, lsl #2]
    0xe0001c84     0xdc    b e0001da0 <provide_cap+0x1f8>
    0xe0001c88     0xe0    .word 0xe0001c38
    0xe0001c8c     0xe4    .word 0xe0001da0
    0xe0001c90     0xe8    .word 0xe0001d98
    0xe0001c94     0xec    .word 0xe0001da0
    0xe0001c98     0xf0    .word 0xe0001c38
    0xe0001c9c     0xf4    .word 0xe0001da0
    0xe0001ca0     0xf8    .word 0xe0001d7c
    0xe0001ca4     0xfc    .word 0xe0001da0
    0xe0001ca8    0x100    .word 0xe0001d84
    0xe0001cac    0x104    .word 0xe0001da0
    0xe0001cb0    0x108    .word 0xe0001d8c
    0xe0001cb4    0x10c    .word 0xe0001da0
    0xe0001cb8    0x110    .word 0xe0001d7c
    0xe0001cbc    0x114    .word 0xe0001da0
    0xe0001cc0    0x118    .word 0xe0001da0
    0xe0001cc4    0x11c    .word 0xe0001da0
    0xe0001cc8    0x120    .word 0xe0001da0
    0xe0001ccc    0x124    .word 0xe0001da0
    0xe0001cd0    0x128    .word 0xe0001da0
    0xe0001cd4    0x12c    .word 0xe0001da0
    0xe0001cd8    0x130    .word 0xe0001da0
    0xe0001cdc    0x134    .word 0xe0001da0
    0xe0001ce0    0x138    .word 0xe0001da0
    0xe0001ce4    0x13c    .word 0xe0001da0
    0xe0001ce8    0x140    .word 0xe0001da0
    0xe0001cec    0x144    .word 0xe0001da0
    0xe0001cf0    0x148    .word 0xe0001da0
    0xe0001cf4    0x14c    .word 0xe0001da0
    0xe0001cf8    0x150    .word 0xe0001d7c
    0xe0001cfc    0x154    .word 0xe0001da0
    0xe0001d00    0x158    .word 0xe0001da0
    0xe0001d04    0x15c    .word 0xe0001da0
    0xe0001d08    0x160    .word 0xe0001da0
    0xe0001d0c    0x164    .word 0xe0001da0
    0xe0001d10    0x168    .word 0xe0001da0
    0xe0001d14    0x16c    .word 0xe0001da0
    0xe0001d18    0x170    .word 0xe0001da0
    0xe0001d1c    0x174    .word 0xe0001da0
    0xe0001d20    0x178    .word 0xe0001da0
    0xe0001d24    0x17c    .word 0xe0001da0
    0xe0001d28    0x180    .word 0xe0001da0
    0xe0001d2c    0x184    .word 0xe0001da0
    0xe0001d30    0x188    .word 0xe0001da0
    0xe0001d34    0x18c    .word 0xe0001da0
    0xe0001d38    0x190    .word 0xe0001dd4
    0xe0001d3c    0x194    .word 0xe0001da0
    0xe0001d40    0x198    .word 0xe0001da0
    0xe0001d44    0x19c    .word 0xe0001da0
    0xe0001d48    0x1a0    .word 0xe0001da0
    0xe0001d4c    0x1a4    .word 0xe0001da0
    0xe0001d50    0x1a8    .word 0xe0001da0
    0xe0001d54    0x1ac    .word 0xe0001da0
    0xe0001d58    0x1b0    .word 0xe0001da0
    0xe0001d5c    0x1b4    .word 0xe0001da0
    0xe0001d60    0x1b8    .word 0xe0001da0
    0xe0001d64    0x1bc    .word 0xe0001da0
    0xe0001d68    0x1c0    .word 0xe0001da0
    0xe0001d6c    0x1c4    .word 0xe0001da0
    0xe0001d70    0x1c8    .word 0xe0001da0
    0xe0001d74    0x1cc    .word 0xe0001da0
    0xe0001d78    0x1d0    .word 0xe0001d7c
    0xe0001d7c    0x1d4    mov r3, #0
    0xe0001d80    0x1d8    b e0001c3c <provide_cap+0x94>
    0xe0001d84    0x1dc    bic r3, r3, #31
    0xe0001d88    0x1e0    b e0001c3c <provide_cap+0x94>
    0xe0001d8c    0x1e4    bic r3, r3, #508 
    0xe0001d90    0x1e8    bic r3, r3, #3
    0xe0001d94    0x1ec    b e0001c3c <provide_cap+0x94>
    0xe0001d98    0x1f0    bic r3, lr, #15
    0xe0001d9c    0x1f4    b e0001c3c <provide_cap+0x94>
    0xe0001da0    0x1f8    sub r0, r2, #1
    0xe0001da4    0x1fc    cmp r0, #8
    0xe0001da8    0x200    ldrls pc, [pc, r0, lsl #2]
    0xe0001dac    0x204    b e0001d7c <provide_cap+0x1d4>
    0xe0001db0    0x208    .word 0xe0001e14
    0xe0001db4    0x20c    .word 0xe0001d7c
    0xe0001db8    0x210    .word 0xe0001e14
    0xe0001dbc    0x214    .word 0xe0001d7c
    0xe0001dc0    0x218    .word 0xe0001c38
    0xe0001dc4    0x21c    .word 0xe0001d7c
    0xe0001dc8    0x220    .word 0xe0001e08
    0xe0001dcc    0x224    .word 0xe0001d7c
    0xe0001dd0    0x228    .word 0xe0001dfc
    0xe0001dd4    0x22c    lsr r2, r3, #8
    0xe0001dd8    0x230    and r3, r2, #63 
    0xe0001ddc    0x234    cmp r3, #32
    0xe0001de0    0x238    andne r3, r2, #31
    0xe0001de4    0x23c    addne r3, r3, #1
    0xe0001de8    0x240    mvnne r2, #0
    0xe0001dec    0x244    lslne r3, r2, r3
    0xe0001df0    0x248    mvneq r3, #31
    0xe0001df4    0x24c    and r3, r3, lr
    0xe0001df8    0x250    b e0001c3c <provide_cap+0x94>
    0xe0001dfc    0x254    bic r3, r3, #16320 
    0xe0001e00    0x258    bic r3, r3, #63 
    0xe0001e04    0x25c    b e0001c3c <provide_cap+0x94>
    0xe0001e08    0x260    bic r3, r3, #1020 
    0xe0001e0c    0x264    bic r3, r3, #3
    0xe0001e10    0x268    b e0001c3c <provide_cap+0x94>
    0xe0001e14    0x26c    cmp r2, #1
    0xe0001e18    0x270    beq e0001e34 <provide_cap+0x28c>
    0xe0001e1c    0x274    cmp r2, #3
    0xe0001e20    0x278    bne e0001d7c <provide_cap+0x1d4>
    0xe0001e24    0x27c    mov r2, #49152 
    0xe0001e28    0x280    movt r2, #65535 
    0xe0001e2c    0x284    and r3, r2, r3, lsl #10
    0xe0001e30    0x288    b e0001c3c <provide_cap+0x94>
    0xe0001e34    0x28c    mov r2, #61440 
    0xe0001e38    0x290    movt r2, #65535 
    0xe0001e3c    0x294    and r3, r2, r3, lsl #8
    0xe0001e40    0x298    b e0001c3c <provide_cap+0x94>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
84 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `provide_cap` has 371 nodes.

Section create_domain_cap (90 of 299)
=====================================

Deriving specifications
-----------------------

Section `create_domain_cap` consists of 155 instructions.
Switch found.
Skipping e7f000f0 udf #0
Switch found.
Switch found.


Stack analysis
---------------

3 stack accesses found. Annotated code for `create_domain_cap`:

    0xe0001234      0x0    sub sp, sp, #8
    0xe0001238      0x4    add r3, sp, #8
    0xe000123c      0x8    stmdb r3, {r0, r1}    ; stack access
    0xe0001240      0xc    ldr r3, [sp]          ; stack access
    0xe0001244     0x10    ldr r0, [sp, #4]      ; stack access
    0xe0001248     0x14    and r2, r3, #14
    0xe000124c     0x18    cmp r2, #14
    0xe0001250     0x1c    beq e00012d0 <create_domain_cap+0x9c>
    0xe0001254     0x20    and r2, r3, #15
    0xe0001258     0x24    sub r1, r2, #2
    0xe000125c     0x28    cmp r1, #12
    0xe0001260     0x2c    ldrls pc, [pc, r1, lsl #2]
    0xe0001264     0x30    b e00013f4 <create_domain_cap+0x1c0>
    0xe0001268     0x34    .word 0xe00012a8
    0xe000126c     0x38    .word 0xe00013f4
    0xe0001270     0x3c    .word 0xe00013e0
    0xe0001274     0x40    .word 0xe00013f4
    0xe0001278     0x44    .word 0xe00012a8
    0xe000127c     0x48    .word 0xe00013f4
    0xe0001280     0x4c    .word 0xe000129c
    0xe0001284     0x50    .word 0xe00013f4
    0xe0001288     0x54    .word 0xe00013d8
    0xe000128c     0x58    .word 0xe00013f4
    0xe0001290     0x5c    .word 0xe00013e8
    0xe0001294     0x60    .word 0xe00013f4
    0xe0001298     0x64    .word 0xe000129c
    0xe000129c     0x68    mov r3, #0
    0xe00012a0     0x6c    str r3, [r3, #176] 
    0xe00012a4     0x70    udf #0
    0xe00012a8     0x74    bic r3, r3, #15
    0xe00012ac     0x78    mov r2, #0
    0xe00012b0     0x7c    mov r1, #62 
    0xe00012b4     0x80    str r2, [r3, #180] 
    0xe00012b8     0x84    str r1, [r3, #176] 
    0xe00012bc     0x88    mov r1, #3
    0xe00012c0     0x8c    str r2, [r3, #184] 
    0xe00012c4     0x90    str r1, [r3, #188] 
    0xe00012c8     0x94    add sp, sp, #8
    0xe00012cc     0x98    bx lr
    0xe00012d0     0x9c    uxtb r2, r3
    0xe00012d4     0xa0    sub r1, r2, #2
    0xe00012d8     0xa4    cmp r1, #60 
    0xe00012dc     0xa8    ldrls pc, [pc, r1, lsl #2]
    0xe00012e0     0xac    b e00013f4 <create_domain_cap+0x1c0>
    0xe00012e4     0xb0    .word 0xe00012a8
    0xe00012e8     0xb4    .word 0xe00013f4
    0xe00012ec     0xb8    .word 0xe00013e0
    0xe00012f0     0xbc    .word 0xe00013f4
    0xe00012f4     0xc0    .word 0xe00012a8
    0xe00012f8     0xc4    .word 0xe00013f4
    0xe00012fc     0xc8    .word 0xe000129c
    0xe0001300     0xcc    .word 0xe00013f4
    0xe0001304     0xd0    .word 0xe00013d8
    0xe0001308     0xd4    .word 0xe00013f4
    0xe000130c     0xd8    .word 0xe00013e8
    0xe0001310     0xdc    .word 0xe00013f4
    0xe0001314     0xe0    .word 0xe000129c
    0xe0001318     0xe4    .word 0xe00013f4
    0xe000131c     0xe8    .word 0xe00013f4
    0xe0001320     0xec    .word 0xe00013f4
    0xe0001324     0xf0    .word 0xe00013f4
    0xe0001328     0xf4    .word 0xe00013f4
    0xe000132c     0xf8    .word 0xe00013f4
    0xe0001330     0xfc    .word 0xe00013f4
    0xe0001334    0x100    .word 0xe00013f4
    0xe0001338    0x104    .word 0xe00013f4
    0xe000133c    0x108    .word 0xe00013f4
    0xe0001340    0x10c    .word 0xe00013f4
    0xe0001344    0x110    .word 0xe00013f4
    0xe0001348    0x114    .word 0xe00013f4
    0xe000134c    0x118    .word 0xe00013f4
    0xe0001350    0x11c    .word 0xe00013f4
    0xe0001354    0x120    .word 0xe000129c
    0xe0001358    0x124    .word 0xe00013f4
    0xe000135c    0x128    .word 0xe00013f4
    0xe0001360    0x12c    .word 0xe00013f4
    0xe0001364    0x130    .word 0xe00013f4
    0xe0001368    0x134    .word 0xe00013f4
    0xe000136c    0x138    .word 0xe00013f4
    0xe0001370    0x13c    .word 0xe00013f4
    0xe0001374    0x140    .word 0xe00013f4
    0xe0001378    0x144    .word 0xe00013f4
    0xe000137c    0x148    .word 0xe00013f4
    0xe0001380    0x14c    .word 0xe00013f4
    0xe0001384    0x150    .word 0xe00013f4
    0xe0001388    0x154    .word 0xe00013f4
    0xe000138c    0x158    .word 0xe00013f4
    0xe0001390    0x15c    .word 0xe00013f4
    0xe0001394    0x160    .word 0xe0001428
    0xe0001398    0x164    .word 0xe00013f4
    0xe000139c    0x168    .word 0xe00013f4
    0xe00013a0    0x16c    .word 0xe00013f4
    0xe00013a4    0x170    .word 0xe00013f4
    0xe00013a8    0x174    .word 0xe00013f4
    0xe00013ac    0x178    .word 0xe00013f4
    0xe00013b0    0x17c    .word 0xe00013f4
    0xe00013b4    0x180    .word 0xe00013f4
    0xe00013b8    0x184    .word 0xe00013f4
    0xe00013bc    0x188    .word 0xe00013f4
    0xe00013c0    0x18c    .word 0xe00013f4
    0xe00013c4    0x190    .word 0xe00013f4
    0xe00013c8    0x194    .word 0xe00013f4
    0xe00013cc    0x198    .word 0xe00013f4
    0xe00013d0    0x19c    .word 0xe00013f4
    0xe00013d4    0x1a0    .word 0xe000129c
    0xe00013d8    0x1a4    bic r3, r3, #31
    0xe00013dc    0x1a8    b e00012ac <create_domain_cap+0x78>
    0xe00013e0    0x1ac    bic r3, r0, #15
    0xe00013e4    0x1b0    b e00012ac <create_domain_cap+0x78>
    0xe00013e8    0x1b4    bic r3, r3, #508 
    0xe00013ec    0x1b8    bic r3, r3, #3
    0xe00013f0    0x1bc    b e00012ac <create_domain_cap+0x78>
    0xe00013f4    0x1c0    sub r1, r2, #1
    0xe00013f8    0x1c4    cmp r1, #8
    0xe00013fc    0x1c8    ldrls pc, [pc, r1, lsl #2]
    0xe0001400    0x1cc    b e000129c <create_domain_cap+0x68>
    0xe0001404    0x1d0    .word 0xe0001468
    0xe0001408    0x1d4    .word 0xe000129c
    0xe000140c    0x1d8    .word 0xe0001468
    0xe0001410    0x1dc    .word 0xe000129c
    0xe0001414    0x1e0    .word 0xe00012a8
    0xe0001418    0x1e4    .word 0xe000129c
    0xe000141c    0x1e8    .word 0xe000145c
    0xe0001420    0x1ec    .word 0xe000129c
    0xe0001424    0x1f0    .word 0xe0001450
    0xe0001428    0x1f4    lsr r3, r3, #8
    0xe000142c    0x1f8    and r2, r3, #63 
    0xe0001430    0x1fc    cmp r2, #32
    0xe0001434    0x200    andne r3, r3, #31
    0xe0001438    0x204    addne r3, r3, #1
    0xe000143c    0x208    mvnne r2, #0
    0xe0001440    0x20c    lslne r3, r2, r3
    0xe0001444    0x210    mvneq r3, #31
    0xe0001448    0x214    and r3, r3, r0
    0xe000144c    0x218    b e00012ac <create_domain_cap+0x78>
    0xe0001450    0x21c    bic r3, r3, #16320 
    0xe0001454    0x220    bic r3, r3, #63 
    0xe0001458    0x224    b e00012ac <create_domain_cap+0x78>
    0xe000145c    0x228    bic r3, r3, #1020 
    0xe0001460    0x22c    bic r3, r3, #3
    0xe0001464    0x230    b e00012ac <create_domain_cap+0x78>
    0xe0001468    0x234    cmp r2, #1
    0xe000146c    0x238    beq e0001488 <create_domain_cap+0x254>
    0xe0001470    0x23c    cmp r2, #3
    0xe0001474    0x240    bne e0001498 <create_domain_cap+0x264>
    0xe0001478    0x244    mov r2, #49152 
    0xe000147c    0x248    movt r2, #65535 
    0xe0001480    0x24c    and r3, r2, r3, lsl #10
    0xe0001484    0x250    b e00012ac <create_domain_cap+0x78>
    0xe0001488    0x254    mov r2, #61440 
    0xe000148c    0x258    movt r2, #65535 
    0xe0001490    0x25c    and r3, r2, r3, lsl #8
    0xe0001494    0x260    b e00012ac <create_domain_cap+0x78>
    0xe0001498    0x264    mov r3, #0
    0xe000149c    0x268    b e00012ac <create_domain_cap+0x78>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
72 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_domain_cap` has 350 nodes.

Section create_root_cnode (91 of 299)
=====================================

Deriving specifications
-----------------------

Section `create_root_cnode` consists of 18 instructions.


Stack analysis
---------------

Section `create_root_cnode` expects pointer to stack in r0.
4 stack accesses found. Annotated code for `create_root_cnode`:

    0xe00011ec     0x0    movw r3, #46848 
    0xe00011f0     0x4    movt r3, #57345 
    0xe00011f4     0x8    push {r4, lr}         ; stack access
    0xe00011f8     0xc    mov r2, #4096 
    0xe00011fc    0x10    ldr r1, [r3, #144] 
    0xe0001200    0x14    mov r4, #0
    0xe0001204    0x18    str r2, [r3, #132] 
    0xe0001208    0x1c    mov lr, #3
    0xe000120c    0x20    bic r3, r1, #31
    0xe0001210    0x24    orr r3, r3, #10
    0xe0001214    0x28    str r4, [r1, #40] 
    0xe0001218    0x2c    str r3, [r1, #32]
    0xe000121c    0x30    str r3, [r0]          ; stack access
    0xe0001220    0x34    mov r3, #170917888 
    0xe0001224    0x38    str lr, [r1, #44] 
    0xe0001228    0x3c    str r3, [r1, #36] 
    0xe000122c    0x40    str r3, [r0, #4]      ; stack access
    0xe0001230    0x44    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_root_cnode` has 28 nodes.

Section write_slot (92 of 299)
==============================

Deriving specifications
-----------------------

Section `write_slot` consists of 13 instructions.
 STMIA;2,0...+


Stack analysis
---------------

4 stack accesses found. Annotated code for `write_slot`:

    0xe00011b8     0x0    push {lr}             ; stack access
    0xe00011bc     0x4    sub sp, sp, #12
    0xe00011c0     0x8    mov r3, r0
    0xe00011c4     0xc    mov r0, #0
    0xe00011c8    0x10    mov ip, sp
    0xe00011cc    0x14    str r0, [r3, #8]
    0xe00011d0    0x18    stm ip, {r1, r2}      ; stack access
    0xe00011d4    0x1c    mov lr, #3
    0xe00011d8    0x20    ldm ip, {r0, r1}      ; stack access
    0xe00011dc    0x24    str lr, [r3, #12]
    0xe00011e0    0x28    stm r3, {r0, r2}
    0xe00011e4    0x2c    add sp, sp, #12
    0xe00011e8    0x30    pop {pc}              ; stack access

Proving inst theorems
---------------------

13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `write_slot` has 20 nodes.

Section initTimer (93 of 299)
=============================

Deriving specifications
-----------------------

Section `initTimer` consists of 15 instructions.


Stack analysis
---------------

No stack accesses found. Code for `initTimer`:

    0xe0000b9c     0x0    movw r3, #9983 
    0xe0000ba0     0x4    movt r3, #65520 
    0xe0000ba4     0x8    mov r1, #0
    0xe0000ba8     0xc    movw r2, #12960 
    0xe0000bac    0x10    str r1, [r3, #-247] 
    0xe0000bb0    0x14    movt r2, #15
    0xe0000bb4    0x18    str r1, [r3, #-243] 
    0xe0000bb8    0x1c    str r2, [r3, #-255] 
    0xe0000bbc    0x20    ldr r2, [r3, #-247] 
    0xe0000bc0    0x24    orr r2, r2, #6
    0xe0000bc4    0x28    str r2, [r3, #-247] 
    0xe0000bc8    0x2c    ldr r2, [r3, #-247] 
    0xe0000bcc    0x30    orr r2, r2, #1
    0xe0000bd0    0x34    str r2, [r3, #-247] 
    0xe0000bd4    0x38    bx lr

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initTimer` has 23 nodes.

Section initL2Cache (94 of 299)
===============================

Deriving specifications
-----------------------

Section `initL2Cache` consists of 58 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `initL2Cache`:

    0xe0000ab4     0x0    movw r3, #12543 
    0xe0000ab8     0x4    movt r3, #65520 
    0xe0000abc     0x8    push {lr}             ; stack access
    0xe0000ac0     0xc    mov r2, r3
    0xe0000ac4    0x10    ldr r1, [r3, #1]
    0xe0000ac8    0x14    movw r0, #289 
    0xe0000acc    0x18    mov ip, #0
    0xe0000ad0    0x1c    mov lr, #805306368 
    0xe0000ad4    0x20    bic r1, r1, #1
    0xe0000ad8    0x24    movt ip, #15367 
    0xe0000adc    0x28    str r1, [r3, #1]
    0xe0000ae0    0x2c    movw r1, #65535 
    0xe0000ae4    0x30    str ip, [r3, #5]
    0xe0000ae8    0x34    str r0, [r3, #9]
    0xe0000aec    0x38    str r0, [r3, #13]
    0xe0000af0    0x3c    str lr, [r3, #3681] 
    0xe0000af4    0x40    str r1, [r3, #1661] 
    0xe0000af8    0x44    ldr r3, [r2, #1661] 
    0xe0000afc    0x48    uxth r3, r3
    0xe0000b00    0x4c    cmp r3, #0
    0xe0000b04    0x50    bne e0000af8 <initL2Cache+0x44>
    0xe0000b08    0x54    ldr r1, [r2, #-251] 
    0xe0000b0c    0x58    and r1, r1, #503316480 
    0xe0000b10    0x5c    cmp r1, #469762048 
    0xe0000b14    0x60    bne e0000b58 <initL2Cache+0xa4>
    0xe0000b18    0x64    str r3, [r2, #2049] 
    0xe0000b1c    0x68    str r3, [r2, #2053] 
    0xe0000b20    0x6c    str r3, [r2, #2057] 
    0xe0000b24    0x70    str r3, [r2, #2061] 
    0xe0000b28    0x74    str r3, [r2, #2065] 
    0xe0000b2c    0x78    str r3, [r2, #2069] 
    0xe0000b30    0x7c    str r3, [r2, #2073] 
    0xe0000b34    0x80    str r3, [r2, #2077] 
    0xe0000b38    0x84    str r3, [r2, #2081] 
    0xe0000b3c    0x88    str r3, [r2, #2085] 
    0xe0000b40    0x8c    str r3, [r2, #2089] 
    0xe0000b44    0x90    str r3, [r2, #2093] 
    0xe0000b48    0x94    str r3, [r2, #2097] 
    0xe0000b4c    0x98    str r3, [r2, #2101] 
    0xe0000b50    0x9c    str r3, [r2, #2105] 
    0xe0000b54    0xa0    str r3, [r2, #2109] 
    0xe0000b58    0xa4    movw r2, #12543 
    0xe0000b5c    0xa8    movt r2, #65520 
    0xe0000b60    0xac    mov r1, #0
    0xe0000b64    0xb0    ldr r3, [r2, #-251] 
    0xe0000b68    0xb4    and r3, r3, #503316480 
    0xe0000b6c    0xb8    cmp r3, #503316480 
    0xe0000b70    0xbc    moveq r3, #0
    0xe0000b74    0xc0    streq r3, [r2, #2129] 
    0xe0000b78    0xc4    movw r3, #12543 
    0xe0000b7c    0xc8    movt r3, #65520 
    0xe0000b80    0xcc    movw r2, #511 
    0xe0000b84    0xd0    str r1, [r3, #277] 
    0xe0000b88    0xd4    str r2, [r3, #289] 
    0xe0000b8c    0xd8    ldr r2, [r3, #1]
    0xe0000b90    0xdc    orr r2, r2, #1
    0xe0000b94    0xe0    str r2, [r3, #1]
    0xe0000b98    0xe4    pop {pc}              ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
58 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initL2Cache` has 99 nodes.

Section get_avail_p_regs (95 of 299)
====================================

Deriving specifications
-----------------------

Section `get_avail_p_regs` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `get_avail_p_regs`:

    0xe0000aa8    0x0    movw r0, #17480 
    0xe0000aac    0x4    movt r0, #57344 
    0xe0000ab0    0x8    bx lr

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `get_avail_p_regs` has 4 nodes.

Section get_num_avail_p_regs (96 of 299)
========================================

Deriving specifications
-----------------------

Section `get_num_avail_p_regs` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `get_num_avail_p_regs`:

    0xe0000aa0    0x0    mov r0, #1
    0xe0000aa4    0x4    bx lr

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `get_num_avail_p_regs` has 3 nodes.

Section arm_errata (97 of 299)
==============================

Deriving specifications
-----------------------

Section `arm_errata` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `arm_errata`:

    0xe0000a94    0x0    bx lr

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_errata` has 2 nodes.

Section fpsimd_HWCapTest (98 of 299)
====================================

Deriving specifications
-----------------------

Section `fpsimd_HWCapTest` consists of 16 instructions.
Skipping ee113f50 mrc 15, 0, r3, cr1, cr0, {2}
Skipping ee013f50 mcr 15, 0, r3, cr1, cr0, {2}
Skipping f57ff06f isb sy
Skipping eef83a10 vmrs r3, fpexc
Skipping eee83a10 vmsr fpexc, r3
Skipping eef83a10 vmrs r3, fpexc


Stack analysis
---------------

No stack accesses found. Code for `fpsimd_HWCapTest`:

    0xe00009f4     0x0    mrc 15, 0, r3, cr1, cr0, {2}
    0xe00009f8     0x4    orr r3, r3, #15728640 
    0xe00009fc     0x8    mcr 15, 0, r3, cr1, cr0, {2}
    0xe0000a00     0xc    isb sy
    0xe0000a04    0x10    .word 0xeef00a10
    0xe0000a08    0x14    mov r3, r0
    0xe0000a0c    0x18    tst r3, #8388608 
    0xe0000a10    0x1c    bne e0000a2c <fpsimd_HWCapTest+0x38>
    0xe0000a14    0x20    vmrs r3, fpexc
    0xe0000a18    0x24    orr r3, r3, #-2147483648 
    0xe0000a1c    0x28    vmsr fpexc, r3
    0xe0000a20    0x2c    vmrs r3, fpexc
    0xe0000a24    0x30    mov r0, #1
    0xe0000a28    0x34    bx lr
    0xe0000a2c    0x38    mov r0, #0
    0xe0000a30    0x3c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `fpsimd_HWCapTest` has 25 nodes.

Section write_it_asid_pool (99 of 299)
======================================

Deriving specifications
-----------------------

Section `write_it_asid_pool` consists of 290 instructions.
Switch found.
 LDMIA;12,3...+
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.


Stack analysis
---------------

5 stack accesses found. Annotated code for `write_it_asid_pool`:

    0xe000056c      0x0    sub sp, sp, #16
    0xe0000570      0x4    add ip, sp, #16
    0xe0000574      0x8    stmdb ip, {r0, r1}    ; stack access
    0xe0000578      0xc    mov r0, sp
    0xe000057c     0x10    ldr r1, [sp, #8]      ; stack access
    0xe0000580     0x14    stm r0, {r2, r3}      ; stack access
    0xe0000584     0x18    and r3, r1, #14
    0xe0000588     0x1c    ldr r0, [sp, #12]     ; stack access
    0xe000058c     0x20    cmp r3, #14
    0xe0000590     0x24    beq e000075c <write_it_asid_pool+0x1f0>
    0xe0000594     0x28    and r3, r1, #15
    0xe0000598     0x2c    sub r2, r3, #2
    0xe000059c     0x30    cmp r2, #12
    0xe00005a0     0x34    ldrls pc, [pc, r2, lsl #2]
    0xe00005a4     0x38    b e00008e0 <write_it_asid_pool+0x374>
    0xe00005a8     0x3c    .word 0xe00005dc
    0xe00005ac     0x40    .word 0xe00008e0
    0xe00005b0     0x44    .word 0xe00008a4
    0xe00005b4     0x48    .word 0xe00008e0
    0xe00005b8     0x4c    .word 0xe00005dc
    0xe00005bc     0x50    .word 0xe00008e0
    0xe00005c0     0x54    .word 0xe000086c
    0xe00005c4     0x58    .word 0xe00008e0
    0xe00005c8     0x5c    .word 0xe000089c
    0xe00005cc     0x60    .word 0xe00008e0
    0xe00005d0     0x64    .word 0xe0000890
    0xe00005d4     0x68    .word 0xe00008e0
    0xe00005d8     0x6c    .word 0xe000086c
    0xe00005dc     0x70    bic r1, r1, #15
    0xe00005e0     0x74    ldm sp, {r3, ip}      ; stack access
    0xe00005e4     0x78    and r2, r3, #14
    0xe00005e8     0x7c    cmp r2, #14
    0xe00005ec     0x80    beq e0000654 <write_it_asid_pool+0xe8>
    0xe00005f0     0x84    and r2, r3, #15
    0xe00005f4     0x88    sub r0, r2, #2
    0xe00005f8     0x8c    cmp r0, #12
    0xe00005fc     0x90    ldrls pc, [pc, r0, lsl #2]
    0xe0000600     0x94    b e00008ac <write_it_asid_pool+0x340>
    0xe0000604     0x98    .word 0xe0000638
    0xe0000608     0x9c    .word 0xe00008ac
    0xe000060c     0xa0    .word 0xe0000874
    0xe0000610     0xa4    .word 0xe00008ac
    0xe0000614     0xa8    .word 0xe0000638
    0xe0000618     0xac    .word 0xe00008ac
    0xe000061c     0xb0    .word 0xe0000864
    0xe0000620     0xb4    .word 0xe00008ac
    0xe0000624     0xb8    .word 0xe0000888
    0xe0000628     0xbc    .word 0xe00008ac
    0xe000062c     0xc0    .word 0xe000087c
    0xe0000630     0xc4    .word 0xe00008ac
    0xe0000634     0xc8    .word 0xe0000864
    0xe0000638     0xcc    bic r3, r3, #15
    0xe000063c     0xd0    movw r2, #37576 
    0xe0000640     0xd4    movt r2, #57346 
    0xe0000644     0xd8    str r3, [r1, #4]
    0xe0000648     0xdc    str r1, [r2]
    0xe000064c     0xe0    add sp, sp, #16
    0xe0000650     0xe4    bx lr
    0xe0000654     0xe8    uxtb r2, r3
    0xe0000658     0xec    sub r0, r2, #2
    0xe000065c     0xf0    cmp r0, #60 
    0xe0000660     0xf4    ldrls pc, [pc, r0, lsl #2]
    0xe0000664     0xf8    b e00008ac <write_it_asid_pool+0x340>
    0xe0000668     0xfc    .word 0xe0000638
    0xe000066c    0x100    .word 0xe00008ac
    0xe0000670    0x104    .word 0xe0000874
    0xe0000674    0x108    .word 0xe00008ac
    0xe0000678    0x10c    .word 0xe0000638
    0xe000067c    0x110    .word 0xe00008ac
    0xe0000680    0x114    .word 0xe0000864
    0xe0000684    0x118    .word 0xe00008ac
    0xe0000688    0x11c    .word 0xe0000888
    0xe000068c    0x120    .word 0xe00008ac
    0xe0000690    0x124    .word 0xe000087c
    0xe0000694    0x128    .word 0xe00008ac
    0xe0000698    0x12c    .word 0xe0000864
    0xe000069c    0x130    .word 0xe00008ac
    0xe00006a0    0x134    .word 0xe00008ac
    0xe00006a4    0x138    .word 0xe00008ac
    0xe00006a8    0x13c    .word 0xe00008ac
    0xe00006ac    0x140    .word 0xe00008ac
    0xe00006b0    0x144    .word 0xe00008ac
    0xe00006b4    0x148    .word 0xe00008ac
    0xe00006b8    0x14c    .word 0xe00008ac
    0xe00006bc    0x150    .word 0xe00008ac
    0xe00006c0    0x154    .word 0xe00008ac
    0xe00006c4    0x158    .word 0xe00008ac
    0xe00006c8    0x15c    .word 0xe00008ac
    0xe00006cc    0x160    .word 0xe00008ac
    0xe00006d0    0x164    .word 0xe00008ac
    0xe00006d4    0x168    .word 0xe00008ac
    0xe00006d8    0x16c    .word 0xe0000864
    0xe00006dc    0x170    .word 0xe00008ac
    0xe00006e0    0x174    .word 0xe00008ac
    0xe00006e4    0x178    .word 0xe00008ac
    0xe00006e8    0x17c    .word 0xe00008ac
    0xe00006ec    0x180    .word 0xe00008ac
    0xe00006f0    0x184    .word 0xe00008ac
    0xe00006f4    0x188    .word 0xe00008ac
    0xe00006f8    0x18c    .word 0xe00008ac
    0xe00006fc    0x190    .word 0xe00008ac
    0xe0000700    0x194    .word 0xe00008ac
    0xe0000704    0x198    .word 0xe00008ac
    0xe0000708    0x19c    .word 0xe00008ac
    0xe000070c    0x1a0    .word 0xe00008ac
    0xe0000710    0x1a4    .word 0xe00008ac
    0xe0000714    0x1a8    .word 0xe00008ac
    0xe0000718    0x1ac    .word 0xe000093c
    0xe000071c    0x1b0    .word 0xe00008ac
    0xe0000720    0x1b4    .word 0xe00008ac
    0xe0000724    0x1b8    .word 0xe00008ac
    0xe0000728    0x1bc    .word 0xe00008ac
    0xe000072c    0x1c0    .word 0xe00008ac
    0xe0000730    0x1c4    .word 0xe00008ac
    0xe0000734    0x1c8    .word 0xe00008ac
    0xe0000738    0x1cc    .word 0xe00008ac
    0xe000073c    0x1d0    .word 0xe00008ac
    0xe0000740    0x1d4    .word 0xe00008ac
    0xe0000744    0x1d8    .word 0xe00008ac
    0xe0000748    0x1dc    .word 0xe00008ac
    0xe000074c    0x1e0    .word 0xe00008ac
    0xe0000750    0x1e4    .word 0xe00008ac
    0xe0000754    0x1e8    .word 0xe00008ac
    0xe0000758    0x1ec    .word 0xe0000864
    0xe000075c    0x1f0    uxtb r3, r1
    0xe0000760    0x1f4    sub r2, r3, #2
    0xe0000764    0x1f8    cmp r2, #60 
    0xe0000768    0x1fc    ldrls pc, [pc, r2, lsl #2]
    0xe000076c    0x200    b e00008e0 <write_it_asid_pool+0x374>
    0xe0000770    0x204    .word 0xe00005dc
    0xe0000774    0x208    .word 0xe00008e0
    0xe0000778    0x20c    .word 0xe00008a4
    0xe000077c    0x210    .word 0xe00008e0
    0xe0000780    0x214    .word 0xe00005dc
    0xe0000784    0x218    .word 0xe00008e0
    0xe0000788    0x21c    .word 0xe000086c
    0xe000078c    0x220    .word 0xe00008e0
    0xe0000790    0x224    .word 0xe000089c
    0xe0000794    0x228    .word 0xe00008e0
    0xe0000798    0x22c    .word 0xe0000890
    0xe000079c    0x230    .word 0xe00008e0
    0xe00007a0    0x234    .word 0xe000086c
    0xe00007a4    0x238    .word 0xe00008e0
    0xe00007a8    0x23c    .word 0xe00008e0
    0xe00007ac    0x240    .word 0xe00008e0
    0xe00007b0    0x244    .word 0xe00008e0
    0xe00007b4    0x248    .word 0xe00008e0
    0xe00007b8    0x24c    .word 0xe00008e0
    0xe00007bc    0x250    .word 0xe00008e0
    0xe00007c0    0x254    .word 0xe00008e0
    0xe00007c4    0x258    .word 0xe00008e0
    0xe00007c8    0x25c    .word 0xe00008e0
    0xe00007cc    0x260    .word 0xe00008e0
    0xe00007d0    0x264    .word 0xe00008e0
    0xe00007d4    0x268    .word 0xe00008e0
    0xe00007d8    0x26c    .word 0xe00008e0
    0xe00007dc    0x270    .word 0xe00008e0
    0xe00007e0    0x274    .word 0xe000086c
    0xe00007e4    0x278    .word 0xe00008e0
    0xe00007e8    0x27c    .word 0xe00008e0
    0xe00007ec    0x280    .word 0xe00008e0
    0xe00007f0    0x284    .word 0xe00008e0
    0xe00007f4    0x288    .word 0xe00008e0
    0xe00007f8    0x28c    .word 0xe00008e0
    0xe00007fc    0x290    .word 0xe00008e0
    0xe0000800    0x294    .word 0xe00008e0
    0xe0000804    0x298    .word 0xe00008e0
    0xe0000808    0x29c    .word 0xe00008e0
    0xe000080c    0x2a0    .word 0xe00008e0
    0xe0000810    0x2a4    .word 0xe00008e0
    0xe0000814    0x2a8    .word 0xe00008e0
    0xe0000818    0x2ac    .word 0xe00008e0
    0xe000081c    0x2b0    .word 0xe00008e0
    0xe0000820    0x2b4    .word 0xe0000914
    0xe0000824    0x2b8    .word 0xe00008e0
    0xe0000828    0x2bc    .word 0xe00008e0
    0xe000082c    0x2c0    .word 0xe00008e0
    0xe0000830    0x2c4    .word 0xe00008e0
    0xe0000834    0x2c8    .word 0xe00008e0
    0xe0000838    0x2cc    .word 0xe00008e0
    0xe000083c    0x2d0    .word 0xe00008e0
    0xe0000840    0x2d4    .word 0xe00008e0
    0xe0000844    0x2d8    .word 0xe00008e0
    0xe0000848    0x2dc    .word 0xe00008e0
    0xe000084c    0x2e0    .word 0xe00008e0
    0xe0000850    0x2e4    .word 0xe00008e0
    0xe0000854    0x2e8    .word 0xe00008e0
    0xe0000858    0x2ec    .word 0xe00008e0
    0xe000085c    0x2f0    .word 0xe00008e0
    0xe0000860    0x2f4    .word 0xe000086c
    0xe0000864    0x2f8    mov r3, #0
    0xe0000868    0x2fc    b e000063c <write_it_asid_pool+0xd0>
    0xe000086c    0x300    mov r1, #0
    0xe0000870    0x304    b e00005e0 <write_it_asid_pool+0x74>
    0xe0000874    0x308    bic r3, ip, #15
    0xe0000878    0x30c    b e000063c <write_it_asid_pool+0xd0>
    0xe000087c    0x310    bic r3, r3, #508 
    0xe0000880    0x314    bic r3, r3, #3
    0xe0000884    0x318    b e000063c <write_it_asid_pool+0xd0>
    0xe0000888    0x31c    bic r3, r3, #31
    0xe000088c    0x320    b e000063c <write_it_asid_pool+0xd0>
    0xe0000890    0x324    bic r1, r1, #508 
    0xe0000894    0x328    bic r1, r1, #3
    0xe0000898    0x32c    b e00005e0 <write_it_asid_pool+0x74>
    0xe000089c    0x330    bic r1, r1, #31
    0xe00008a0    0x334    b e00005e0 <write_it_asid_pool+0x74>
    0xe00008a4    0x338    bic r1, r0, #15
    0xe00008a8    0x33c    b e00005e0 <write_it_asid_pool+0x74>
    0xe00008ac    0x340    sub r0, r2, #1
    0xe00008b0    0x344    cmp r0, #8
    0xe00008b4    0x348    ldrls pc, [pc, r0, lsl #2]
    0xe00008b8    0x34c    b e0000864 <write_it_asid_pool+0x2f8>
    0xe00008bc    0x350    .word 0xe00009b4
    0xe00008c0    0x354    .word 0xe0000864
    0xe00008c4    0x358    .word 0xe00009b4
    0xe00008c8    0x35c    .word 0xe0000864
    0xe00008cc    0x360    .word 0xe0000638
    0xe00008d0    0x364    .word 0xe0000864
    0xe00008d4    0x368    .word 0xe00009a8
    0xe00008d8    0x36c    .word 0xe0000864
    0xe00008dc    0x370    .word 0xe000099c
    0xe00008e0    0x374    sub r2, r3, #1
    0xe00008e4    0x378    cmp r2, #8
    0xe00008e8    0x37c    ldrls pc, [pc, r2, lsl #2]
    0xe00008ec    0x380    b e000086c <write_it_asid_pool+0x300>
    0xe00008f0    0x384    .word 0xe000097c
    0xe00008f4    0x388    .word 0xe000086c
    0xe00008f8    0x38c    .word 0xe000097c
    0xe00008fc    0x390    .word 0xe000086c
    0xe0000900    0x394    .word 0xe00005dc
    0xe0000904    0x398    .word 0xe000086c
    0xe0000908    0x39c    .word 0xe0000970
    0xe000090c    0x3a0    .word 0xe000086c
    0xe0000910    0x3a4    .word 0xe0000964
    0xe0000914    0x3a8    lsr r3, r1, #8
    0xe0000918    0x3ac    and r2, r3, #63 
    0xe000091c    0x3b0    cmp r2, #32
    0xe0000920    0x3b4    andne r3, r3, #31
    0xe0000924    0x3b8    mvnne r1, #0
    0xe0000928    0x3bc    addne r3, r3, #1
    0xe000092c    0x3c0    lslne r1, r1, r3
    0xe0000930    0x3c4    mvneq r1, #31
    0xe0000934    0x3c8    and r1, r1, r0
    0xe0000938    0x3cc    b e00005e0 <write_it_asid_pool+0x74>
    0xe000093c    0x3d0    lsr r2, r3, #8
    0xe0000940    0x3d4    and r3, r2, #63 
    0xe0000944    0x3d8    cmp r3, #32
    0xe0000948    0x3dc    andne r3, r2, #31
    0xe000094c    0x3e0    addne r3, r3, #1
    0xe0000950    0x3e4    mvnne r2, #0
    0xe0000954    0x3e8    lslne r3, r2, r3
    0xe0000958    0x3ec    mvneq r3, #31
    0xe000095c    0x3f0    and r3, r3, ip
    0xe0000960    0x3f4    b e000063c <write_it_asid_pool+0xd0>
    0xe0000964    0x3f8    bic r1, r1, #16320 
    0xe0000968    0x3fc    bic r1, r1, #63 
    0xe000096c    0x400    b e00005e0 <write_it_asid_pool+0x74>
    0xe0000970    0x404    bic r1, r1, #1020 
    0xe0000974    0x408    bic r1, r1, #3
    0xe0000978    0x40c    b e00005e0 <write_it_asid_pool+0x74>
    0xe000097c    0x410    cmp r3, #1
    0xe0000980    0x414    beq e00009d4 <write_it_asid_pool+0x468>
    0xe0000984    0x418    cmp r3, #3
    0xe0000988    0x41c    bne e000086c <write_it_asid_pool+0x300>
    0xe000098c    0x420    mov r3, #49152 
    0xe0000990    0x424    movt r3, #65535 
    0xe0000994    0x428    and r1, r3, r1, lsl #10
    0xe0000998    0x42c    b e00005e0 <write_it_asid_pool+0x74>
    0xe000099c    0x430    bic r3, r3, #16320 
    0xe00009a0    0x434    bic r3, r3, #63 
    0xe00009a4    0x438    b e000063c <write_it_asid_pool+0xd0>
    0xe00009a8    0x43c    bic r3, r3, #1020 
    0xe00009ac    0x440    bic r3, r3, #3
    0xe00009b0    0x444    b e000063c <write_it_asid_pool+0xd0>
    0xe00009b4    0x448    cmp r2, #1
    0xe00009b8    0x44c    beq e00009e4 <write_it_asid_pool+0x478>
    0xe00009bc    0x450    cmp r2, #3
    0xe00009c0    0x454    bne e0000864 <write_it_asid_pool+0x2f8>
    0xe00009c4    0x458    mov r2, #49152 
    0xe00009c8    0x45c    movt r2, #65535 
    0xe00009cc    0x460    and r3, r2, r3, lsl #10
    0xe00009d0    0x464    b e000063c <write_it_asid_pool+0xd0>
    0xe00009d4    0x468    mov r3, #61440 
    0xe00009d8    0x46c    movt r3, #65535 
    0xe00009dc    0x470    and r1, r3, r1, lsl #8
    0xe00009e0    0x474    b e00005e0 <write_it_asid_pool+0x74>
    0xe00009e4    0x478    mov r2, #61440 
    0xe00009e8    0x47c    movt r2, #65535 
    0xe00009ec    0x480    and r3, r2, r3, lsl #8
    0xe00009f0    0x484    b e000063c <write_it_asid_pool+0xd0>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
124 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `write_it_asid_pool` has 668 nodes.

Section create_mapped_it_frame_cap (100 of 299)
===============================================

Deriving specifications
-----------------------

Section `create_mapped_it_frame_cap` consists of 75 instructions.
 ORREQ (imm)....+++


Stack analysis
---------------

Section `create_mapped_it_frame_cap` expects pointer to stack in r0.
10 stack accesses found. Annotated code for `create_mapped_it_frame_cap`:

    0xe0000440      0x0    push {r4, r5, lr}     ; stack access
    0xe0000444      0x4    sub sp, sp, #12
    0xe0000448      0x8    ldr lr, [sp, #32]     ; stack access
    0xe000044c      0xc    ldr ip, [sp, #28]     ; stack access
    0xe0000450     0x10    cmp lr, #0
    0xe0000454     0x14    add lr, sp, #8
    0xe0000458     0x18    ldr r4, [sp, #24]     ; stack access
    0xe000045c     0x1c    stmdb lr, {r1, r2}    ; stack access
    0xe0000460     0x20    lsr r2, ip, #10
    0xe0000464     0x24    bne e0000514 <create_mapped_it_frame_cap+0xd4>
    0xe0000468     0x28    lsl r2, r2, #24
    0xe000046c     0x2c    lsl r1, ip, #22
    0xe0000470     0x30    and r2, r2, #2130706432 
    0xe0000474     0x34    movw ip, #65520 
    0xe0000478     0x38    movt ip, #255 
    0xe000047c     0x3c    orr r2, r2, #1
    0xe0000480     0x40    orr r1, r1, #3145728 
    0xe0000484     0x44    and r3, ip, r3, lsr #8
    0xe0000488     0x48    orr r1, r1, r4, lsr #12
    0xe000048c     0x4c    orr r3, r2, r3
    0xe0000490     0x50    and lr, r3, #15
    0xe0000494     0x54    ldr ip, [sp]          ; stack access
    0xe0000498     0x58    cmp lr, #1
    0xe000049c     0x5c    mov r2, #49152 
    0xe00004a0     0x60    movt r2, #65535 
    0xe00004a4     0x64    and r4, ip, r2
    0xe00004a8     0x68    beq e000054c <create_mapped_it_frame_cap+0x10c>
    0xe00004ac     0x6c    cmp lr, #3
    0xe00004b0     0x70    beq e0000508 <create_mapped_it_frame_cap+0xc8>
    0xe00004b4     0x74    cmp lr, #1
    0xe00004b8     0x78    movne r2, #805306368 
    0xe00004bc     0x7c    beq e0000564 <create_mapped_it_frame_cap+0x124>
    0xe00004c0     0x80    lsl ip, r1, #14
    0xe00004c4     0x84    lsr r5, ip, #20
    0xe00004c8     0x88    str r3, [r0]          ; stack access
    0xe00004cc     0x8c    ubfx lr, ip, #12, #8
    0xe00004d0     0x90    movw ip, #2422 
    0xe00004d4     0x94    ldr r3, [r4, r5, lsl #2]
    0xe00004d8     0x98    ldr r4, [sp, #36]     ; stack access
    0xe00004dc     0x9c    bic r3, r3, #1020 
    0xe00004e0     0xa0    str r1, [r0, #4]      ; stack access
    0xe00004e4     0xa4    bic r3, r3, #3
    0xe00004e8     0xa8    cmp r4, #0
    0xe00004ec     0xac    orreq ip, ip, #1
    0xe00004f0     0xb0    add r3, r3, lr, lsl #2
    0xe00004f4     0xb4    orr r2, ip, r2
    0xe00004f8     0xb8    add r3, r3, #-805306368 
    0xe00004fc     0xbc    str r2, [r3]
    0xe0000500     0xc0    add sp, sp, #12
    0xe0000504     0xc4    pop {r4, r5, pc}      ; stack access
    0xe0000508     0xc8    and r2, r2, r3, lsl #10
    0xe000050c     0xcc    add r2, r2, #805306368 
    0xe0000510     0xd0    b e00004c0 <create_mapped_it_frame_cap+0x80>
    0xe0000514     0xd4    mov lr, #0
    0xe0000518     0xd8    movt lr, #16368 
    0xe000051c     0xdc    and r1, lr, ip, lsl #20
    0xe0000520     0xe0    lsl r2, r2, #22
    0xe0000524     0xe4    and r2, r2, #532676608 
    0xe0000528     0xe8    movw ip, #65520 
    0xe000052c     0xec    orr r1, r1, r4, lsr #14
    0xe0000530     0xf0    movt ip, #63 
    0xe0000534     0xf4    orr r2, r2, #3
    0xe0000538     0xf8    and r3, ip, r3, lsr #10
    0xe000053c     0xfc    orr r1, r1, #-2147483648 
    0xe0000540    0x100    orr r3, r2, r3
    0xe0000544    0x104    orr r1, r1, #786432 
    0xe0000548    0x108    b e0000490 <create_mapped_it_frame_cap+0x50>
    0xe000054c    0x10c    mov r2, #61440 
    0xe0000550    0x110    movt r2, #65535 
    0xe0000554    0x114    and r2, r2, r3, lsl #8
    0xe0000558    0x118    add r2, r2, #805306368 
    0xe000055c    0x11c    lsl ip, r1, #12
    0xe0000560    0x120    b e00004c4 <create_mapped_it_frame_cap+0x84>
    0xe0000564    0x124    mov r2, #0
    0xe0000568    0x128    b e0000558 <create_mapped_it_frame_cap+0x118>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
75 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_mapped_it_frame_cap` has 99 nodes.

Section create_unmapped_it_frame_cap (101 of 299)
=================================================

Deriving specifications
-----------------------

Section `create_unmapped_it_frame_cap` consists of 18 instructions.


Stack analysis
---------------

Section `create_unmapped_it_frame_cap` expects pointer to stack in r0.
3 stack accesses found. Annotated code for `create_unmapped_it_frame_cap`:

    0xe00003f8     0x0    cmp r2, #0
    0xe00003fc     0x4    bne e0000420 <create_unmapped_it_frame_cap+0x28>
    0xe0000400     0x8    movw r3, #65520 
    0xe0000404     0xc    movt r3, #255 
    0xe0000408    0x10    and r3, r3, r1, lsr #8
    0xe000040c    0x14    mov r2, #3145728 
    0xe0000410    0x18    orr r3, r3, #1
    0xe0000414    0x1c    str r2, [r0, #4]      ; stack access
    0xe0000418    0x20    str r3, [r0]          ; stack access
    0xe000041c    0x24    bx lr
    0xe0000420    0x28    movw r2, #65520 
    0xe0000424    0x2c    movt r2, #63 
    0xe0000428    0x30    and r2, r2, r1, lsr #10
    0xe000042c    0x34    mov r3, #0
    0xe0000430    0x38    orr r2, r2, #3
    0xe0000434    0x3c    movt r3, #32780 
    0xe0000438    0x40    strd r2, [r0]         ; stack access
    0xe000043c    0x44    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_unmapped_it_frame_cap` has 25 nodes.

Section arch_get_n_paging (102 of 299)
======================================

Deriving specifications
-----------------------

Section `arch_get_n_paging` consists of 14 instructions.
 LDMIA;3,0...+


Stack analysis
---------------

2 stack accesses found. Annotated code for `arch_get_n_paging`:

    0xe00003c0     0x0    sub sp, sp, #8
    0xe00003c4     0x4    add r3, sp, #8
    0xe00003c8     0x8    stmdb r3, {r0, r1}    ; stack access
    0xe00003cc     0xc    ldm sp, {r0, r3}      ; stack access
    0xe00003d0    0x10    sub r3, r3, #1
    0xe00003d4    0x14    lsr r0, r0, #20
    0xe00003d8    0x18    lsr r3, r3, #20
    0xe00003dc    0x1c    lsl r0, r0, #20
    0xe00003e0    0x20    lsl r3, r3, #20
    0xe00003e4    0x24    add r3, r3, #1048576 
    0xe00003e8    0x28    sub r0, r3, r0
    0xe00003ec    0x2c    lsr r0, r0, #20
    0xe00003f0    0x30    add sp, sp, #8
    0xe00003f4    0x34    bx lr

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arch_get_n_paging` has 17 nodes.

Section Arch_configureIdleThread (103 of 299)
=============================================

Deriving specifications
-----------------------

Section `Arch_configureIdleThread` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_configureIdleThread`:

    0xe000035c     0x0    movw r2, #351 
    0xe0000360     0x4    movw r3, #1952 
    0xe0000364     0x8    str r2, [r0, #64] 
    0xe0000368     0xc    movt r3, #57345 
    0xe000036c    0x10    str r3, [r0, #60] 
    0xe0000370    0x14    bx lr

Proving inst theorems
---------------------

6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_configureIdleThread` has 9 nodes.

Section maybe_alloc_extra_bi_part_182 (104 of 299)
==================================================

Deriving specifications
-----------------------

Section `maybe_alloc_extra_bi_part_182` consists of 16 instructions.


Stack analysis
---------------

No stack accesses found. Code for `maybe_alloc_extra_bi_part_182`:

    0xe000031c     0x0    movw r1, #46848 
    0xe0000320     0x4    movt r1, #57345 
    0xe0000324     0x8    mov r3, #1
    0xe0000328     0xc    ldr ip, [r1, #136] 
    0xe000032c    0x10    lsl r0, r3, r0
    0xe0000330    0x14    cmp r0, #0
    0xe0000334    0x18    add r3, ip, r0
    0xe0000338    0x1c    str r3, [r1, #136] 
    0xe000033c    0x20    mov r3, ip
    0xe0000340    0x24    beq e0000354 <maybe_alloc_extra_bi.part.182+0x38>
    0xe0000344    0x28    mov r2, #0
    0xe0000348    0x2c    subs r0, r0, #4
    0xe000034c    0x30    str r2, [r3], #4
    0xe0000350    0x34    bne e0000348 <maybe_alloc_extra_bi.part.182+0x2c>
    0xe0000354    0x38    str ip, [r1, #164] 
    0xe0000358    0x3c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maybe_alloc_extra_bi_part_182` has 25 nodes.

Section calculate_extra_bi_size_bits_part_160 (105 of 299)
==========================================================

Deriving specifications
-----------------------

Section `calculate_extra_bi_size_bits_part_160` consists of 11 instructions.
 CMP (reg-shift).....+++++
 RSBHI (imm)....+++


Stack analysis
---------------

No stack accesses found. Code for `calculate_extra_bi_size_bits_part_160`:

    0xe00002f0     0x0    sub r3, r0, #1
    0xe00002f4     0x4    mov r1, #1
    0xe00002f8     0x8    bic r3, r3, #4080 
    0xe00002fc     0xc    bic r3, r3, #15
    0xe0000300    0x10    add r3, r3, #4096 
    0xe0000304    0x14    clz r3, r3
    0xe0000308    0x18    rsb r2, r3, #31
    0xe000030c    0x1c    cmp r0, r1, lsl r2
    0xe0000310    0x20    rsbhi r2, r3, #32
    0xe0000314    0x24    mov r0, r2
    0xe0000318    0x28    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `calculate_extra_bi_size_bits_part_160` has 14 nodes.

Section merge_regions (106 of 299)
==================================

Deriving specifications
-----------------------

Section `merge_regions` consists of 36 instructions.
 LDMIACS (wb);15,5,4..++
+


Stack analysis
---------------

2 stack accesses found. Annotated code for `merge_regions`:

    0xe0000260     0x0    push {r4, r5, lr}     ; stack access
    0xe0000264     0x4    movw lr, #46848 
    0xe0000268     0x8    movt lr, #57345 
    0xe000026c     0xc    mov r2, #1
    0xe0000270    0x10    ldr r4, [lr, #88] 
    0xe0000274    0x14    b e000027c <merge_regions+0x1c>
    0xe0000278    0x18    mov r2, r0
    0xe000027c    0x1c    cmp r2, r4
    0xe0000280    0x20    popcs {r4, r5, pc}    ; stack access
    0xe0000284    0x24    sub r3, r2, #1
    0xe0000288    0x28    ldr r1, [lr, r2, lsl #3]
    0xe000028c    0x2c    add r0, r2, #1
    0xe0000290    0x30    add r3, lr, r3, lsl #3
    0xe0000294    0x34    ldr ip, [r3, #4]
    0xe0000298    0x38    cmp ip, r1
    0xe000029c    0x3c    bne e0000278 <merge_regions+0x18>
    0xe00002a0    0x40    lsl r1, r2, #3
    0xe00002a4    0x44    cmp r0, r4
    0xe00002a8    0x48    add r0, lr, r1
    0xe00002ac    0x4c    ldr r0, [r0, #4]
    0xe00002b0    0x50    str r0, [r3, #4]
    0xe00002b4    0x54    bcs e00002e0 <merge_regions+0x80>
    0xe00002b8    0x58    sub r5, r4, #-536870911 
    0xe00002bc    0x5c    mov r3, r1
    0xe00002c0    0x60    lsl r5, r5, #3
    0xe00002c4    0x64    add ip, lr, r3
    0xe00002c8    0x68    add r3, r3, #8
    0xe00002cc    0x6c    add r1, ip, #8
    0xe00002d0    0x70    cmp r5, r3
    0xe00002d4    0x74    ldm r1, {r0, r1}
    0xe00002d8    0x78    stm ip, {r0, r1}
    0xe00002dc    0x7c    bne e00002c4 <merge_regions+0x64>
    0xe00002e0    0x80    sub r4, r4, #1
    0xe00002e4    0x84    mov r0, r2
    0xe00002e8    0x88    str r4, [lr, #88] 
    0xe00002ec    0x8c    b e0000278 <merge_regions+0x18>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
36 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `merge_regions` has 55 nodes.

Section cpu_iface_init (107 of 299)
===================================

Deriving specifications
-----------------------

Section `cpu_iface_init` consists of 35 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `cpu_iface_init`:

    0xe00001d4     0x0    movw r2, #4351 
    0xe00001d8     0x4    movw r3, #8703 
    0xe00001dc     0x8    movt r2, #65520 
    0xe00001e0     0xc    movt r3, #65520 
    0xe00001e4    0x10    push {r4, lr}         ; stack access
    0xe00001e8    0x14    mvn r1, #0
    0xe00001ec    0x18    mov ip, #0
    0xe00001f0    0x1c    str r1, [r2, #129] 
    0xe00001f4    0x20    mov r4, #240 
    0xe00001f8    0x24    str r1, [r2, #385] 
    0xe00001fc    0x28    mov lr, #3
    0xe0000200    0x2c    str ip, [r2, #-127] 
    0xe0000204    0x30    str ip, [r2, #769] 
    0xe0000208    0x34    movw r0, #1023 
    0xe000020c    0x38    str r1, [r2, #3601] 
    0xe0000210    0x3c    str r1, [r2, #3605] 
    0xe0000214    0x40    str r1, [r2, #3609] 
    0xe0000218    0x44    str r1, [r2, #3613] 
    0xe000021c    0x48    str ip, [r3, #-255] 
    0xe0000220    0x4c    str r4, [r3, #-251] 
    0xe0000224    0x50    str lr, [r3, #-247] 
    0xe0000228    0x54    ldr r2, [r3, #-243] 
    0xe000022c    0x58    ubfx r1, r2, #0, #10
    0xe0000230    0x5c    cmp r1, r0
    0xe0000234    0x60    beq e000024c <cpu_iface_init+0x78>
    0xe0000238    0x64    str r2, [r3, #-239] 
    0xe000023c    0x68    ldr r2, [r3, #-243] 
    0xe0000240    0x6c    ubfx r1, r2, #0, #10
    0xe0000244    0x70    cmp r1, r0
    0xe0000248    0x74    bne e0000238 <cpu_iface_init+0x64>
    0xe000024c    0x78    movw r3, #8703 
    0xe0000250    0x7c    movt r3, #65520 
    0xe0000254    0x80    mov r2, #1
    0xe0000258    0x84    str r2, [r3, #-255] 
    0xe000025c    0x88    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cpu_iface_init` has 56 nodes.

Section dist_init (108 of 299)
==============================

Deriving specifications
-----------------------

Section `dist_init` consists of 93 instructions.
 ORRS (reg)..........+++++


Stack analysis
---------------

No stack accesses found. Code for `dist_init`:

    0xe0000060      0x0    movw r3, #4351 
    0xe0000064      0x4    movt r3, #65520 
    0xe0000068      0x8    mov ip, #0
    0xe000006c      0xc    mvn r0, #0
    0xe0000070     0x10    ldr r2, [r3, #-251] 
    0xe0000074     0x14    mov r1, ip
    0xe0000078     0x18    str ip, [r3, #-255] 
    0xe000007c     0x1c    and r2, r2, #31
    0xe0000080     0x20    add r2, r2, #1
    0xe0000084     0x24    lsl r2, r2, #5
    0xe0000088     0x28    lsr r3, r1, #5
    0xe000008c     0x2c    add r1, r1, #32
    0xe0000090     0x30    cmp r2, r1
    0xe0000094     0x34    lsl r3, r3, #2
    0xe0000098     0x38    sub r3, r3, #1044480 
    0xe000009c     0x3c    str r0, [r3, #384] 
    0xe00000a0     0x40    str r0, [r3, #640] 
    0xe00000a4     0x44    bhi e0000088 <dist_init+0x28>
    0xe00000a8     0x48    cmp r2, #32
    0xe00000ac     0x4c    beq e00000dc <dist_init+0x7c>
    0xe00000b0     0x50    movw r0, #4351 
    0xe00000b4     0x54    movt r0, #65520 
    0xe00000b8     0x58    mov r1, #32
    0xe00000bc     0x5c    mov ip, #0
    0xe00000c0     0x60    bic r3, r1, #3
    0xe00000c4     0x64    add r1, r1, #4
    0xe00000c8     0x68    add r3, r3, #1024 
    0xe00000cc     0x6c    cmp r2, r1
    0xe00000d0     0x70    add r3, r0, r3
    0xe00000d4     0x74    str ip, [r3, #-255] 
    0xe00000d8     0x78    bhi e00000c0 <dist_init+0x60>
    0xe00000dc     0x7c    movw r0, #4351 
    0xe00000e0     0x80    movt r0, #65520 
    0xe00000e4     0x84    mov r1, #0
    0xe00000e8     0x88    bic r3, r1, #3
    0xe00000ec     0x8c    add r1, r1, #4
    0xe00000f0     0x90    add r3, r3, #2048 
    0xe00000f4     0x94    add r3, r0, r3
    0xe00000f8     0x98    ldr r3, [r3, #-255] 
    0xe00000fc     0x9c    orr r3, r3, r3, lsr #16
    0xe0000100     0xa0    orrs r3, r3, r3, lsr #8
    0xe0000104     0xa4    bne e00001b0 <dist_init+0x150>
    0xe0000108     0xa8    cmp r2, r1
    0xe000010c     0xac    bhi e00000e8 <dist_init+0x88>
    0xe0000110     0xb0    movw r3, #257 
    0xe0000114     0xb4    movt r3, #257 
    0xe0000118     0xb8    movw ip, #4351 
    0xe000011c     0xbc    movt ip, #65520 
    0xe0000120     0xc0    mov r0, #0
    0xe0000124     0xc4    bic r1, r0, #3
    0xe0000128     0xc8    add r0, r0, #4
    0xe000012c     0xcc    add r1, r1, #2048 
    0xe0000130     0xd0    cmp r2, r0
    0xe0000134     0xd4    add r1, ip, r1
    0xe0000138     0xd8    str r3, [r1, #-255] 
    0xe000013c     0xdc    bhi e0000124 <dist_init+0xc4>
    0xe0000140     0xe0    cmp r2, #64 
    0xe0000144     0xe4    bls e0000178 <dist_init+0x118>
    0xe0000148     0xe8    movw ip, #4351 
    0xe000014c     0xec    movw r0, #21845 
    0xe0000150     0xf0    movt ip, #65520 
    0xe0000154     0xf4    movt r0, #21845 
    0xe0000158     0xf8    mov r1, #64 
    0xe000015c     0xfc    lsr r3, r1, #5
    0xe0000160    0x100    add r1, r1, #32
    0xe0000164    0x104    add r3, r3, #768 
    0xe0000168    0x108    cmp r2, r1
    0xe000016c    0x10c    add r3, ip, r3, lsl #2
    0xe0000170    0x110    str r0, [r3, #-255] 
    0xe0000174    0x114    bhi e000015c <dist_init+0xfc>
    0xe0000178    0x118    mov r1, #0
    0xe000017c    0x11c    movw r0, #4351 
    0xe0000180    0x120    movt r0, #65520 
    0xe0000184    0x124    mov ip, r1
    0xe0000188    0x128    lsr r3, r1, #5
    0xe000018c    0x12c    add r1, r1, #32
    0xe0000190    0x130    add r3, r3, #32
    0xe0000194    0x134    cmp r2, r1
    0xe0000198    0x138    add r3, r0, r3, lsl #2
    0xe000019c    0x13c    str ip, [r3, #-255] 
    0xe00001a0    0x140    bhi e0000188 <dist_init+0x128>
    0xe00001a4    0x144    mov r3, #1
    0xe00001a8    0x148    str r3, [r0, #-255] 
    0xe00001ac    0x14c    bx lr
    0xe00001b0    0x150    lsl r0, r3, #8
    0xe00001b4    0x154    uxtb r1, r3
    0xe00001b8    0x158    orr r1, r1, r3, lsl #24
    0xe00001bc    0x15c    lsl r3, r3, #16
    0xe00001c0    0x160    uxth r0, r0
    0xe00001c4    0x164    and r3, r3, #16711680 
    0xe00001c8    0x168    orr r1, r1, r0
    0xe00001cc    0x16c    orr r3, r1, r3
    0xe00001d0    0x170    b e0000118 <dist_init+0xb8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
93 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `dist_init` has 122 nodes.

Section initIRQController (109 of 299)
======================================

Deriving specifications
-----------------------

Section `initIRQController` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `initIRQController`:

    0xe0000a98    0x0    b e0000060 <dist_init>

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `initIRQController` has 2 nodes.

Section cpu_initLocalIRQController (110 of 299)
===============================================

Deriving specifications
-----------------------

Section `cpu_initLocalIRQController` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `cpu_initLocalIRQController`:

    0xe0000a9c    0x0    b e00001d4 <cpu_iface_init>

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cpu_initLocalIRQController` has 2 nodes.

Section arm_reset_exception (111 of 299)
========================================

Deriving specifications
-----------------------

Section `arm_reset_exception` consists of 1 instructions.
 BL.+


Stack analysis
---------------

No stack accesses found. Code for `arm_reset_exception`:

    0xe0010110    0x0    bl e0010a3c <halt>

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_reset_exception` has 2 nodes.

Section invokeCNodeRevoke (112 of 299)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeRevoke` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `invokeCNodeRevoke`:

    0xe0016d48    0x0    b e0016cc0 <cteRevoke>

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeRevoke` has 2 nodes.

Section deletingIRQHandler (113 of 299)
=======================================

Deriving specifications
-----------------------

Section `deletingIRQHandler` consists of 1 instructions.


Stack analysis
---------------

No stack accesses found. Code for `deletingIRQHandler`:

    0xe0017970    0x0    b e0017960 <invokeIRQHandler_ClearIRQHandler>

Proving inst theorems
---------------------

1 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deletingIRQHandler` has 2 nodes.

Section str_to_long (114 of 299)
================================

Deriving specifications
-----------------------

Section `str_to_long` consists of 31 instructions.
 CMN (imm)..+
 CMPNE (reg)......+++
 MLA...............+++++++++++++++
 LDRBEQ (+imm,pre)...+++
 ADDEQ (imm)....+++


Stack analysis
---------------

3 stack accesses found. Annotated code for `str_to_long`:

    0xe001b34c     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe001b350     0x4    mov r4, r0
    0xe001b354     0x8    ldrb r0, [r0]
    0xe001b358     0xc    cmp r0, #48 
    0xe001b35c    0x10    movne r5, #10
    0xe001b360    0x14    beq e001b3a4 <str_to_long+0x58>
    0xe001b364    0x18    cmp r0, #0
    0xe001b368    0x1c    beq e001b398 <str_to_long+0x4c>
    0xe001b36c    0x20    mov r1, #0
    0xe001b370    0x24    bl e001b30c <char_to_long>
    0xe001b374    0x28    cmn r0, #1
    0xe001b378    0x2c    cmpne r0, r5
    0xe001b37c    0x30    mla r1, r5, r1, r0
    0xe001b380    0x34    bcs e001b398 <str_to_long+0x4c>
    0xe001b384    0x38    ldrb r0, [r4, #1]!
    0xe001b388    0x3c    cmp r0, #0
    0xe001b38c    0x40    bne e001b370 <str_to_long+0x24>
    0xe001b390    0x44    mov r0, r1
    0xe001b394    0x48    pop {r4, r5, r6, pc}  ; stack access
    0xe001b398    0x4c    mvn r1, #0
    0xe001b39c    0x50    mov r0, r1
    0xe001b3a0    0x54    pop {r4, r5, r6, pc}  ; stack access
    0xe001b3a4    0x58    ldrb r3, [r4, #1]
    0xe001b3a8    0x5c    and r3, r3, #223 
    0xe001b3ac    0x60    cmp r3, #88 
    0xe001b3b0    0x64    ldrbeq r0, [r4, #2]
    0xe001b3b4    0x68    moveq r5, #16
    0xe001b3b8    0x6c    addeq r4, r4, #2
    0xe001b3bc    0x70    beq e001b364 <str_to_long+0x18>
    0xe001b3c0    0x74    mov r5, #10
    0xe001b3c4    0x78    b e001b36c <str_to_long+0x20>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
31 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `str_to_long` has 59 nodes.

Section setMRs_syscall_error (115 of 299)
=========================================

Deriving specifications
-----------------------

Section `setMRs_syscall_error` consists of 80 instructions.
Switch found.


Stack analysis
---------------

11 stack accesses found. Annotated code for `setMRs_syscall_error`:

    0xe001a2d0      0x0    movw r2, #36896 
    0xe001a2d4      0x4    movt r2, #57346 
    0xe001a2d8      0x8    push {r4, lr}         ; stack access
    0xe001a2dc      0xc    mov ip, r0
    0xe001a2e0     0x10    ldr r3, [r2, #24]
    0xe001a2e4     0x14    sub r3, r3, #1
    0xe001a2e8     0x18    cmp r3, #9
    0xe001a2ec     0x1c    ldrls pc, [pc, r3, lsl #2]
    0xe001a2f0     0x20    b e001a40c <setMRs_syscall_error+0x13c>
    0xe001a2f4     0x24    .word 0xe001a368
    0xe001a2f8     0x28    .word 0xe001a378
    0xe001a2fc     0x2c    .word 0xe001a388
    0xe001a300     0x30    .word 0xe001a390
    0xe001a304     0x34    .word 0xe001a388
    0xe001a308     0x38    .word 0xe001a31c
    0xe001a30c     0x3c    .word 0xe001a388
    0xe001a310     0x40    .word 0xe001a388
    0xe001a314     0x44    .word 0xe001a388
    0xe001a318     0x48    .word 0xe001a3a8
    0xe001a31c     0x4c    movw r3, #36884 
    0xe001a320     0x50    movt r3, #57346 
    0xe001a324     0x54    ldr r0, [r2, #20]
    0xe001a328     0x58    ldr r2, [r3]
    0xe001a32c     0x5c    adds r0, r0, #0
    0xe001a330     0x60    ldr lr, [r3, #4]
    0xe001a334     0x64    and r3, r2, #3
    0xe001a338     0x68    movne r0, #1
    0xe001a33c     0x6c    cmp r3, #2
    0xe001a340     0x70    str r0, [ip, #8]
    0xe001a344     0x74    add r0, r3, #1
    0xe001a348     0x78    str r0, [ip, #12]
    0xe001a34c     0x7c    beq e001a3b8 <setMRs_syscall_error+0xe8>
    0xe001a350     0x80    cmp r3, #3
    0xe001a354     0x84    beq e001a3e0 <setMRs_syscall_error+0x110>
    0xe001a358     0x88    cmp r3, #1
    0xe001a35c     0x8c    beq e001a3d0 <setMRs_syscall_error+0x100>
    0xe001a360     0x90    mov r0, #2
    0xe001a364     0x94    pop {r4, pc}          ; stack access
    0xe001a368     0x98    ldr r3, [r2]
    0xe001a36c     0x9c    mov r0, #1
    0xe001a370     0xa0    str r3, [ip, #8]
    0xe001a374     0xa4    pop {r4, pc}          ; stack access
    0xe001a378     0xa8    ldr r3, [r2, #4]
    0xe001a37c     0xac    mov r0, #1
    0xe001a380     0xb0    str r3, [ip, #8]
    0xe001a384     0xb4    pop {r4, pc}          ; stack access
    0xe001a388     0xb8    mov r0, #0
    0xe001a38c     0xbc    pop {r4, pc}          ; stack access
    0xe001a390     0xc0    ldr r3, [r2, #12]
    0xe001a394     0xc4    mov r0, #2
    0xe001a398     0xc8    ldr r1, [r2, #8]
    0xe001a39c     0xcc    str r3, [ip, #12]
    0xe001a3a0     0xd0    str r1, [ip, #8]
    0xe001a3a4     0xd4    pop {r4, pc}          ; stack access
    0xe001a3a8     0xd8    ldr r3, [r2, #16]
    0xe001a3ac     0xdc    mov r0, #1
    0xe001a3b0     0xe0    str r3, [ip, #8]
    0xe001a3b4     0xe4    pop {r4, pc}          ; stack access
    0xe001a3b8     0xe8    ubfx r3, r2, #2, #6
    0xe001a3bc     0xec    mov r0, #4
    0xe001a3c0     0xf0    ubfx r2, r2, #8, #6
    0xe001a3c4     0xf4    str r3, [ip, #16]
    0xe001a3c8     0xf8    str r2, [ip, #20]
    0xe001a3cc     0xfc    pop {r4, pc}          ; stack access
    0xe001a3d0    0x100    ubfx r2, r2, #2, #6
    0xe001a3d4    0x104    mov r0, #3
    0xe001a3d8    0x108    str r2, [ip, #16]
    0xe001a3dc    0x10c    pop {r4, pc}          ; stack access
    0xe001a3e0    0x110    cmp r1, #0
    0xe001a3e4    0x114    ubfx r3, r2, #8, #6
    0xe001a3e8    0x118    str lr, [ip, #20]
    0xe001a3ec    0x11c    str r3, [ip, #16]
    0xe001a3f0    0x120    beq e001a404 <setMRs_syscall_error+0x134>
    0xe001a3f4    0x124    ubfx r2, r2, #2, #6
    0xe001a3f8    0x128    mov r0, #5
    0xe001a3fc    0x12c    str r2, [r1, #20]
    0xe001a400    0x130    pop {r4, pc}          ; stack access
    0xe001a404    0x134    mov r0, #4
    0xe001a408    0x138    pop {r4, pc}          ; stack access
    0xe001a40c    0x13c    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
70 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMRs_syscall_error` has 145 nodes.

Section invokeTCB_NotificationControl (116 of 299)
==================================================

Deriving specifications
-----------------------

Section `invokeTCB_NotificationControl` consists of 15 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_NotificationControl`:

    0xe001a294     0x0    cmp r1, #0
    0xe001a298     0x4    beq e001a2c0 <invokeTCB_NotificationControl+0x2c>
    0xe001a29c     0x8    ldr r3, [r1, #12]
    0xe001a2a0     0xc    mov r2, r0
    0xe001a2a4    0x10    bic r0, r0, #15
    0xe001a2a8    0x14    and r3, r3, #15
    0xe001a2ac    0x18    orr r3, r3, r0
    0xe001a2b0    0x1c    mov r0, #0
    0xe001a2b4    0x20    str r3, [r1, #12]
    0xe001a2b8    0x24    str r1, [r2, #92] 
    0xe001a2bc    0x28    bx lr
    0xe001a2c0    0x2c    push {r4, lr}         ; stack access
    0xe001a2c4    0x30    bl e0010908 <invokeTCB_NotificationControl.part.179>
    0xe001a2c8    0x34    mov r0, #0
    0xe001a2cc    0x38    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_NotificationControl` has 24 nodes.

Section invokeTCB_Resume (117 of 299)
=====================================

Deriving specifications
-----------------------

Section `invokeTCB_Resume` consists of 4 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_Resume`:

    0xe0018d50    0x0    push {r4, lr}         ; stack access
    0xe0018d54    0x4    bl e0017514 <restart>
    0xe0018d58    0x8    mov r0, #0
    0xe0018d5c    0xc    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_Resume` has 7 nodes.

Section invokeTCB_Suspend (118 of 299)
======================================

Deriving specifications
-----------------------

Section `invokeTCB_Suspend` consists of 4 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `invokeTCB_Suspend`:

    0xe0018d40    0x0    push {r4, lr}         ; stack access
    0xe0018d44    0x4    bl e00167b4 <suspend>
    0xe0018d48    0x8    mov r0, #0
    0xe0018d4c    0xc    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_Suspend` has 7 nodes.

Section performInvocation_Endpoint (119 of 299)
===============================================

Deriving specifications
-----------------------

Section `performInvocation_Endpoint` consists of 16 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `performInvocation_Endpoint`:

    0xe001861c     0x0    push {lr}             ; stack access
    0xe0018620     0x4    movw ip, #13900 
    0xe0018624     0x8    sub sp, sp, #20
    0xe0018628     0xc    movt ip, #57347 
    0xe001862c    0x10    str r3, [sp]          ; stack access
    0xe0018630    0x14    mov r3, r2
    0xe0018634    0x18    ldr ip, [ip]
    0xe0018638    0x1c    mov r2, r1
    0xe001863c    0x20    str r0, [sp, #8]      ; stack access
    0xe0018640    0x24    ldr r1, [sp, #28]     ; stack access
    0xe0018644    0x28    ldr r0, [sp, #24]     ; stack access
    0xe0018648    0x2c    str ip, [sp, #4]      ; stack access
    0xe001864c    0x30    bl e00181f0 <sendIPC>
    0xe0018650    0x34    mov r0, #0
    0xe0018654    0x38    add sp, sp, #20
    0xe0018658    0x3c    pop {pc}              ; stack access

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Endpoint` has 25 nodes.

Section performInvocation_Reply (120 of 299)
============================================

Deriving specifications
-----------------------

Section `performInvocation_Reply` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `performInvocation_Reply`:

    0xe00181c8     0x0    movw ip, #13900 
    0xe00181cc     0x4    movt ip, #57347 
    0xe00181d0     0x8    mov r3, r2
    0xe00181d4     0xc    mov r2, r1
    0xe00181d8    0x10    push {r4, lr}         ; stack access
    0xe00181dc    0x14    mov r1, r0
    0xe00181e0    0x18    ldr r0, [ip]
    0xe00181e4    0x1c    bl e0018080 <doReplyTransfer>
    0xe00181e8    0x20    mov r0, #0
    0xe00181ec    0x24    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Reply` has 14 nodes.

Section lookupExtraCaps (121 of 299)
====================================

Deriving specifications
-----------------------

Section `lookupExtraCaps` consists of 49 instructions.
 STMIA;9,2...+


Stack analysis
---------------

6 stack accesses found. Annotated code for `lookupExtraCaps`:

    0xe0017c8c     0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe0017c90     0x4    subs r5, r1, #0
    0xe0017c94     0x8    sub sp, sp, #12
    0xe0017c98     0xc    beq e0017d28 <lookupExtraCaps+0x9c>
    0xe0017c9c    0x10    ubfx r7, r2, #7, #2
    0xe0017ca0    0x14    cmp r7, #0
    0xe0017ca4    0x18    beq e0017d40 <lookupExtraCaps+0xb4>
    0xe0017ca8    0x1c    movw r6, #36924 
    0xe0017cac    0x20    mov r8, r0
    0xe0017cb0    0x24    add r5, r5, #484 
    0xe0017cb4    0x28    movt r6, #57346 
    0xe0017cb8    0x2c    mov r4, #0
    0xe0017cbc    0x30    b e0017cd4 <lookupExtraCaps+0x48>
    0xe0017cc0    0x34    ldr r3, [sp, #4]      ; stack access
    0xe0017cc4    0x38    str r3, [r6, r4, lsl #2]
    0xe0017cc8    0x3c    add r4, r4, #1
    0xe0017ccc    0x40    cmp r4, r7
    0xe0017cd0    0x44    beq e0017d10 <lookupExtraCaps+0x84>
    0xe0017cd4    0x48    ldr r9, [r5, #4]!
    0xe0017cd8    0x4c    mov r0, sp
    0xe0017cdc    0x50    mov r1, r8
    0xe0017ce0    0x54    mov r2, r9
    0xe0017ce4    0x58    bl e0012d38 <lookupSlot>
    0xe0017ce8    0x5c    ldr r0, [sp]          ; stack access
    0xe0017cec    0x60    mov r2, r6
    0xe0017cf0    0x64    cmp r0, #0
    0xe0017cf4    0x68    beq e0017cc0 <lookupExtraCaps+0x34>
    0xe0017cf8    0x6c    movw r3, #32768 
    0xe0017cfc    0x70    movt r3, #57346 
    0xe0017d00    0x74    mov r2, #1
    0xe0017d04    0x78    stm r3, {r2, r9}
    0xe0017d08    0x7c    add sp, sp, #12
    0xe0017d0c    0x80    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0017d10    0x84    cmp r4, #3
    0xe0017d14    0x88    beq e0017d08 <lookupExtraCaps+0x7c>
    0xe0017d18    0x8c    mov r0, #0
    0xe0017d1c    0x90    str r0, [r2, r4, lsl #2]
    0xe0017d20    0x94    add sp, sp, #12
    0xe0017d24    0x98    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0017d28    0x9c    movw r3, #36924 
    0xe0017d2c    0xa0    movt r3, #57346 
    0xe0017d30    0xa4    mov r0, r5
    0xe0017d34    0xa8    str r5, [r3]
    0xe0017d38    0xac    add sp, sp, #12
    0xe0017d3c    0xb0    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0017d40    0xb4    movw r2, #36924 
    0xe0017d44    0xb8    mov r4, r7
    0xe0017d48    0xbc    movt r2, #57346 
    0xe0017d4c    0xc0    b e0017d18 <lookupExtraCaps+0x8c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
49 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupExtraCaps` has 71 nodes.

Section deleteCallerCap (122 of 299)
====================================

Deriving specifications
-----------------------

Section `deleteCallerCap` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `deleteCallerCap`:

    0xe0017c7c    0x0    bic r0, r0, #508 
    0xe0017c80    0x4    bic r0, r0, #3
    0xe0017c84    0x8    add r0, r0, #48 
    0xe0017c88    0xc    b e00173d0 <cteDeleteOne>

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteCallerCap` has 5 nodes.

Section invokeIRQHandler_ClearIRQHandler (123 of 299)
=====================================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_ClearIRQHandler` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `invokeIRQHandler_ClearIRQHandler`:

    0xe0017960    0x0    movw r3, #8192 
    0xe0017964    0x4    movt r3, #57347 
    0xe0017968    0x8    add r0, r3, r0, lsl #4
    0xe001796c    0xc    b e00173d0 <cteDeleteOne>

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_ClearIRQHandler` has 5 nodes.

Section performInvocation_Notification (124 of 299)
===================================================

Deriving specifications
-----------------------

Section `performInvocation_Notification` consists of 4 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `performInvocation_Notification`:

    0xe0017910    0x0    push {r4, lr}         ; stack access
    0xe0017914    0x4    bl e00175d8 <sendSignal>
    0xe0017918    0x8    mov r0, #0
    0xe001791c    0xc    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performInvocation_Notification` has 7 nodes.

Section invokeCNodeDelete (125 of 299)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeDelete` consists of 2 instructions.


Stack analysis
---------------

No stack accesses found. Code for `invokeCNodeDelete`:

    0xe0016cb8    0x0    mov r1, #1
    0xe0016cbc    0x4    b e0016a68 <cteDelete>

Proving inst theorems
---------------------

2 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeDelete` has 3 nodes.

Section scheduleChooseNewThread (126 of 299)
============================================

Deriving specifications
-----------------------

Section `scheduleChooseNewThread` consists of 27 instructions.
 STRHI (+imm,pre)....+++
 MOVWLS..++
 MOVTLS..++
 ADDLS (reg)...........++++++
 LDRLS (+imm,pre)...+++


Stack analysis
---------------

No stack accesses found. Code for `scheduleChooseNewThread`:

    0xe001653c     0x0    movw r3, #5324 
    0xe0016540     0x4    movt r3, #57347 
    0xe0016544     0x8    ldr r2, [r3]
    0xe0016548     0xc    cmp r2, #0
    0xe001654c    0x10    bne e00165a4 <scheduleChooseNewThread+0x68>
    0xe0016550    0x14    movw r1, #13904 
    0xe0016554    0x18    movt r1, #57347 
    0xe0016558    0x1c    ldr r0, [r1]
    0xe001655c    0x20    add r0, r0, #1
    0xe0016560    0x24    str r0, [r1]
    0xe0016564    0x28    cmp r0, #2
    0xe0016568    0x2c    strhi r2, [r1]
    0xe001656c    0x30    movw r1, #12804 
    0xe0016570    0x34    movt r1, #57347 
    0xe0016574    0x38    movwls r2, #46024 
    0xe0016578    0x3c    movtls r2, #57345 
    0xe001657c    0x40    addls r0, r2, r0, lsl #3
    0xe0016580    0x44    movhi ip, #15
    0xe0016584    0x48    ldrls r2, [r0, #112] 
    0xe0016588    0x4c    ldrls ip, [r0, #116] 
    0xe001658c    0x50    movw r0, #12288 
    0xe0016590    0x54    movt r0, #57347 
    0xe0016594    0x58    str ip, [r3]
    0xe0016598    0x5c    mov r3, #0
    0xe001659c    0x60    str r2, [r0]
    0xe00165a0    0x64    str r3, [r1]
    0xe00165a4    0x68    b e0016488 <chooseThread>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `scheduleChooseNewThread` has 53 nodes.

Section tcbSchedAppend (127 of 299)
===================================

Deriving specifications
-----------------------

Section `tcbSchedAppend` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `tcbSchedAppend`:

    0xe0016374    0x0    ldr r3, [r0, #84] 
    0xe0016378    0x4    tst r3, #1
    0xe001637c    0x8    bxne lr
    0xe0016380    0xc    b e0010870 <tcbSchedAppend.part.171>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedAppend` has 9 nodes.

Section tcbSchedEnqueue (128 of 299)
====================================

Deriving specifications
-----------------------

Section `tcbSchedEnqueue` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `tcbSchedEnqueue`:

    0xe0016364    0x0    ldr r3, [r0, #84] 
    0xe0016368    0x4    tst r3, #1
    0xe001636c    0x8    bxne lr
    0xe0016370    0xc    b e00107d8 <tcbSchedEnqueue.part.164>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `tcbSchedEnqueue` has 9 nodes.

Section createObject (129 of 299)
=================================

Deriving specifications
-----------------------

Section `createObject` consists of 72 instructions.
Switch found.
 STMIA;14,3...+


Stack analysis
---------------

Section `createObject` expects pointer to stack in r0.
19 stack accesses found. Annotated code for `createObject`:

    0xe0016168      0x0    cmp r1, #4
    0xe001616c      0x4    push {r4, r5, lr}     ; stack access
    0xe0016170      0x8    mov r4, r0
    0xe0016174      0xc    sub sp, sp, #12
    0xe0016178     0x10    bhi e00161a0 <createObject+0x38>
    0xe001617c     0x14    sub ip, r1, #1
    0xe0016180     0x18    mov r5, r3
    0xe0016184     0x1c    cmp ip, #3
    0xe0016188     0x20    ldrls pc, [pc, ip, lsl #2]
    0xe001618c     0x24    b e00161d8 <createObject+0x70>
    0xe0016190     0x28    .word 0xe0016208
    0xe0016194     0x2c    .word 0xe001624c
    0xe0016198     0x30    .word 0xe00161b8
    0xe001619c     0x34    .word 0xe0016264
    0xe00161a0     0x38    ldr ip, [sp, #24]     ; stack access
    0xe00161a4     0x3c    str ip, [sp]          ; stack access
    0xe00161a8     0x40    bl e0011eb0 <Arch_createObject>
    0xe00161ac     0x44    mov r0, r4
    0xe00161b0     0x48    add sp, sp, #12
    0xe00161b4     0x4c    pop {r4, r5, pc}      ; stack access
    0xe00161b8     0x50    bic lr, r2, #15
    0xe00161bc     0x54    mov r3, #3
    0xe00161c0     0x58    orr lr, lr, #6
    0xe00161c4     0x5c    str r3, [r0, #4]      ; stack access
    0xe00161c8     0x60    str lr, [r0]          ; stack access
    0xe00161cc     0x64    mov r0, r4
    0xe00161d0     0x68    add sp, sp, #12
    0xe00161d4     0x6c    pop {r4, r5, pc}      ; stack access
    0xe00161d8     0x70    ldr r3, [sp, #24]     ; stack access
    0xe00161dc     0x74    bic lr, r2, #15
    0xe00161e0     0x78    and r5, r5, #31
    0xe00161e4     0x7c    orr lr, lr, #2
    0xe00161e8     0x80    adds r3, r3, #0
    0xe00161ec     0x84    str lr, [r0]          ; stack access
    0xe00161f0     0x88    movne r3, #1
    0xe00161f4     0x8c    orr r5, r5, r3, lsl #5
    0xe00161f8     0x90    str r5, [r0, #4]      ; stack access
    0xe00161fc     0x94    mov r0, r4
    0xe0016200     0x98    add sp, sp, #12
    0xe0016204     0x9c    pop {r4, r5, pc}      ; stack access
    0xe0016208     0xa0    movw r3, #12288 
    0xe001620c     0xa4    movt r3, #57347 
    0xe0016210     0xa8    add lr, r2, #256 
    0xe0016214     0xac    mov r1, #336 
    0xe0016218     0xb0    ldr r2, [r3]
    0xe001621c     0xb4    bic r3, lr, #15
    0xe0016220     0xb8    str r1, [lr, #64] 
    0xe0016224     0xbc    orr r3, r3, #12
    0xe0016228     0xc0    mov r1, #5
    0xe001622c     0xc4    str r3, [r0]          ; stack access
    0xe0016230     0xc8    str r2, [lr, #112] 
    0xe0016234     0xcc    mov r2, #0
    0xe0016238     0xd0    str r1, [lr, #124] 
    0xe001623c     0xd4    str r2, [r0, #4]      ; stack access
    0xe0016240     0xd8    mov r0, r4
    0xe0016244     0xdc    add sp, sp, #12
    0xe0016248     0xe0    pop {r4, r5, pc}      ; stack access
    0xe001624c     0xe4    orr lr, r2, #15
    0xe0016250     0xe8    mov r3, #4
    0xe0016254     0xec    stm r0, {r3, lr}      ; stack access
    0xe0016258     0xf0    mov r0, r4
    0xe001625c     0xf4    add sp, sp, #12
    0xe0016260     0xf8    pop {r4, r5, pc}      ; stack access
    0xe0016264     0xfc    bic lr, r2, #31
    0xe0016268    0x100    lsl r5, r3, #18
    0xe001626c    0x104    orr lr, lr, #10
    0xe0016270    0x108    and r5, r5, #8126464 
    0xe0016274    0x10c    str lr, [r0]          ; stack access
    0xe0016278    0x110    str r5, [r0, #4]      ; stack access
    0xe001627c    0x114    mov r0, r4
    0xe0016280    0x118    add sp, sp, #12
    0xe0016284    0x11c    pop {r4, r5, pc}      ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
68 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `createObject` has 109 nodes.

Section Arch_decodeInvocation (130 of 299)
==========================================

Deriving specifications
-----------------------

Section `Arch_decodeInvocation` consists of 11 instructions.
 LDMIA (wb);14,7,6,5,4.+


Stack analysis
---------------

4 stack accesses found. Annotated code for `Arch_decodeInvocation`:

    0xe0015e50     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0015e54     0x4    mov r4, r0
    0xe0015e58     0x8    ldr r6, [sp, #44]     ; stack access
    0xe0015e5c     0xc    mov r5, r1
    0xe0015e60    0x10    mov r7, r2
    0xe0015e64    0x14    mov r1, r5
    0xe0015e68    0x18    mov r2, r7
    0xe0015e6c    0x1c    mov r0, r4
    0xe0015e70    0x20    str r6, [sp, #40]     ; stack access
    0xe0015e74    0x24    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0015e78    0x28    b e0014df4 <decodeARMMMUInvocation>

Proving inst theorems
---------------------

11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeInvocation` has 16 nodes.

Section slotCapLongRunningDelete (131 of 299)
=============================================

Deriving specifications
-----------------------

Section `slotCapLongRunningDelete` consists of 21 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `slotCapLongRunningDelete`:

    0xe0014da0     0x0    push {r4, lr}         ; stack access
    0xe0014da4     0x4    ldr r4, [r0]
    0xe0014da8     0x8    and r3, r4, #14
    0xe0014dac     0xc    cmp r3, #14
    0xe0014db0    0x10    andne r4, r4, #15
    0xe0014db4    0x14    uxtbeq r4, r4
    0xe0014db8    0x18    cmp r4, #0
    0xe0014dbc    0x1c    beq e0014de4 <slotCapLongRunningDelete+0x44>
    0xe0014dc0    0x20    bl e0014d44 <isFinalCapability>
    0xe0014dc4    0x24    cmp r0, #0
    0xe0014dc8    0x28    popeq {r4, pc}        ; stack access
    0xe0014dcc    0x2c    cmp r4, #12
    0xe0014dd0    0x30    beq e0014dec <slotCapLongRunningDelete+0x4c>
    0xe0014dd4    0x34    cmp r4, #46 
    0xe0014dd8    0x38    beq e0014dec <slotCapLongRunningDelete+0x4c>
    0xe0014ddc    0x3c    cmp r4, #10
    0xe0014de0    0x40    beq e0014dec <slotCapLongRunningDelete+0x4c>
    0xe0014de4    0x44    mov r0, #0
    0xe0014de8    0x48    pop {r4, pc}          ; stack access
    0xe0014dec    0x4c    mov r0, #1
    0xe0014df0    0x50    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `slotCapLongRunningDelete` has 41 nodes.

Section isFinalCapability (132 of 299)
======================================

Deriving specifications
-----------------------

Section `isFinalCapability` consists of 23 instructions.
 LDMIA;3,2...+
+


Stack analysis
---------------

4 stack accesses found. Annotated code for `isFinalCapability`:

    0xe0014d44     0x0    ldr r3, [r0, #8]
    0xe0014d48     0x4    push {r4, lr}         ; stack access
    0xe0014d4c     0x8    bics r1, r3, #7
    0xe0014d50     0xc    mov r4, r0
    0xe0014d54    0x10    beq e0014d6c <isFinalCapability+0x28>
    0xe0014d58    0x14    ldm r0, {r2, r3}
    0xe0014d5c    0x18    ldm r1, {r0, r1}
    0xe0014d60    0x1c    bl e0014c9c <sameObjectAs>
    0xe0014d64    0x20    cmp r0, #0
    0xe0014d68    0x24    bne e0014d98 <isFinalCapability+0x54>
    0xe0014d6c    0x28    ldr r3, [r4, #12]
    0xe0014d70    0x2c    bics r3, r3, #7
    0xe0014d74    0x30    beq e0014d90 <isFinalCapability+0x4c>
    0xe0014d78    0x34    ldm r3, {r2, r3}
    0xe0014d7c    0x38    ldm r4, {r0, r1}
    0xe0014d80    0x3c    bl e0014c9c <sameObjectAs>
    0xe0014d84    0x40    clz r0, r0
    0xe0014d88    0x44    lsr r0, r0, #5
    0xe0014d8c    0x48    pop {r4, pc}          ; stack access
    0xe0014d90    0x4c    mov r0, #1
    0xe0014d94    0x50    pop {r4, pc}          ; stack access
    0xe0014d98    0x54    mov r0, #0
    0xe0014d9c    0x58    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isFinalCapability` has 41 nodes.

Section ensureNoChildren (133 of 299)
=====================================

Deriving specifications
-----------------------

Section `ensureNoChildren` consists of 14 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `ensureNoChildren`:

    0xe0014bbc     0x0    ldr r1, [r0, #12]
    0xe0014bc0     0x4    bics r1, r1, #7
    0xe0014bc4     0x8    beq e0014bec <ensureNoChildren+0x30>
    0xe0014bc8     0xc    push {r4, lr}         ; stack access
    0xe0014bcc    0x10    bl e0014b14 <isMDBParentOf>
    0xe0014bd0    0x14    cmp r0, #0
    0xe0014bd4    0x18    movwne r3, #36896 
    0xe0014bd8    0x1c    movtne r3, #57346 
    0xe0014bdc    0x20    movne r2, #9
    0xe0014be0    0x24    movne r0, #3
    0xe0014be4    0x28    strne r2, [r3, #24]
    0xe0014be8    0x2c    pop {r4, pc}          ; stack access
    0xe0014bec    0x30    mov r0, r1
    0xe0014bf0    0x34    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `ensureNoChildren` has 32 nodes.

Section isMDBParentOf (134 of 299)
==================================

Deriving specifications
-----------------------

Section `isMDBParentOf` consists of 42 instructions.
+
 LDMIAEQ (wb);15,6,5,4..++
 EOR (imm)...++


Stack analysis
---------------

5 stack accesses found. Annotated code for `isMDBParentOf`:

    0xe0014b14     0x0    ldr r3, [r0, #12]
    0xe0014b18     0x4    ubfx r3, r3, #1, #1
    0xe0014b1c     0x8    cmp r3, #0
    0xe0014b20     0xc    beq e0014b88 <isMDBParentOf+0x74>
    0xe0014b24    0x10    push {r4, r5, r6, lr}  ; stack access
    0xe0014b28    0x14    mov r5, r1
    0xe0014b2c    0x18    ldm r1, {r2, r3}
    0xe0014b30    0x1c    mov r4, r0
    0xe0014b34    0x20    ldm r0, {r0, r1}
    0xe0014b38    0x24    bl e0014300 <sameRegionAs>
    0xe0014b3c    0x28    cmp r0, #0
    0xe0014b40    0x2c    popeq {r4, r5, r6, pc}  ; stack access
    0xe0014b44    0x30    ldr r3, [r4]
    0xe0014b48    0x34    and r2, r3, #14
    0xe0014b4c    0x38    cmp r2, #14
    0xe0014b50    0x3c    andne r2, r3, #15
    0xe0014b54    0x40    uxtbeq r2, r3
    0xe0014b58    0x44    cmp r2, #4
    0xe0014b5c    0x48    beq e0014b90 <isMDBParentOf+0x7c>
    0xe0014b60    0x4c    cmp r2, #6
    0xe0014b64    0x50    bne e0014bb4 <isMDBParentOf+0xa0>
    0xe0014b68    0x54    ldr r3, [r4, #4]
    0xe0014b6c    0x58    lsrs r3, r3, #4
    0xe0014b70    0x5c    beq e0014bb4 <isMDBParentOf+0xa0>
    0xe0014b74    0x60    ldr r2, [r5, #4]
    0xe0014b78    0x64    cmp r3, r2, lsr #4
    0xe0014b7c    0x68    beq e0014ba4 <isMDBParentOf+0x90>
    0xe0014b80    0x6c    mov r0, #0
    0xe0014b84    0x70    pop {r4, r5, r6, pc}  ; stack access
    0xe0014b88    0x74    mov r0, r3
    0xe0014b8c    0x78    bx lr
    0xe0014b90    0x7c    lsrs r3, r3, #4
    0xe0014b94    0x80    beq e0014bb4 <isMDBParentOf+0xa0>
    0xe0014b98    0x84    ldr r2, [r5]
    0xe0014b9c    0x88    cmp r3, r2, lsr #4
    0xe0014ba0    0x8c    bne e0014b80 <isMDBParentOf+0x6c>
    0xe0014ba4    0x90    ldr r3, [r5, #12]
    0xe0014ba8    0x94    eor r3, r3, #1
    0xe0014bac    0x98    and r0, r3, #1
    0xe0014bb0    0x9c    pop {r4, r5, r6, pc}  ; stack access
    0xe0014bb4    0xa0    mov r0, #1
    0xe0014bb8    0xa4    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
42 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `isMDBParentOf` has 77 nodes.

Section sameRegionAs (135 of 299)
=================================

Deriving specifications
-----------------------

Section `sameRegionAs` consists of 517 instructions.
 STMDB (wb);14,8,7,6,5,4..+
Switch found.
 LDMIA (wb);15,8,7,6,5,4.+
Switch found.
 LDMIA (wb);14,8,7,6,5,4.+
 ADD (reg-shift)...............+++++++++++++++
Switch found.
Switch found.
 ANDLS (imm)....+++
 ANDS (reg-shift)...............+++++++++++++++
Switch found.
Switch found.
Switch found.


Stack analysis
---------------

10 stack accesses found. Annotated code for `sameRegionAs`:

    0xe0014300      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0014304      0x4    sub sp, sp, #16
    0xe0014308      0x8    add ip, sp, #8
    0xe001430c      0xc    mov lr, sp
    0xe0014310     0x10    stm lr, {r2, r3}      ; stack access
    0xe0014314     0x14    and r3, r0, #14
    0xe0014318     0x18    stm ip, {r0, r1}      ; stack access
    0xe001431c     0x1c    cmp r3, #14
    0xe0014320     0x20    mov r1, r0
    0xe0014324     0x24    andne r0, r0, #15
    0xe0014328     0x28    uxtbeq r0, r1
    0xe001432c     0x2c    ldr r4, [sp, #12]     ; stack access
    0xe0014330     0x30    sub r3, r0, #2
    0xe0014334     0x34    ldr r5, [sp, #4]      ; stack access
    0xe0014338     0x38    cmp r3, #60 
    0xe001433c     0x3c    ldrls pc, [pc, r3, lsl #2]
    0xe0014340     0x40    b e00145e8 <sameRegionAs+0x2e8>
    0xe0014344     0x44    .word 0xe0014450
    0xe0014348     0x48    .word 0xe00145e8
    0xe001434c     0x4c    .word 0xe00144a4
    0xe0014350     0x50    .word 0xe00145e8
    0xe0014354     0x54    .word 0xe00144d4
    0xe0014358     0x58    .word 0xe00145e8
    0xe001435c     0x5c    .word 0xe0014504
    0xe0014360     0x60    .word 0xe00145e8
    0xe0014364     0x64    .word 0xe0014534
    0xe0014368     0x68    .word 0xe00145e8
    0xe001436c     0x6c    .word 0xe0014574
    0xe0014370     0x70    .word 0xe00145e8
    0xe0014374     0x74    .word 0xe0014590
    0xe0014378     0x78    .word 0xe00145e8
    0xe001437c     0x7c    .word 0xe00145e8
    0xe0014380     0x80    .word 0xe00145e8
    0xe0014384     0x84    .word 0xe00145e8
    0xe0014388     0x88    .word 0xe00145e8
    0xe001438c     0x8c    .word 0xe00145e8
    0xe0014390     0x90    .word 0xe00145e8
    0xe0014394     0x94    .word 0xe00145e8
    0xe0014398     0x98    .word 0xe00145e8
    0xe001439c     0x9c    .word 0xe00145e8
    0xe00143a0     0xa0    .word 0xe00145e8
    0xe00143a4     0xa4    .word 0xe00145e8
    0xe00143a8     0xa8    .word 0xe00145e8
    0xe00143ac     0xac    .word 0xe00145e8
    0xe00143b0     0xb0    .word 0xe00145e8
    0xe00143b4     0xb4    .word 0xe00145b8
    0xe00143b8     0xb8    .word 0xe00145e8
    0xe00143bc     0xbc    .word 0xe00145e8
    0xe00143c0     0xc0    .word 0xe00145e8
    0xe00143c4     0xc4    .word 0xe00145e8
    0xe00143c8     0xc8    .word 0xe00145e8
    0xe00143cc     0xcc    .word 0xe00145e8
    0xe00143d0     0xd0    .word 0xe00145e8
    0xe00143d4     0xd4    .word 0xe00145e8
    0xe00143d8     0xd8    .word 0xe00145e8
    0xe00143dc     0xdc    .word 0xe00145e8
    0xe00143e0     0xe0    .word 0xe00145e8
    0xe00143e4     0xe4    .word 0xe00145e8
    0xe00143e8     0xe8    .word 0xe00145e8
    0xe00143ec     0xec    .word 0xe00145e8
    0xe00143f0     0xf0    .word 0xe00145e8
    0xe00143f4     0xf4    .word 0xe00145e8
    0xe00143f8     0xf8    .word 0xe00145e8
    0xe00143fc     0xfc    .word 0xe00145e8
    0xe0014400    0x100    .word 0xe00145e8
    0xe0014404    0x104    .word 0xe00145e8
    0xe0014408    0x108    .word 0xe00145e8
    0xe001440c    0x10c    .word 0xe00145e8
    0xe0014410    0x110    .word 0xe00145e8
    0xe0014414    0x114    .word 0xe00145e8
    0xe0014418    0x118    .word 0xe00145e8
    0xe001441c    0x11c    .word 0xe00145e8
    0xe0014420    0x120    .word 0xe00145e8
    0xe0014424    0x124    .word 0xe00145e8
    0xe0014428    0x128    .word 0xe00145e8
    0xe001442c    0x12c    .word 0xe00145e8
    0xe0014430    0x130    .word 0xe00145e8
    0xe0014434    0x134    .word 0xe0014438
    0xe0014438    0x138    and r3, r2, #14
    0xe001443c    0x13c    cmp r3, #14
    0xe0014440    0x140    beq e0014ae8 <sameRegionAs+0x7e8>
    0xe0014444    0x144    mov r0, #0
    0xe0014448    0x148    add sp, sp, #16
    0xe001444c    0x14c    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0014450    0x150    and lr, r2, #14
    0xe0014454    0x154    cmp lr, #14
    0xe0014458    0x158    beq e00149e0 <sameRegionAs+0x6e0>
    0xe001445c    0x15c    and r6, r2, #15
    0xe0014460    0x160    sub ip, r6, #2
    0xe0014464    0x164    cmp ip, #12
    0xe0014468    0x168    ldrls pc, [pc, ip, lsl #2]
    0xe001446c    0x16c    b e0014844 <sameRegionAs+0x544>
    0xe0014470    0x170    .word 0xe001461c
    0xe0014474    0x174    .word 0xe0014844
    0xe0014478    0x178    .word 0xe001461c
    0xe001447c    0x17c    .word 0xe0014844
    0xe0014480    0x180    .word 0xe001461c
    0xe0014484    0x184    .word 0xe0014844
    0xe0014488    0x188    .word 0xe0014444
    0xe001448c    0x18c    .word 0xe0014844
    0xe0014490    0x190    .word 0xe001461c
    0xe0014494    0x194    .word 0xe0014844
    0xe0014498    0x198    .word 0xe001461c
    0xe001449c    0x19c    .word 0xe0014844
    0xe00144a0    0x1a0    .word 0xe0014444
    0xe00144a4    0x1a4    and r3, r2, #14
    0xe00144a8    0x1a8    cmp r3, #14
    0xe00144ac    0x1ac    andne r0, r2, #15
    0xe00144b0    0x1b0    uxtbeq r0, r2
    0xe00144b4    0x1b4    cmp r0, #4
    0xe00144b8    0x1b8    bne e0014444 <sameRegionAs+0x144>
    0xe00144bc    0x1bc    bic r0, r5, #15
    0xe00144c0    0x1c0    bic r4, r4, #15
    0xe00144c4    0x1c4    sub r0, r0, r4
    0xe00144c8    0x1c8    clz r0, r0
    0xe00144cc    0x1cc    lsr r0, r0, #5
    0xe00144d0    0x1d0    b e0014448 <sameRegionAs+0x148>
    0xe00144d4    0x1d4    and r3, r2, #14
    0xe00144d8    0x1d8    cmp r3, #14
    0xe00144dc    0x1dc    andne r3, r2, #15
    0xe00144e0    0x1e0    uxtbeq r3, r2
    0xe00144e4    0x1e4    cmp r3, #6
    0xe00144e8    0x1e8    bne e0014444 <sameRegionAs+0x144>
    0xe00144ec    0x1ec    bic r0, r2, #15
    0xe00144f0    0x1f0    bic r1, r1, #15
    0xe00144f4    0x1f4    sub r0, r0, r1
    0xe00144f8    0x1f8    clz r0, r0
    0xe00144fc    0x1fc    lsr r0, r0, #5
    0xe0014500    0x200    b e0014448 <sameRegionAs+0x148>
    0xe0014504    0x204    and r3, r2, #14
    0xe0014508    0x208    cmp r3, #14
    0xe001450c    0x20c    andne r3, r2, #15
    0xe0014510    0x210    uxtbeq r3, r2
    0xe0014514    0x214    cmp r3, #8
    0xe0014518    0x218    bne e0014444 <sameRegionAs+0x144>
    0xe001451c    0x21c    bic r0, r2, #63 
    0xe0014520    0x220    bic r1, r1, #63 
    0xe0014524    0x224    sub r0, r0, r1
    0xe0014528    0x228    clz r0, r0
    0xe001452c    0x22c    lsr r0, r0, #5
    0xe0014530    0x230    b e0014448 <sameRegionAs+0x148>
    0xe0014534    0x234    and r3, r2, #14
    0xe0014538    0x238    cmp r3, #14
    0xe001453c    0x23c    andne r3, r2, #15
    0xe0014540    0x240    uxtbeq r3, r2
    0xe0014544    0x244    cmp r3, #10
    0xe0014548    0x248    bne e0014444 <sameRegionAs+0x144>
    0xe001454c    0x24c    bic r0, r2, #31
    0xe0014550    0x250    bic r1, r1, #31
    0xe0014554    0x254    cmp r0, r1
    0xe0014558    0x258    bne e0014444 <sameRegionAs+0x144>
    0xe001455c    0x25c    ubfx r3, r5, #18, #5
    0xe0014560    0x260    ubfx r0, r4, #18, #5
    0xe0014564    0x264    sub r0, r3, r0
    0xe0014568    0x268    clz r0, r0
    0xe001456c    0x26c    lsr r0, r0, #5
    0xe0014570    0x270    b e0014448 <sameRegionAs+0x148>
    0xe0014574    0x274    and r3, r2, #14
    0xe0014578    0x278    cmp r3, #14
    0xe001457c    0x27c    andne r3, r2, #15
    0xe0014580    0x280    uxtbeq r3, r2
    0xe0014584    0x284    cmp r3, #12
    0xe0014588    0x288    bne e0014444 <sameRegionAs+0x144>
    0xe001458c    0x28c    b e00144ec <sameRegionAs+0x1ec>
    0xe0014590    0x290    and r3, r2, #14
    0xe0014594    0x294    cmp r3, #14
    0xe0014598    0x298    andne r0, r2, #15
    0xe001459c    0x29c    uxtbeq r0, r2
    0xe00145a0    0x2a0    bic r0, r0, #16
    0xe00145a4    0x2a4    sub r0, r0, #14
    0xe00145a8    0x2a8    clz r0, r0
    0xe00145ac    0x2ac    lsr r0, r0, #5
    0xe00145b0    0x2b0    add sp, sp, #16
    0xe00145b4    0x2b4    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe00145b8    0x2b8    and r3, r2, #14
    0xe00145bc    0x2bc    cmp r3, #14
    0xe00145c0    0x2c0    bne e0014444 <sameRegionAs+0x144>
    0xe00145c4    0x2c4    uxtb r0, r2
    0xe00145c8    0x2c8    cmp r0, #30
    0xe00145cc    0x2cc    bne e0014444 <sameRegionAs+0x144>
    0xe00145d0    0x2d0    uxtb r0, r5
    0xe00145d4    0x2d4    uxtb r4, r4
    0xe00145d8    0x2d8    sub r0, r0, r4
    0xe00145dc    0x2dc    clz r0, r0
    0xe00145e0    0x2e0    lsr r0, r0, #5
    0xe00145e4    0x2e4    b e0014448 <sameRegionAs+0x148>
    0xe00145e8    0x2e8    ands r0, r0, #1
    0xe00145ec    0x2ec    beq e0014448 <sameRegionAs+0x148>
    0xe00145f0    0x2f0    and r3, r2, #14
    0xe00145f4    0x2f4    cmp r3, #14
    0xe00145f8    0x2f8    andne r0, r2, #15
    0xe00145fc    0x2fc    uxtbeq r0, r2
    0xe0014600    0x300    ands r0, r0, #1
    0xe0014604    0x304    beq e0014448 <sameRegionAs+0x148>
    0xe0014608    0x308    ldm lr, {r2, r3}      ; stack access
    0xe001460c    0x30c    ldm ip, {r0, r1}      ; stack access
    0xe0014610    0x310    add sp, sp, #16
    0xe0014614    0x314    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0014618    0x318    b e0011a14 <Arch_sameRegionAs>
    0xe001461c    0x31c    bic r1, r1, #15
    0xe0014620    0x320    and r4, r4, #31
    0xe0014624    0x324    sub r0, r1, #1
    0xe0014628    0x328    mov r3, #1
    0xe001462c    0x32c    add r0, r0, r3, lsl r4
    0xe0014630    0x330    cmp ip, #44 
    0xe0014634    0x334    ldrls pc, [pc, ip, lsl #2]
    0xe0014638    0x338    b e00148cc <sameRegionAs+0x5cc>
    0xe001463c    0x33c    .word 0xe00146f0
    0xe0014640    0x340    .word 0xe00148cc
    0xe0014644    0x344    .word 0xe00147f0
    0xe0014648    0x348    .word 0xe00148cc
    0xe001464c    0x34c    .word 0xe00146f0
    0xe0014650    0x350    .word 0xe00148cc
    0xe0014654    0x354    .word 0xe00147e4
    0xe0014658    0x358    .word 0xe00148cc
    0xe001465c    0x35c    .word 0xe00147fc
    0xe0014660    0x360    .word 0xe00148cc
    0xe0014664    0x364    .word 0xe0014808
    0xe0014668    0x368    .word 0xe00148cc
    0xe001466c    0x36c    .word 0xe00147e4
    0xe0014670    0x370    .word 0xe00148cc
    0xe0014674    0x374    .word 0xe00148cc
    0xe0014678    0x378    .word 0xe00148cc
    0xe001467c    0x37c    .word 0xe00148cc
    0xe0014680    0x380    .word 0xe00148cc
    0xe0014684    0x384    .word 0xe00148cc
    0xe0014688    0x388    .word 0xe00148cc
    0xe001468c    0x38c    .word 0xe00148cc
    0xe0014690    0x390    .word 0xe00148cc
    0xe0014694    0x394    .word 0xe00148cc
    0xe0014698    0x398    .word 0xe00148cc
    0xe001469c    0x39c    .word 0xe00148cc
    0xe00146a0    0x3a0    .word 0xe00148cc
    0xe00146a4    0x3a4    .word 0xe00148cc
    0xe00146a8    0x3a8    .word 0xe00148cc
    0xe00146ac    0x3ac    .word 0xe00147e4
    0xe00146b0    0x3b0    .word 0xe00148cc
    0xe00146b4    0x3b4    .word 0xe00148cc
    0xe00146b8    0x3b8    .word 0xe00148cc
    0xe00146bc    0x3bc    .word 0xe00148cc
    0xe00146c0    0x3c0    .word 0xe00148cc
    0xe00146c4    0x3c4    .word 0xe00148cc
    0xe00146c8    0x3c8    .word 0xe00148cc
    0xe00146cc    0x3cc    .word 0xe00148cc
    0xe00146d0    0x3d0    .word 0xe00148cc
    0xe00146d4    0x3d4    .word 0xe00148cc
    0xe00146d8    0x3d8    .word 0xe00148cc
    0xe00146dc    0x3dc    .word 0xe00148cc
    0xe00146e0    0x3e0    .word 0xe00148cc
    0xe00146e4    0x3e4    .word 0xe00148cc
    0xe00146e8    0x3e8    .word 0xe00148cc
    0xe00146ec    0x3ec    .word 0xe0014818
    0xe00146f0    0x3f0    bic r4, r2, #15
    0xe00146f4    0x3f4    sub r7, r4, #1
    0xe00146f8    0x3f8    cmp ip, #44 
    0xe00146fc    0x3fc    ldrls pc, [pc, ip, lsl #2]
    0xe0014700    0x400    b e00149d0 <sameRegionAs+0x6d0>
    0xe0014704    0x404    .word 0xe0014898
    0xe0014708    0x408    .word 0xe00149d0
    0xe001470c    0x40c    .word 0xe0014874
    0xe0014710    0x410    .word 0xe00149d0
    0xe0014714    0x414    .word 0xe0014874
    0xe0014718    0x418    .word 0xe00149d0
    0xe001471c    0x41c    .word 0xe00147b8
    0xe0014720    0x420    .word 0xe00149d0
    0xe0014724    0x424    .word 0xe0014884
    0xe0014728    0x428    .word 0xe00149d0
    0xe001472c    0x42c    .word 0xe001487c
    0xe0014730    0x430    .word 0xe00149d0
    0xe0014734    0x434    .word 0xe00147b8
    0xe0014738    0x438    .word 0xe00149d0
    0xe001473c    0x43c    .word 0xe00149d0
    0xe0014740    0x440    .word 0xe00149d0
    0xe0014744    0x444    .word 0xe00149d0
    0xe0014748    0x448    .word 0xe00149d0
    0xe001474c    0x44c    .word 0xe00149d0
    0xe0014750    0x450    .word 0xe00149d0
    0xe0014754    0x454    .word 0xe00149d0
    0xe0014758    0x458    .word 0xe00149d0
    0xe001475c    0x45c    .word 0xe00149d0
    0xe0014760    0x460    .word 0xe00149d0
    0xe0014764    0x464    .word 0xe00149d0
    0xe0014768    0x468    .word 0xe00149d0
    0xe001476c    0x46c    .word 0xe00149d0
    0xe0014770    0x470    .word 0xe00149d0
    0xe0014774    0x474    .word 0xe00147b8
    0xe0014778    0x478    .word 0xe00149d0
    0xe001477c    0x47c    .word 0xe00149d0
    0xe0014780    0x480    .word 0xe00149d0
    0xe0014784    0x484    .word 0xe00149d0
    0xe0014788    0x488    .word 0xe00149d0
    0xe001478c    0x48c    .word 0xe00149d0
    0xe0014790    0x490    .word 0xe00149d0
    0xe0014794    0x494    .word 0xe00149d0
    0xe0014798    0x498    .word 0xe00149d0
    0xe001479c    0x49c    .word 0xe00149d0
    0xe00147a0    0x4a0    .word 0xe00149d0
    0xe00147a4    0x4a4    .word 0xe00149d0
    0xe00147a8    0x4a8    .word 0xe00149d0
    0xe00147ac    0x4ac    .word 0xe00149d0
    0xe00147b0    0x4b0    .word 0xe00149d0
    0xe00147b4    0x4b4    .word 0xe00148a8
    0xe00147b8    0x4b8    mov r3, #1
    0xe00147bc    0x4bc    add r3, r3, r7
    0xe00147c0    0x4c0    cmp r3, r0
    0xe00147c4    0x4c4    movhi r2, #0
    0xe00147c8    0x4c8    movls r2, #1
    0xe00147cc    0x4cc    cmp r3, r4
    0xe00147d0    0x4d0    movcc r2, #0
    0xe00147d4    0x4d4    cmp r1, r4
    0xe00147d8    0x4d8    movhi r0, #0
    0xe00147dc    0x4dc    andls r0, r2, #1
    0xe00147e0    0x4e0    b e0014448 <sameRegionAs+0x148>
    0xe00147e4    0x4e4    mvn r7, #0
    0xe00147e8    0x4e8    mov r4, #0
    0xe00147ec    0x4ec    b e00146f8 <sameRegionAs+0x3f8>
    0xe00147f0    0x4f0    bic r4, r5, #15
    0xe00147f4    0x4f4    sub r7, r4, #1
    0xe00147f8    0x4f8    b e00146f8 <sameRegionAs+0x3f8>
    0xe00147fc    0x4fc    bic r4, r2, #31
    0xe0014800    0x500    sub r7, r4, #1
    0xe0014804    0x504    b e00146f8 <sameRegionAs+0x3f8>
    0xe0014808    0x508    bic r4, r2, #508 
    0xe001480c    0x50c    bic r4, r4, #3
    0xe0014810    0x510    sub r7, r4, #1
    0xe0014814    0x514    b e00146f8 <sameRegionAs+0x3f8>
    0xe0014818    0x518    lsr r3, r2, #8
    0xe001481c    0x51c    and r4, r3, #63 
    0xe0014820    0x520    cmp r4, #32
    0xe0014824    0x524    andne r3, r3, #31
    0xe0014828    0x528    mvnne r4, #0
    0xe001482c    0x52c    addne r3, r3, #1
    0xe0014830    0x530    lslne r3, r4, r3
    0xe0014834    0x534    mvneq r3, #31
    0xe0014838    0x538    and r4, r5, r3
    0xe001483c    0x53c    sub r7, r4, #1
    0xe0014840    0x540    b e00146f8 <sameRegionAs+0x3f8>
    0xe0014844    0x544    sub r8, r6, #1
    0xe0014848    0x548    cmp r8, #10
    0xe001484c    0x54c    bhi e0014444 <sameRegionAs+0x144>
    0xe0014850    0x550    mov r7, #1
    0xe0014854    0x554    movw r3, #341 
    0xe0014858    0x558    ands r3, r3, r7, lsl r8
    0xe001485c    0x55c    beq e0014444 <sameRegionAs+0x144>
    0xe0014860    0x560    bic r1, r1, #15
    0xe0014864    0x564    and r4, r4, #31
    0xe0014868    0x568    sub r0, r1, #1
    0xe001486c    0x56c    add r0, r0, r7, lsl r4
    0xe0014870    0x570    b e0014630 <sameRegionAs+0x330>
    0xe0014874    0x574    mov r3, #16
    0xe0014878    0x578    b e00147bc <sameRegionAs+0x4bc>
    0xe001487c    0x57c    mov r3, #512 
    0xe0014880    0x580    b e00147bc <sameRegionAs+0x4bc>
    0xe0014884    0x584    ubfx r3, r5, #18, #5
    0xe0014888    0x588    mov r2, #1
    0xe001488c    0x58c    add r3, r3, #4
    0xe0014890    0x590    lsl r3, r2, r3
    0xe0014894    0x594    b e00147bc <sameRegionAs+0x4bc>
    0xe0014898    0x598    and r3, r5, #31
    0xe001489c    0x59c    mov r2, #1
    0xe00148a0    0x5a0    lsl r3, r2, r3
    0xe00148a4    0x5a4    b e00147bc <sameRegionAs+0x4bc>
    0xe00148a8    0x5a8    lsr r2, r2, #8
    0xe00148ac    0x5ac    and r3, r2, #63 
    0xe00148b0    0x5b0    cmp r3, #32
    0xe00148b4    0x5b4    beq e001487c <sameRegionAs+0x57c>
    0xe00148b8    0x5b8    and r2, r2, #31
    0xe00148bc    0x5bc    mov r3, #1
    0xe00148c0    0x5c0    add r2, r2, #4
    0xe00148c4    0x5c4    lsl r3, r3, r2
    0xe00148c8    0x5c8    b e00147bc <sameRegionAs+0x4bc>
    0xe00148cc    0x5cc    sub r8, r6, #1
    0xe00148d0    0x5d0    cmp r8, #8
    0xe00148d4    0x5d4    ldrls pc, [pc, r8, lsl #2]
    0xe00148d8    0x5d8    b e00147e4 <sameRegionAs+0x4e4>
    0xe00148dc    0x5dc    .word 0xe0014978
    0xe00148e0    0x5e0    .word 0xe00147e4
    0xe00148e4    0x5e4    .word 0xe0014978
    0xe00148e8    0x5e8    .word 0xe00147e4
    0xe00148ec    0x5ec    .word 0xe0014938
    0xe00148f0    0x5f0    .word 0xe00147e4
    0xe00148f4    0x5f4    .word 0xe001491c
    0xe00148f8    0x5f8    .word 0xe00147e4
    0xe00148fc    0x5fc    .word 0xe0014900
    0xe0014900    0x600    bic r4, r2, #16320 
    0xe0014904    0x604    cmp lr, #14
    0xe0014908    0x608    bic r4, r4, #63 
    0xe001490c    0x60c    sub r7, r4, #1
    0xe0014910    0x610    beq e00146f8 <sameRegionAs+0x3f8>
    0xe0014914    0x614    mov r3, #16384 
    0xe0014918    0x618    b e00147bc <sameRegionAs+0x4bc>
    0xe001491c    0x61c    bic r4, r2, #1020 
    0xe0014920    0x620    cmp lr, #14
    0xe0014924    0x624    bic r4, r4, #3
    0xe0014928    0x628    sub r7, r4, #1
    0xe001492c    0x62c    beq e00146f8 <sameRegionAs+0x3f8>
    0xe0014930    0x630    mov r3, #1024 
    0xe0014934    0x634    b e00147bc <sameRegionAs+0x4bc>
    0xe0014938    0x638    cmp lr, #14
    0xe001493c    0x63c    bic r4, r2, #15
    0xe0014940    0x640    sub r7, r4, #1
    0xe0014944    0x644    beq e00149d8 <sameRegionAs+0x6d8>
    0xe0014948    0x648    cmp r8, #8
    0xe001494c    0x64c    ldrls pc, [pc, r8, lsl #2]
    0xe0014950    0x650    b e00147b8 <sameRegionAs+0x4b8>
    0xe0014954    0x654    .word 0xe001499c
    0xe0014958    0x658    .word 0xe00147b8
    0xe001495c    0x65c    .word 0xe001499c
    0xe0014960    0x660    .word 0xe00147b8
    0xe0014964    0x664    .word 0xe00149d8
    0xe0014968    0x668    .word 0xe00147b8
    0xe001496c    0x66c    .word 0xe0014930
    0xe0014970    0x670    .word 0xe00147b8
    0xe0014974    0x674    .word 0xe0014914
    0xe0014978    0x678    cmp r6, #1
    0xe001497c    0x67c    beq e0014b04 <sameRegionAs+0x804>
    0xe0014980    0x680    cmp r6, #3
    0xe0014984    0x684    bne e0014afc <sameRegionAs+0x7fc>
    0xe0014988    0x688    mov r4, #49152 
    0xe001498c    0x68c    movt r4, #65535 
    0xe0014990    0x690    and r4, r4, r2, lsl #10
    0xe0014994    0x694    sub r7, r4, #1
    0xe0014998    0x698    b e00146f8 <sameRegionAs+0x3f8>
    0xe001499c    0x69c    cmp r6, #3
    0xe00149a0    0x6a0    bne e00149d8 <sameRegionAs+0x6d8>
    0xe00149a4    0x6a4    lsr r3, r5, #30
    0xe00149a8    0x6a8    cmp r3, #2
    0xe00149ac    0x6ac    moveq r3, #1048576 
    0xe00149b0    0x6b0    beq e00147bc <sameRegionAs+0x4bc>
    0xe00149b4    0x6b4    cmp r3, #3
    0xe00149b8    0x6b8    moveq r3, #16777216 
    0xe00149bc    0x6bc    beq e00147bc <sameRegionAs+0x4bc>
    0xe00149c0    0x6c0    cmp r3, #1
    0xe00149c4    0x6c4    moveq r3, #65536 
    0xe00149c8    0x6c8    movne r3, #4096 
    0xe00149cc    0x6cc    b e00147bc <sameRegionAs+0x4bc>
    0xe00149d0    0x6d0    sub r8, r6, #1
    0xe00149d4    0x6d4    b e0014948 <sameRegionAs+0x648>
    0xe00149d8    0x6d8    mov r3, #4096 
    0xe00149dc    0x6dc    b e00147bc <sameRegionAs+0x4bc>
    0xe00149e0    0x6e0    uxtb r6, r2
    0xe00149e4    0x6e4    sub ip, r6, #2
    0xe00149e8    0x6e8    cmp ip, #60 
    0xe00149ec    0x6ec    ldrls pc, [pc, ip, lsl #2]
    0xe00149f0    0x6f0    b e0014844 <sameRegionAs+0x544>
    0xe00149f4    0x6f4    .word 0xe001461c
    0xe00149f8    0x6f8    .word 0xe0014844
    0xe00149fc    0x6fc    .word 0xe001461c
    0xe0014a00    0x700    .word 0xe0014844
    0xe0014a04    0x704    .word 0xe001461c
    0xe0014a08    0x708    .word 0xe0014844
    0xe0014a0c    0x70c    .word 0xe0014444
    0xe0014a10    0x710    .word 0xe0014844
    0xe0014a14    0x714    .word 0xe001461c
    0xe0014a18    0x718    .word 0xe0014844
    0xe0014a1c    0x71c    .word 0xe001461c
    0xe0014a20    0x720    .word 0xe0014844
    0xe0014a24    0x724    .word 0xe0014444
    0xe0014a28    0x728    .word 0xe0014844
    0xe0014a2c    0x72c    .word 0xe0014844
    0xe0014a30    0x730    .word 0xe0014844
    0xe0014a34    0x734    .word 0xe0014844
    0xe0014a38    0x738    .word 0xe0014844
    0xe0014a3c    0x73c    .word 0xe0014844
    0xe0014a40    0x740    .word 0xe0014844
    0xe0014a44    0x744    .word 0xe0014844
    0xe0014a48    0x748    .word 0xe0014844
    0xe0014a4c    0x74c    .word 0xe0014844
    0xe0014a50    0x750    .word 0xe0014844
    0xe0014a54    0x754    .word 0xe0014844
    0xe0014a58    0x758    .word 0xe0014844
    0xe0014a5c    0x75c    .word 0xe0014844
    0xe0014a60    0x760    .word 0xe0014844
    0xe0014a64    0x764    .word 0xe0014444
    0xe0014a68    0x768    .word 0xe0014844
    0xe0014a6c    0x76c    .word 0xe0014844
    0xe0014a70    0x770    .word 0xe0014844
    0xe0014a74    0x774    .word 0xe0014844
    0xe0014a78    0x778    .word 0xe0014844
    0xe0014a7c    0x77c    .word 0xe0014844
    0xe0014a80    0x780    .word 0xe0014844
    0xe0014a84    0x784    .word 0xe0014844
    0xe0014a88    0x788    .word 0xe0014844
    0xe0014a8c    0x78c    .word 0xe0014844
    0xe0014a90    0x790    .word 0xe0014844
    0xe0014a94    0x794    .word 0xe0014844
    0xe0014a98    0x798    .word 0xe0014844
    0xe0014a9c    0x79c    .word 0xe0014844
    0xe0014aa0    0x7a0    .word 0xe0014844
    0xe0014aa4    0x7a4    .word 0xe001461c
    0xe0014aa8    0x7a8    .word 0xe0014844
    0xe0014aac    0x7ac    .word 0xe0014844
    0xe0014ab0    0x7b0    .word 0xe0014844
    0xe0014ab4    0x7b4    .word 0xe0014844
    0xe0014ab8    0x7b8    .word 0xe0014844
    0xe0014abc    0x7bc    .word 0xe0014844
    0xe0014ac0    0x7c0    .word 0xe0014844
    0xe0014ac4    0x7c4    .word 0xe0014844
    0xe0014ac8    0x7c8    .word 0xe0014844
    0xe0014acc    0x7cc    .word 0xe0014844
    0xe0014ad0    0x7d0    .word 0xe0014844
    0xe0014ad4    0x7d4    .word 0xe0014844
    0xe0014ad8    0x7d8    .word 0xe0014844
    0xe0014adc    0x7dc    .word 0xe0014844
    0xe0014ae0    0x7e0    .word 0xe0014844
    0xe0014ae4    0x7e4    .word 0xe0014444
    0xe0014ae8    0x7e8    uxtb r0, r2
    0xe0014aec    0x7ec    sub r0, r0, #62 
    0xe0014af0    0x7f0    clz r0, r0
    0xe0014af4    0x7f4    lsr r0, r0, #5
    0xe0014af8    0x7f8    b e0014448 <sameRegionAs+0x148>
    0xe0014afc    0x7fc    mov r4, #0
    0xe0014b00    0x800    b e0014994 <sameRegionAs+0x694>
    0xe0014b04    0x804    mov r4, #61440 
    0xe0014b08    0x808    movt r4, #65535 
    0xe0014b0c    0x80c    and r4, r4, r2, lsl #8
    0xe0014b10    0x810    b e0014994 <sameRegionAs+0x694>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
274 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sameRegionAs` has 1127 nodes.

Section getObjectSize (136 of 299)
==================================

Deriving specifications
-----------------------

Section `getObjectSize` consists of 19 instructions.
Switch found.


Stack analysis
---------------

No stack accesses found. Code for `getObjectSize`:

    0xe0014258     0x0    cmp r0, #4
    0xe001425c     0x4    bhi e0014288 <getObjectSize+0x30>
    0xe0014260     0x8    sub r3, r0, #1
    0xe0014264     0xc    cmp r3, #3
    0xe0014268    0x10    ldrls pc, [pc, r3, lsl #2]
    0xe001426c    0x14    b e0014294 <getObjectSize+0x3c>
    0xe0014270    0x18    .word 0xe001428c
    0xe0014274    0x1c    .word 0xe0014280
    0xe0014278    0x20    .word 0xe0014280
    0xe001427c    0x24    .word 0xe001429c
    0xe0014280    0x28    mov r0, #4
    0xe0014284    0x2c    bx lr
    0xe0014288    0x30    b e0011e50 <Arch_getObjectSize>
    0xe001428c    0x34    mov r0, #9
    0xe0014290    0x38    bx lr
    0xe0014294    0x3c    mov r0, r1
    0xe0014298    0x40    bx lr
    0xe001429c    0x44    add r0, r1, #4
    0xe00142a0    0x48    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getObjectSize` has 35 nodes.

Section completeSignal (137 of 299)
===================================

Deriving specifications
-----------------------

Section `completeSignal` consists of 13 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `completeSignal`:

    0xe00141cc     0x0    cmp r1, #0
    0xe00141d0     0x4    beq e00141f8 <completeSignal+0x2c>
    0xe00141d4     0x8    ldr r3, [r0]
    0xe00141d8     0xc    and r2, r3, #3
    0xe00141dc    0x10    cmp r2, #2
    0xe00141e0    0x14    bne e00141f8 <completeSignal+0x2c>
    0xe00141e4    0x18    ldr r2, [r0, #8]
    0xe00141e8    0x1c    bic r3, r3, #3
    0xe00141ec    0x20    str r2, [r1]
    0xe00141f0    0x24    str r3, [r0]
    0xe00141f4    0x28    bx lr
    0xe00141f8    0x2c    push {r4, lr}         ; stack access
    0xe00141fc    0x30    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `completeSignal` has 24 nodes.

Section cancelSignal (138 of 299)
=================================

Deriving specifications
-----------------------

Section `cancelSignal` consists of 33 instructions.
 BICEQ (imm)....+++
 LDMIANE (wb);15,4..++


Stack analysis
---------------

3 stack accesses found. Annotated code for `cancelSignal`:

    0xe0014148     0x0    ldr r3, [r0, #148] 
    0xe001414c     0x4    push {r4, lr}         ; stack access
    0xe0014150     0x8    cmp r3, #0
    0xe0014154     0xc    ldr r4, [r0, #144] 
    0xe0014158    0x10    ldr ip, [r1, #4]
    0xe001415c    0x14    ldr r2, [r1]
    0xe0014160    0x18    strne r4, [r3, #144] 
    0xe0014164    0x1c    bicne lr, ip, #15
    0xe0014168    0x20    ldrne r4, [r0, #144] 
    0xe001416c    0x24    moveq lr, r4
    0xe0014170    0x28    and ip, ip, #15
    0xe0014174    0x2c    cmp r4, #0
    0xe0014178    0x30    strne r3, [r4, #148] 
    0xe001417c    0x34    bicne r3, r2, #15
    0xe0014180    0x38    bic r3, r3, #15
    0xe0014184    0x3c    and r2, r2, #15
    0xe0014188    0x40    orr r3, r2, r3
    0xe001418c    0x44    movw r2, #13900 
    0xe0014190    0x48    movt r2, #57347 
    0xe0014194    0x4c    cmp lr, #0
    0xe0014198    0x50    bic lr, lr, #15
    0xe001419c    0x54    biceq r3, r3, #3
    0xe00141a0    0x58    ldr r2, [r2]
    0xe00141a4    0x5c    orr ip, ip, lr
    0xe00141a8    0x60    str r3, [r1]
    0xe00141ac    0x64    str ip, [r1, #4]
    0xe00141b0    0x68    cmp r0, r2
    0xe00141b4    0x6c    ldr r3, [r0, #80] 
    0xe00141b8    0x70    bic r3, r3, #15
    0xe00141bc    0x74    str r3, [r0, #80] 
    0xe00141c0    0x78    popne {r4, pc}        ; stack access
    0xe00141c4    0x7c    pop {r4, lr}          ; stack access
    0xe00141c8    0x80    b e0013114 <setThreadState.part.166>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
33 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelSignal` has 65 nodes.

Section receiveSignal (139 of 299)
==================================

Deriving specifications
-----------------------

Section `receiveSignal` consists of 57 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `receiveSignal`:

    0xe0013fcc     0x0    push {r4, lr}         ; stack access
    0xe0013fd0     0x4    sub sp, sp, #16
    0xe0013fd4     0x8    add ip, sp, #16
    0xe0013fd8     0xc    stmdb ip, {r1, r2}    ; stack access
    0xe0013fdc    0x10    mov r1, r0
    0xe0013fe0    0x14    ldr r4, [sp, #8]      ; stack access
    0xe0013fe4    0x18    bic r4, r4, #15
    0xe0013fe8    0x1c    ldr r2, [r4]
    0xe0013fec    0x20    and ip, r2, #3
    0xe0013ff0    0x24    cmp ip, #1
    0xe0013ff4    0x28    bls e0014014 <receiveSignal+0x48>
    0xe0013ff8    0x2c    cmp ip, #2
    0xe0013ffc    0x30    ldreq r3, [r4, #8]
    0xe0014000    0x34    biceq r2, r2, #3
    0xe0014004    0x38    streq r3, [r0]
    0xe0014008    0x3c    streq r2, [r4]
    0xe001400c    0x40    add sp, sp, #16
    0xe0014010    0x44    pop {r4, pc}          ; stack access
    0xe0014014    0x48    cmp r3, #0
    0xe0014018    0x4c    streq r3, [r0]
    0xe001401c    0x50    beq e001400c <receiveSignal+0x40>
    0xe0014020    0x54    movw r3, #13900 
    0xe0014024    0x58    movt r3, #57347 
    0xe0014028    0x5c    orr r2, r4, #6
    0xe001402c    0x60    str r2, [r0, #80] 
    0xe0014030    0x64    ldr r3, [r3]
    0xe0014034    0x68    cmp r0, r3
    0xe0014038    0x6c    beq e001408c <receiveSignal+0xc0>
    0xe001403c    0x70    ldr r2, [r4, #4]
    0xe0014040    0x74    bic lr, r1, #15
    0xe0014044    0x78    ldr r3, [r4]
    0xe0014048    0x7c    bics r0, r2, #15
    0xe001404c    0x80    and r2, r2, #15
    0xe0014050    0x84    bic ip, r3, #15
    0xe0014054    0x88    and r3, r3, #12
    0xe0014058    0x8c    moveq r0, r1
    0xe001405c    0x90    orr r3, r3, #1
    0xe0014060    0x94    bic r0, r0, #15
    0xe0014064    0x98    strne r1, [ip, #144] 
    0xe0014068    0x9c    orr r2, r2, r0
    0xe001406c    0xa0    str ip, [r1, #148] 
    0xe0014070    0xa4    orr r3, r3, lr
    0xe0014074    0xa8    mov r0, #0
    0xe0014078    0xac    str r0, [r1, #144] 
    0xe001407c    0xb0    str r3, [r4]
    0xe0014080    0xb4    str r2, [r4, #4]
    0xe0014084    0xb8    add sp, sp, #16
    0xe0014088    0xbc    pop {r4, pc}          ; stack access
    0xe001408c    0xc0    movw r3, #36892 
    0xe0014090    0xc4    movt r3, #57346 
    0xe0014094    0xc8    ldr r3, [r3]
    0xe0014098    0xcc    cmp r3, #0
    0xe001409c    0xd0    bne e001403c <receiveSignal+0x70>
    0xe00140a0    0xd4    str r0, [sp, #4]      ; stack access
    0xe00140a4    0xd8    bl e00130d0 <scheduleTCB.part.165>
    0xe00140a8    0xdc    ldr r1, [sp, #4]      ; stack access
    0xe00140ac    0xe0    b e001403c <receiveSignal+0x70>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
57 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `receiveSignal` has 102 nodes.

Section invokeIRQControl (140 of 299)
=====================================

Deriving specifications
-----------------------

Section `invokeIRQControl` consists of 25 instructions.
 LDMDB;1,0...++


Stack analysis
---------------

5 stack accesses found. Annotated code for `invokeIRQControl`:

    0xe0013b3c     0x0    lsr r3, r0, #5
    0xe0013b40     0x4    movw ip, #4607 
    0xe0013b44     0x8    movt ip, #65520 
    0xe0013b48     0xc    lsl r3, r3, #2
    0xe0013b4c    0x10    push {r4, r5, lr}     ; stack access
    0xe0013b50    0x14    add ip, r3, ip
    0xe0013b54    0x18    sub sp, sp, #12
    0xe0013b58    0x1c    movw r4, #36936 
    0xe0013b5c    0x20    movt r4, #57346 
    0xe0013b60    0x24    and r5, r0, #31
    0xe0013b64    0x28    mov lr, #1
    0xe0013b68    0x2c    mov r3, r1
    0xe0013b6c    0x30    str lr, [r4, r0, lsl #2]
    0xe0013b70    0x34    mov r1, #30
    0xe0013b74    0x38    lsl lr, lr, r5
    0xe0013b78    0x3c    str lr, [ip, #-255] 
    0xe0013b7c    0x40    str r1, [sp]          ; stack access
    0xe0013b80    0x44    add r1, sp, #8
    0xe0013b84    0x48    uxtb r0, r0
    0xe0013b88    0x4c    str r0, [sp, #4]      ; stack access
    0xe0013b8c    0x50    ldmdb r1, {r0, r1}    ; stack access
    0xe0013b90    0x54    bl e0013308 <cteInsert>
    0xe0013b94    0x58    mov r0, #0
    0xe0013b98    0x5c    add sp, sp, #12
    0xe0013b9c    0x60    pop {r4, r5, pc}      ; stack access

Proving inst theorems
---------------------

25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQControl` has 33 nodes.

Section invokeCNodeCancelBadgedSends (141 of 299)
=================================================

Deriving specifications
-----------------------

Section `invokeCNodeCancelBadgedSends` consists of 13 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `invokeCNodeCancelBadgedSends`:

    0xe0013b08     0x0    push {lr}             ; stack access
    0xe0013b0c     0x4    sub sp, sp, #12
    0xe0013b10     0x8    add r3, sp, #8
    0xe0013b14     0xc    stmdb r3, {r0, r1}    ; stack access
    0xe0013b18    0x10    ldr r1, [sp]          ; stack access
    0xe0013b1c    0x14    lsrs r1, r1, #4
    0xe0013b20    0x18    beq e0013b30 <invokeCNodeCancelBadgedSends+0x28>
    0xe0013b24    0x1c    ldr r0, [sp, #4]      ; stack access
    0xe0013b28    0x20    bic r0, r0, #15
    0xe0013b2c    0x24    bl e00139d8 <cancelBadgedSends>
    0xe0013b30    0x28    mov r0, #0
    0xe0013b34    0x2c    add sp, sp, #12
    0xe0013b38    0x30    pop {pc}              ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeCancelBadgedSends` has 21 nodes.

Section capSwapForDelete (142 of 299)
=====================================

Deriving specifications
-----------------------

Section `capSwapForDelete` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `capSwapForDelete`:

    0xe0013798    0x0    cmp r1, r0
    0xe001379c    0x4    bxeq lr
    0xe00137a0    0x8    b e0013750 <capSwapForDelete.part.162>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `capSwapForDelete` has 7 nodes.

Section capSwapForDelete_part_162 (143 of 299)
==============================================

Deriving specifications
-----------------------

Section `capSwapForDelete_part_162` consists of 18 instructions.


Stack analysis
---------------

9 stack accesses found. Annotated code for `capSwapForDelete_part_162`:

    0xe0013750     0x0    push {lr}             ; stack access
    0xe0013754     0x4    mov r3, r1
    0xe0013758     0x8    sub sp, sp, #28
    0xe001375c     0xc    mov r2, r0
    0xe0013760    0x10    ldm r0, {r0, r1}
    0xe0013764    0x14    add ip, sp, #8
    0xe0013768    0x18    str r3, [sp, #4]      ; stack access
    0xe001376c    0x1c    stm ip, {r0, r1}      ; stack access
    0xe0013770    0x20    ldm r3, {r0, r1}
    0xe0013774    0x24    add r3, sp, #24
    0xe0013778    0x28    stmdb r3, {r0, r1}    ; stack access
    0xe001377c    0x2c    ldr lr, [sp, #20]     ; stack access
    0xe0013780    0x30    ldm ip, {r0, r1}      ; stack access
    0xe0013784    0x34    ldr r3, [sp, #16]     ; stack access
    0xe0013788    0x38    str lr, [sp]          ; stack access
    0xe001378c    0x3c    bl e0013610 <cteSwap>
    0xe0013790    0x40    add sp, sp, #28
    0xe0013794    0x44    pop {pc}              ; stack access

Proving inst theorems
---------------------

18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `capSwapForDelete_part_162` has 30 nodes.

Section invokeCNodeMove (144 of 299)
====================================

Deriving specifications
-----------------------

Section `invokeCNodeMove` consists of 9 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `invokeCNodeMove`:

    0xe001356c     0x0    push {lr}             ; stack access
    0xe0013570     0x4    sub sp, sp, #12
    0xe0013574     0x8    mov ip, sp
    0xe0013578     0xc    stm ip, {r0, r1}      ; stack access
    0xe001357c    0x10    ldm ip, {r0, r1}      ; stack access
    0xe0013580    0x14    bl e00134f8 <cteMove>
    0xe0013584    0x18    mov r0, #0
    0xe0013588    0x1c    add sp, sp, #12
    0xe001358c    0x20    pop {pc}              ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeMove` has 14 nodes.

Section invokeCNodeInsert (145 of 299)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeInsert` consists of 9 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `invokeCNodeInsert`:

    0xe00134d4     0x0    push {lr}             ; stack access
    0xe00134d8     0x4    sub sp, sp, #12
    0xe00134dc     0x8    mov ip, sp
    0xe00134e0     0xc    stm ip, {r0, r1}      ; stack access
    0xe00134e4    0x10    ldm ip, {r0, r1}      ; stack access
    0xe00134e8    0x14    bl e0013308 <cteInsert>
    0xe00134ec    0x18    mov r0, #0
    0xe00134f0    0x1c    add sp, sp, #12
    0xe00134f4    0x20    pop {pc}              ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeInsert` has 14 nodes.

Section preemptionPoint (146 of 299)
====================================

Deriving specifications
-----------------------

Section `preemptionPoint` consists of 10 instructions.


Stack analysis
---------------

No stack accesses found. Code for `preemptionPoint`:

    0xe00132e0     0x0    movw r2, #12804 
    0xe00132e4     0x4    movt r2, #57347 
    0xe00132e8     0x8    ldr r3, [r2]
    0xe00132ec     0xc    add r3, r3, #1
    0xe00132f0    0x10    str r3, [r2]
    0xe00132f4    0x14    cmp r3, #99 
    0xe00132f8    0x18    bls e0013300 <preemptionPoint+0x20>
    0xe00132fc    0x1c    b e00107a8 <preemptionPoint.part.161>
    0xe0013300    0x20    mov r0, #0
    0xe0013304    0x24    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `preemptionPoint` has 17 nodes.

Section handleDoubleFault (147 of 299)
======================================

Deriving specifications
-----------------------

Section `handleDoubleFault` consists of 17 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `handleDoubleFault`:

    0xe0013158     0x0    push {lr}             ; stack access
    0xe001315c     0x4    sub sp, sp, #12
    0xe0013160     0x8    movw ip, #13900 
    0xe0013164     0xc    add lr, sp, #8
    0xe0013168    0x10    movt ip, #57347 
    0xe001316c    0x14    stmdb lr, {r1, r2}    ; stack access
    0xe0013170    0x18    ldr r1, [ip]
    0xe0013174    0x1c    ldr r2, [r0, #80] 
    0xe0013178    0x20    cmp r0, r1
    0xe001317c    0x24    bic r2, r2, #15
    0xe0013180    0x28    str r2, [r0, #80] 
    0xe0013184    0x2c    beq e0013190 <handleDoubleFault+0x38>
    0xe0013188    0x30    add sp, sp, #12
    0xe001318c    0x34    pop {pc}              ; stack access
    0xe0013190    0x38    add sp, sp, #12
    0xe0013194    0x3c    pop {lr}              ; stack access
    0xe0013198    0x40    b e0013114 <setThreadState.part.166>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleDoubleFault` has 27 nodes.

Section setThreadState (148 of 299)
===================================

Deriving specifications
-----------------------

Section `setThreadState` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setThreadState`:

    0xe001312c     0x0    movw r2, #13900 
    0xe0013130     0x4    movt r2, #57347 
    0xe0013134     0x8    and ip, r1, #15
    0xe0013138     0xc    ldr r1, [r0, #80] 
    0xe001313c    0x10    ldr r2, [r2]
    0xe0013140    0x14    bic r1, r1, #15
    0xe0013144    0x18    cmp r0, r2
    0xe0013148    0x1c    orr r1, r1, ip
    0xe001314c    0x20    str r1, [r0, #80] 
    0xe0013150    0x24    bxne lr
    0xe0013154    0x28    b e0013114 <setThreadState.part.166>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setThreadState` has 18 nodes.

Section setThreadState_part_166 (149 of 299)
============================================

Deriving specifications
-----------------------

Section `setThreadState_part_166` consists of 6 instructions.


Stack analysis
---------------

No stack accesses found. Code for `setThreadState_part_166`:

    0xe0013114     0x0    movw r3, #36892 
    0xe0013118     0x4    movt r3, #57346 
    0xe001311c     0x8    ldr r3, [r3]
    0xe0013120     0xc    cmp r3, #0
    0xe0013124    0x10    bxne lr
    0xe0013128    0x14    b e00130d0 <scheduleTCB.part.165>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setThreadState_part_166` has 11 nodes.

Section scheduleTCB (150 of 299)
================================

Deriving specifications
-----------------------

Section `scheduleTCB` consists of 11 instructions.


Stack analysis
---------------

No stack accesses found. Code for `scheduleTCB`:

    0xe00130e8     0x0    movw r3, #13900 
    0xe00130ec     0x4    movt r3, #57347 
    0xe00130f0     0x8    ldr r3, [r3]
    0xe00130f4     0xc    cmp r3, r0
    0xe00130f8    0x10    bxne lr
    0xe00130fc    0x14    movw r3, #36892 
    0xe0013100    0x18    movt r3, #57346 
    0xe0013104    0x1c    ldr r3, [r3]
    0xe0013108    0x20    cmp r3, #0
    0xe001310c    0x24    bxne lr
    0xe0013110    0x28    b e00130d0 <scheduleTCB.part.165>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `scheduleTCB` has 20 nodes.

Section scheduleTCB_part_165 (151 of 299)
=========================================

Deriving specifications
-----------------------

Section `scheduleTCB_part_165` consists of 6 instructions.
 BXLS..++


Stack analysis
---------------

No stack accesses found. Code for `scheduleTCB_part_165`:

    0xe00130d0     0x0    ldr r3, [r0, #80] 
    0xe00130d4     0x4    and r3, r3, #15
    0xe00130d8     0x8    sub r3, r3, #1
    0xe00130dc     0xc    cmp r3, #1
    0xe00130e0    0x10    bxls lr
    0xe00130e4    0x14    b e0013098 <rescheduleRequired>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `scheduleTCB_part_165` has 11 nodes.

Section rescheduleRequired (152 of 299)
=======================================

Deriving specifications
-----------------------

Section `rescheduleRequired` consists of 14 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `rescheduleRequired`:

    0xe0013098     0x0    push {r4, lr}         ; stack access
    0xe001309c     0x4    movw r4, #36892 
    0xe00130a0     0x8    movt r4, #57346 
    0xe00130a4     0xc    ldr r0, [r4]
    0xe00130a8    0x10    cmp r0, #1
    0xe00130ac    0x14    bls e00130bc <rescheduleRequired+0x24>
    0xe00130b0    0x18    ldr r3, [r0, #84] 
    0xe00130b4    0x1c    tst r3, #1
    0xe00130b8    0x20    beq e00130c8 <rescheduleRequired+0x30>
    0xe00130bc    0x24    mov r3, #1
    0xe00130c0    0x28    str r3, [r4]
    0xe00130c4    0x2c    pop {r4, pc}          ; stack access
    0xe00130c8    0x30    bl e00107d8 <tcbSchedEnqueue.part.164>
    0xe00130cc    0x34    b e00130bc <rescheduleRequired+0x24>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `rescheduleRequired` has 24 nodes.

Section switchToIdleThread (153 of 299)
=======================================

Deriving specifications
-----------------------

Section `switchToIdleThread` consists of 10 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `switchToIdleThread`:

    0xe0013068     0x0    push {r4, lr}         ; stack access
    0xe001306c     0x4    movw r4, #36880 
    0xe0013070     0x8    movt r4, #57346 
    0xe0013074     0xc    ldr r0, [r4]
    0xe0013078    0x10    bl e0011294 <setVMRoot>
    0xe001307c    0x14    ldr r2, [r4]
    0xe0013080    0x18    movw r3, #13900 
    0xe0013084    0x1c    movt r3, #57347 
    0xe0013088    0x20    str r2, [r3]
    0xe001308c    0x24    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `switchToIdleThread` has 16 nodes.

Section doFaultTransfer (154 of 299)
====================================

Deriving specifications
-----------------------

Section `doFaultTransfer` consists of 16 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `doFaultTransfer`:

    0xe001301c     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0013020     0x4    mov r4, r2
    0xe0013024     0x8    mov r5, r1
    0xe0013028     0xc    mov r6, r0
    0xe001302c    0x10    mov r2, r3
    0xe0013030    0x14    mov r1, r4
    0xe0013034    0x18    mov r0, r5
    0xe0013038    0x1c    bl e0010a8c <setMRs_fault>
    0xe001303c    0x20    ldr r3, [r5, #96] 
    0xe0013040    0x24    str r6, [r4]
    0xe0013044    0x28    lsl r3, r3, #12
    0xe0013048    0x2c    uxth r3, r3
    0xe001304c    0x30    and r0, r0, #127 
    0xe0013050    0x34    orr r3, r3, r0
    0xe0013054    0x38    str r3, [r4, #4]
    0xe0013058    0x3c    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doFaultTransfer` has 22 nodes.

Section lookupTargetSlot (155 of 299)
=====================================

Deriving specifications
-----------------------

Section `lookupTargetSlot` consists of 14 instructions.


Stack analysis
---------------

Section `lookupTargetSlot` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `lookupTargetSlot`:

    0xe0012fe4     0x0    push {r4, lr}         ; stack access
    0xe0012fe8     0x4    sub sp, sp, #16
    0xe0012fec     0x8    add ip, sp, #8
    0xe0012ff0     0xc    mov r4, r0
    0xe0012ff4    0x10    ldr lr, [sp, #24]     ; stack access
    0xe0012ff8    0x14    str r3, [sp]          ; stack access
    0xe0012ffc    0x18    stm ip, {r1, r2}      ; stack access
    0xe0013000    0x1c    mov r1, #0
    0xe0013004    0x20    ldm ip, {r2, r3}      ; stack access
    0xe0013008    0x24    str lr, [sp, #4]      ; stack access
    0xe001300c    0x28    bl e0012e24 <lookupSlotForCNodeOp>
    0xe0013010    0x2c    mov r0, r4
    0xe0013014    0x30    add sp, sp, #16
    0xe0013018    0x34    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupTargetSlot` has 22 nodes.

Section lookupPivotSlot (156 of 299)
====================================

Deriving specifications
-----------------------

Section `lookupPivotSlot` consists of 12 instructions.
 LDMIA;2,1...+


Stack analysis
---------------

Section `lookupPivotSlot` expects pointer to stack in r0.
6 stack accesses found. Annotated code for `lookupPivotSlot`:

    0xe0012fb4     0x0    push {r4, lr}         ; stack access
    0xe0012fb8     0x4    sub sp, sp, #16
    0xe0012fbc     0x8    add ip, sp, #8
    0xe0012fc0     0xc    mov r4, r0
    0xe0012fc4    0x10    ldr lr, [sp, #24]     ; stack access
    0xe0012fc8    0x14    stm ip, {r1, r2}      ; stack access
    0xe0012fcc    0x18    ldm ip, {r1, r2}      ; stack access
    0xe0012fd0    0x1c    str lr, [sp]          ; stack access
    0xe0012fd4    0x20    bl e0012f7c <lookupSourceSlot>
    0xe0012fd8    0x24    mov r0, r4
    0xe0012fdc    0x28    add sp, sp, #16
    0xe0012fe0    0x2c    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupPivotSlot` has 19 nodes.

Section lookupSourceSlot (157 of 299)
=====================================

Deriving specifications
-----------------------

Section `lookupSourceSlot` consists of 14 instructions.


Stack analysis
---------------

Section `lookupSourceSlot` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `lookupSourceSlot`:

    0xe0012f7c     0x0    push {r4, lr}         ; stack access
    0xe0012f80     0x4    sub sp, sp, #16
    0xe0012f84     0x8    add ip, sp, #8
    0xe0012f88     0xc    mov r4, r0
    0xe0012f8c    0x10    ldr lr, [sp, #24]     ; stack access
    0xe0012f90    0x14    str r3, [sp]          ; stack access
    0xe0012f94    0x18    stm ip, {r1, r2}      ; stack access
    0xe0012f98    0x1c    mov r1, #1
    0xe0012f9c    0x20    ldm ip, {r2, r3}      ; stack access
    0xe0012fa0    0x24    str lr, [sp, #4]      ; stack access
    0xe0012fa4    0x28    bl e0012e24 <lookupSlotForCNodeOp>
    0xe0012fa8    0x2c    mov r0, r4
    0xe0012fac    0x30    add sp, sp, #16
    0xe0012fb0    0x34    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSourceSlot` has 22 nodes.

Section lookupSlotForCNodeOp (158 of 299)
=========================================

Deriving specifications
-----------------------

Section `lookupSlotForCNodeOp` consists of 86 instructions.


Stack analysis
---------------

Section `lookupSlotForCNodeOp` expects pointer to stack in r0.
18 stack accesses found. Annotated code for `lookupSlotForCNodeOp`:

    0xe0012e24      0x0    push {r4, r5, lr}     ; stack access
    0xe0012e28      0x4    sub sp, sp, #36 
    0xe0012e2c      0x8    add ip, sp, #8
    0xe0012e30      0xc    mov r5, r1
    0xe0012e34     0x10    mov r4, r0
    0xe0012e38     0x14    stm ip, {r2, r3}      ; stack access
    0xe0012e3c     0x18    mov r3, r2
    0xe0012e40     0x1c    and r1, r3, #14
    0xe0012e44     0x20    ldr r2, [sp, #52]     ; stack access
    0xe0012e48     0x24    cmp r1, #14
    0xe0012e4c     0x28    andne r3, r3, #15
    0xe0012e50     0x2c    uxtbeq r3, r3
    0xe0012e54     0x30    cmp r3, #10
    0xe0012e58     0x34    bne e0012eac <lookupSlotForCNodeOp+0x88>
    0xe0012e5c     0x38    sub r3, r2, #1
    0xe0012e60     0x3c    cmp r3, #31
    0xe0012e64     0x40    bhi e0012ee8 <lookupSlotForCNodeOp+0xc4>
    0xe0012e68     0x44    str r2, [sp]          ; stack access
    0xe0012e6c     0x48    add r0, sp, #20
    0xe0012e70     0x4c    ldr r3, [sp, #48]     ; stack access
    0xe0012e74     0x50    ldm ip, {r1, r2}      ; stack access
    0xe0012e78     0x54    bl e0012bd0 <resolveAddressBits>
    0xe0012e7c     0x58    ldr r2, [sp, #20]     ; stack access
    0xe0012e80     0x5c    ldr r3, [sp, #28]     ; stack access
    0xe0012e84     0x60    cmp r2, #0
    0xe0012e88     0x64    bne e0012f18 <lookupSlotForCNodeOp+0xf4>
    0xe0012e8c     0x68    cmp r3, #0
    0xe0012e90     0x6c    streq r3, [r4]        ; stack access
    0xe0012e94     0x70    ldreq r2, [sp, #24]   ; stack access
    0xe0012e98     0x74    streq r2, [r4, #4]    ; stack access
    0xe0012e9c     0x78    bne e0012f3c <lookupSlotForCNodeOp+0x118>
    0xe0012ea0     0x7c    mov r0, r4
    0xe0012ea4     0x80    add sp, sp, #36 
    0xe0012ea8     0x84    pop {r4, r5, pc}      ; stack access
    0xe0012eac     0x88    movw r2, #36896 
    0xe0012eb0     0x8c    movw r3, #36884 
    0xe0012eb4     0x90    movt r2, #57346 
    0xe0012eb8     0x94    movt r3, #57346 
    0xe0012ebc     0x98    mov r1, #0
    0xe0012ec0     0x9c    mov ip, #6
    0xe0012ec4     0xa0    mov r0, #3
    0xe0012ec8     0xa4    str r5, [r2, #20]
    0xe0012ecc     0xa8    strd r0, [r4]         ; stack access
    0xe0012ed0     0xac    mov r0, r4
    0xe0012ed4     0xb0    str ip, [r2, #24]
    0xe0012ed8     0xb4    str r1, [r3]
    0xe0012edc     0xb8    str r1, [r3, #4]
    0xe0012ee0     0xbc    add sp, sp, #36 
    0xe0012ee4     0xc0    pop {r4, r5, pc}      ; stack access
    0xe0012ee8     0xc4    movw r3, #36896 
    0xe0012eec     0xc8    movt r3, #57346 
    0xe0012ef0     0xcc    mov r1, #4
    0xe0012ef4     0xd0    mov r2, #1
    0xe0012ef8     0xd4    str r1, [r3, #24]
    0xe0012efc     0xd8    mov r1, #32
    0xe0012f00     0xdc    str r2, [r3, #8]
    0xe0012f04     0xe0    mov r2, #3
    0xe0012f08     0xe4    str r1, [r3, #12]
    0xe0012f0c     0xe8    mov r3, #0
    0xe0012f10     0xec    strd r2, [r0]         ; stack access
    0xe0012f14     0xf0    b e0012ea0 <lookupSlotForCNodeOp+0x7c>
    0xe0012f18     0xf4    movw r3, #36896 
    0xe0012f1c     0xf8    movt r3, #57346 
    0xe0012f20     0xfc    mov r0, #6
    0xe0012f24    0x100    mov r1, #3
    0xe0012f28    0x104    mov r2, #0
    0xe0012f2c    0x108    str r5, [r3, #20]
    0xe0012f30    0x10c    str r0, [r3, #24]
    0xe0012f34    0x110    stm r4, {r1, r2}      ; stack access
    0xe0012f38    0x114    b e0012ea0 <lookupSlotForCNodeOp+0x7c>
    0xe0012f3c    0x118    lsl r3, r3, #2
    0xe0012f40    0x11c    movw r0, #36884 
    0xe0012f44    0x120    movw r1, #36896 
    0xe0012f48    0x124    movt r0, #57346 
    0xe0012f4c    0x128    movt r1, #57346 
    0xe0012f50    0x12c    uxtb r3, r3
    0xe0012f54    0x130    orr r3, r3, #2
    0xe0012f58    0x134    mov ip, #6
    0xe0012f5c    0x138    str r3, [r0]
    0xe0012f60    0x13c    mov r3, #3
    0xe0012f64    0x140    str r2, [r4, #4]      ; stack access
    0xe0012f68    0x144    str r2, [r0, #4]
    0xe0012f6c    0x148    str r5, [r1, #20]
    0xe0012f70    0x14c    str ip, [r1, #24]
    0xe0012f74    0x150    str r3, [r4]          ; stack access
    0xe0012f78    0x154    b e0012ea0 <lookupSlotForCNodeOp+0x7c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
86 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSlotForCNodeOp` has 136 nodes.

Section lookupCapAndSlot (159 of 299)
=====================================

Deriving specifications
-----------------------

Section `lookupCapAndSlot` consists of 22 instructions.
 STMIB;3,1,0....+


Stack analysis
---------------

Section `lookupCapAndSlot` expects pointer to stack in r0.
10 stack accesses found. Annotated code for `lookupCapAndSlot`:

    0xe0012dcc     0x0    push {r4, lr}         ; stack access
    0xe0012dd0     0x4    sub sp, sp, #8
    0xe0012dd4     0x8    mov r4, r0
    0xe0012dd8     0xc    mov r0, sp
    0xe0012ddc    0x10    bl e0012d38 <lookupSlot>
    0xe0012de0    0x14    ldrd r2, [sp]         ; stack access
    0xe0012de4    0x18    cmp r2, #0
    0xe0012de8    0x1c    bne e0012e04 <lookupCapAndSlot+0x38>
    0xe0012dec    0x20    ldrd r0, [r3]
    0xe0012df0    0x24    str r2, [r4]          ; stack access
    0xe0012df4    0x28    stmib r4, {r0, r1, r3}  ; stack access
    0xe0012df8    0x2c    mov r0, r4
    0xe0012dfc    0x30    add sp, sp, #8
    0xe0012e00    0x34    pop {r4, pc}          ; stack access
    0xe0012e04    0x38    mov r3, #0
    0xe0012e08    0x3c    mov r0, r4
    0xe0012e0c    0x40    str r2, [r4]          ; stack access
    0xe0012e10    0x44    str r3, [r4, #4]      ; stack access
    0xe0012e14    0x48    str r3, [r4, #8]      ; stack access
    0xe0012e18    0x4c    str r3, [r4, #12]     ; stack access
    0xe0012e1c    0x50    add sp, sp, #8
    0xe0012e20    0x54    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupCapAndSlot` has 36 nodes.

Section lookupCap (160 of 299)
==============================

Deriving specifications
-----------------------

Section `lookupCap` consists of 18 instructions.
 LDMIAEQ;3,1....++
 STMIBEQ;3,1....++


Stack analysis
---------------

Section `lookupCap` expects pointer to stack in r0.
9 stack accesses found. Annotated code for `lookupCap`:

    0xe0012d84     0x0    push {r4, lr}         ; stack access
    0xe0012d88     0x4    sub sp, sp, #8
    0xe0012d8c     0x8    mov r4, r0
    0xe0012d90     0xc    mov r0, sp
    0xe0012d94    0x10    bl e0012d38 <lookupSlot>
    0xe0012d98    0x14    ldr r3, [sp]          ; stack access
    0xe0012d9c    0x18    mov r0, r4
    0xe0012da0    0x1c    cmp r3, #0
    0xe0012da4    0x20    streq r3, [r4]        ; stack access
    0xe0012da8    0x24    ldreq r2, [sp, #4]    ; stack access
    0xe0012dac    0x28    strne r3, [r4]        ; stack access
    0xe0012db0    0x2c    movne r3, #0
    0xe0012db4    0x30    strne r3, [r4, #4]    ; stack access
    0xe0012db8    0x34    strne r3, [r4, #8]    ; stack access
    0xe0012dbc    0x38    ldmeq r2, {r1, r3}
    0xe0012dc0    0x3c    stmibeq r4, {r1, r3}  ; stack access
    0xe0012dc4    0x40    add sp, sp, #8
    0xe0012dc8    0x44    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupCap` has 45 nodes.

Section lookupSlot (161 of 299)
===============================

Deriving specifications
-----------------------

Section `lookupSlot` consists of 19 instructions.


Stack analysis
---------------

Section `lookupSlot` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `lookupSlot`:

    0xe0012d38     0x0    bic r1, r1, #508 
    0xe0012d3c     0x4    mov r3, r2
    0xe0012d40     0x8    bic r1, r1, #3
    0xe0012d44     0xc    mov r2, #32
    0xe0012d48    0x10    push {r4, lr}         ; stack access
    0xe0012d4c    0x14    mov r4, r0
    0xe0012d50    0x18    sub sp, sp, #32
    0xe0012d54    0x1c    ldm r1, {r0, r1}
    0xe0012d58    0x20    add ip, sp, #12
    0xe0012d5c    0x24    str r2, [sp]          ; stack access
    0xe0012d60    0x28    stm ip, {r0, r1}      ; stack access
    0xe0012d64    0x2c    add r0, sp, #20
    0xe0012d68    0x30    ldm ip, {r1, r2}      ; stack access
    0xe0012d6c    0x34    bl e0012bd0 <resolveAddressBits>
    0xe0012d70    0x38    ldrd r2, [sp, #20]    ; stack access
    0xe0012d74    0x3c    mov r0, r4
    0xe0012d78    0x40    strd r2, [r4]         ; stack access
    0xe0012d7c    0x44    add sp, sp, #32
    0xe0012d80    0x48    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lookupSlot` has 28 nodes.

Section cleanInvalidateL1Caches (162 of 299)
============================================

Deriving specifications
-----------------------

Section `cleanInvalidateL1Caches` consists of 9 instructions.
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee073f15 mcr 15, 0, r3, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `cleanInvalidateL1Caches`:

    0xe00129ac     0x0    push {r4, lr}         ; stack access
    0xe00129b0     0x4    dsb sy
    0xe00129b4     0x8    bl e0012410 <cleanInvalidate_D_PoC>
    0xe00129b8     0xc    dsb sy
    0xe00129bc    0x10    mov r3, #0
    0xe00129c0    0x14    mcr 15, 0, r3, cr7, cr5, {0}
    0xe00129c4    0x18    isb sy
    0xe00129c8    0x1c    dsb sy
    0xe00129cc    0x20    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanInvalidateL1Caches` has 17 nodes.

Section cleanCaches_PoU (163 of 299)
====================================

Deriving specifications
-----------------------

Section `cleanCaches_PoU` consists of 9 instructions.
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee073f15 mcr 15, 0, r3, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `cleanCaches_PoU`:

    0xe0012988     0x0    push {r4, lr}         ; stack access
    0xe001298c     0x4    dsb sy
    0xe0012990     0x8    bl e00120a8 <clean_D_PoU>
    0xe0012994     0xc    dsb sy
    0xe0012998    0x10    mov r3, #0
    0xe001299c    0x14    mcr 15, 0, r3, cr7, cr5, {0}
    0xe00129a0    0x18    isb sy
    0xe00129a4    0x1c    dsb sy
    0xe00129a8    0x20    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cleanCaches_PoU` has 17 nodes.

Section invalidateCacheRange_RAM (164 of 299)
=============================================

Deriving specifications
-----------------------

Section `invalidateCacheRange_RAM` consists of 52 instructions.
Skipping f57ff05f dmb sy
Skipping ee073f36 mcr 15, 0, r3, cr7, cr6, {1}
Skipping f57ff05f dmb sy
Skipping f57ff04f dsb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `invalidateCacheRange_RAM`:

    0xe0012710     0x0    tst r0, #31
    0xe0012714     0x4    push {r4, r5, r6, lr}  ; stack access
    0xe0012718     0x8    mov r4, r0
    0xe001271c     0xc    mov r5, r1
    0xe0012720    0x10    mov r6, r2
    0xe0012724    0x14    beq e0012730 <invalidateCacheRange_RAM+0x20>
    0xe0012728    0x18    mov r1, r0
    0xe001272c    0x1c    bl e001264c <cleanCacheRange_RAM>
    0xe0012730    0x20    add r3, r5, #1
    0xe0012734    0x24    tst r3, #31
    0xe0012738    0x28    beq e0012750 <invalidateCacheRange_RAM+0x40>
    0xe001273c    0x2c    bic r1, r5, #31
    0xe0012740    0x30    add r2, r6, r1
    0xe0012744    0x34    sub r2, r2, r4
    0xe0012748    0x38    mov r0, r1
    0xe001274c    0x3c    bl e001264c <cleanCacheRange_RAM>
    0xe0012750    0x40    add r2, r5, #32
    0xe0012754    0x44    bic r3, r6, #31
    0xe0012758    0x48    add r2, r2, r6
    0xe001275c    0x4c    sub r2, r2, r4
    0xe0012760    0x50    bic r2, r2, #31
    0xe0012764    0x54    cmp r3, r2
    0xe0012768    0x58    beq e0012784 <invalidateCacheRange_RAM+0x74>
    0xe001276c    0x5c    movw r1, #12543 
    0xe0012770    0x60    movt r1, #65520 
    0xe0012774    0x64    str r3, [r1, #1649] 
    0xe0012778    0x68    add r3, r3, #32
    0xe001277c    0x6c    cmp r3, r2
    0xe0012780    0x70    bne e0012774 <invalidateCacheRange_RAM+0x64>
    0xe0012784    0x74    dmb sy
    0xe0012788    0x78    movw r3, #12543 
    0xe001278c    0x7c    movt r3, #65520 
    0xe0012790    0x80    mov r1, #0
    0xe0012794    0x84    mov r2, r3
    0xe0012798    0x88    str r1, [r3, #1585] 
    0xe001279c    0x8c    ldr r3, [r2, #1585] 
    0xe00127a0    0x90    tst r3, #1
    0xe00127a4    0x94    bne e001279c <invalidateCacheRange_RAM+0x8c>
    0xe00127a8    0x98    lsr r2, r5, #5
    0xe00127ac    0x9c    lsr r3, r4, #5
    0xe00127b0    0xa0    add r2, r2, #1
    0xe00127b4    0xa4    cmp r3, r2
    0xe00127b8    0xa8    bcs e00127d8 <invalidateCacheRange_RAM+0xc8>
    0xe00127bc    0xac    lsl r3, r3, #5
    0xe00127c0    0xb0    lsl r2, r2, #5
    0xe00127c4    0xb4    mcr 15, 0, r3, cr7, cr6, {1}
    0xe00127c8    0xb8    dmb sy
    0xe00127cc    0xbc    add r3, r3, #32
    0xe00127d0    0xc0    cmp r2, r3
    0xe00127d4    0xc4    bne e00127c4 <invalidateCacheRange_RAM+0xb4>
    0xe00127d8    0xc8    dsb sy
    0xe00127dc    0xcc    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
52 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invalidateCacheRange_RAM` has 77 nodes.

Section lockTLBEntry (165 of 299)
=================================

Deriving specifications
-----------------------

Section `lockTLBEntry` consists of 9 instructions.


Stack analysis
---------------

No stack accesses found. Code for `lockTLBEntry`:

    0xe0012544     0x0    movw r3, #47028 
    0xe0012548     0x4    movt r3, #57345 
    0xe001254c     0x8    ldr r1, [r3]
    0xe0012550     0xc    add r2, r1, #1
    0xe0012554    0x10    str r2, [r3]
    0xe0012558    0x14    lsl r1, r1, #28
    0xe001255c    0x18    lsl r2, r2, #28
    0xe0012560    0x1c    orr r1, r1, #1
    0xe0012564    0x20    b e0010780 <lockTLBEntryCritical>

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `lockTLBEntry` has 12 nodes.

Section flushSpace (166 of 299)
===============================

Deriving specifications
-----------------------

Section `flushSpace` consists of 24 instructions.
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee073f15 mcr 15, 0, r3, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee084f57 mcr 15, 0, r4, cr8, cr7, {2}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

3 stack accesses found. Annotated code for `flushSpace`:

    0xe0012160     0x0    lsr r2, r0, #10
    0xe0012164     0x4    movw r3, #37576 
    0xe0012168     0x8    movt r3, #57346 
    0xe001216c     0xc    ubfx r0, r0, #0, #10
    0xe0012170    0x10    push {r4, lr}         ; stack access
    0xe0012174    0x14    ldr r3, [r3, r2, lsl #2]
    0xe0012178    0x18    ldr r3, [r3, r0, lsl #2]
    0xe001217c    0x1c    add r3, r3, #12288 
    0xe0012180    0x20    ldr r4, [r3, #4032] 
    0xe0012184    0x24    dsb sy
    0xe0012188    0x28    bl e00120a8 <clean_D_PoU>
    0xe001218c    0x2c    dsb sy
    0xe0012190    0x30    mov r3, #0
    0xe0012194    0x34    mcr 15, 0, r3, cr7, cr5, {0}
    0xe0012198    0x38    isb sy
    0xe001219c    0x3c    dsb sy
    0xe00121a0    0x40    tst r4, #8388608 
    0xe00121a4    0x44    popeq {r4, pc}        ; stack access
    0xe00121a8    0x48    dsb sy
    0xe00121ac    0x4c    lsr r4, r4, #24
    0xe00121b0    0x50    mcr 15, 0, r4, cr8, cr7, {2}
    0xe00121b4    0x54    dsb sy
    0xe00121b8    0x58    isb sy
    0xe00121bc    0x5c    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
24 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `flushSpace` has 42 nodes.

Section Arch_setMRs_fault (167 of 299)
======================================

Deriving specifications
-----------------------

Section `Arch_setMRs_fault` consists of 16 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_setMRs_fault`:

    0xe0012068     0x0    cmp r3, #5
    0xe001206c     0x4    bne e00120a0 <Arch_setMRs_fault+0x38>
    0xe0012070     0x8    ldr r3, [r0, #68] 
    0xe0012074     0xc    str r3, [r1, #8]
    0xe0012078    0x10    ldr r3, [r0, #100] 
    0xe001207c    0x14    str r3, [r1, #12]
    0xe0012080    0x18    ldr r3, [r0, #96] 
    0xe0012084    0x1c    ubfx r3, r3, #17, #1
    0xe0012088    0x20    str r3, [r1, #16]
    0xe001208c    0x24    ldr r3, [r0, #96] 
    0xe0012090    0x28    mov r0, #4
    0xe0012094    0x2c    lsr r3, r3, #18
    0xe0012098    0x30    str r3, [r1, #20]
    0xe001209c    0x34    bx lr
    0xe00120a0    0x38    push {r4, lr}         ; stack access
    0xe00120a4    0x3c    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_setMRs_fault` has 29 nodes.

Section Arch_handleFaultReply (168 of 299)
==========================================

Deriving specifications
-----------------------

Section `Arch_handleFaultReply` consists of 6 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_handleFaultReply`:

    0xe0012050     0x0    cmp r2, #5
    0xe0012054     0x4    bne e0012060 <Arch_handleFaultReply+0x10>
    0xe0012058     0x8    mov r0, #1
    0xe001205c     0xc    bx lr
    0xe0012060    0x10    push {r4, lr}         ; stack access
    0xe0012064    0x14    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
6 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_handleFaultReply` has 11 nodes.

Section Arch_createObject (169 of 299)
======================================

Deriving specifications
-----------------------

Section `Arch_createObject` consists of 103 instructions.
Switch found.
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy


Stack analysis
---------------

Section `Arch_createObject` expects pointer to stack in r0.
23 stack accesses found. Annotated code for `Arch_createObject`:

    0xe0011eb0      0x0    sub r1, r1, #5
    0xe0011eb4      0x4    push {r4, lr}         ; stack access
    0xe0011eb8      0x8    cmp r1, #5
    0xe0011ebc      0xc    ldrls pc, [pc, r1, lsl #2]
    0xe0011ec0     0x10    b e0012048 <Arch_createObject+0x198>
    0xe0011ec4     0x14    .word 0xe0011f60
    0xe0011ec8     0x18    .word 0xe0011f90
    0xe0011ecc     0x1c    .word 0xe0011fc4
    0xe0011ed0     0x20    .word 0xe0011ff8
    0xe0011ed4     0x24    .word 0xe001202c
    0xe0011ed8     0x28    .word 0xe0011edc
    0xe0011edc     0x2c    movw ip, #16384 
    0xe0011ee0     0x30    mov r3, #3584 
    0xe0011ee4     0x34    movt ip, #57346 
    0xe0011ee8     0x38    movw lr, #4095 
    0xe0011eec     0x3c    b e0011ef4 <Arch_createObject+0x44>
    0xe0011ef0     0x40    add r3, r3, #1
    0xe0011ef4     0x44    cmp r3, #4080 
    0xe0011ef8     0x48    beq e0011ef0 <Arch_createObject+0x40>
    0xe0011efc     0x4c    ldr r1, [ip, r3, lsl #2]
    0xe0011f00     0x50    cmp r3, lr
    0xe0011f04     0x54    str r1, [r2, r3, lsl #2]
    0xe0011f08     0x58    bne e0011ef0 <Arch_createObject+0x40>
    0xe0011f0c     0x5c    add r1, r2, #16320 
    0xe0011f10     0x60    lsr r3, r2, #5
    0xe0011f14     0x64    add r1, r1, #63 
    0xe0011f18     0x68    lsr r1, r1, #5
    0xe0011f1c     0x6c    add r1, r1, #1
    0xe0011f20     0x70    cmp r3, r1
    0xe0011f24     0x74    bcs e0011f44 <Arch_createObject+0x94>
    0xe0011f28     0x78    lsl r3, r3, #5
    0xe0011f2c     0x7c    lsl r1, r1, #5
    0xe0011f30     0x80    mcr 15, 0, r3, cr7, cr11, {1}
    0xe0011f34     0x84    dmb sy
    0xe0011f38     0x88    add r3, r3, #32
    0xe0011f3c     0x8c    cmp r1, r3
    0xe0011f40     0x90    bne e0011f30 <Arch_createObject+0x80>
    0xe0011f44     0x94    bic r2, r2, #16320 
    0xe0011f48     0x98    mov r3, #0
    0xe0011f4c     0x9c    bic r2, r2, #63 
    0xe0011f50     0xa0    str r3, [r0, #4]      ; stack access
    0xe0011f54     0xa4    orr r2, r2, #9
    0xe0011f58     0xa8    str r2, [r0]          ; stack access
    0xe0011f5c     0xac    pop {r4, pc}          ; stack access
    0xe0011f60     0xb0    movw r3, #65520 
    0xe0011f64     0xb4    movt r3, #255 
    0xe0011f68     0xb8    and r3, r3, r2, lsr #8
    0xe0011f6c     0xbc    ldr r2, [sp, #8]      ; stack access
    0xe0011f70     0xc0    cmp r2, #0
    0xe0011f74     0xc4    movne r2, #-2147483647 
    0xe0011f78     0xc8    moveq r2, #1
    0xe0011f7c     0xcc    orr r3, r2, r3
    0xe0011f80     0xd0    mov r2, #3145728 
    0xe0011f84     0xd4    str r3, [r0]          ; stack access
    0xe0011f88     0xd8    str r2, [r0, #4]      ; stack access
    0xe0011f8c     0xdc    pop {r4, pc}          ; stack access
    0xe0011f90     0xe0    movw r3, #65520 
    0xe0011f94     0xe4    movt r3, #63 
    0xe0011f98     0xe8    and r3, r3, r2, lsr #10
    0xe0011f9c     0xec    ldr r2, [sp, #8]      ; stack access
    0xe0011fa0     0xf0    cmp r2, #0
    0xe0011fa4     0xf4    movne r2, #536870915 
    0xe0011fa8     0xf8    moveq r2, #3
    0xe0011fac     0xfc    orr r3, r2, r3
    0xe0011fb0    0x100    mov r2, #0
    0xe0011fb4    0x104    str r3, [r0]          ; stack access
    0xe0011fb8    0x108    movt r2, #16396 
    0xe0011fbc    0x10c    str r2, [r0, #4]      ; stack access
    0xe0011fc0    0x110    pop {r4, pc}          ; stack access
    0xe0011fc4    0x114    movw r3, #65520 
    0xe0011fc8    0x118    movt r3, #63 
    0xe0011fcc    0x11c    and r3, r3, r2, lsr #10
    0xe0011fd0    0x120    ldr r2, [sp, #8]      ; stack access
    0xe0011fd4    0x124    cmp r2, #0
    0xe0011fd8    0x128    movne r2, #536870915 
    0xe0011fdc    0x12c    moveq r2, #3
    0xe0011fe0    0x130    orr r3, r2, r3
    0xe0011fe4    0x134    mov r2, #0
    0xe0011fe8    0x138    str r3, [r0]          ; stack access
    0xe0011fec    0x13c    movt r2, #32780 
    0xe0011ff0    0x140    str r2, [r0, #4]      ; stack access
    0xe0011ff4    0x144    pop {r4, pc}          ; stack access
    0xe0011ff8    0x148    movw r3, #65520 
    0xe0011ffc    0x14c    movt r3, #63 
    0xe0012000    0x150    and r2, r3, r2, lsr #10
    0xe0012004    0x154    ldr r3, [sp, #8]      ; stack access
    0xe0012008    0x158    cmp r3, #0
    0xe001200c    0x15c    movne r3, #536870915 
    0xe0012010    0x160    moveq r3, #3
    0xe0012014    0x164    orr r3, r3, r2
    0xe0012018    0x168    mov r2, #0
    0xe001201c    0x16c    str r3, [r0]          ; stack access
    0xe0012020    0x170    movt r2, #49164 
    0xe0012024    0x174    str r2, [r0, #4]      ; stack access
    0xe0012028    0x178    pop {r4, pc}          ; stack access
    0xe001202c    0x17c    bic r2, r2, #1020 
    0xe0012030    0x180    mov r3, #0
    0xe0012034    0x184    bic r2, r2, #3
    0xe0012038    0x188    str r3, [r0, #4]      ; stack access
    0xe001203c    0x18c    orr r2, r2, #7
    0xe0012040    0x190    str r2, [r0]          ; stack access
    0xe0012044    0x194    pop {r4, pc}          ; stack access
    0xe0012048    0x198    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
97 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_createObject` has 169 nodes.

Section Arch_getObjectSize (170 of 299)
=======================================

Deriving specifications
-----------------------

Section `Arch_getObjectSize` consists of 24 instructions.
Switch found.


Stack analysis
---------------

1 stack accesses found. Annotated code for `Arch_getObjectSize`:

    0xe0011e50     0x0    sub r0, r0, #5
    0xe0011e54     0x4    cmp r0, #5
    0xe0011e58     0x8    ldrls pc, [pc, r0, lsl #2]
    0xe0011e5c     0xc    b e0011ea8 <Arch_getObjectSize+0x58>
    0xe0011e60    0x10    .word 0xe0011e80
    0xe0011e64    0x14    .word 0xe0011e88
    0xe0011e68    0x18    .word 0xe0011e90
    0xe0011e6c    0x1c    .word 0xe0011e98
    0xe0011e70    0x20    .word 0xe0011ea0
    0xe0011e74    0x24    .word 0xe0011e78
    0xe0011e78    0x28    mov r0, #14
    0xe0011e7c    0x2c    bx lr
    0xe0011e80    0x30    mov r0, #12
    0xe0011e84    0x34    bx lr
    0xe0011e88    0x38    mov r0, #16
    0xe0011e8c    0x3c    bx lr
    0xe0011e90    0x40    mov r0, #20
    0xe0011e94    0x44    bx lr
    0xe0011e98    0x48    mov r0, #24
    0xe0011e9c    0x4c    bx lr
    0xe0011ea0    0x50    mov r0, #10
    0xe0011ea4    0x54    bx lr
    0xe0011ea8    0x58    push {r4, lr}         ; stack access
    0xe0011eac    0x5c    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_getObjectSize` has 45 nodes.

Section Arch_sameObjectAs (171 of 299)
======================================

Deriving specifications
-----------------------

Section `Arch_sameObjectAs` consists of 70 instructions.
 MVN (reg)...++


Stack analysis
---------------

10 stack accesses found. Annotated code for `Arch_sameObjectAs`:

    0xe0011d38      0x0    push {lr}             ; stack access
    0xe0011d3c      0x4    sub sp, sp, #20
    0xe0011d40      0x8    add ip, sp, #8
    0xe0011d44      0xc    mov lr, sp
    0xe0011d48     0x10    stm lr, {r2, r3}      ; stack access
    0xe0011d4c     0x14    and r2, r0, #14
    0xe0011d50     0x18    cmp r2, #14
    0xe0011d54     0x1c    stm ip, {r0, r1}      ; stack access
    0xe0011d58     0x20    andne r2, r0, #15
    0xe0011d5c     0x24    uxtbeq r2, r0
    0xe0011d60     0x28    cmp r2, #1
    0xe0011d64     0x2c    mov r1, r0
    0xe0011d68     0x30    ldr r3, [sp]          ; stack access
    0xe0011d6c     0x34    beq e0011db8 <Arch_sameObjectAs+0x80>
    0xe0011d70     0x38    cmp r2, #3
    0xe0011d74     0x3c    beq e0011d8c <Arch_sameObjectAs+0x54>
    0xe0011d78     0x40    ldm lr, {r2, r3}      ; stack access
    0xe0011d7c     0x44    ldm ip, {r0, r1}      ; stack access
    0xe0011d80     0x48    add sp, sp, #20
    0xe0011d84     0x4c    pop {lr}              ; stack access
    0xe0011d88     0x50    b e0011a14 <Arch_sameRegionAs>
    0xe0011d8c     0x54    and r2, r3, #14
    0xe0011d90     0x58    cmp r2, #14
    0xe0011d94     0x5c    andne r2, r3, #15
    0xe0011d98     0x60    uxtbeq r2, r3
    0xe0011d9c     0x64    cmp r2, #3
    0xe0011da0     0x68    beq e0011ddc <Arch_sameObjectAs+0xa4>
    0xe0011da4     0x6c    cmp r2, #1
    0xe0011da8     0x70    bne e0011d78 <Arch_sameObjectAs+0x40>
    0xe0011dac     0x74    mov r0, #0
    0xe0011db0     0x78    add sp, sp, #20
    0xe0011db4     0x7c    pop {pc}              ; stack access
    0xe0011db8     0x80    and r2, r3, #14
    0xe0011dbc     0x84    cmp r2, #14
    0xe0011dc0     0x88    andne r2, r3, #15
    0xe0011dc4     0x8c    uxtbeq r2, r3
    0xe0011dc8     0x90    cmp r2, #1
    0xe0011dcc     0x94    beq e0011e20 <Arch_sameObjectAs+0xe8>
    0xe0011dd0     0x98    cmp r2, #3
    0xe0011dd4     0x9c    bne e0011d78 <Arch_sameObjectAs+0x40>
    0xe0011dd8     0xa0    b e0011dac <Arch_sameObjectAs+0x74>
    0xe0011ddc     0xa4    mov r2, #49152 
    0xe0011de0     0xa8    movt r2, #65535 
    0xe0011de4     0xac    and r0, r2, r3, lsl #10
    0xe0011de8     0xb0    and r2, r2, r1, lsl #10
    0xe0011dec     0xb4    cmp r0, r2
    0xe0011df0     0xb8    bne e0011dac <Arch_sameObjectAs+0x74>
    0xe0011df4     0xbc    ldr r2, [sp, #12]     ; stack access
    0xe0011df8     0xc0    ldr r0, [sp, #4]      ; stack access
    0xe0011dfc     0xc4    lsr r2, r2, #30
    0xe0011e00     0xc8    cmp r2, r0, lsr #30
    0xe0011e04     0xcc    bne e0011dac <Arch_sameObjectAs+0x74>
    0xe0011e08     0xd0    mvn r0, r3, lsr #29
    0xe0011e0c     0xd4    ubfx r2, r1, #29, #1
    0xe0011e10     0xd8    and r0, r0, #1
    0xe0011e14     0xdc    subs r0, r0, r2
    0xe0011e18     0xe0    movne r0, #1
    0xe0011e1c     0xe4    b e0011db0 <Arch_sameObjectAs+0x78>
    0xe0011e20     0xe8    mov r2, #61440 
    0xe0011e24     0xec    movt r2, #65535 
    0xe0011e28     0xf0    and r0, r2, r3, lsl #8
    0xe0011e2c     0xf4    and r2, r2, r1, lsl #8
    0xe0011e30     0xf8    cmp r0, r2
    0xe0011e34     0xfc    bne e0011dac <Arch_sameObjectAs+0x74>
    0xe0011e38    0x100    lsr r3, r3, #31
    0xe0011e3c    0x104    eor r3, r3, #1
    0xe0011e40    0x108    cmp r3, r1, lsr #31
    0xe0011e44    0x10c    movne r0, #1
    0xe0011e48    0x110    moveq r0, #0
    0xe0011e4c    0x114    b e0011db0 <Arch_sameObjectAs+0x78>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
70 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_sameObjectAs` has 117 nodes.

Section Arch_maskCapRights (172 of 299)
=======================================

Deriving specifications
-----------------------

Section `Arch_maskCapRights` consists of 40 instructions.
 LDMIA;4,2...+


Stack analysis
---------------

Section `Arch_maskCapRights` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `Arch_maskCapRights`:

    0xe0011974     0x0    push {r4, lr}         ; stack access
    0xe0011978     0x4    sub sp, sp, #8
    0xe001197c     0x8    add ip, sp, #8
    0xe0011980     0xc    stmdb ip, {r2, r3}    ; stack access
    0xe0011984    0x10    mov r3, r0
    0xe0011988    0x14    ldm sp, {r2, r4}      ; stack access
    0xe001198c    0x18    and r0, r2, #14
    0xe0011990    0x1c    cmp r0, #14
    0xe0011994    0x20    andne r0, r2, #15
    0xe0011998    0x24    uxtbeq r0, r2
    0xe001199c    0x28    cmp r0, #1
    0xe00119a0    0x2c    beq e00119e8 <Arch_maskCapRights+0x74>
    0xe00119a4    0x30    cmp r0, #3
    0xe00119a8    0x34    beq e00119bc <Arch_maskCapRights+0x48>
    0xe00119ac    0x38    mov r0, r3
    0xe00119b0    0x3c    stm r3, {r2, r4}      ; stack access
    0xe00119b4    0x40    add sp, sp, #8
    0xe00119b8    0x44    pop {r4, pc}          ; stack access
    0xe00119bc    0x48    ubfx r0, r4, #18, #2
    0xe00119c0    0x4c    bic r4, r4, #786432 
    0xe00119c4    0x50    bl e0010cb8 <maskVMRights>
    0xe00119c8    0x54    lsl r0, r0, #18
    0xe00119cc    0x58    str r2, [r3]
    0xe00119d0    0x5c    and r0, r0, #786432 
    0xe00119d4    0x60    orr r4, r0, r4
    0xe00119d8    0x64    mov r0, r3
    0xe00119dc    0x68    str r4, [r3, #4]
    0xe00119e0    0x6c    add sp, sp, #8
    0xe00119e4    0x70    pop {r4, pc}          ; stack access
    0xe00119e8    0x74    ubfx r0, r4, #20, #2
    0xe00119ec    0x78    bic r4, r4, #3145728 
    0xe00119f0    0x7c    bl e0010cb8 <maskVMRights>
    0xe00119f4    0x80    lsl r0, r0, #20
    0xe00119f8    0x84    str r2, [r3]
    0xe00119fc    0x88    and r0, r0, #3145728 
    0xe0011a00    0x8c    orr r4, r0, r4
    0xe0011a04    0x90    mov r0, r3
    0xe0011a08    0x94    str r4, [r3, #4]
    0xe0011a0c    0x98    add sp, sp, #8
    0xe0011a10    0x9c    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
40 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_maskCapRights` has 61 nodes.

Section Arch_deriveCap (173 of 299)
===================================

Deriving specifications
-----------------------

Section `Arch_deriveCap` consists of 68 instructions.
Switch found.


Stack analysis
---------------

Section `Arch_deriveCap` expects pointer to stack in r0.
19 stack accesses found. Annotated code for `Arch_deriveCap`:

    0xe0011840      0x0    push {lr}             ; stack access
    0xe0011844      0x4    sub sp, sp, #12
    0xe0011848      0x8    add r1, sp, #8
    0xe001184c      0xc    stmdb r1, {r2, r3}    ; stack access
    0xe0011850     0x10    ldr r3, [sp]          ; stack access
    0xe0011854     0x14    ldr r1, [sp, #4]      ; stack access
    0xe0011858     0x18    and r2, r3, #14
    0xe001185c     0x1c    cmp r2, #14
    0xe0011860     0x20    andne r2, r3, #15
    0xe0011864     0x24    uxtbeq r2, r3
    0xe0011868     0x28    sub r2, r2, #1
    0xe001186c     0x2c    cmp r2, #10
    0xe0011870     0x30    ldrls pc, [pc, r2, lsl #2]
    0xe0011874     0x34    b e001194c <Arch_deriveCap+0x10c>
    0xe0011878     0x38    .word 0xe001192c
    0xe001187c     0x3c    .word 0xe001194c
    0xe0011880     0x40    .word 0xe0011908
    0xe0011884     0x44    .word 0xe001194c
    0xe0011888     0x48    .word 0xe00118f0
    0xe001188c     0x4c    .word 0xe001194c
    0xe0011890     0x50    .word 0xe00118dc
    0xe0011894     0x54    .word 0xe001194c
    0xe0011898     0x58    .word 0xe00118a4
    0xe001189c     0x5c    .word 0xe001194c
    0xe00118a0     0x60    .word 0xe00118f0
    0xe00118a4     0x64    ubfx r2, r3, #4, #1
    0xe00118a8     0x68    cmp r2, #0
    0xe00118ac     0x6c    bne e00118e8 <Arch_deriveCap+0xa8>
    0xe00118b0     0x70    movw r3, #36896 
    0xe00118b4     0x74    movt r3, #57346 
    0xe00118b8     0x78    mov r1, r2
    0xe00118bc     0x7c    mov ip, #3
    0xe00118c0     0x80    mov r2, ip
    0xe00118c4     0x84    str ip, [r3, #24]
    0xe00118c8     0x88    mov r3, r1
    0xe00118cc     0x8c    strd r2, [r0]         ; stack access
    0xe00118d0     0x90    str r1, [r0, #8]      ; stack access
    0xe00118d4     0x94    add sp, sp, #12
    0xe00118d8     0x98    pop {pc}              ; stack access
    0xe00118dc     0x9c    ubfx r2, r1, #29, #1
    0xe00118e0     0xa0    cmp r2, #0
    0xe00118e4     0xa4    beq e00118b0 <Arch_deriveCap+0x70>
    0xe00118e8     0xa8    mov r2, #0
    0xe00118ec     0xac    b e00118cc <Arch_deriveCap+0x8c>
    0xe00118f0     0xb0    str r3, [r0, #4]      ; stack access
    0xe00118f4     0xb4    mov r3, #0
    0xe00118f8     0xb8    str r1, [r0, #8]      ; stack access
    0xe00118fc     0xbc    str r3, [r0]          ; stack access
    0xe0011900     0xc0    add sp, sp, #12
    0xe0011904     0xc4    pop {pc}              ; stack access
    0xe0011908     0xc8    bic r1, r1, #1069547520 
    0xe001190c     0xcc    bic r3, r3, #532676608 
    0xe0011910     0xd0    bic r1, r1, #3145728 
    0xe0011914     0xd4    str r3, [r0, #4]      ; stack access
    0xe0011918     0xd8    str r1, [r0, #8]      ; stack access
    0xe001191c     0xdc    mov r3, #0
    0xe0011920     0xe0    str r3, [r0]          ; stack access
    0xe0011924     0xe4    add sp, sp, #12
    0xe0011928     0xe8    pop {pc}              ; stack access
    0xe001192c     0xec    bic r3, r3, #2130706432 
    0xe0011930     0xf0    ubfx r1, r1, #0, #22
    0xe0011934     0xf4    str r3, [r0, #4]      ; stack access
    0xe0011938     0xf8    mov r3, #0
    0xe001193c     0xfc    str r1, [r0, #8]      ; stack access
    0xe0011940    0x100    str r3, [r0]          ; stack access
    0xe0011944    0x104    add sp, sp, #12
    0xe0011948    0x108    pop {pc}              ; stack access
    0xe001194c    0x10c    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
57 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_deriveCap` has 120 nodes.

Section handleVMFault (174 of 299)
==================================

Deriving specifications
-----------------------

Section `handleVMFault` consists of 27 instructions.
Skipping ee150f30 mrc 15, 0, r0, cr5, cr0, {1}
Skipping ee161f10 mrc 15, 0, r1, cr6, cr0, {0}
Skipping ee153f10 mrc 15, 0, r3, cr5, cr0, {0}


Stack analysis
---------------

1 stack accesses found. Annotated code for `handleVMFault`:

    0xe001144c     0x0    cmp r1, #0
    0xe0011450     0x4    beq e0011488 <handleVMFault+0x3c>
    0xe0011454     0x8    cmp r1, #1
    0xe0011458     0xc    bne e00114b0 <handleVMFault+0x64>
    0xe001145c    0x10    ldr r1, [r0, #68] 
    0xe0011460    0x14    mrc 15, 0, r0, cr5, cr0, {1}
    0xe0011464    0x18    movw r3, #32768 
    0xe0011468    0x1c    movt r3, #57346 
    0xe001146c    0x20    mov r2, #5
    0xe0011470    0x24    movt r2, #2
    0xe0011474    0x28    orr r2, r2, r0, lsl #18
    0xe0011478    0x2c    str r1, [r3, #4]
    0xe001147c    0x30    str r2, [r3]
    0xe0011480    0x34    mov r0, #1
    0xe0011484    0x38    bx lr
    0xe0011488    0x3c    mrc 15, 0, r1, cr6, cr0, {0}
    0xe001148c    0x40    mrc 15, 0, r3, cr5, cr0, {0}
    0xe0011490    0x44    movw r2, #32768 
    0xe0011494    0x48    movt r2, #57346 
    0xe0011498    0x4c    lsl r3, r3, #18
    0xe001149c    0x50    mov r0, #1
    0xe00114a0    0x54    orr r3, r3, #5
    0xe00114a4    0x58    str r1, [r2, #4]
    0xe00114a8    0x5c    str r3, [r2]
    0xe00114ac    0x60    bx lr
    0xe00114b0    0x64    push {r4, lr}         ; stack access
    0xe00114b4    0x68    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
27 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleVMFault` has 43 nodes.

Section setVMRootForFlush (175 of 299)
======================================

Deriving specifications
-----------------------

Section `setVMRootForFlush` consists of 40 instructions.
Skipping f57ff04f dsb sy
Skipping ee023f10 mcr 15, 0, r3, cr2, cr0, {0}
Skipping f57ff06f isb sy
Skipping ee0d0f30 mcr 15, 0, r0, cr13, cr0, {1}
Skipping f57ff06f isb sy
Skipping ee020f10 mcr 15, 0, r0, cr2, cr0, {0}
Skipping f57ff06f isb sy


Stack analysis
---------------

3 stack accesses found. Annotated code for `setVMRootForFlush`:

    0xe001137c     0x0    movw r2, #13900 
    0xe0011380     0x4    movt r2, #57347 
    0xe0011384     0x8    push {r4, lr}         ; stack access
    0xe0011388     0xc    mov r4, r0
    0xe001138c    0x10    ldr r2, [r2]
    0xe0011390    0x14    bic r2, r2, #508 
    0xe0011394    0x18    bic r2, r2, #3
    0xe0011398    0x1c    ldr r2, [r2, #16]
    0xe001139c    0x20    and r0, r2, #14
    0xe00113a0    0x24    cmp r0, #14
    0xe00113a4    0x28    andne r0, r2, #15
    0xe00113a8    0x2c    uxtbeq r0, r2
    0xe00113ac    0x30    cmp r0, #9
    0xe00113b0    0x34    bne e00113cc <setVMRootForFlush+0x50>
    0xe00113b4    0x38    tst r2, #16
    0xe00113b8    0x3c    beq e00113cc <setVMRootForFlush+0x50>
    0xe00113bc    0x40    bic r2, r2, #16320 
    0xe00113c0    0x44    bic r2, r2, #63 
    0xe00113c4    0x48    cmp r4, r2
    0xe00113c8    0x4c    beq e0011410 <setVMRootForFlush+0x94>
    0xe00113cc    0x50    mov r0, r1
    0xe00113d0    0x54    bl e0011230 <getHWASID>
    0xe00113d4    0x58    dsb sy
    0xe00113d8    0x5c    ldr r3, [pc, #56] 
    0xe00113dc    0x60    orr r3, r3, #24
    0xe00113e0    0x64    mcr 15, 0, r3, cr2, cr0, {0}
    0xe00113e4    0x68    isb sy
    0xe00113e8    0x6c    mcr 15, 0, r0, cr13, cr0, {1}
    0xe00113ec    0x70    isb sy
    0xe00113f0    0x74    add r0, r4, #805306368 
    0xe00113f4    0x78    bic r0, r0, #8128 
    0xe00113f8    0x7c    bic r0, r0, #63 
    0xe00113fc    0x80    orr r0, r0, #24
    0xe0011400    0x84    mcr 15, 0, r0, cr2, cr0, {0}
    0xe0011404    0x88    isb sy
    0xe0011408    0x8c    mov r0, #1
    0xe001140c    0x90    pop {r4, pc}          ; stack access
    0xe0011410    0x94    mov r0, #0
    0xe0011414    0x98    pop {r4, pc}          ; stack access
    0xe0011418    0x9c    .word 0x10024000

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setVMRootForFlush` has 62 nodes.

Section Arch_switchToIdleThread (176 of 299)
============================================

Deriving specifications
-----------------------

Section `Arch_switchToIdleThread` consists of 4 instructions.


Stack analysis
---------------

No stack accesses found. Code for `Arch_switchToIdleThread`:

    0xe001136c    0x0    movw r3, #36880 
    0xe0011370    0x4    movt r3, #57346 
    0xe0011374    0x8    ldr r0, [r3]
    0xe0011378    0xc    b e0011294 <setVMRoot>

Proving inst theorems
---------------------

4 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_switchToIdleThread` has 6 nodes.

Section Arch_switchToThread (177 of 299)
========================================

Deriving specifications
-----------------------

Section `Arch_switchToThread` consists of 7 instructions.
Skipping e1830f91 strex r0, r1, [r3]


Stack analysis
---------------

2 stack accesses found. Annotated code for `Arch_switchToThread`:

    0xe0011350     0x0    push {lr}             ; stack access
    0xe0011354     0x4    sub sp, sp, #12
    0xe0011358     0x8    bl e0011294 <setVMRoot>
    0xe001135c     0xc    add r3, sp, #4
    0xe0011360    0x10    strex r0, r1, [r3]
    0xe0011364    0x14    add sp, sp, #12
    0xe0011368    0x18    pop {pc}              ; stack access

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_switchToThread` has 11 nodes.

Section getHWASID (178 of 299)
==============================

Deriving specifications
-----------------------

Section `getHWASID` consists of 25 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `getHWASID`:

    0xe0011230     0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0011234     0x4    movw r4, #37576 
    0xe0011238     0x8    lsr r7, r0, #10
    0xe001123c     0xc    movt r4, #57346 
    0xe0011240    0x10    ubfx r6, r0, #0, #10
    0xe0011244    0x14    ldr r3, [r4, r7, lsl #2]
    0xe0011248    0x18    ldr r3, [r3, r6, lsl #2]
    0xe001124c    0x1c    add r3, r3, #12288 
    0xe0011250    0x20    ldr r3, [r3, #4032] 
    0xe0011254    0x24    tst r3, #8388608 
    0xe0011258    0x28    beq e0011264 <getHWASID+0x34>
    0xe001125c    0x2c    lsr r0, r3, #24
    0xe0011260    0x30    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0011264    0x34    mov r5, r0
    0xe0011268    0x38    bl e00111a4 <findFreeHWASID>
    0xe001126c    0x3c    ldr r3, [r4, r7, lsl #2]
    0xe0011270    0x40    movw r1, #12872 
    0xe0011274    0x44    movt r1, #57347 
    0xe0011278    0x48    ldr r3, [r3, r6, lsl #2]
    0xe001127c    0x4c    add r3, r3, #12288 
    0xe0011280    0x50    lsl r2, r0, #24
    0xe0011284    0x54    str r5, [r1, r0, lsl #2]
    0xe0011288    0x58    orr r2, r2, #8388608 
    0xe001128c    0x5c    str r2, [r3, #4032] 
    0xe0011290    0x60    pop {r4, r5, r6, r7, r8, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getHWASID` has 38 nodes.

Section pageTableMapped (179 of 299)
====================================

Deriving specifications
-----------------------

Section `pageTableMapped` consists of 28 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `pageTableMapped`:

    0xe0011134     0x0    push {r4, r5, lr}     ; stack access
    0xe0011138     0x4    sub sp, sp, #12
    0xe001113c     0x8    mov r4, r1
    0xe0011140     0xc    mov r1, r0
    0xe0011144    0x10    mov r0, sp
    0xe0011148    0x14    mov r5, r2
    0xe001114c    0x18    bl e0010cf8 <findPDForASID>
    0xe0011150    0x1c    ldr r1, [sp]          ; stack access
    0xe0011154    0x20    ldr r0, [sp, #4]      ; stack access
    0xe0011158    0x24    cmp r1, #0
    0xe001115c    0x28    bne e0011190 <pageTableMapped+0x5c>
    0xe0011160    0x2c    lsr r4, r4, #20
    0xe0011164    0x30    ldr r3, [r0, r4, lsl #2]
    0xe0011168    0x34    and r2, r3, #3
    0xe001116c    0x38    cmp r2, #1
    0xe0011170    0x3c    bne e001119c <pageTableMapped+0x68>
    0xe0011174    0x40    bic r3, r3, #1020 
    0xe0011178    0x44    bic r3, r3, #3
    0xe001117c    0x48    add r3, r3, #-805306368 
    0xe0011180    0x4c    cmp r5, r3
    0xe0011184    0x50    movne r0, #0
    0xe0011188    0x54    add sp, sp, #12
    0xe001118c    0x58    pop {r4, r5, pc}      ; stack access
    0xe0011190    0x5c    mov r0, #0
    0xe0011194    0x60    add sp, sp, #12
    0xe0011198    0x64    pop {r4, r5, pc}      ; stack access
    0xe001119c    0x68    mov r0, r1
    0xe00111a0    0x6c    b e0011188 <pageTableMapped+0x54>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
28 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `pageTableMapped` has 41 nodes.

Section makeUserPDE_constprop_186 (180 of 299)
==============================================

Deriving specifications
-----------------------

Section `makeUserPDE_constprop_186` consists of 26 instructions.
 ORRNE (imm)....+++


Stack analysis
---------------

4 stack accesses found. Annotated code for `makeUserPDE_constprop_186`:

    0xe0010c4c     0x0    push {r4, lr}         ; stack access
    0xe0010c50     0x4    mov r4, r0
    0xe0010c54     0x8    ldr r0, [sp, #12]     ; stack access
    0xe0010c58     0xc    bl e0010a48 <APFromVMRights>
    0xe0010c5c    0x10    ldr ip, [sp, #8]      ; stack access
    0xe0010c60    0x14    cmp r4, #3
    0xe0010c64    0x18    moveq lr, #262144 
    0xe0010c68    0x1c    movne lr, #0
    0xe0010c6c    0x20    cmp r3, #0
    0xe0010c70    0x24    lsl r3, ip, #4
    0xe0010c74    0x28    orrne r3, r3, #151552 
    0xe0010c78    0x2c    orreq r3, r3, #196608 
    0xe0010c7c    0x30    lsr r1, r1, #20
    0xe0010c80    0x34    lsl r0, r0, #10
    0xe0010c84    0x38    lsl r2, r2, #9
    0xe0010c88    0x3c    orrne r3, r3, #6
    0xe0010c8c    0x40    orreq r3, r3, #2
    0xe0010c90    0x44    and ip, r0, #3072 
    0xe0010c94    0x48    lsl r1, r1, #20
    0xe0010c98    0x4c    orreq r0, r3, r2
    0xe0010c9c    0x50    orrne r3, r3, r2
    0xe0010ca0    0x54    orreq r0, r0, r1
    0xe0010ca4    0x58    orrne r0, r3, r1
    0xe0010ca8    0x5c    orr r0, r0, ip
    0xe0010cac    0x60    orr r0, r0, lr
    0xe0010cb0    0x64    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `makeUserPDE_constprop_186` has 51 nodes.

Section setMRs_fault (181 of 299)
=================================

Deriving specifications
-----------------------

Section `setMRs_fault` consists of 112 instructions.


Stack analysis
---------------

9 stack accesses found. Annotated code for `setMRs_fault`:

    0xe0010a8c      0x0    mov r3, r0
    0xe0010a90      0x4    ldr r0, [r0, #96] 
    0xe0010a94      0x8    push {r4, lr}         ; stack access
    0xe0010a98      0xc    and r0, r0, #15
    0xe0010a9c     0x10    cmp r0, #2
    0xe0010aa0     0x14    beq e0010b78 <setMRs_fault+0xec>
    0xe0010aa4     0x18    cmp r0, #3
    0xe0010aa8     0x1c    beq e0010b3c <setMRs_fault+0xb0>
    0xe0010aac     0x20    cmp r0, #1
    0xe0010ab0     0x24    beq e0010aec <setMRs_fault+0x60>
    0xe0010ab4     0x28    cmp r0, #5
    0xe0010ab8     0x2c    bne e0010c44 <setMRs_fault+0x1b8>
    0xe0010abc     0x30    ldr r2, [r3, #68] 
    0xe0010ac0     0x34    mov r0, #4
    0xe0010ac4     0x38    str r2, [r1, #8]
    0xe0010ac8     0x3c    ldr r2, [r3, #100] 
    0xe0010acc     0x40    str r2, [r1, #12]
    0xe0010ad0     0x44    ldr r2, [r3, #96] 
    0xe0010ad4     0x48    ubfx r2, r2, #17, #1
    0xe0010ad8     0x4c    str r2, [r1, #16]
    0xe0010adc     0x50    ldr r3, [r3, #96] 
    0xe0010ae0     0x54    lsr r3, r3, #18
    0xe0010ae4     0x58    str r3, [r1, #20]
    0xe0010ae8     0x5c    pop {r4, pc}          ; stack access
    0xe0010aec     0x60    ldr r0, [r3, #68] 
    0xe0010af0     0x64    str r0, [r1, #8]
    0xe0010af4     0x68    ldr r0, [r3, #100] 
    0xe0010af8     0x6c    str r0, [r1, #12]
    0xe0010afc     0x70    ldr r0, [r3, #96] 
    0xe0010b00     0x74    lsr r0, r0, #31
    0xe0010b04     0x78    str r0, [r1, #16]
    0xe0010b08     0x7c    ldr r0, [r3, #104] 
    0xe0010b0c     0x80    ldr lr, [r3, #108] 
    0xe0010b10     0x84    and r3, r0, #3
    0xe0010b14     0x88    cmp r3, #2
    0xe0010b18     0x8c    add ip, r3, #1
    0xe0010b1c     0x90    str ip, [r1, #20]
    0xe0010b20     0x94    beq e0010be8 <setMRs_fault+0x15c>
    0xe0010b24     0x98    cmp r3, #3
    0xe0010b28     0x9c    beq e0010c20 <setMRs_fault+0x194>
    0xe0010b2c     0xa0    cmp r3, #1
    0xe0010b30     0xa4    beq e0010c08 <setMRs_fault+0x17c>
    0xe0010b34     0xa8    mov r0, #4
    0xe0010b38     0xac    pop {r4, pc}          ; stack access
    0xe0010b3c     0xb0    ldr r0, [r3, #68] 
    0xe0010b40     0xb4    cmp r2, #0
    0xe0010b44     0xb8    str r0, [r1, #8]
    0xe0010b48     0xbc    ldr r0, [r3, #52] 
    0xe0010b4c     0xc0    str r0, [r1, #12]
    0xe0010b50     0xc4    ldr r0, [r3, #64] 
    0xe0010b54     0xc8    str r0, [r1, #16]
    0xe0010b58     0xcc    beq e0010bd8 <setMRs_fault+0x14c>
    0xe0010b5c     0xd0    ldr ip, [r3, #100] 
    0xe0010b60     0xd4    mov r0, #5
    0xe0010b64     0xd8    str ip, [r1, #20]
    0xe0010b68     0xdc    ldr r3, [r3, #96] 
    0xe0010b6c     0xe0    lsr r3, r3, #4
    0xe0010b70     0xe4    str r3, [r2, #20]
    0xe0010b74     0xe8    pop {r4, pc}          ; stack access
    0xe0010b78     0xec    ldr r0, [r3]
    0xe0010b7c     0xf0    cmp r2, #0
    0xe0010b80     0xf4    str r0, [r1, #8]
    0xe0010b84     0xf8    ldr r0, [r3, #4]
    0xe0010b88     0xfc    str r0, [r1, #12]
    0xe0010b8c    0x100    ldr r0, [r3, #8]
    0xe0010b90    0x104    str r0, [r1, #16]
    0xe0010b94    0x108    ldr r0, [r3, #12]
    0xe0010b98    0x10c    str r0, [r1, #20]
    0xe0010b9c    0x110    beq e0010b34 <setMRs_fault+0xa8>
    0xe0010ba0    0x114    add r1, r2, #16
    0xe0010ba4    0x118    ldr ip, [pc, #156] 
    0xe0010ba8    0x11c    add lr, r2, #48 
    0xe0010bac    0x120    mov r0, #4
    0xe0010bb0    0x124    b e0010bb8 <setMRs_fault+0x12c>
    0xe0010bb4    0x128    ldr r0, [ip], #4
    0xe0010bb8    0x12c    ldr r0, [r3, r0, lsl #2]
    0xe0010bbc    0x130    str r0, [r1, #4]!
    0xe0010bc0    0x134    cmp r1, lr
    0xe0010bc4    0x138    bne e0010bb4 <setMRs_fault+0x128>
    0xe0010bc8    0x13c    ldr r3, [r3, #100] 
    0xe0010bcc    0x140    mov r0, #13
    0xe0010bd0    0x144    str r3, [r2, #52] 
    0xe0010bd4    0x148    pop {r4, pc}          ; stack access
    0xe0010bd8    0x14c    ldr r3, [r3, #100] 
    0xe0010bdc    0x150    mov r0, #4
    0xe0010be0    0x154    str r3, [r1, #20]
    0xe0010be4    0x158    pop {r4, pc}          ; stack access
    0xe0010be8    0x15c    cmp r2, #0
    0xe0010bec    0x160    beq e0010b34 <setMRs_fault+0xa8>
    0xe0010bf0    0x164    ubfx r1, r0, #2, #6
    0xe0010bf4    0x168    ubfx r3, r0, #8, #6
    0xe0010bf8    0x16c    str r1, [r2, #20]
    0xe0010bfc    0x170    mov r0, #6
    0xe0010c00    0x174    str r3, [r2, #24]
    0xe0010c04    0x178    pop {r4, pc}          ; stack access
    0xe0010c08    0x17c    cmp r2, #0
    0xe0010c0c    0x180    beq e0010b34 <setMRs_fault+0xa8>
    0xe0010c10    0x184    ubfx r3, r0, #2, #6
    0xe0010c14    0x188    mov r0, #5
    0xe0010c18    0x18c    str r3, [r2, #20]
    0xe0010c1c    0x190    pop {r4, pc}          ; stack access
    0xe0010c20    0x194    cmp r2, #0
    0xe0010c24    0x198    beq e0010b34 <setMRs_fault+0xa8>
    0xe0010c28    0x19c    ubfx r3, r0, #8, #6
    0xe0010c2c    0x1a0    str lr, [r2, #24]
    0xe0010c30    0x1a4    ubfx r0, r0, #2, #6
    0xe0010c34    0x1a8    str r3, [r2, #20]
    0xe0010c38    0x1ac    str r0, [r2, #28]
    0xe0010c3c    0x1b0    mov r0, #7
    0xe0010c40    0x1b4    pop {r4, pc}          ; stack access
    0xe0010c44    0x1b8    bl e0010a3c <halt>
    0xe0010c48    0x1bc    .word 0xe001b3dc

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
111 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setMRs_fault` has 197 nodes.

Section APFromVMRights (182 of 299)
===================================

Deriving specifications
-----------------------

Section `APFromVMRights` consists of 17 instructions.
Switch found.


Stack analysis
---------------

1 stack accesses found. Annotated code for `APFromVMRights`:

    0xe0010a48     0x0    cmp r0, #3
    0xe0010a4c     0x4    ldrls pc, [pc, r0, lsl #2]
    0xe0010a50     0x8    b e0010a84 <APFromVMRights+0x3c>
    0xe0010a54     0xc    .word 0xe0010a7c
    0xe0010a58    0x10    .word 0xe0010a74
    0xe0010a5c    0x14    .word 0xe0010a6c
    0xe0010a60    0x18    .word 0xe0010a64
    0xe0010a64    0x1c    mov r0, #3
    0xe0010a68    0x20    bx lr
    0xe0010a6c    0x24    mov r0, #2
    0xe0010a70    0x28    bx lr
    0xe0010a74    0x2c    mov r0, #1
    0xe0010a78    0x30    bx lr
    0xe0010a7c    0x34    mov r0, #0
    0xe0010a80    0x38    bx lr
    0xe0010a84    0x3c    push {r4, lr}         ; stack access
    0xe0010a88    0x40    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `APFromVMRights` has 32 nodes.

Section c_handle_syscall (183 of 299)
=====================================

Deriving specifications
-----------------------

Section `c_handle_syscall` consists of 21 instructions.
Skipping ee1d1f50 mrc 15, 0, r1, cr13, cr0, {2}
Skipping ee1d1f70 mrc 15, 0, r1, cr13, cr0, {3}


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_syscall`:

    0xe001072c     0x0    movw r3, #13900 
    0xe0010730     0x4    movt r3, #57347 
    0xe0010734     0x8    push {r4, lr}         ; stack access
    0xe0010738     0xc    ldr r3, [r3]
    0xe001073c    0x10    mrc 15, 0, r1, cr13, cr0, {2}
    0xe0010740    0x14    str r1, [r3, #72] 
    0xe0010744    0x18    mrc 15, 0, r1, cr13, cr0, {3}
    0xe0010748    0x1c    str r1, [r3, #76] 
    0xe001074c    0x20    mov r0, r2
    0xe0010750    0x24    bl e001b068 <slowpath>
    0xe0010754    0x28    andeq r0, r0, r0
    0xe0010758    0x2c    andeq r0, r0, r0
    0xe001075c    0x30    andeq r0, r0, r0
    0xe0010760    0x34    andeq r0, r0, r0
    0xe0010764    0x38    andeq r0, r0, r0
    0xe0010768    0x3c    andeq r0, r0, r0
    0xe001076c    0x40    andeq r0, r0, r0
    0xe0010770    0x44    andeq r0, r0, r0
    0xe0010774    0x48    andeq r0, r0, r0
    0xe0010778    0x4c    andeq r0, r0, r0
    0xe001077c    0x50    andeq r0, r0, r0

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
21 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_syscall` has 50 nodes.

Section c_handle_instruction_fault (184 of 299)
===============================================

Deriving specifications
-----------------------

Section `c_handle_instruction_fault` consists of 7 instructions.
 MSR (cpsr, imm) NOP.+


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_instruction_fault`:

    0xe0010184     0x0    push {r4, lr}         ; stack access
    0xe0010188     0x4    mov r0, #1
    0xe001018c     0x8    bl e00185f4 <c_handle_vm_fault>
    0xe0010190     0xc    nop {0}
    0xe0010194    0x10    nop {0}
    0xe0010198    0x14    nop {0}
    0xe001019c    0x18    nop {0}

Proving inst theorems
---------------------

7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_instruction_fault` has 9 nodes.

Section c_handle_data_fault (185 of 299)
========================================

Deriving specifications
-----------------------

Section `c_handle_data_fault` consists of 3 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_data_fault`:

    0xe0010178    0x0    push {r4, lr}         ; stack access
    0xe001017c    0x4    mov r0, #0
    0xe0010180    0x8    bl e00185f4 <c_handle_vm_fault>

Proving inst theorems
---------------------

3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_data_fault` has 5 nodes.

Section arm_fiq_exception (186 of 299)
======================================

Deriving specifications
-----------------------

Section `arm_fiq_exception` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `arm_fiq_exception`:

    0xe0010114    0x0    bl e0010a3c <halt>
    0xe0010118    0x4    andeq r0, r0, r0
    0xe001011c    0x8    andeq r0, r0, r0

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_fiq_exception` has 8 nodes.

Section arm_irq_exception (187 of 299)
======================================

Deriving specifications
-----------------------

Section `arm_irq_exception` consists of 9 instructions.
Skipping f8cd0513 srsia sp, #19
Skipping f1020013 cps #19
Skipping e94d7fff stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
Skipping ee1ddf90 mrc 15, 0, sp, cr13, cr0, {4}


Stack analysis
---------------

3 stack accesses found. Annotated code for `arm_irq_exception`:

    0xe00100ec     0x0    srsia sp, #19
    0xe00100f0     0x4    cps #19
    0xe00100f4     0x8    stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    0xe00100f8     0xc    ldr r8, [sp]          ; stack access
    0xe00100fc    0x10    sub r8, r8, #4
    0xe0010100    0x14    str r8, [sp]          ; stack access
    0xe0010104    0x18    str r8, [sp, #8]      ; stack access
    0xe0010108    0x1c    mrc 15, 0, sp, cr13, cr0, {4}
    0xe001010c    0x20    b e0010120 <c_handle_interrupt>

Proving inst theorems
---------------------

9 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_irq_exception` has 17 nodes.

Section arm_undefined_inst_exception (188 of 299)
=================================================

Deriving specifications
-----------------------

Section `arm_undefined_inst_exception` consists of 8 instructions.
Skipping f8cd0513 srsia sp, #19
Skipping f1020013 cps #19
Skipping e94d7fff stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
Skipping ee1ddf90 mrc 15, 0, sp, cr13, cr0, {4}


Stack analysis
---------------

2 stack accesses found. Annotated code for `arm_undefined_inst_exception`:

    0xe001003c     0x0    srsia sp, #19
    0xe0010040     0x4    cps #19
    0xe0010044     0x8    stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    0xe0010048     0xc    ldr r8, [sp]          ; stack access
    0xe001004c    0x10    sub r8, r8, #4
    0xe0010050    0x14    str r8, [sp, #8]      ; stack access
    0xe0010054    0x18    mrc 15, 0, sp, cr13, cr0, {4}
    0xe0010058    0x1c    b e0010148 <c_handle_undefined_instruction>

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_undefined_inst_exception` has 15 nodes.

Section create_idle_thread (189 of 299)
=======================================

Deriving specifications
-----------------------

Section `create_idle_thread` consists of 25 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `create_idle_thread`:

    0xe0002f68     0x0    ldr r0, [pc, #88] 
    0xe0002f6c     0x4    movw r3, #13900 
    0xe0002f70     0x8    movt r3, #57347 
    0xe0002f74     0xc    movw r1, #36880 
    0xe0002f78    0x10    push {r4, lr}         ; stack access
    0xe0002f7c    0x14    movt r1, #57346 
    0xe0002f80    0x18    ldr lr, [r3]
    0xe0002f84    0x1c    movw ip, #351 
    0xe0002f88    0x20    ldr r3, [r0, #80] 
    0xe0002f8c    0x24    movw r2, #1952 
    0xe0002f90    0x28    cmp r0, lr
    0xe0002f94    0x2c    movt r2, #57345 
    0xe0002f98    0x30    bic r3, r3, #15
    0xe0002f9c    0x34    str r0, [r1]
    0xe0002fa0    0x38    orr r3, r3, #7
    0xe0002fa4    0x3c    str ip, [r0, #64] 
    0xe0002fa8    0x40    str r2, [r0, #60] 
    0xe0002fac    0x44    str r3, [r0, #80] 
    0xe0002fb0    0x48    beq e0002fbc <create_idle_thread+0x54>
    0xe0002fb4    0x4c    mov r0, #1
    0xe0002fb8    0x50    pop {r4, pc}          ; stack access
    0xe0002fbc    0x54    bl e0013114 <setThreadState.part.166>
    0xe0002fc0    0x58    mov r0, #1
    0xe0002fc4    0x5c    pop {r4, pc}          ; stack access
    0xe0002fc8    0x60    .word 0xe001b600

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
24 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_idle_thread` has 36 nodes.

Section configureIdleThread (190 of 299)
========================================

Deriving specifications
-----------------------

Section `configureIdleThread` consists of 17 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `configureIdleThread`:

    0xe0002f24     0x0    movw r2, #13900 
    0xe0002f28     0x4    movt r2, #57347 
    0xe0002f2c     0x8    push {lr}             ; stack access
    0xe0002f30     0xc    movw ip, #351 
    0xe0002f34    0x10    ldr lr, [r2]
    0xe0002f38    0x14    movw r1, #1952 
    0xe0002f3c    0x18    ldr r2, [r0, #80] 
    0xe0002f40    0x1c    movt r1, #57345 
    0xe0002f44    0x20    cmp r0, lr
    0xe0002f48    0x24    str ip, [r0, #64] 
    0xe0002f4c    0x28    bic r2, r2, #15
    0xe0002f50    0x2c    str r1, [r0, #60] 
    0xe0002f54    0x30    orr r2, r2, #7
    0xe0002f58    0x34    str r2, [r0, #80] 
    0xe0002f5c    0x38    popne {pc}            ; stack access
    0xe0002f60    0x3c    pop {lr}              ; stack access
    0xe0002f64    0x40    b e0013114 <setThreadState.part.166>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `configureIdleThread` has 28 nodes.

Section create_kernel_untypeds (191 of 299)
===========================================

Deriving specifications
-----------------------

Section `create_kernel_untypeds` consists of 44 instructions.


Stack analysis
---------------

17 stack accesses found. Annotated code for `create_kernel_untypeds`:

    0xe0002a3c     0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe0002a40     0x4    sub sp, sp, #36 
    0xe0002a44     0x8    add ip, sp, #8
    0xe0002a48     0xc    add r5, sp, #16
    0xe0002a4c    0x10    ldr r8, [sp, #64]     ; stack access
    0xe0002a50    0x14    stm ip, {r2, r3}      ; stack access
    0xe0002a54    0x18    mov r2, #0
    0xe0002a58    0x1c    ldr ip, [sp, #12]     ; stack access
    0xe0002a5c    0x20    stm r5, {r0, r1}      ; stack access
    0xe0002a60    0x24    ldr r3, [sp, #8]      ; stack access
    0xe0002a64    0x28    str ip, [sp]          ; stack access
    0xe0002a68    0x2c    ldm r5, {r0, r1}      ; stack access
    0xe0002a6c    0x30    str r8, [sp, #4]      ; stack access
    0xe0002a70    0x34    bl e0002844 <create_untypeds_for_region>
    0xe0002a74    0x38    cmp r0, #0
    0xe0002a78    0x3c    beq e0002ae0 <create_kernel_untypeds+0xa4>
    0xe0002a7c    0x40    movw r4, #46848 
    0xe0002a80    0x44    movt r4, #57345 
    0xe0002a84    0x48    add r9, r4, #32
    0xe0002a88    0x4c    add r7, sp, #24
    0xe0002a8c    0x50    mov r6, #0
    0xe0002a90    0x54    add r3, r4, #92 
    0xe0002a94    0x58    str r8, [sp, #4]      ; stack access
    0xe0002a98    0x5c    mov r2, #0
    0xe0002a9c    0x60    add r4, r4, #8
    0xe0002aa0    0x64    ldm r3, {r0, r1}
    0xe0002aa4    0x68    str r6, [r4, #84] 
    0xe0002aa8    0x6c    str r6, [r4, #88] 
    0xe0002aac    0x70    stm r7, {r0, r1}      ; stack access
    0xe0002ab0    0x74    ldr ip, [sp, #28]     ; stack access
    0xe0002ab4    0x78    ldm r5, {r0, r1}      ; stack access
    0xe0002ab8    0x7c    ldr r3, [sp, #24]     ; stack access
    0xe0002abc    0x80    str ip, [sp]          ; stack access
    0xe0002ac0    0x84    bl e0002844 <create_untypeds_for_region>
    0xe0002ac4    0x88    cmp r0, #0
    0xe0002ac8    0x8c    beq e0002ae0 <create_kernel_untypeds+0xa4>
    0xe0002acc    0x90    cmp r4, r9
    0xe0002ad0    0x94    bne e0002a90 <create_kernel_untypeds+0x54>
    0xe0002ad4    0x98    mov r0, #1
    0xe0002ad8    0x9c    add sp, sp, #36 
    0xe0002adc    0xa0    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0002ae0    0xa4    mov r0, #0
    0xe0002ae4    0xa8    add sp, sp, #36 
    0xe0002ae8    0xac    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
44 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_kernel_untypeds` has 72 nodes.

Section create_device_untypeds (192 of 299)
===========================================

Deriving specifications
-----------------------

Section `create_device_untypeds` consists of 50 instructions.
 STMIA;7,2...+


Stack analysis
---------------

10 stack accesses found. Annotated code for `create_device_untypeds`:

    0xe0002974     0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0002978     0x4    movw r8, #46848 
    0xe000297c     0x8    movt r8, #57345 
    0xe0002980     0xc    sub sp, sp, #24
    0xe0002984    0x10    add r6, sp, #8
    0xe0002988    0x14    mov r7, r2
    0xe000298c    0x18    ldr r3, [r8, #88] 
    0xe0002990    0x1c    stm r6, {r0, r1}      ; stack access
    0xe0002994    0x20    cmp r3, #0
    0xe0002998    0x24    beq e0002a10 <create_device_untypeds+0x9c>
    0xe000299c    0x28    mov r4, #0
    0xe00029a0    0x2c    mov r5, r8
    0xe00029a4    0x30    mov r3, r4
    0xe00029a8    0x34    b e00029c0 <create_device_untypeds+0x4c>
    0xe00029ac    0x38    ldr r2, [r8, #88] 
    0xe00029b0    0x3c    add r5, r5, #8
    0xe00029b4    0x40    ldr r3, [r5, #-4]
    0xe00029b8    0x44    cmp r2, r4
    0xe00029bc    0x48    bls e00029f8 <create_device_untypeds+0x84>
    0xe00029c0    0x4c    ldr r2, [r8, r4, lsl #3]
    0xe00029c4    0x50    add r4, r4, #1
    0xe00029c8    0x54    cmp r2, r3
    0xe00029cc    0x58    bls e00029ac <create_device_untypeds+0x38>
    0xe00029d0    0x5c    add r2, r2, #-805306368 
    0xe00029d4    0x60    add r3, r3, #-805306368 
    0xe00029d8    0x64    stm sp, {r2, r7}      ; stack access
    0xe00029dc    0x68    mov r2, #1
    0xe00029e0    0x6c    ldm r6, {r0, r1}      ; stack access
    0xe00029e4    0x70    bl e0002844 <create_untypeds_for_region>
    0xe00029e8    0x74    cmp r0, #0
    0xe00029ec    0x78    bne e00029ac <create_device_untypeds+0x38>
    0xe00029f0    0x7c    add sp, sp, #24
    0xe00029f4    0x80    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe00029f8    0x84    cmn r3, #1
    0xe00029fc    0x88    addne r3, r3, #-805306368 
    0xe0002a00    0x8c    bne e0002a14 <create_device_untypeds+0xa0>
    0xe0002a04    0x90    mov r0, #1
    0xe0002a08    0x94    add sp, sp, #24
    0xe0002a0c    0x98    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0002a10    0x9c    mov r3, #-805306368 
    0xe0002a14    0xa0    str r7, [sp, #4]      ; stack access
    0xe0002a18    0xa4    mvn r1, #805306368 
    0xe0002a1c    0xa8    mov r2, #1
    0xe0002a20    0xac    str r1, [sp]          ; stack access
    0xe0002a24    0xb0    ldm r6, {r0, r1}      ; stack access
    0xe0002a28    0xb4    bl e0002844 <create_untypeds_for_region>
    0xe0002a2c    0xb8    adds r0, r0, #0
    0xe0002a30    0xbc    movne r0, #1
    0xe0002a34    0xc0    add sp, sp, #24
    0xe0002a38    0xc4    pop {r4, r5, r6, r7, r8, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
50 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_device_untypeds` has 80 nodes.

Section create_untypeds_for_region (193 of 299)
===============================================

Deriving specifications
-----------------------

Section `create_untypeds_for_region` consists of 76 instructions.
 RBIT..++
 LDMDB;3,2...++
 LDMIA (wb);14,11,10,9,8,7,6,5,4.+


Stack analysis
---------------

15 stack accesses found. Annotated code for `create_untypeds_for_region`:

    0xe0002844      0x0    sub sp, sp, #8
    0xe0002848      0x4    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe000284c      0x8    sub sp, sp, #36 
    0xe0002850      0xc    add r8, sp, #8
    0xe0002854     0x10    ldr r6, [sp, #80]     ; stack access
    0xe0002858     0x14    str r3, [sp, #76]     ; stack access
    0xe000285c     0x18    cmp r6, r3
    0xe0002860     0x1c    stm r8, {r0, r1}      ; stack access
    0xe0002864     0x20    ldr sl, [sp, #84]     ; stack access
    0xe0002868     0x24    beq e0002960 <create_untypeds_for_region+0x11c>
    0xe000286c     0x28    mov r5, r3
    0xe0002870     0x2c    lsl r3, r2, #5
    0xe0002874     0x30    movw r9, #46848 
    0xe0002878     0x34    and r3, r3, #32
    0xe000287c     0x38    mov fp, r2
    0xe0002880     0x3c    str r3, [sp, #4]      ; stack access
    0xe0002884     0x40    movt r9, #57345 
    0xe0002888     0x44    add r7, sp, #16
    0xe000288c     0x48    b e00028c0 <create_untypeds_for_region+0x7c>
    0xe0002890     0x4c    cmp r4, #3
    0xe0002894     0x50    bls e00028b0 <create_untypeds_for_region+0x6c>
    0xe0002898     0x54    ldr r3, [r9, #128] 
    0xe000289c     0x58    ldm r8, {r0, r1}      ; stack access
    0xe00028a0     0x5c    sub r3, r3, sl
    0xe00028a4     0x60    cmp r3, #229 
    0xe00028a8     0x64    stm r7, {r0, r1}      ; stack access
    0xe00028ac     0x68    bls e00028f4 <create_untypeds_for_region+0xb0>
    0xe00028b0     0x6c    mov r3, #1
    0xe00028b4     0x70    add r5, r5, r3, lsl r4
    0xe00028b8     0x74    cmp r6, r5
    0xe00028bc     0x78    beq e0002960 <create_untypeds_for_region+0x11c>
    0xe00028c0     0x7c    sub r4, r6, r5
    0xe00028c4     0x80    cmp r5, #0
    0xe00028c8     0x84    rbit r3, r5
    0xe00028cc     0x88    clz r4, r4
    0xe00028d0     0x8c    clz r3, r3
    0xe00028d4     0x90    rsb r4, r4, #31
    0xe00028d8     0x94    beq e00028e4 <create_untypeds_for_region+0xa0>
    0xe00028dc     0x98    cmp r4, r3
    0xe00028e0     0x9c    movcs r4, r3
    0xe00028e4     0xa0    cmp r4, #29
    0xe00028e8     0xa4    bls e0002890 <create_untypeds_for_region+0x4c>
    0xe00028ec     0xa8    mov r4, #29
    0xe00028f0     0xac    b e0002898 <create_untypeds_for_region+0x54>
    0xe00028f4     0xb0    ldr r2, [r9, #124] 
    0xe00028f8     0xb4    bic r1, r5, #15
    0xe00028fc     0xb8    orr r1, r1, #2
    0xe0002900     0xbc    mov lr, #0
    0xe0002904     0xc0    add r3, r2, r3, lsl #3
    0xe0002908     0xc4    ldr r2, [sp, #4]      ; stack access
    0xe000290c     0xc8    str r1, [sp, #24]     ; stack access
    0xe0002910     0xcc    add r1, r5, #805306368 
    0xe0002914     0xd0    str lr, [r3, #88] 
    0xe0002918     0xd4    sub r0, r4, #4
    0xe000291c     0xd8    str r1, [r3, #84] 
    0xe0002920     0xdc    mov ip, #64 
    0xe0002924     0xe0    strb r4, [r3, #88] 
    0xe0002928     0xe4    orr r2, r4, r2
    0xe000292c     0xe8    strb fp, [r3, #89] 
    0xe0002930     0xec    add r3, sp, #32
    0xe0002934     0xf0    orr r2, r2, ip, lsl r0
    0xe0002938     0xf4    ldm r7, {r0, r1}      ; stack access
    0xe000293c     0xf8    str r2, [sp, #28]     ; stack access
    0xe0002940     0xfc    ldmdb r3, {r2, r3}    ; stack access
    0xe0002944    0x100    bl e0001ba8 <provide_cap>
    0xe0002948    0x104    cmp r0, #0
    0xe000294c    0x108    bne e00028b0 <create_untypeds_for_region+0x6c>
    0xe0002950    0x10c    add sp, sp, #36 
    0xe0002954    0x110    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0002958    0x114    add sp, sp, #8
    0xe000295c    0x118    bx lr
    0xe0002960    0x11c    mov r0, #1
    0xe0002964    0x120    add sp, sp, #36 
    0xe0002968    0x124    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe000296c    0x128    add sp, sp, #8
    0xe0002970    0x12c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
76 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_untypeds_for_region` has 116 nodes.

Section create_it_address_space (194 of 299)
============================================

Deriving specifications
-----------------------

Section `create_it_address_space` consists of 251 instructions.
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy
Switch found.
Skipping e7f000f0 udf #0
Switch found.
Switch found.


Stack analysis
---------------

Section `create_it_address_space` expects pointer to stack in r0.
25 stack accesses found. Annotated code for `create_it_address_space`:

    0xe0001e44      0x0    sub sp, sp, #8
    0xe0001e48      0x4    ldr ip, [pc, #988] 
    0xe0001e4c      0x8    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0001e50      0xc    movw r5, #46848 
    0xe0001e54     0x10    movt r5, #57345 
    0xe0001e58     0x14    sub sp, sp, #36 
    0xe0001e5c     0x18    add r7, sp, #16
    0xe0001e60     0x1c    sub lr, ip, #14336 
    0xe0001e64     0x20    ldr r6, [r5, #148] 
    0xe0001e68     0x24    str r3, [sp, #76]     ; stack access
    0xe0001e6c     0x28    mov r3, #3584 
    0xe0001e70     0x2c    stm r7, {r1, r2}      ; stack access
    0xe0001e74     0x30    sub lr, r6, lr
    0xe0001e78     0x34    ldr fp, [sp, #80]     ; stack access
    0xe0001e7c     0x38    movw r1, #4095 
    0xe0001e80     0x3c    b e0001e8c <create_it_address_space+0x48>
    0xe0001e84     0x40    add r3, r3, #1
    0xe0001e88     0x44    add ip, ip, #4
    0xe0001e8c     0x48    cmp r3, #4080 
    0xe0001e90     0x4c    beq e0001e84 <create_it_address_space+0x40>
    0xe0001e94     0x50    ldr r2, [ip]
    0xe0001e98     0x54    cmp r3, r1
    0xe0001e9c     0x58    str r2, [lr, ip]
    0xe0001ea0     0x5c    bne e0001e84 <create_it_address_space+0x40>
    0xe0001ea4     0x60    add r2, r6, #16320 
    0xe0001ea8     0x64    lsr r3, r6, #5
    0xe0001eac     0x68    add r2, r2, #63 
    0xe0001eb0     0x6c    lsr r2, r2, #5
    0xe0001eb4     0x70    add r2, r2, #1
    0xe0001eb8     0x74    cmp r3, r2
    0xe0001ebc     0x78    bcs e0001ee0 <create_it_address_space+0x9c>
    0xe0001ec0     0x7c    lsl r3, r3, #5
    0xe0001ec4     0x80    lsl r2, r2, #5
    0xe0001ec8     0x84    mcr 15, 0, r3, cr7, cr11, {1}
    0xe0001ecc     0x88    dmb sy
    0xe0001ed0     0x8c    add r3, r3, #32
    0xe0001ed4     0x90    cmp r3, r2
    0xe0001ed8     0x94    bne e0001ec8 <create_it_address_space+0x84>
    0xe0001edc     0x98    ldr r6, [r5, #148] 
    0xe0001ee0     0x9c    ldr r2, [r5, #128] 
    0xe0001ee4     0xa0    bic r6, r6, #16320 
    0xe0001ee8     0xa4    ldr r3, [sp, #16]     ; stack access
    0xe0001eec     0xa8    bic r6, r6, #63 
    0xe0001ef0     0xac    orr r1, r6, #25
    0xe0001ef4     0xb0    ldr ip, [sp, #20]     ; stack access
    0xe0001ef8     0xb4    str r2, [sp, #8]      ; stack access
    0xe0001efc     0xb8    and r2, r3, #14
    0xe0001f00     0xbc    cmp r2, #14
    0xe0001f04     0xc0    str r1, [sp, #12]     ; stack access
    0xe0001f08     0xc4    beq e0002054 <create_it_address_space+0x210>
    0xe0001f0c     0xc8    and r2, r3, #15
    0xe0001f10     0xcc    sub r1, r2, #2
    0xe0001f14     0xd0    cmp r1, #12
    0xe0001f18     0xd4    ldrls pc, [pc, r1, lsl #2]
    0xe0001f1c     0xd8    b e00021a0 <create_it_address_space+0x35c>
    0xe0001f20     0xdc    .word 0xe0001f60
    0xe0001f24     0xe0    .word 0xe00021a0
    0xe0001f28     0xe4    .word 0xe0002164
    0xe0001f2c     0xe8    .word 0xe00021a0
    0xe0001f30     0xec    .word 0xe0001f60
    0xe0001f34     0xf0    .word 0xe00021a0
    0xe0001f38     0xf4    .word 0xe0001f54
    0xe0001f3c     0xf8    .word 0xe00021a0
    0xe0001f40     0xfc    .word 0xe000215c
    0xe0001f44    0x100    .word 0xe00021a0
    0xe0001f48    0x104    .word 0xe000216c
    0xe0001f4c    0x108    .word 0xe00021a0
    0xe0001f50    0x10c    .word 0xe0001f54
    0xe0001f54    0x110    mov r3, #0
    0xe0001f58    0x114    str r3, [r3, #48] 
    0xe0001f5c    0x118    udf #0
    0xe0001f60    0x11c    bic r3, r3, #15
    0xe0001f64    0x120    ldr r4, [sp, #76]     ; stack access
    0xe0001f68    0x124    mov r2, #1
    0xe0001f6c    0x128    orr r1, r6, #25
    0xe0001f70    0x12c    str r2, [r3, #52] 
    0xe0001f74    0x130    str r1, [r3, #48] 
    0xe0001f78    0x134    mov r2, #3
    0xe0001f7c    0x138    lsr r4, r4, #20
    0xe0001f80    0x13c    mov r1, #0
    0xe0001f84    0x140    str r0, [sp, #4]      ; stack access
    0xe0001f88    0x144    lsl r4, r4, #20
    0xe0001f8c    0x148    str r1, [r3, #56] 
    0xe0001f90    0x14c    cmp fp, r4
    0xe0001f94    0x150    str r2, [r3, #60] 
    0xe0001f98    0x154    bls e00021d4 <create_it_address_space+0x390>
    0xe0001f9c    0x158    mov sl, #64512 
    0xe0001fa0    0x15c    mov r9, #4096 
    0xe0001fa4    0x160    movt sl, #65535 
    0xe0001fa8    0x164    movt r9, #8192 
    0xe0001fac    0x168    add r8, sp, #24
    0xe0001fb0    0x16c    b e0001fc0 <create_it_address_space+0x17c>
    0xe0001fb4    0x170    add r4, r4, #1048576 
    0xe0001fb8    0x174    cmp fp, r4
    0xe0001fbc    0x178    bls e0002028 <create_it_address_space+0x1e4>
    0xe0001fc0    0x17c    ldr r2, [r5, #172] 
    0xe0001fc4    0x180    lsr r1, r4, #20
    0xe0001fc8    0x184    orr r3, r1, r9
    0xe0001fcc    0x188    str r3, [sp, #28]     ; stack access
    0xe0001fd0    0x18c    and r3, r2, sl
    0xe0001fd4    0x190    add r2, r2, #1024 
    0xe0001fd8    0x194    add r0, r3, #805306368 
    0xe0001fdc    0x198    str r2, [r5, #172] 
    0xe0001fe0    0x19c    orr r2, r0, #512 
    0xe0001fe4    0x1a0    orr r3, r3, #7
    0xe0001fe8    0x1a4    orr r2, r2, #1
    0xe0001fec    0x1a8    str r3, [sp, #24]     ; stack access
    0xe0001ff0    0x1ac    str r2, [r6, r1, lsl #2]
    0xe0001ff4    0x1b0    ldm r7, {r0, r1}      ; stack access
    0xe0001ff8    0x1b4    ldm r8, {r2, r3}      ; stack access
    0xe0001ffc    0x1b8    bl e0001ba8 <provide_cap>
    0xe0002000    0x1bc    cmp r0, #0
    0xe0002004    0x1c0    bne e0001fb4 <create_it_address_space+0x170>
    0xe0002008    0x1c4    ldr r3, [sp, #4]      ; stack access
    0xe000200c    0x1c8    str r0, [r3]          ; indirect stack access
    0xe0002010    0x1cc    str r0, [r3, #4]      ; indirect stack access
    0xe0002014    0x1d0    ldr r0, [sp, #4]      ; stack access
    0xe0002018    0x1d4    add sp, sp, #36 
    0xe000201c    0x1d8    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0002020    0x1dc    add sp, sp, #8
    0xe0002024    0x1e0    bx lr
    0xe0002028    0x1e4    ldr r2, [r5, #128] 
    0xe000202c    0x1e8    ldr r0, [sp, #4]      ; stack access
    0xe0002030    0x1ec    mov r1, #1
    0xe0002034    0x1f0    ldr r3, [r5, #124] 
    0xe0002038    0x1f4    ldr ip, [sp, #12]     ; stack access
    0xe000203c    0x1f8    str r1, [r0, #4]      ; indirect stack access
    0xe0002040    0x1fc    ldr r1, [sp, #8]      ; stack access
    0xe0002044    0x200    str ip, [r0]          ; indirect stack access
    0xe0002048    0x204    str r2, [r3, #48] 
    0xe000204c    0x208    str r1, [r3, #44] 
    0xe0002050    0x20c    b e0002014 <create_it_address_space+0x1d0>
    0xe0002054    0x210    uxtb r2, r3
    0xe0002058    0x214    sub r1, r2, #2
    0xe000205c    0x218    cmp r1, #60 
    0xe0002060    0x21c    ldrls pc, [pc, r1, lsl #2]
    0xe0002064    0x220    b e00021a0 <create_it_address_space+0x35c>
    0xe0002068    0x224    .word 0xe0001f60
    0xe000206c    0x228    .word 0xe00021a0
    0xe0002070    0x22c    .word 0xe0002164
    0xe0002074    0x230    .word 0xe00021a0
    0xe0002078    0x234    .word 0xe0001f60
    0xe000207c    0x238    .word 0xe00021a0
    0xe0002080    0x23c    .word 0xe0001f54
    0xe0002084    0x240    .word 0xe00021a0
    0xe0002088    0x244    .word 0xe000215c
    0xe000208c    0x248    .word 0xe00021a0
    0xe0002090    0x24c    .word 0xe000216c
    0xe0002094    0x250    .word 0xe00021a0
    0xe0002098    0x254    .word 0xe0001f54
    0xe000209c    0x258    .word 0xe00021a0
    0xe00020a0    0x25c    .word 0xe00021a0
    0xe00020a4    0x260    .word 0xe00021a0
    0xe00020a8    0x264    .word 0xe00021a0
    0xe00020ac    0x268    .word 0xe00021a0
    0xe00020b0    0x26c    .word 0xe00021a0
    0xe00020b4    0x270    .word 0xe00021a0
    0xe00020b8    0x274    .word 0xe00021a0
    0xe00020bc    0x278    .word 0xe00021a0
    0xe00020c0    0x27c    .word 0xe00021a0
    0xe00020c4    0x280    .word 0xe00021a0
    0xe00020c8    0x284    .word 0xe00021a0
    0xe00020cc    0x288    .word 0xe00021a0
    0xe00020d0    0x28c    .word 0xe00021a0
    0xe00020d4    0x290    .word 0xe00021a0
    0xe00020d8    0x294    .word 0xe0001f54
    0xe00020dc    0x298    .word 0xe00021a0
    0xe00020e0    0x29c    .word 0xe00021a0
    0xe00020e4    0x2a0    .word 0xe00021a0
    0xe00020e8    0x2a4    .word 0xe00021a0
    0xe00020ec    0x2a8    .word 0xe00021a0
    0xe00020f0    0x2ac    .word 0xe00021a0
    0xe00020f4    0x2b0    .word 0xe00021a0
    0xe00020f8    0x2b4    .word 0xe00021a0
    0xe00020fc    0x2b8    .word 0xe00021a0
    0xe0002100    0x2bc    .word 0xe00021a0
    0xe0002104    0x2c0    .word 0xe00021a0
    0xe0002108    0x2c4    .word 0xe00021a0
    0xe000210c    0x2c8    .word 0xe00021a0
    0xe0002110    0x2cc    .word 0xe00021a0
    0xe0002114    0x2d0    .word 0xe00021a0
    0xe0002118    0x2d4    .word 0xe0002178
    0xe000211c    0x2d8    .word 0xe00021a0
    0xe0002120    0x2dc    .word 0xe00021a0
    0xe0002124    0x2e0    .word 0xe00021a0
    0xe0002128    0x2e4    .word 0xe00021a0
    0xe000212c    0x2e8    .word 0xe00021a0
    0xe0002130    0x2ec    .word 0xe00021a0
    0xe0002134    0x2f0    .word 0xe00021a0
    0xe0002138    0x2f4    .word 0xe00021a0
    0xe000213c    0x2f8    .word 0xe00021a0
    0xe0002140    0x2fc    .word 0xe00021a0
    0xe0002144    0x300    .word 0xe00021a0
    0xe0002148    0x304    .word 0xe00021a0
    0xe000214c    0x308    .word 0xe00021a0
    0xe0002150    0x30c    .word 0xe00021a0
    0xe0002154    0x310    .word 0xe00021a0
    0xe0002158    0x314    .word 0xe0001f54
    0xe000215c    0x318    bic r3, r3, #31
    0xe0002160    0x31c    b e0001f64 <create_it_address_space+0x120>
    0xe0002164    0x320    bic r3, ip, #15
    0xe0002168    0x324    b e0001f64 <create_it_address_space+0x120>
    0xe000216c    0x328    bic r3, r3, #508 
    0xe0002170    0x32c    bic r3, r3, #3
    0xe0002174    0x330    b e0001f64 <create_it_address_space+0x120>
    0xe0002178    0x334    lsr r3, r3, #8
    0xe000217c    0x338    and r2, r3, #63 
    0xe0002180    0x33c    cmp r2, #32
    0xe0002184    0x340    andne r2, r3, #31
    0xe0002188    0x344    addne r2, r2, #1
    0xe000218c    0x348    mvnne r3, #0
    0xe0002190    0x34c    lslne r3, r3, r2
    0xe0002194    0x350    mvneq r3, #31
    0xe0002198    0x354    and r3, r3, ip
    0xe000219c    0x358    b e0001f64 <create_it_address_space+0x120>
    0xe00021a0    0x35c    sub r1, r2, #1
    0xe00021a4    0x360    cmp r1, #8
    0xe00021a8    0x364    ldrls pc, [pc, r1, lsl #2]
    0xe00021ac    0x368    b e0001f54 <create_it_address_space+0x110>
    0xe00021b0    0x36c    .word 0xe00021f4
    0xe00021b4    0x370    .word 0xe0001f54
    0xe00021b8    0x374    .word 0xe00021f4
    0xe00021bc    0x378    .word 0xe0001f54
    0xe00021c0    0x37c    .word 0xe0001f60
    0xe00021c4    0x380    .word 0xe0001f54
    0xe00021c8    0x384    .word 0xe00021e8
    0xe00021cc    0x388    .word 0xe0001f54
    0xe00021d0    0x38c    .word 0xe00021dc
    0xe00021d4    0x390    ldr r2, [sp, #8]      ; stack access
    0xe00021d8    0x394    b e000202c <create_it_address_space+0x1e8>
    0xe00021dc    0x398    bic r3, r3, #16320 
    0xe00021e0    0x39c    bic r3, r3, #63 
    0xe00021e4    0x3a0    b e0001f64 <create_it_address_space+0x120>
    0xe00021e8    0x3a4    bic r3, r3, #1020 
    0xe00021ec    0x3a8    bic r3, r3, #3
    0xe00021f0    0x3ac    b e0001f64 <create_it_address_space+0x120>
    0xe00021f4    0x3b0    cmp r2, #1
    0xe00021f8    0x3b4    beq e0002214 <create_it_address_space+0x3d0>
    0xe00021fc    0x3b8    cmp r2, #3
    0xe0002200    0x3bc    bne e0002224 <create_it_address_space+0x3e0>
    0xe0002204    0x3c0    mov r2, #49152 
    0xe0002208    0x3c4    movt r2, #65535 
    0xe000220c    0x3c8    and r3, r2, r3, lsl #10
    0xe0002210    0x3cc    b e0001f64 <create_it_address_space+0x120>
    0xe0002214    0x3d0    mov r2, #61440 
    0xe0002218    0x3d4    movt r2, #65535 
    0xe000221c    0x3d8    and r3, r2, r3, lsl #8
    0xe0002220    0x3dc    b e0001f64 <create_it_address_space+0x120>
    0xe0002224    0x3e0    mov r3, #0
    0xe0002228    0x3e4    b e0001f64 <create_it_address_space+0x120>
    0xe000222c    0x3e8    .word 0xe0027800

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
167 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_it_address_space` has 496 nodes.

Section populate_bi_frame (195 of 299)
======================================

Deriving specifications
-----------------------

Section `populate_bi_frame` consists of 77 instructions.
Skipping ee070f3b mcr 15, 0, r0, cr7, cr11, {1}
Skipping f57ff05f dmb sy
 MOVS (reg-shift).....+++++
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `populate_bi_frame`:

    0xe0001a74      0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0001a78      0x4    movw r5, #46848 
    0xe0001a7c      0x8    movt r5, #57345 
    0xe0001a80      0xc    mov r6, r0
    0xe0001a84     0x10    mov r7, r1
    0xe0001a88     0x14    mov r8, r2
    0xe0001a8c     0x18    ldr r4, [r5, #160] 
    0xe0001a90     0x1c    mov r9, r3
    0xe0001a94     0x20    mov lr, #0
    0xe0001a98     0x24    add ip, r4, #4096 
    0xe0001a9c     0x28    mov r0, r4
    0xe0001aa0     0x2c    str lr, [r0], #4
    0xe0001aa4     0x30    cmp r0, ip
    0xe0001aa8     0x34    bne e0001aa0 <populate_bi_frame+0x2c>
    0xe0001aac     0x38    add r3, r4, #4080 
    0xe0001ab0     0x3c    lsr r0, r4, #5
    0xe0001ab4     0x40    add r3, r3, #15
    0xe0001ab8     0x44    lsr r3, r3, #5
    0xe0001abc     0x48    add r3, r3, #1
    0xe0001ac0     0x4c    cmp r0, r3
    0xe0001ac4     0x50    bcs e0001ae4 <populate_bi_frame+0x70>
    0xe0001ac8     0x54    lsl r0, r0, #5
    0xe0001acc     0x58    lsl r3, r3, #5
    0xe0001ad0     0x5c    mcr 15, 0, r0, cr7, cr11, {1}
    0xe0001ad4     0x60    dmb sy
    0xe0001ad8     0x64    add r0, r0, #32
    0xe0001adc     0x68    cmp r0, r3
    0xe0001ae0     0x6c    bne e0001ad0 <populate_bi_frame+0x5c>
    0xe0001ae4     0x70    cmp r9, #0
    0xe0001ae8     0x74    beq e0001b54 <populate_bi_frame+0xe0>
    0xe0001aec     0x78    mov r0, r9
    0xe0001af0     0x7c    ldr r4, [r5, #164] 
    0xe0001af4     0x80    bl e00002f0 <calculate_extra_bi_size_bits.part.160>
    0xe0001af8     0x84    mov r3, #1
    0xe0001afc     0x88    mov r2, r4
    0xe0001b00     0x8c    lsls r0, r3, r0
    0xe0001b04     0x90    beq e0001b1c <populate_bi_frame+0xa8>
    0xe0001b08     0x94    mov r3, r0
    0xe0001b0c     0x98    mov r1, #0
    0xe0001b10     0x9c    subs r3, r3, #4
    0xe0001b14     0xa0    str r1, [r2], #4
    0xe0001b18     0xa4    bne e0001b10 <populate_bi_frame+0x9c>
    0xe0001b1c     0xa8    sub r2, r4, #1
    0xe0001b20     0xac    lsr r3, r4, #5
    0xe0001b24     0xb0    add r2, r2, r0
    0xe0001b28     0xb4    lsr r2, r2, #5
    0xe0001b2c     0xb8    add r2, r2, #1
    0xe0001b30     0xbc    cmp r3, r2
    0xe0001b34     0xc0    bcs e0001b54 <populate_bi_frame+0xe0>
    0xe0001b38     0xc4    lsl r3, r3, #5
    0xe0001b3c     0xc8    lsl r2, r2, #5
    0xe0001b40     0xcc    mcr 15, 0, r3, cr7, cr11, {1}
    0xe0001b44     0xd0    dmb sy
    0xe0001b48     0xd4    add r3, r3, #32
    0xe0001b4c     0xd8    cmp r2, r3
    0xe0001b50     0xdc    bne e0001b40 <populate_bi_frame+0xcc>
    0xe0001b54     0xe0    movw r3, #13904 
    0xe0001b58     0xe4    movt r3, #57347 
    0xe0001b5c     0xe8    movw r2, #46024 
    0xe0001b60     0xec    movt r2, #57345 
    0xe0001b64     0xf0    ldr r1, [r3]
    0xe0001b68     0xf4    mov r3, #14
    0xe0001b6c     0xf8    str r3, [r5, #128] 
    0xe0001b70     0xfc    mov r0, #0
    0xe0001b74    0x100    ldr r3, [r5, #160] 
    0xe0001b78    0x104    add r2, r2, r1, lsl #3
    0xe0001b7c    0x108    mov r1, #12
    0xe0001b80    0x10c    ldr r2, [r2, #112] 
    0xe0001b84    0x110    str r3, [r5, #124] 
    0xe0001b88    0x114    str r6, [r3, #4]
    0xe0001b8c    0x118    str r2, [r3, #72] 
    0xe0001b90    0x11c    str r7, [r3, #8]
    0xe0001b94    0x120    str r8, [r3, #16]
    0xe0001b98    0x124    str r9, [r3]
    0xe0001b9c    0x128    str r0, [r3, #12]
    0xe0001ba0    0x12c    str r1, [r3, #68] 
    0xe0001ba4    0x130    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
77 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `populate_bi_frame` has 116 nodes.

Section calculate_extra_bi_size_bits (196 of 299)
=================================================

Deriving specifications
-----------------------

Section `calculate_extra_bi_size_bits` consists of 3 instructions.


Stack analysis
---------------

No stack accesses found. Code for `calculate_extra_bi_size_bits`:

    0xe0001a68    0x0    cmp r0, #0
    0xe0001a6c    0x4    bxeq lr
    0xe0001a70    0x8    b e00002f0 <calculate_extra_bi_size_bits.part.160>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
3 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `calculate_extra_bi_size_bits` has 7 nodes.

Section create_bi_frame_cap (197 of 299)
========================================

Deriving specifications
-----------------------

Section `create_bi_frame_cap` consists of 172 instructions.
 STMIB;14,4...+
Switch found.
Skipping e7f000f0 udf #0
Switch found.
Switch found.


Stack analysis
---------------

13 stack accesses found. Annotated code for `create_bi_frame_cap`:

    0xe00017b8      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00017bc      0x4    movw lr, #46848 
    0xe00017c0      0x8    sub sp, sp, #40 
    0xe00017c4      0xc    movt lr, #57345 
    0xe00017c8     0x10    add ip, sp, #16
    0xe00017cc     0x14    add r4, sp, #24
    0xe00017d0     0x18    ldr r6, [lr, #160] 
    0xe00017d4     0x1c    mov lr, #0
    0xe00017d8     0x20    ldr r5, [sp, #56]     ; stack access
    0xe00017dc     0x24    stm r4, {r0, r1}      ; stack access
    0xe00017e0     0x28    add r0, sp, #32
    0xe00017e4     0x2c    stm ip, {r2, r3}      ; stack access
    0xe00017e8     0x30    mov r4, #1
    0xe00017ec     0x34    ldm ip, {r1, r2}      ; stack access
    0xe00017f0     0x38    mov r3, r6
    0xe00017f4     0x3c    str r5, [sp]          ; stack access
    0xe00017f8     0x40    str lr, [sp, #12]     ; stack access
    0xe00017fc     0x44    stmib sp, {r4, lr}    ; stack access
    0xe0001800     0x48    bl e0000440 <create_mapped_it_frame_cap>
    0xe0001804     0x4c    ldr r3, [sp, #24]     ; stack access
    0xe0001808     0x50    ldr r0, [sp, #28]     ; stack access
    0xe000180c     0x54    and r2, r3, #14
    0xe0001810     0x58    cmp r2, #14
    0xe0001814     0x5c    beq e0001898 <create_bi_frame_cap+0xe0>
    0xe0001818     0x60    and r2, r3, #15
    0xe000181c     0x64    sub r1, r2, #2
    0xe0001820     0x68    cmp r1, #12
    0xe0001824     0x6c    ldrls pc, [pc, r1, lsl #2]
    0xe0001828     0x70    b e00019bc <create_bi_frame_cap+0x204>
    0xe000182c     0x74    .word 0xe000186c
    0xe0001830     0x78    .word 0xe00019bc
    0xe0001834     0x7c    .word 0xe00019a8
    0xe0001838     0x80    .word 0xe00019bc
    0xe000183c     0x84    .word 0xe000186c
    0xe0001840     0x88    .word 0xe00019bc
    0xe0001844     0x8c    .word 0xe0001860
    0xe0001848     0x90    .word 0xe00019bc
    0xe000184c     0x94    .word 0xe00019a0
    0xe0001850     0x98    .word 0xe00019bc
    0xe0001854     0x9c    .word 0xe00019b0
    0xe0001858     0xa0    .word 0xe00019bc
    0xe000185c     0xa4    .word 0xe0001860
    0xe0001860     0xa8    mov r3, #0
    0xe0001864     0xac    str r3, [r3, #144] 
    0xe0001868     0xb0    udf #0
    0xe000186c     0xb4    bic r3, r3, #15
    0xe0001870     0xb8    ldr r0, [sp, #36]     ; stack access
    0xe0001874     0xbc    mov ip, #0
    0xe0001878     0xc0    ldr r1, [sp, #32]     ; stack access
    0xe000187c     0xc4    mov r2, #3
    0xe0001880     0xc8    str ip, [r3, #152] 
    0xe0001884     0xcc    str r0, [r3, #148] 
    0xe0001888     0xd0    str r1, [r3, #144] 
    0xe000188c     0xd4    str r2, [r3, #156] 
    0xe0001890     0xd8    add sp, sp, #40 
    0xe0001894     0xdc    pop {r4, r5, r6, pc}  ; stack access
    0xe0001898     0xe0    uxtb r2, r3
    0xe000189c     0xe4    sub r1, r2, #2
    0xe00018a0     0xe8    cmp r1, #60 
    0xe00018a4     0xec    ldrls pc, [pc, r1, lsl #2]
    0xe00018a8     0xf0    b e00019bc <create_bi_frame_cap+0x204>
    0xe00018ac     0xf4    .word 0xe000186c
    0xe00018b0     0xf8    .word 0xe00019bc
    0xe00018b4     0xfc    .word 0xe00019a8
    0xe00018b8    0x100    .word 0xe00019bc
    0xe00018bc    0x104    .word 0xe000186c
    0xe00018c0    0x108    .word 0xe00019bc
    0xe00018c4    0x10c    .word 0xe0001860
    0xe00018c8    0x110    .word 0xe00019bc
    0xe00018cc    0x114    .word 0xe00019a0
    0xe00018d0    0x118    .word 0xe00019bc
    0xe00018d4    0x11c    .word 0xe00019b0
    0xe00018d8    0x120    .word 0xe00019bc
    0xe00018dc    0x124    .word 0xe0001860
    0xe00018e0    0x128    .word 0xe00019bc
    0xe00018e4    0x12c    .word 0xe00019bc
    0xe00018e8    0x130    .word 0xe00019bc
    0xe00018ec    0x134    .word 0xe00019bc
    0xe00018f0    0x138    .word 0xe00019bc
    0xe00018f4    0x13c    .word 0xe00019bc
    0xe00018f8    0x140    .word 0xe00019bc
    0xe00018fc    0x144    .word 0xe00019bc
    0xe0001900    0x148    .word 0xe00019bc
    0xe0001904    0x14c    .word 0xe00019bc
    0xe0001908    0x150    .word 0xe00019bc
    0xe000190c    0x154    .word 0xe00019bc
    0xe0001910    0x158    .word 0xe00019bc
    0xe0001914    0x15c    .word 0xe00019bc
    0xe0001918    0x160    .word 0xe00019bc
    0xe000191c    0x164    .word 0xe0001860
    0xe0001920    0x168    .word 0xe00019bc
    0xe0001924    0x16c    .word 0xe00019bc
    0xe0001928    0x170    .word 0xe00019bc
    0xe000192c    0x174    .word 0xe00019bc
    0xe0001930    0x178    .word 0xe00019bc
    0xe0001934    0x17c    .word 0xe00019bc
    0xe0001938    0x180    .word 0xe00019bc
    0xe000193c    0x184    .word 0xe00019bc
    0xe0001940    0x188    .word 0xe00019bc
    0xe0001944    0x18c    .word 0xe00019bc
    0xe0001948    0x190    .word 0xe00019bc
    0xe000194c    0x194    .word 0xe00019bc
    0xe0001950    0x198    .word 0xe00019bc
    0xe0001954    0x19c    .word 0xe00019bc
    0xe0001958    0x1a0    .word 0xe00019bc
    0xe000195c    0x1a4    .word 0xe00019f0
    0xe0001960    0x1a8    .word 0xe00019bc
    0xe0001964    0x1ac    .word 0xe00019bc
    0xe0001968    0x1b0    .word 0xe00019bc
    0xe000196c    0x1b4    .word 0xe00019bc
    0xe0001970    0x1b8    .word 0xe00019bc
    0xe0001974    0x1bc    .word 0xe00019bc
    0xe0001978    0x1c0    .word 0xe00019bc
    0xe000197c    0x1c4    .word 0xe00019bc
    0xe0001980    0x1c8    .word 0xe00019bc
    0xe0001984    0x1cc    .word 0xe00019bc
    0xe0001988    0x1d0    .word 0xe00019bc
    0xe000198c    0x1d4    .word 0xe00019bc
    0xe0001990    0x1d8    .word 0xe00019bc
    0xe0001994    0x1dc    .word 0xe00019bc
    0xe0001998    0x1e0    .word 0xe00019bc
    0xe000199c    0x1e4    .word 0xe0001860
    0xe00019a0    0x1e8    bic r3, r3, #31
    0xe00019a4    0x1ec    b e0001870 <create_bi_frame_cap+0xb8>
    0xe00019a8    0x1f0    bic r3, r0, #15
    0xe00019ac    0x1f4    b e0001870 <create_bi_frame_cap+0xb8>
    0xe00019b0    0x1f8    bic r3, r3, #508 
    0xe00019b4    0x1fc    bic r3, r3, #3
    0xe00019b8    0x200    b e0001870 <create_bi_frame_cap+0xb8>
    0xe00019bc    0x204    sub r1, r2, #1
    0xe00019c0    0x208    cmp r1, #8
    0xe00019c4    0x20c    ldrls pc, [pc, r1, lsl #2]
    0xe00019c8    0x210    b e0001860 <create_bi_frame_cap+0xa8>
    0xe00019cc    0x214    .word 0xe0001a30
    0xe00019d0    0x218    .word 0xe0001860
    0xe00019d4    0x21c    .word 0xe0001a30
    0xe00019d8    0x220    .word 0xe0001860
    0xe00019dc    0x224    .word 0xe000186c
    0xe00019e0    0x228    .word 0xe0001860
    0xe00019e4    0x22c    .word 0xe0001a24
    0xe00019e8    0x230    .word 0xe0001860
    0xe00019ec    0x234    .word 0xe0001a18
    0xe00019f0    0x238    lsr r3, r3, #8
    0xe00019f4    0x23c    and r2, r3, #63 
    0xe00019f8    0x240    cmp r2, #32
    0xe00019fc    0x244    andne r3, r3, #31
    0xe0001a00    0x248    addne r3, r3, #1
    0xe0001a04    0x24c    mvnne r2, #0
    0xe0001a08    0x250    lslne r3, r2, r3
    0xe0001a0c    0x254    mvneq r3, #31
    0xe0001a10    0x258    and r3, r3, r0
    0xe0001a14    0x25c    b e0001870 <create_bi_frame_cap+0xb8>
    0xe0001a18    0x260    bic r3, r3, #16320 
    0xe0001a1c    0x264    bic r3, r3, #63 
    0xe0001a20    0x268    b e0001870 <create_bi_frame_cap+0xb8>
    0xe0001a24    0x26c    bic r3, r3, #1020 
    0xe0001a28    0x270    bic r3, r3, #3
    0xe0001a2c    0x274    b e0001870 <create_bi_frame_cap+0xb8>
    0xe0001a30    0x278    cmp r2, #1
    0xe0001a34    0x27c    beq e0001a50 <create_bi_frame_cap+0x298>
    0xe0001a38    0x280    cmp r2, #3
    0xe0001a3c    0x284    bne e0001a60 <create_bi_frame_cap+0x2a8>
    0xe0001a40    0x288    mov r2, #49152 
    0xe0001a44    0x28c    movt r2, #65535 
    0xe0001a48    0x290    and r3, r2, r3, lsl #10
    0xe0001a4c    0x294    b e0001870 <create_bi_frame_cap+0xb8>
    0xe0001a50    0x298    mov r2, #61440 
    0xe0001a54    0x29c    movt r2, #65535 
    0xe0001a58    0x2a0    and r3, r2, r3, lsl #8
    0xe0001a5c    0x2a4    b e0001870 <create_bi_frame_cap+0xb8>
    0xe0001a60    0x2a8    mov r3, #0
    0xe0001a64    0x2ac    b e0001870 <create_bi_frame_cap+0xb8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
89 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_bi_frame_cap` has 378 nodes.

Section create_ipcbuf_frame_cap (198 of 299)
============================================

Deriving specifications
-----------------------

Section `create_ipcbuf_frame_cap` consists of 198 instructions.
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy
+
Switch found.
Skipping e7f000f0 udf #0
 LDMIA (wb);14,6,5,4.+
Switch found.
Switch found.


Stack analysis
---------------

Section `create_ipcbuf_frame_cap` expects pointer to stack in r0.
14 stack accesses found. Annotated code for `create_ipcbuf_frame_cap`:

    0xe00014a0      0x0    sub sp, sp, #8
    0xe00014a4      0x4    push {r4, r5, r6, lr}  ; stack access
    0xe00014a8      0x8    movw lr, #46848 
    0xe00014ac      0xc    movt lr, #57345 
    0xe00014b0     0x10    sub sp, sp, #24
    0xe00014b4     0x14    add r6, sp, #24
    0xe00014b8     0x18    mov r4, r0
    0xe00014bc     0x1c    ldr ip, [lr, #156] 
    0xe00014c0     0x20    mov r0, #0
    0xe00014c4     0x24    ldr r5, [sp, #52]     ; stack access
    0xe00014c8     0x28    stmdb r6, {r1, r2}    ; stack access
    0xe00014cc     0x2c    add r2, ip, #4096 
    0xe00014d0     0x30    str r3, [sp, #44]     ; stack access
    0xe00014d4     0x34    mov r3, ip
    0xe00014d8     0x38    str r0, [r3], #4
    0xe00014dc     0x3c    cmp r3, r2
    0xe00014e0     0x40    bne e00014d8 <create_ipcbuf_frame_cap+0x38>
    0xe00014e4     0x44    add r2, ip, #4080 
    0xe00014e8     0x48    lsr r3, ip, #5
    0xe00014ec     0x4c    add r2, r2, #15
    0xe00014f0     0x50    lsr r2, r2, #5
    0xe00014f4     0x54    add r2, r2, #1
    0xe00014f8     0x58    cmp r2, r3
    0xe00014fc     0x5c    bls e000151c <create_ipcbuf_frame_cap+0x7c>
    0xe0001500     0x60    lsl r3, r3, #5
    0xe0001504     0x64    lsl r2, r2, #5
    0xe0001508     0x68    mcr 15, 0, r3, cr7, cr11, {1}
    0xe000150c     0x6c    dmb sy
    0xe0001510     0x70    add r3, r3, #32
    0xe0001514     0x74    cmp r2, r3
    0xe0001518     0x78    bne e0001508 <create_ipcbuf_frame_cap+0x68>
    0xe000151c     0x7c    add r2, sp, #44 
    0xe0001520     0x80    ldr r3, [lr, #156] 
    0xe0001524     0x84    mov r0, #0
    0xe0001528     0x88    str r5, [sp]          ; stack access
    0xe000152c     0x8c    mov ip, #1
    0xe0001530     0x90    ldm r2, {r1, r2}      ; stack access
    0xe0001534     0x94    str r0, [sp, #12]     ; stack access
    0xe0001538     0x98    str r0, [sp, #8]      ; stack access
    0xe000153c     0x9c    mov r0, r4
    0xe0001540     0xa0    str ip, [sp, #4]      ; stack access
    0xe0001544     0xa4    bl e0000440 <create_mapped_it_frame_cap>
    0xe0001548     0xa8    ldr r3, [sp, #16]     ; stack access
    0xe000154c     0xac    ldr r0, [sp, #20]     ; stack access
    0xe0001550     0xb0    and r2, r3, #14
    0xe0001554     0xb4    cmp r2, #14
    0xe0001558     0xb8    beq e00015e8 <create_ipcbuf_frame_cap+0x148>
    0xe000155c     0xbc    and r2, r3, #15
    0xe0001560     0xc0    sub r1, r2, #2
    0xe0001564     0xc4    cmp r1, #12
    0xe0001568     0xc8    ldrls pc, [pc, r1, lsl #2]
    0xe000156c     0xcc    b e0001734 <create_ipcbuf_frame_cap+0x294>
    0xe0001570     0xd0    .word 0xe00015b0
    0xe0001574     0xd4    .word 0xe0001734
    0xe0001578     0xd8    .word 0xe00016f8
    0xe000157c     0xdc    .word 0xe0001734
    0xe0001580     0xe0    .word 0xe00015b0
    0xe0001584     0xe4    .word 0xe0001734
    0xe0001588     0xe8    .word 0xe00015a4
    0xe000158c     0xec    .word 0xe0001734
    0xe0001590     0xf0    .word 0xe00016f0
    0xe0001594     0xf4    .word 0xe0001734
    0xe0001598     0xf8    .word 0xe0001700
    0xe000159c     0xfc    .word 0xe0001734
    0xe00015a0    0x100    .word 0xe00015a4
    0xe00015a4    0x104    mov r3, #0
    0xe00015a8    0x108    str r3, [r3, #160] 
    0xe00015ac    0x10c    udf #0
    0xe00015b0    0x110    bic r3, r3, #15
    0xe00015b4    0x114    ldr r0, [r4, #4]      ; stack access
    0xe00015b8    0x118    mov ip, #0
    0xe00015bc    0x11c    ldr r1, [r4]          ; stack access
    0xe00015c0    0x120    mov r2, #3
    0xe00015c4    0x124    str ip, [r3, #168] 
    0xe00015c8    0x128    str r0, [r3, #164] 
    0xe00015cc    0x12c    mov r0, r4
    0xe00015d0    0x130    str r1, [r3, #160] 
    0xe00015d4    0x134    str r2, [r3, #172] 
    0xe00015d8    0x138    add sp, sp, #24
    0xe00015dc    0x13c    pop {r4, r5, r6, lr}  ; stack access
    0xe00015e0    0x140    add sp, sp, #8
    0xe00015e4    0x144    bx lr
    0xe00015e8    0x148    uxtb r2, r3
    0xe00015ec    0x14c    sub r1, r2, #2
    0xe00015f0    0x150    cmp r1, #60 
    0xe00015f4    0x154    ldrls pc, [pc, r1, lsl #2]
    0xe00015f8    0x158    b e0001734 <create_ipcbuf_frame_cap+0x294>
    0xe00015fc    0x15c    .word 0xe00015b0
    0xe0001600    0x160    .word 0xe0001734
    0xe0001604    0x164    .word 0xe00016f8
    0xe0001608    0x168    .word 0xe0001734
    0xe000160c    0x16c    .word 0xe00015b0
    0xe0001610    0x170    .word 0xe0001734
    0xe0001614    0x174    .word 0xe00015a4
    0xe0001618    0x178    .word 0xe0001734
    0xe000161c    0x17c    .word 0xe00016f0
    0xe0001620    0x180    .word 0xe0001734
    0xe0001624    0x184    .word 0xe0001700
    0xe0001628    0x188    .word 0xe0001734
    0xe000162c    0x18c    .word 0xe00015a4
    0xe0001630    0x190    .word 0xe0001734
    0xe0001634    0x194    .word 0xe0001734
    0xe0001638    0x198    .word 0xe0001734
    0xe000163c    0x19c    .word 0xe0001734
    0xe0001640    0x1a0    .word 0xe0001734
    0xe0001644    0x1a4    .word 0xe0001734
    0xe0001648    0x1a8    .word 0xe0001734
    0xe000164c    0x1ac    .word 0xe0001734
    0xe0001650    0x1b0    .word 0xe0001734
    0xe0001654    0x1b4    .word 0xe0001734
    0xe0001658    0x1b8    .word 0xe0001734
    0xe000165c    0x1bc    .word 0xe0001734
    0xe0001660    0x1c0    .word 0xe0001734
    0xe0001664    0x1c4    .word 0xe0001734
    0xe0001668    0x1c8    .word 0xe0001734
    0xe000166c    0x1cc    .word 0xe00015a4
    0xe0001670    0x1d0    .word 0xe0001734
    0xe0001674    0x1d4    .word 0xe0001734
    0xe0001678    0x1d8    .word 0xe0001734
    0xe000167c    0x1dc    .word 0xe0001734
    0xe0001680    0x1e0    .word 0xe0001734
    0xe0001684    0x1e4    .word 0xe0001734
    0xe0001688    0x1e8    .word 0xe0001734
    0xe000168c    0x1ec    .word 0xe0001734
    0xe0001690    0x1f0    .word 0xe0001734
    0xe0001694    0x1f4    .word 0xe0001734
    0xe0001698    0x1f8    .word 0xe0001734
    0xe000169c    0x1fc    .word 0xe0001734
    0xe00016a0    0x200    .word 0xe0001734
    0xe00016a4    0x204    .word 0xe0001734
    0xe00016a8    0x208    .word 0xe0001734
    0xe00016ac    0x20c    .word 0xe000170c
    0xe00016b0    0x210    .word 0xe0001734
    0xe00016b4    0x214    .word 0xe0001734
    0xe00016b8    0x218    .word 0xe0001734
    0xe00016bc    0x21c    .word 0xe0001734
    0xe00016c0    0x220    .word 0xe0001734
    0xe00016c4    0x224    .word 0xe0001734
    0xe00016c8    0x228    .word 0xe0001734
    0xe00016cc    0x22c    .word 0xe0001734
    0xe00016d0    0x230    .word 0xe0001734
    0xe00016d4    0x234    .word 0xe0001734
    0xe00016d8    0x238    .word 0xe0001734
    0xe00016dc    0x23c    .word 0xe0001734
    0xe00016e0    0x240    .word 0xe0001734
    0xe00016e4    0x244    .word 0xe0001734
    0xe00016e8    0x248    .word 0xe0001734
    0xe00016ec    0x24c    .word 0xe00015a4
    0xe00016f0    0x250    bic r3, r3, #31
    0xe00016f4    0x254    b e00015b4 <create_ipcbuf_frame_cap+0x114>
    0xe00016f8    0x258    bic r3, r0, #15
    0xe00016fc    0x25c    b e00015b4 <create_ipcbuf_frame_cap+0x114>
    0xe0001700    0x260    bic r3, r3, #508 
    0xe0001704    0x264    bic r3, r3, #3
    0xe0001708    0x268    b e00015b4 <create_ipcbuf_frame_cap+0x114>
    0xe000170c    0x26c    lsr r3, r3, #8
    0xe0001710    0x270    and r2, r3, #63 
    0xe0001714    0x274    cmp r2, #32
    0xe0001718    0x278    andne r2, r3, #31
    0xe000171c    0x27c    addne r2, r2, #1
    0xe0001720    0x280    mvnne r3, #0
    0xe0001724    0x284    lslne r3, r3, r2
    0xe0001728    0x288    mvneq r3, #31
    0xe000172c    0x28c    and r3, r3, r0
    0xe0001730    0x290    b e00015b4 <create_ipcbuf_frame_cap+0x114>
    0xe0001734    0x294    sub r1, r2, #1
    0xe0001738    0x298    cmp r1, #8
    0xe000173c    0x29c    ldrls pc, [pc, r1, lsl #2]
    0xe0001740    0x2a0    b e00015a4 <create_ipcbuf_frame_cap+0x104>
    0xe0001744    0x2a4    .word 0xe0001780
    0xe0001748    0x2a8    .word 0xe00015a4
    0xe000174c    0x2ac    .word 0xe0001780
    0xe0001750    0x2b0    .word 0xe00015a4
    0xe0001754    0x2b4    .word 0xe00015b0
    0xe0001758    0x2b8    .word 0xe00015a4
    0xe000175c    0x2bc    .word 0xe0001774
    0xe0001760    0x2c0    .word 0xe00015a4
    0xe0001764    0x2c4    .word 0xe0001768
    0xe0001768    0x2c8    bic r3, r3, #16320 
    0xe000176c    0x2cc    bic r3, r3, #63 
    0xe0001770    0x2d0    b e00015b4 <create_ipcbuf_frame_cap+0x114>
    0xe0001774    0x2d4    bic r3, r3, #1020 
    0xe0001778    0x2d8    bic r3, r3, #3
    0xe000177c    0x2dc    b e00015b4 <create_ipcbuf_frame_cap+0x114>
    0xe0001780    0x2e0    cmp r2, #1
    0xe0001784    0x2e4    beq e00017a0 <create_ipcbuf_frame_cap+0x300>
    0xe0001788    0x2e8    cmp r2, #3
    0xe000178c    0x2ec    bne e00017b0 <create_ipcbuf_frame_cap+0x310>
    0xe0001790    0x2f0    mov r2, #49152 
    0xe0001794    0x2f4    movt r2, #65535 
    0xe0001798    0x2f8    and r3, r2, r3, lsl #10
    0xe000179c    0x2fc    b e00015b4 <create_ipcbuf_frame_cap+0x114>
    0xe00017a0    0x300    mov r2, #61440 
    0xe00017a4    0x304    movt r2, #65535 
    0xe00017a8    0x308    and r3, r2, r3, lsl #8
    0xe00017ac    0x30c    b e00015b4 <create_ipcbuf_frame_cap+0x114>
    0xe00017b0    0x310    mov r3, #0
    0xe00017b4    0x314    b e00015b4 <create_ipcbuf_frame_cap+0x114>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
115 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_ipcbuf_frame_cap` has 416 nodes.

Section create_rootserver_objects (199 of 299)
==============================================

Deriving specifications
-----------------------

Section `create_rootserver_objects` consists of 116 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `create_rootserver_objects`:

    0xe0000fe8      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0000fec      0x4    sub sp, sp, #8
    0xe0000ff0      0x8    add ip, sp, #8
    0xe0000ff4      0xc    subs r6, r3, #0
    0xe0000ff8     0x10    add r3, r0, #94208 
    0xe0000ffc     0x14    stmdb ip, {r1, r2}    ; stack access
    0xe0001000     0x18    add r3, r3, #512 
    0xe0001004     0x1c    ldm sp, {r1, r2}      ; stack access
    0xe0001008     0x20    sub r2, r2, #1
    0xe000100c     0x24    lsr r1, r1, #20
    0xe0001010     0x28    lsr r2, r2, #20
    0xe0001014     0x2c    lsl r1, r1, #20
    0xe0001018     0x30    lsl r2, r2, #20
    0xe000101c     0x34    add r5, r2, #1048576 
    0xe0001020     0x38    sub r5, r5, r1
    0xe0001024     0x3c    lsr r5, r5, #10
    0xe0001028     0x40    beq e0001174 <create_rootserver_objects+0x18c>
    0xe000102c     0x44    cmp r6, #16
    0xe0001030     0x48    mov r1, #1
    0xe0001034     0x4c    movw r4, #46848 
    0xe0001038     0x50    movt r4, #57345 
    0xe000103c     0x54    movcs r2, r6
    0xe0001040     0x58    movcc r2, #16
    0xe0001044     0x5c    cmp r6, r2
    0xe0001048     0x60    add r3, r3, r1, lsl r6
    0xe000104c     0x64    add r3, r3, r5
    0xe0001050     0x68    str r0, [r4, #136] 
    0xe0001054     0x6c    str r3, [r4, #140] 
    0xe0001058     0x70    bcc e0001068 <create_rootserver_objects+0x80>
    0xe000105c     0x74    ldr r3, [r4, #164] 
    0xe0001060     0x78    cmp r3, #0
    0xe0001064     0x7c    beq e0001198 <create_rootserver_objects+0x1b0>
    0xe0001068     0x80    mov r2, r0
    0xe000106c     0x84    mov r1, #0
    0xe0001070     0x88    add ip, r0, #65536 
    0xe0001074     0x8c    str ip, [r4, #136] 
    0xe0001078     0x90    str r1, [r2], #4
    0xe000107c     0x94    cmp ip, r2
    0xe0001080     0x98    bne e0001078 <create_rootserver_objects+0x90>
    0xe0001084     0x9c    cmp r6, #13
    0xe0001088     0xa0    str r0, [r4, #144] 
    0xe000108c     0xa4    bls e000109c <create_rootserver_objects+0xb4>
    0xe0001090     0xa8    ldr r3, [r4, #164] 
    0xe0001094     0xac    cmp r3, #0
    0xe0001098     0xb0    beq e00011a8 <create_rootserver_objects+0x1c0>
    0xe000109c     0xb4    mov r2, ip
    0xe00010a0     0xb8    mov r0, #0
    0xe00010a4     0xbc    add r1, ip, #16384 
    0xe00010a8     0xc0    str r1, [r4, #136] 
    0xe00010ac     0xc4    str r0, [r2], #4
    0xe00010b0     0xc8    cmp r1, r2
    0xe00010b4     0xcc    bne e00010ac <create_rootserver_objects+0xc4>
    0xe00010b8     0xd0    cmp r6, #11
    0xe00010bc     0xd4    str ip, [r4, #148] 
    0xe00010c0     0xd8    bls e00010d0 <create_rootserver_objects+0xe8>
    0xe00010c4     0xdc    ldr r3, [r4, #164] 
    0xe00010c8     0xe0    cmp r3, #0
    0xe00010cc     0xe4    beq e0001188 <create_rootserver_objects+0x1a0>
    0xe00010d0     0xe8    add r0, r1, #4096 
    0xe00010d4     0xec    mov r3, r1
    0xe00010d8     0xf0    mov r2, #0
    0xe00010dc     0xf4    str r2, [r3], #4
    0xe00010e0     0xf8    cmp r0, r3
    0xe00010e4     0xfc    bne e00010dc <create_rootserver_objects+0xf4>
    0xe00010e8    0x100    add r2, r1, #8192 
    0xe00010ec    0x104    mov ip, #0
    0xe00010f0    0x108    str r1, [r4, #152] 
    0xe00010f4    0x10c    str ip, [r3], #4
    0xe00010f8    0x110    cmp r3, r2
    0xe00010fc    0x114    bne e00010f4 <create_rootserver_objects+0x10c>
    0xe0001100    0x118    add r1, r1, #12288 
    0xe0001104    0x11c    mov ip, #0
    0xe0001108    0x120    str r0, [r4, #156] 
    0xe000110c    0x124    str ip, [r3], #4
    0xe0001110    0x128    cmp r3, r1
    0xe0001114    0x12c    bne e000110c <create_rootserver_objects+0x124>
    0xe0001118    0x130    cmp r5, #0
    0xe000111c    0x134    str r2, [r4, #160] 
    0xe0001120    0x138    add ip, r5, r3
    0xe0001124    0x13c    mov r2, r5
    0xe0001128    0x140    str ip, [r4, #136] 
    0xe000112c    0x144    beq e0001140 <create_rootserver_objects+0x158>
    0xe0001130    0x148    mov r0, #0
    0xe0001134    0x14c    subs r2, r2, #4
    0xe0001138    0x150    str r0, [r3], #4
    0xe000113c    0x154    bne e0001134 <create_rootserver_objects+0x14c>
    0xe0001140    0x158    mov r3, ip
    0xe0001144    0x15c    mov r0, #0
    0xe0001148    0x160    add r5, r1, r5
    0xe000114c    0x164    add r2, ip, #512 
    0xe0001150    0x168    str r1, [r4, #172] 
    0xe0001154    0x16c    str r5, [r4, #176] 
    0xe0001158    0x170    str r2, [r4, #136] 
    0xe000115c    0x174    str r0, [r3], #4
    0xe0001160    0x178    cmp r3, r2
    0xe0001164    0x17c    bne e000115c <create_rootserver_objects+0x174>
    0xe0001168    0x180    str ip, [r4, #168] 
    0xe000116c    0x184    add sp, sp, #8
    0xe0001170    0x188    pop {r4, r5, r6, pc}  ; stack access
    0xe0001174    0x18c    movw r4, #46848 
    0xe0001178    0x190    movt r4, #57345 
    0xe000117c    0x194    add r3, r5, r3
    0xe0001180    0x198    str r3, [r4, #140] 
    0xe0001184    0x19c    b e0001068 <create_rootserver_objects+0x80>
    0xe0001188    0x1a0    mov r0, r6
    0xe000118c    0x1a4    bl e000031c <maybe_alloc_extra_bi.part.182>
    0xe0001190    0x1a8    ldr r1, [r4, #136] 
    0xe0001194    0x1ac    b e00010d0 <create_rootserver_objects+0xe8>
    0xe0001198    0x1b0    mov r0, r6
    0xe000119c    0x1b4    bl e000031c <maybe_alloc_extra_bi.part.182>
    0xe00011a0    0x1b8    ldr r0, [r4, #136] 
    0xe00011a4    0x1bc    b e0001068 <create_rootserver_objects+0x80>
    0xe00011a8    0x1c0    mov r0, r6
    0xe00011ac    0x1c4    bl e000031c <maybe_alloc_extra_bi.part.182>
    0xe00011b0    0x1c8    ldr ip, [r4, #136] 
    0xe00011b4    0x1cc    b e000109c <create_rootserver_objects+0xb4>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
116 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_rootserver_objects` has 185 nodes.

Section insert_region (200 of 299)
==================================

Deriving specifications
-----------------------

Section `insert_region` consists of 47 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `insert_region`:

    0xe0000f2c     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0000f30     0x4    sub sp, sp, #16
    0xe0000f34     0x8    cmp r0, r1
    0xe0000f38     0xc    mov r5, sp
    0xe0000f3c    0x10    stm r5, {r0, r1}      ; stack access
    0xe0000f40    0x14    moveq r3, #1
    0xe0000f44    0x18    beq e0000f90 <insert_region+0x64>
    0xe0000f48    0x1c    movw r4, #46848 
    0xe0000f4c    0x20    movt r4, #57345 
    0xe0000f50    0x24    mov r2, r0
    0xe0000f54    0x28    mov r3, r1
    0xe0000f58    0x2c    ldrd r0, [r4, #92] 
    0xe0000f5c    0x30    cmp r0, r1
    0xe0000f60    0x34    beq e0000fd8 <insert_region+0xac>
    0xe0000f64    0x38    ldrd r0, [r4, #100] 
    0xe0000f68    0x3c    cmp r0, r1
    0xe0000f6c    0x40    beq e0000fe0 <insert_region+0xb4>
    0xe0000f70    0x44    ldrd r0, [r4, #108] 
    0xe0000f74    0x48    cmp r0, r1
    0xe0000f78    0x4c    beq e0000f9c <insert_region+0x70>
    0xe0000f7c    0x50    ldrd r0, [r4, #116] 
    0xe0000f80    0x54    cmp r0, r1
    0xe0000f84    0x58    moveq r6, #3
    0xe0000f88    0x5c    beq e0000fa0 <insert_region+0x74>
    0xe0000f8c    0x60    mov r3, #0
    0xe0000f90    0x64    mov r0, r3
    0xe0000f94    0x68    add sp, sp, #16
    0xe0000f98    0x6c    pop {r4, r5, r6, pc}  ; stack access
    0xe0000f9c    0x70    mov r6, #2
    0xe0000fa0    0x74    add r2, r2, #805306368 
    0xe0000fa4    0x78    add r3, r3, #805306368 
    0xe0000fa8    0x7c    strd r2, [sp, #8]     ; stack access
    0xe0000fac    0x80    add r3, sp, #16
    0xe0000fb0    0x84    add r4, r4, r6, lsl #3
    0xe0000fb4    0x88    ldmdb r3, {r0, r1}    ; stack access
    0xe0000fb8    0x8c    add r4, r4, #92 
    0xe0000fbc    0x90    bl e0000bd8 <reserve_region>
    0xe0000fc0    0x94    ldm r5, {r0, r1}      ; stack access
    0xe0000fc4    0x98    mov r3, #1
    0xe0000fc8    0x9c    stm r4, {r0, r1}
    0xe0000fcc    0xa0    mov r0, r3
    0xe0000fd0    0xa4    add sp, sp, #16
    0xe0000fd4    0xa8    pop {r4, r5, r6, pc}  ; stack access
    0xe0000fd8    0xac    mov r6, #0
    0xe0000fdc    0xb0    b e0000fa0 <insert_region+0x74>
    0xe0000fe0    0xb4    mov r6, #1
    0xe0000fe4    0xb8    b e0000fa0 <insert_region+0x74>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
47 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `insert_region` has 74 nodes.

Section map_kernel_window (201 of 299)
======================================

Deriving specifications
-----------------------

Section `map_kernel_window` consists of 89 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `map_kernel_window`:

    0xe0000dc8      0x0    push {r4, lr}         ; stack access
    0xe0000dcc      0x4    movw r4, #22022 
    0xe0000dd0      0x8    ldr lr, [pc, #324] 
    0xe0000dd4      0xc    movt r4, #4
    0xe0000dd8     0x10    mov r3, #3584 
    0xe0000ddc     0x14    mov ip, #268435456 
    0xe0000de0     0x18    add r1, r3, #16
    0xe0000de4     0x1c    orr r0, ip, r4
    0xe0000de8     0x20    cmp r1, r3
    0xe0000dec     0x24    bls e0000e04 <map_kernel_window+0x3c>
    0xe0000df0     0x28    mov r2, lr
    0xe0000df4     0x2c    add r3, r3, #1
    0xe0000df8     0x30    str r0, [r2, #4]!
    0xe0000dfc     0x34    cmp r3, r1
    0xe0000e00     0x38    bcc e0000df4 <map_kernel_window+0x2c>
    0xe0000e04     0x3c    add ip, ip, #16777216 
    0xe0000e08     0x40    add lr, lr, #64 
    0xe0000e0c     0x44    cmp ip, #788529152 
    0xe0000e10     0x48    mov r3, r1
    0xe0000e14     0x4c    bne e0000de0 <map_kernel_window+0x18>
    0xe0000e18     0x50    ldr r3, [pc, #256] 
    0xe0000e1c     0x54    mov r1, #0
    0xe0000e20     0x58    ldr r0, [pc, #252] 
    0xe0000e24     0x5c    movw lr, #22022 
    0xe0000e28     0x60    add ip, r3, #-805306368 
    0xe0000e2c     0x64    orr r3, r3, #512 
    0xe0000e30     0x68    add r2, ip, #1024 
    0xe0000e34     0x6c    orr r3, r3, #1
    0xe0000e38     0x70    str r3, [r0, #4092] 
    0xe0000e3c     0x74    mov r3, ip
    0xe0000e40     0x78    movt lr, #12032 
    0xe0000e44     0x7c    str lr, [r0, #4032] 
    0xe0000e48     0x80    movw lr, #22022 
    0xe0000e4c     0x84    movt lr, #12048 
    0xe0000e50     0x88    str lr, [r0, #4036] 
    0xe0000e54     0x8c    movw lr, #22022 
    0xe0000e58     0x90    movt lr, #12064 
    0xe0000e5c     0x94    str lr, [r0, #4040] 
    0xe0000e60     0x98    movw lr, #22022 
    0xe0000e64     0x9c    movt lr, #12080 
    0xe0000e68     0xa0    str lr, [r0, #4044] 
    0xe0000e6c     0xa4    movw lr, #22022 
    0xe0000e70     0xa8    movt lr, #12096 
    0xe0000e74     0xac    str lr, [r0, #4048] 
    0xe0000e78     0xb0    movw lr, #22022 
    0xe0000e7c     0xb4    movt lr, #12112 
    0xe0000e80     0xb8    str lr, [r0, #4052] 
    0xe0000e84     0xbc    movw lr, #22022 
    0xe0000e88     0xc0    movt lr, #12128 
    0xe0000e8c     0xc4    str lr, [r0, #4056] 
    0xe0000e90     0xc8    movw lr, #22022 
    0xe0000e94     0xcc    movt lr, #12144 
    0xe0000e98     0xd0    str lr, [r0, #4060] 
    0xe0000e9c     0xd4    movw lr, #22022 
    0xe0000ea0     0xd8    movt lr, #12160 
    0xe0000ea4     0xdc    str lr, [r0, #4064] 
    0xe0000ea8     0xe0    movw lr, #22022 
    0xe0000eac     0xe4    movt lr, #12176 
    0xe0000eb0     0xe8    str lr, [r0, #4068] 
    0xe0000eb4     0xec    movw lr, #22022 
    0xe0000eb8     0xf0    movt lr, #12192 
    0xe0000ebc     0xf4    str lr, [r0, #4072] 
    0xe0000ec0     0xf8    movw lr, #22022 
    0xe0000ec4     0xfc    movt lr, #12208 
    0xe0000ec8    0x100    str lr, [r0, #4076] 
    0xe0000ecc    0x104    movw lr, #22022 
    0xe0000ed0    0x108    movt lr, #12224 
    0xe0000ed4    0x10c    str lr, [r0, #4080] 
    0xe0000ed8    0x110    movw lr, #22022 
    0xe0000edc    0x114    movt lr, #12240 
    0xe0000ee0    0x118    str lr, [r0, #4084] 
    0xe0000ee4    0x11c    movw lr, #22022 
    0xe0000ee8    0x120    movt lr, #12256 
    0xe0000eec    0x124    str lr, [r0, #4088] 
    0xe0000ef0    0x128    str r1, [r3], #4
    0xe0000ef4    0x12c    cmp r3, r2
    0xe0000ef8    0x130    bne e0000ef0 <map_kernel_window+0x128>
    0xe0000efc    0x134    ldr r3, [pc, #36] 
    0xe0000f00    0x138    pop {r4, lr}          ; stack access
    0xe0000f04    0x13c    bic r3, r3, #4080 
    0xe0000f08    0x140    bic r3, r3, #15
    0xe0000f0c    0x144    orr r3, r3, #340 
    0xe0000f10    0x148    orr r3, r3, #2
    0xe0000f14    0x14c    str r3, [ip, #960] 
    0xe0000f18    0x150    b e0000d40 <map_kernel_devices>
    0xe0000f1c    0x154    .word 0xe00277fc
    0xe0000f20    0x158    .word 0x10020000
    0xe0000f24    0x15c    .word 0xe0027000
    0xe0000f28    0x160    .word 0x10010000

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
85 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_window` has 115 nodes.

Section reserve_region (202 of 299)
===================================

Deriving specifications
-----------------------

Section `reserve_region` consists of 90 instructions.
 LDMIA;12,4...+
 MOVLS (reg)....+++


Stack analysis
---------------

7 stack accesses found. Annotated code for `reserve_region`:

    0xe0000bd8      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0000bdc      0x4    sub sp, sp, #8
    0xe0000be0      0x8    add r3, sp, #8
    0xe0000be4      0xc    stmdb r3, {r0, r1}    ; stack access
    0xe0000be8     0x10    ldm sp, {r4, ip}      ; stack access
    0xe0000bec     0x14    cmp r4, ip
    0xe0000bf0     0x18    moveq r0, #1
    0xe0000bf4     0x1c    beq e0000c8c <reserve_region+0xb4>
    0xe0000bf8     0x20    movw r5, #46848 
    0xe0000bfc     0x24    movt r5, #57345 
    0xe0000c00     0x28    ldr lr, [r5, #88] 
    0xe0000c04     0x2c    cmp lr, #0
    0xe0000c08     0x30    beq e0000d24 <reserve_region+0x14c>
    0xe0000c0c     0x34    ldr r3, [r5]
    0xe0000c10     0x38    cmp r3, ip
    0xe0000c14     0x3c    beq e0000c94 <reserve_region+0xbc>
    0xe0000c18     0x40    ldr r2, [r5, #4]
    0xe0000c1c     0x44    cmp r4, r2
    0xe0000c20     0x48    beq e0000cac <reserve_region+0xd4>
    0xe0000c24     0x4c    cmp r3, ip
    0xe0000c28     0x50    movls r3, r5
    0xe0000c2c     0x54    movls r2, #0
    0xe0000c30     0x58    bls e0000c5c <reserve_region+0x84>
    0xe0000c34     0x5c    b e0000d2c <reserve_region+0x154>
    0xe0000c38     0x60    ldr r1, [r3, #8]
    0xe0000c3c     0x64    cmp r1, ip
    0xe0000c40     0x68    beq e0000c98 <reserve_region+0xc0>
    0xe0000c44     0x6c    ldr r0, [r3, #12]
    0xe0000c48     0x70    add r3, r3, #8
    0xe0000c4c     0x74    cmp r0, r4
    0xe0000c50     0x78    beq e0000cb0 <reserve_region+0xd8>
    0xe0000c54     0x7c    cmp r1, ip
    0xe0000c58     0x80    bhi e0000cc8 <reserve_region+0xf0>
    0xe0000c5c     0x84    add r2, r2, #1
    0xe0000c60     0x88    cmp lr, r2
    0xe0000c64     0x8c    bne e0000c38 <reserve_region+0x60>
    0xe0000c68     0x90    cmp lr, #10
    0xe0000c6c     0x94    beq e0000d18 <reserve_region+0x140>
    0xe0000c70     0x98    add lr, r5, lr, lsl #3
    0xe0000c74     0x9c    str r4, [lr]
    0xe0000c78     0xa0    mov r0, #1
    0xe0000c7c     0xa4    str ip, [lr, #4]
    0xe0000c80     0xa8    ldr r3, [r5, #88] 
    0xe0000c84     0xac    add r3, r3, r0
    0xe0000c88     0xb0    str r3, [r5, #88] 
    0xe0000c8c     0xb4    add sp, sp, #8
    0xe0000c90     0xb8    pop {r4, r5, r6, pc}  ; stack access
    0xe0000c94     0xbc    mov r2, #0
    0xe0000c98     0xc0    str r4, [r5, r2, lsl #3]
    0xe0000c9c     0xc4    bl e0000260 <merge_regions>
    0xe0000ca0     0xc8    mov r0, #1
    0xe0000ca4     0xcc    add sp, sp, #8
    0xe0000ca8     0xd0    pop {r4, r5, r6, pc}  ; stack access
    0xe0000cac     0xd4    mov r2, #0
    0xe0000cb0     0xd8    add r2, r5, r2, lsl #3
    0xe0000cb4     0xdc    str ip, [r2, #4]
    0xe0000cb8     0xe0    bl e0000260 <merge_regions>
    0xe0000cbc     0xe4    mov r0, #1
    0xe0000cc0     0xe8    add sp, sp, #8
    0xe0000cc4     0xec    pop {r4, r5, r6, pc}  ; stack access
    0xe0000cc8     0xf0    add r3, lr, #1
    0xe0000ccc     0xf4    cmp r3, #10
    0xe0000cd0     0xf8    bhi e0000d18 <reserve_region+0x140>
    0xe0000cd4     0xfc    mov r6, lr
    0xe0000cd8    0x100    sub lr, lr, #1
    0xe0000cdc    0x104    add r3, r5, r6, lsl #3
    0xe0000ce0    0x108    cmp lr, r2
    0xe0000ce4    0x10c    sub r6, r6, #1
    0xe0000ce8    0x110    add r1, r5, lr, lsl #3
    0xe0000cec    0x114    ldm r1, {r0, r1}
    0xe0000cf0    0x118    stm r3, {r0, r1}
    0xe0000cf4    0x11c    bhi e0000cd8 <reserve_region+0x100>
    0xe0000cf8    0x120    add r3, r5, r2, lsl #3
    0xe0000cfc    0x124    str r4, [r5, r2, lsl #3]
    0xe0000d00    0x128    mov r0, #1
    0xe0000d04    0x12c    str ip, [r3, #4]
    0xe0000d08    0x130    ldr r3, [r5, #88] 
    0xe0000d0c    0x134    add r3, r3, r0
    0xe0000d10    0x138    str r3, [r5, #88] 
    0xe0000d14    0x13c    b e0000c8c <reserve_region+0xb4>
    0xe0000d18    0x140    mov r0, #0
    0xe0000d1c    0x144    add sp, sp, #8
    0xe0000d20    0x148    pop {r4, r5, r6, pc}  ; stack access
    0xe0000d24    0x14c    mov lr, r5
    0xe0000d28    0x150    b e0000c74 <reserve_region+0x9c>
    0xe0000d2c    0x154    add r3, lr, #1
    0xe0000d30    0x158    cmp r3, #10
    0xe0000d34    0x15c    bhi e0000d18 <reserve_region+0x140>
    0xe0000d38    0x160    mov r2, #0
    0xe0000d3c    0x164    b e0000cd4 <reserve_region+0xfc>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
90 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `reserve_region` has 148 nodes.

Section map_kernel_frame (203 of 299)
=====================================

Deriving specifications
-----------------------

Section `map_kernel_frame` consists of 19 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `map_kernel_frame`:

    0xe0000374     0x0    tst r3, #1
    0xe0000378     0x4    ubfx r1, r1, #12, #8
    0xe000037c     0x8    push {r4, r5, r6, lr}  ; stack access
    0xe0000380     0xc    mov r4, r0
    0xe0000384    0x10    mov r0, r2
    0xe0000388    0x14    moveq r5, #0
    0xe000038c    0x18    movne r5, #320 
    0xe0000390    0x1c    bl e0010a48 <APFromVMRights>
    0xe0000394    0x20    bic r3, r4, #4080 
    0xe0000398    0x24    movw r2, #0
    0xe000039c    0x28    bic r3, r3, #15
    0xe00003a0    0x2c    movt r2, #57346 
    0xe00003a4    0x30    orr r3, r3, #6
    0xe00003a8    0x34    orr r3, r3, r5
    0xe00003ac    0x38    lsl r0, r0, #4
    0xe00003b0    0x3c    and r0, r0, #48 
    0xe00003b4    0x40    orr r3, r3, r0
    0xe00003b8    0x44    str r3, [r2, r1, lsl #2]
    0xe00003bc    0x48    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
19 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_frame` has 27 nodes.

Section replyFromKernel_error (204 of 299)
==========================================

Deriving specifications
-----------------------

Section `replyFromKernel_error` consists of 17 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `replyFromKernel_error`:

    0xe001a410     0x0    push {r4, lr}         ; stack access
    0xe001a414     0x4    mov r4, r0
    0xe001a418     0x8    mov r1, r4
    0xe001a41c     0xc    mov r0, #1
    0xe001a420    0x10    bl e0010d50 <lookupIPCBuffer>
    0xe001a424    0x14    mov r3, #0
    0xe001a428    0x18    str r3, [r4]
    0xe001a42c    0x1c    mov r1, r0
    0xe001a430    0x20    mov r0, r4
    0xe001a434    0x24    bl e001a2d0 <setMRs_syscall_error>
    0xe001a438    0x28    movw r3, #36896 
    0xe001a43c    0x2c    movt r3, #57346 
    0xe001a440    0x30    ldr r3, [r3, #24]
    0xe001a444    0x34    and r0, r0, #127 
    0xe001a448    0x38    orr r0, r0, r3, lsl #12
    0xe001a44c    0x3c    str r0, [r4, #4]
    0xe001a450    0x40    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

17 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `replyFromKernel_error` has 24 nodes.

Section decodeWriteRegisters (205 of 299)
=========================================

Deriving specifications
-----------------------

Section `decodeWriteRegisters` consists of 47 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `decodeWriteRegisters`:

    0xe0019f20     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0019f24     0x4    sub sp, sp, #20
    0xe0019f28     0x8    add ip, sp, #16
    0xe0019f2c     0xc    cmp r2, #1
    0xe0019f30    0x10    stmdb ip, {r0, r1}    ; stack access
    0xe0019f34    0x14    bls e0019fa4 <decodeWriteRegisters+0x84>
    0xe0019f38    0x18    movw r0, #13900 
    0xe0019f3c    0x1c    movt r0, #57347 
    0xe0019f40    0x20    sub r1, r2, #2
    0xe0019f44    0x24    ldr ip, [r0]
    0xe0019f48    0x28    ldr r6, [ip, #12]
    0xe0019f4c    0x2c    cmp r1, r6
    0xe0019f50    0x30    bcc e0019fa4 <decodeWriteRegisters+0x84>
    0xe0019f54    0x34    ldr r4, [sp, #8]      ; stack access
    0xe0019f58    0x38    bic r4, r4, #15
    0xe0019f5c    0x3c    cmp r4, ip
    0xe0019f60    0x40    beq e0019fc0 <decodeWriteRegisters+0xa0>
    0xe0019f64    0x44    ldr lr, [ip, #80] 
    0xe0019f68    0x48    mov r0, ip
    0xe0019f6c    0x4c    ldr r7, [ip, #8]
    0xe0019f70    0x50    mov r5, r3
    0xe0019f74    0x54    bic lr, lr, #15
    0xe0019f78    0x58    orr lr, lr, #2
    0xe0019f7c    0x5c    str lr, [ip, #80] 
    0xe0019f80    0x60    bl e0013114 <setThreadState.part.166>
    0xe0019f84    0x64    and r1, r7, #1
    0xe0019f88    0x68    str r5, [sp]          ; stack access
    0xe0019f8c    0x6c    mov r2, r6
    0xe0019f90    0x70    mov r0, r4
    0xe0019f94    0x74    mov r3, #0
    0xe0019f98    0x78    bl e0019e24 <invokeTCB_WriteRegisters>
    0xe0019f9c    0x7c    add sp, sp, #20
    0xe0019fa0    0x80    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0019fa4    0x84    movw r3, #36896 
    0xe0019fa8    0x88    movt r3, #57346 
    0xe0019fac    0x8c    mov r2, #7
    0xe0019fb0    0x90    mov r0, #3
    0xe0019fb4    0x94    str r2, [r3, #24]
    0xe0019fb8    0x98    add sp, sp, #20
    0xe0019fbc    0x9c    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0019fc0    0xa0    movw r3, #36896 
    0xe0019fc4    0xa4    movt r3, #57346 
    0xe0019fc8    0xa8    mov r2, #3
    0xe0019fcc    0xac    mov r0, r2
    0xe0019fd0    0xb0    str r2, [r3, #24]
    0xe0019fd4    0xb4    add sp, sp, #20
    0xe0019fd8    0xb8    pop {r4, r5, r6, r7, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
47 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeWriteRegisters` has 69 nodes.

Section invokeTCB_WriteRegisters (206 of 299)
=============================================

Deriving specifications
-----------------------

Section `invokeTCB_WriteRegisters` consists of 63 instructions.
 MOVCC (reg)....+++
 LDRHI (+imm,pre)...+++
 LDRCC (+reg,pre)......++++++


Stack analysis
---------------

4 stack accesses found. Annotated code for `invokeTCB_WriteRegisters`:

    0xe0019e24     0x0    cmp r2, #19
    0xe0019e28     0x4    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0019e2c     0x8    movcc r6, r2
    0xe0019e30     0xc    movcs r6, #19
    0xe0019e34    0x10    movw r5, #13900 
    0xe0019e38    0x14    cmp r2, #0
    0xe0019e3c    0x18    movt r5, #57347 
    0xe0019e40    0x1c    mov r4, r0
    0xe0019e44    0x20    ldr r0, [sp, #32]     ; stack access
    0xe0019e48    0x24    ldr r7, [r5]
    0xe0019e4c    0x28    beq e0019ea0 <invokeTCB_WriteRegisters+0x7c>
    0xe0019e50    0x2c    ldr r8, [pc, #192] 
    0xe0019e54    0x30    mov r2, #2
    0xe0019e58    0x34    mov lr, #17
    0xe0019e5c    0x38    mov r3, #0
    0xe0019e60    0x3c    add r9, r8, #48 
    0xe0019e64    0x40    cmp r2, #3
    0xe0019e68    0x44    add ip, r0, r3, lsl #2
    0xe0019e6c    0x48    add r3, r3, #1
    0xe0019e70    0x4c    ldrls ip, [r8, r2, lsl #2]
    0xe0019e74    0x50    add r2, r2, #1
    0xe0019e78    0x54    ldrhi ip, [ip, #12]
    0xe0019e7c    0x58    ldrls ip, [r7, ip, lsl #2]
    0xe0019e80    0x5c    cmp lr, #16
    0xe0019e84    0x60    andeq ip, ip, #-134217728 
    0xe0019e88    0x64    orreq ip, ip, #336 
    0xe0019e8c    0x68    cmp r3, #9
    0xe0019e90    0x6c    cmpls r3, r6
    0xe0019e94    0x70    str ip, [r4, lr, lsl #2]
    0xe0019e98    0x74    ldrcc lr, [r9, r3, lsl #2]
    0xe0019e9c    0x78    bcc e0019e64 <invokeTCB_WriteRegisters+0x40>
    0xe0019ea0    0x7c    ldr lr, [pc, #116] 
    0xe0019ea4    0x80    add r0, r0, #48 
    0xe0019ea8    0x84    mov r3, #10
    0xe0019eac    0x88    cmp r6, r3
    0xe0019eb0    0x8c    add r3, r3, #1
    0xe0019eb4    0x90    bls e0019ed8 <invokeTCB_WriteRegisters+0xb4>
    0xe0019eb8    0x94    ldr ip, [lr, #4]!
    0xe0019ebc    0x98    ldr r2, [r0, #4]!
    0xe0019ec0    0x9c    cmp ip, #16
    0xe0019ec4    0xa0    andeq r2, r2, #-134217728 
    0xe0019ec8    0xa4    orreq r2, r2, #336 
    0xe0019ecc    0xa8    cmp r3, #19
    0xe0019ed0    0xac    str r2, [r4, ip, lsl #2]
    0xe0019ed4    0xb0    bne e0019eac <invokeTCB_WriteRegisters+0x88>
    0xe0019ed8    0xb4    ldr r3, [r4, #68] 
    0xe0019edc    0xb8    cmp r1, #0
    0xe0019ee0    0xbc    str r3, [r4, #60] 
    0xe0019ee4    0xc0    bne e0019ef8 <invokeTCB_WriteRegisters+0xd4>
    0xe0019ee8    0xc4    cmp r4, r7
    0xe0019eec    0xc8    beq e0019f0c <invokeTCB_WriteRegisters+0xe8>
    0xe0019ef0    0xcc    mov r0, #0
    0xe0019ef4    0xd0    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe0019ef8    0xd4    mov r0, r4
    0xe0019efc    0xd8    bl e0017514 <restart>
    0xe0019f00    0xdc    ldr r7, [r5]
    0xe0019f04    0xe0    cmp r4, r7
    0xe0019f08    0xe4    bne e0019ef0 <invokeTCB_WriteRegisters+0xcc>
    0xe0019f0c    0xe8    bl e0013098 <rescheduleRequired>
    0xe0019f10    0xec    mov r0, #0
    0xe0019f14    0xf0    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe0019f18    0xf4    .word 0xe001b428
    0xe0019f1c    0xf8    .word 0xe001b47c

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
61 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_WriteRegisters` has 115 nodes.

Section decodeReadRegisters (207 of 299)
========================================

Deriving specifications
-----------------------

Section `decodeReadRegisters` consists of 58 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `decodeReadRegisters`:

    0xe0019d3c     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0019d40     0x4    sub sp, sp, #12
    0xe0019d44     0x8    cmp r2, #1
    0xe0019d48     0xc    add r2, sp, #8
    0xe0019d4c    0x10    stmdb r2, {r0, r1}    ; stack access
    0xe0019d50    0x14    bls e0019dec <decodeReadRegisters+0xb0>
    0xe0019d54    0x18    movw r2, #13900 
    0xe0019d58    0x1c    movt r2, #57347 
    0xe0019d5c    0x20    ldr ip, [r2]
    0xe0019d60    0x24    ldr r6, [ip, #12]
    0xe0019d64    0x28    sub r2, r6, #1
    0xe0019d68    0x2c    cmp r2, #18
    0xe0019d6c    0x30    bhi e0019dc0 <decodeReadRegisters+0x84>
    0xe0019d70    0x34    ldr r4, [sp]          ; stack access
    0xe0019d74    0x38    bic r4, r4, #15
    0xe0019d78    0x3c    cmp r4, ip
    0xe0019d7c    0x40    beq e0019e08 <decodeReadRegisters+0xcc>
    0xe0019d80    0x44    ldr lr, [ip, #80] 
    0xe0019d84    0x48    mov r0, ip
    0xe0019d88    0x4c    mov r5, r3
    0xe0019d8c    0x50    ldr r7, [ip, #8]
    0xe0019d90    0x54    bic lr, lr, #15
    0xe0019d94    0x58    orr lr, lr, #2
    0xe0019d98    0x5c    str lr, [ip, #80] 
    0xe0019d9c    0x60    bl e0013114 <setThreadState.part.166>
    0xe0019da0    0x64    and r1, r7, #1
    0xe0019da4    0x68    str r5, [sp, #32]     ; stack access
    0xe0019da8    0x6c    mov r2, r6
    0xe0019dac    0x70    mov r0, r4
    0xe0019db0    0x74    mov r3, #0
    0xe0019db4    0x78    add sp, sp, #12
    0xe0019db8    0x7c    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0019dbc    0x80    b e0019ba0 <invokeTCB_ReadRegisters>
    0xe0019dc0    0x84    movw r3, #36896 
    0xe0019dc4    0x88    movt r3, #57346 
    0xe0019dc8    0x8c    mov r2, #4
    0xe0019dcc    0x90    mov r1, #1
    0xe0019dd0    0x94    str r2, [r3, #24]
    0xe0019dd4    0x98    mov r0, #3
    0xe0019dd8    0x9c    mov r2, #19
    0xe0019ddc    0xa0    str r1, [r3, #8]
    0xe0019de0    0xa4    str r2, [r3, #12]
    0xe0019de4    0xa8    add sp, sp, #12
    0xe0019de8    0xac    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0019dec    0xb0    movw r3, #36896 
    0xe0019df0    0xb4    movt r3, #57346 
    0xe0019df4    0xb8    mov r2, #7
    0xe0019df8    0xbc    mov r0, #3
    0xe0019dfc    0xc0    str r2, [r3, #24]
    0xe0019e00    0xc4    add sp, sp, #12
    0xe0019e04    0xc8    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0019e08    0xcc    movw r3, #36896 
    0xe0019e0c    0xd0    movt r3, #57346 
    0xe0019e10    0xd4    mov r2, #3
    0xe0019e14    0xd8    mov r0, #3
    0xe0019e18    0xdc    str r2, [r3, #24]
    0xe0019e1c    0xe0    add sp, sp, #12
    0xe0019e20    0xe4    pop {r4, r5, r6, r7, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
58 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeReadRegisters` has 84 nodes.

Section decodeCopyRegisters (208 of 299)
========================================

Deriving specifications
-----------------------

Section `decodeCopyRegisters` consists of 57 instructions.
 LDMIA (wb);14,5,4.+


Stack analysis
---------------

9 stack accesses found. Annotated code for `decodeCopyRegisters`:

    0xe0019abc     0x0    sub sp, sp, #8
    0xe0019ac0     0x4    cmp r3, #0
    0xe0019ac4     0x8    cmpne r2, #0
    0xe0019ac8     0xc    push {r4, r5, lr}     ; stack access
    0xe0019acc    0x10    sub sp, sp, #12
    0xe0019ad0    0x14    add r2, sp, #8
    0xe0019ad4    0x18    str r3, [sp, #28]     ; stack access
    0xe0019ad8    0x1c    stmdb r2, {r0, r1}    ; stack access
    0xe0019adc    0x20    beq e0019b8c <decodeCopyRegisters+0xd0>
    0xe0019ae0    0x24    ldr r4, [r3]
    0xe0019ae4    0x28    and r3, r4, #14
    0xe0019ae8    0x2c    cmp r3, #14
    0xe0019aec    0x30    andne r3, r4, #15
    0xe0019af0    0x34    uxtbeq r3, r4
    0xe0019af4    0x38    cmp r3, #12
    0xe0019af8    0x3c    beq e0019b28 <decodeCopyRegisters+0x6c>
    0xe0019afc    0x40    movw r3, #36896 
    0xe0019b00    0x44    movt r3, #57346 
    0xe0019b04    0x48    mov r1, #2
    0xe0019b08    0x4c    mov r2, #1
    0xe0019b0c    0x50    str r1, [r3, #24]
    0xe0019b10    0x54    str r2, [r3, #4]
    0xe0019b14    0x58    mov r0, #3
    0xe0019b18    0x5c    add sp, sp, #12
    0xe0019b1c    0x60    pop {r4, r5, lr}      ; stack access
    0xe0019b20    0x64    add sp, sp, #8
    0xe0019b24    0x68    bx lr
    0xe0019b28    0x6c    movw r3, #13900 
    0xe0019b2c    0x70    movt r3, #57347 
    0xe0019b30    0x74    ldr r2, [r3]
    0xe0019b34    0x78    ldr r3, [r2, #80] 
    0xe0019b38    0x7c    mov r0, r2
    0xe0019b3c    0x80    ldr r5, [r2, #8]
    0xe0019b40    0x84    bic r3, r3, #15
    0xe0019b44    0x88    orr r3, r3, #2
    0xe0019b48    0x8c    str r3, [r2, #80] 
    0xe0019b4c    0x90    bl e0013114 <setThreadState.part.166>
    0xe0019b50    0x94    ldr r0, [sp]          ; stack access
    0xe0019b54    0x98    and r2, r5, #8
    0xe0019b58    0x9c    and r3, r5, #4
    0xe0019b5c    0xa0    str r2, [sp, #36]     ; stack access
    0xe0019b60    0xa4    mov ip, #0
    0xe0019b64    0xa8    str r3, [sp, #32]     ; stack access
    0xe0019b68    0xac    bic r1, r4, #15
    0xe0019b6c    0xb0    and r3, r5, #2
    0xe0019b70    0xb4    and r2, r5, #1
    0xe0019b74    0xb8    bic r0, r0, #15
    0xe0019b78    0xbc    str ip, [sp, #40]     ; stack access
    0xe0019b7c    0xc0    add sp, sp, #12
    0xe0019b80    0xc4    pop {r4, r5, lr}      ; stack access
    0xe0019b84    0xc8    add sp, sp, #8
    0xe0019b88    0xcc    b e00199e8 <invokeTCB_CopyRegisters>
    0xe0019b8c    0xd0    movw r3, #36896 
    0xe0019b90    0xd4    movt r3, #57346 
    0xe0019b94    0xd8    mov r2, #7
    0xe0019b98    0xdc    str r2, [r3, #24]
    0xe0019b9c    0xe0    b e0019b14 <decodeCopyRegisters+0x58>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
57 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeCopyRegisters` has 87 nodes.

Section decodeSetSchedParams (209 of 299)
=========================================

Deriving specifications
-----------------------

Section `decodeSetSchedParams` consists of 93 instructions.
 STMIB;1,0...+


Stack analysis
---------------

22 stack accesses found. Annotated code for `decodeSetSchedParams`:

    0xe00194dc      0x0    sub sp, sp, #8
    0xe00194e0      0x4    cmp r3, #0
    0xe00194e4      0x8    cmpne r2, #1
    0xe00194e8      0xc    push {r4, r5, r6, lr}  ; stack access
    0xe00194ec     0x10    sub sp, sp, #64 
    0xe00194f0     0x14    add r2, sp, #48 
    0xe00194f4     0x18    str r3, [sp, #84]     ; stack access
    0xe00194f8     0x1c    stm r2, {r0, r1}      ; stack access
    0xe00194fc     0x20    bls e001962c <decodeSetSchedParams+0x150>
    0xe0019500     0x24    ldr r3, [r3]
    0xe0019504     0x28    and r2, r3, #14
    0xe0019508     0x2c    cmp r2, #14
    0xe001950c     0x30    andne r2, r3, #15
    0xe0019510     0x34    uxtbeq r2, r3
    0xe0019514     0x38    cmp r2, #12
    0xe0019518     0x3c    bne e00195d0 <decodeSetSchedParams+0xf4>
    0xe001951c     0x40    movw r2, #13900 
    0xe0019520     0x44    movt r2, #57347 
    0xe0019524     0x48    bic r3, r3, #15
    0xe0019528     0x4c    ldr r2, [r2]
    0xe001952c     0x50    ldr r1, [r3, #116] 
    0xe0019530     0x54    ldr r4, [r2, #8]
    0xe0019534     0x58    cmp r1, r4
    0xe0019538     0x5c    bcc e00195fc <decodeSetSchedParams+0x120>
    0xe001953c     0x60    ldr r5, [r2, #12]
    0xe0019540     0x64    cmp r1, r5
    0xe0019544     0x68    bcc e00195fc <decodeSetSchedParams+0x120>
    0xe0019548     0x6c    ldr r3, [r2, #80] 
    0xe001954c     0x70    mov r0, r2
    0xe0019550     0x74    add r6, sp, #32
    0xe0019554     0x78    bic r3, r3, #15
    0xe0019558     0x7c    orr r3, r3, #2
    0xe001955c     0x80    str r3, [r2, #80] 
    0xe0019560     0x84    bl e0013114 <setThreadState.part.166>
    0xe0019564     0x88    add ip, sp, #56 
    0xe0019568     0x8c    mov r2, #0
    0xe001956c     0x90    str r2, [sp, #56]     ; stack access
    0xe0019570     0x94    str r2, [sp, #60]     ; stack access
    0xe0019574     0x98    mov lr, #9
    0xe0019578     0x9c    ldm ip, {r0, r1}      ; stack access
    0xe001957c     0xa0    mov r3, r4
    0xe0019580     0xa4    str lr, [sp, #44]     ; stack access
    0xe0019584     0xa8    add lr, sp, #16
    0xe0019588     0xac    str r2, [sp, #40]     ; stack access
    0xe001958c     0xb0    stm r6, {r0, r1}      ; stack access
    0xe0019590     0xb4    ldm ip, {r0, r1}      ; stack access
    0xe0019594     0xb8    str r2, [sp, #28]     ; stack access
    0xe0019598     0xbc    str r2, [sp, #24]     ; stack access
    0xe001959c     0xc0    stm lr, {r0, r1}      ; stack access
    0xe00195a0     0xc4    ldm ip, {r0, r1}      ; stack access
    0xe00195a4     0xc8    ldr ip, [sp, #48]     ; stack access
    0xe00195a8     0xcc    str r2, [sp, #12]     ; stack access
    0xe00195ac     0xd0    stmib sp, {r0, r1}    ; stack access
    0xe00195b0     0xd4    mov r1, r2
    0xe00195b4     0xd8    str r5, [sp]          ; stack access
    0xe00195b8     0xdc    bic r0, ip, #15
    0xe00195bc     0xe0    bl e0018d60 <invokeTCB_ThreadControl>
    0xe00195c0     0xe4    add sp, sp, #64 
    0xe00195c4     0xe8    pop {r4, r5, r6, lr}  ; stack access
    0xe00195c8     0xec    add sp, sp, #8
    0xe00195cc     0xf0    bx lr
    0xe00195d0     0xf4    movw r3, #36896 
    0xe00195d4     0xf8    movt r3, #57346 
    0xe00195d8     0xfc    mov r1, #2
    0xe00195dc    0x100    mov r2, #1
    0xe00195e0    0x104    mov r0, #3
    0xe00195e4    0x108    str r1, [r3, #24]
    0xe00195e8    0x10c    str r2, [r3, #4]
    0xe00195ec    0x110    add sp, sp, #64 
    0xe00195f0    0x114    pop {r4, r5, r6, lr}  ; stack access
    0xe00195f4    0x118    add sp, sp, #8
    0xe00195f8    0x11c    bx lr
    0xe00195fc    0x120    movw r3, #36896 
    0xe0019600    0x124    movt r3, #57346 
    0xe0019604    0x128    mov ip, #4
    0xe0019608    0x12c    mov r2, #0
    0xe001960c    0x130    mov r0, #3
    0xe0019610    0x134    str r1, [r3, #12]
    0xe0019614    0x138    str ip, [r3, #24]
    0xe0019618    0x13c    str r2, [r3, #8]
    0xe001961c    0x140    add sp, sp, #64 
    0xe0019620    0x144    pop {r4, r5, r6, lr}  ; stack access
    0xe0019624    0x148    add sp, sp, #8
    0xe0019628    0x14c    bx lr
    0xe001962c    0x150    movw r3, #36896 
    0xe0019630    0x154    movt r3, #57346 
    0xe0019634    0x158    mov r2, #7
    0xe0019638    0x15c    mov r0, #3
    0xe001963c    0x160    str r2, [r3, #24]
    0xe0019640    0x164    add sp, sp, #64 
    0xe0019644    0x168    pop {r4, r5, r6, lr}  ; stack access
    0xe0019648    0x16c    add sp, sp, #8
    0xe001964c    0x170    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
93 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetSchedParams` has 148 nodes.

Section decodeSetMCPriority (210 of 299)
========================================

Deriving specifications
-----------------------

Section `decodeSetMCPriority` consists of 90 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `decodeSetMCPriority`:

    0xe0019374      0x0    sub sp, sp, #8
    0xe0019378      0x4    cmp r2, #0
    0xe001937c      0x8    cmpne r3, #0
    0xe0019380      0xc    push {r4, r5, lr}     ; stack access
    0xe0019384     0x10    sub sp, sp, #68 
    0xe0019388     0x14    add r2, sp, #48 
    0xe001938c     0x18    str r3, [sp, #84]     ; stack access
    0xe0019390     0x1c    stm r2, {r0, r1}      ; stack access
    0xe0019394     0x20    beq e0019488 <decodeSetMCPriority+0x114>
    0xe0019398     0x24    ldr r3, [r3]
    0xe001939c     0x28    and r2, r3, #14
    0xe00193a0     0x2c    cmp r2, #14
    0xe00193a4     0x30    andne r2, r3, #15
    0xe00193a8     0x34    uxtbeq r2, r3
    0xe00193ac     0x38    cmp r2, #12
    0xe00193b0     0x3c    bne e001945c <decodeSetMCPriority+0xe8>
    0xe00193b4     0x40    movw r2, #13900 
    0xe00193b8     0x44    movt r2, #57347 
    0xe00193bc     0x48    bic r3, r3, #15
    0xe00193c0     0x4c    ldr r2, [r2]
    0xe00193c4     0x50    ldr r1, [r3, #116] 
    0xe00193c8     0x54    ldr r4, [r2, #8]
    0xe00193cc     0x58    cmp r1, r4
    0xe00193d0     0x5c    bcc e00194ac <decodeSetMCPriority+0x138>
    0xe00193d4     0x60    ldr r1, [r2, #80] 
    0xe00193d8     0x64    mov r0, r2
    0xe00193dc     0x68    add r5, sp, #32
    0xe00193e0     0x6c    bic r1, r1, #15
    0xe00193e4     0x70    orr r1, r1, #2
    0xe00193e8     0x74    str r1, [r2, #80] 
    0xe00193ec     0x78    bl e0013114 <setThreadState.part.166>
    0xe00193f0     0x7c    add ip, sp, #56 
    0xe00193f4     0x80    mov r2, #0
    0xe00193f8     0x84    str r2, [sp, #56]     ; stack access
    0xe00193fc     0x88    str r2, [sp, #60]     ; stack access
    0xe0019400     0x8c    mov lr, #8
    0xe0019404     0x90    ldm ip, {r0, r1}      ; stack access
    0xe0019408     0x94    mov r3, r4
    0xe001940c     0x98    str lr, [sp, #44]     ; stack access
    0xe0019410     0x9c    add lr, sp, #16
    0xe0019414     0xa0    str r2, [sp, #40]     ; stack access
    0xe0019418     0xa4    stm r5, {r0, r1}      ; stack access
    0xe001941c     0xa8    ldm ip, {r0, r1}      ; stack access
    0xe0019420     0xac    str r2, [sp, #28]     ; stack access
    0xe0019424     0xb0    str r2, [sp, #24]     ; stack access
    0xe0019428     0xb4    stm lr, {r0, r1}      ; stack access
    0xe001942c     0xb8    ldm ip, {r0, r1}      ; stack access
    0xe0019430     0xbc    ldr ip, [sp, #48]     ; stack access
    0xe0019434     0xc0    str r2, [sp, #12]     ; stack access
    0xe0019438     0xc4    stmib sp, {r0, r1}    ; stack access
    0xe001943c     0xc8    mov r1, r2
    0xe0019440     0xcc    str r2, [sp]          ; stack access
    0xe0019444     0xd0    bic r0, ip, #15
    0xe0019448     0xd4    bl e0018d60 <invokeTCB_ThreadControl>
    0xe001944c     0xd8    add sp, sp, #68 
    0xe0019450     0xdc    pop {r4, r5, lr}      ; stack access
    0xe0019454     0xe0    add sp, sp, #8
    0xe0019458     0xe4    bx lr
    0xe001945c     0xe8    movw r3, #36896 
    0xe0019460     0xec    movt r3, #57346 
    0xe0019464     0xf0    mov r1, #2
    0xe0019468     0xf4    mov r2, #1
    0xe001946c     0xf8    mov r0, #3
    0xe0019470     0xfc    str r1, [r3, #24]
    0xe0019474    0x100    str r2, [r3, #4]
    0xe0019478    0x104    add sp, sp, #68 
    0xe001947c    0x108    pop {r4, r5, lr}      ; stack access
    0xe0019480    0x10c    add sp, sp, #8
    0xe0019484    0x110    bx lr
    0xe0019488    0x114    movw r3, #36896 
    0xe001948c    0x118    movt r3, #57346 
    0xe0019490    0x11c    mov r2, #7
    0xe0019494    0x120    mov r0, #3
    0xe0019498    0x124    str r2, [r3, #24]
    0xe001949c    0x128    add sp, sp, #68 
    0xe00194a0    0x12c    pop {r4, r5, lr}      ; stack access
    0xe00194a4    0x130    add sp, sp, #8
    0xe00194a8    0x134    bx lr
    0xe00194ac    0x138    movw r3, #36896 
    0xe00194b0    0x13c    movt r3, #57346 
    0xe00194b4    0x140    mov r0, #3
    0xe00194b8    0x144    mov ip, #4
    0xe00194bc    0x148    mov r2, #0
    0xe00194c0    0x14c    str r1, [r3, #12]
    0xe00194c4    0x150    str ip, [r3, #24]
    0xe00194c8    0x154    str r2, [r3, #8]
    0xe00194cc    0x158    add sp, sp, #68 
    0xe00194d0    0x15c    pop {r4, r5, lr}      ; stack access
    0xe00194d4    0x160    add sp, sp, #8
    0xe00194d8    0x164    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
90 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetMCPriority` has 142 nodes.

Section decodeSetPriority (211 of 299)
======================================

Deriving specifications
-----------------------

Section `decodeSetPriority` consists of 90 instructions.


Stack analysis
---------------

22 stack accesses found. Annotated code for `decodeSetPriority`:

    0xe001920c      0x0    sub sp, sp, #8
    0xe0019210      0x4    cmp r2, #0
    0xe0019214      0x8    cmpne r3, #0
    0xe0019218      0xc    push {r4, lr}         ; stack access
    0xe001921c     0x10    sub sp, sp, #64 
    0xe0019220     0x14    add r2, sp, #48 
    0xe0019224     0x18    str r3, [sp, #76]     ; stack access
    0xe0019228     0x1c    stm r2, {r0, r1}      ; stack access
    0xe001922c     0x20    beq e0019320 <decodeSetPriority+0x114>
    0xe0019230     0x24    ldr r3, [r3]
    0xe0019234     0x28    and r2, r3, #14
    0xe0019238     0x2c    cmp r2, #14
    0xe001923c     0x30    andne r2, r3, #15
    0xe0019240     0x34    uxtbeq r2, r3
    0xe0019244     0x38    cmp r2, #12
    0xe0019248     0x3c    bne e00192f4 <decodeSetPriority+0xe8>
    0xe001924c     0x40    movw r2, #13900 
    0xe0019250     0x44    movt r2, #57347 
    0xe0019254     0x48    bic r3, r3, #15
    0xe0019258     0x4c    ldr r2, [r2]
    0xe001925c     0x50    ldr r1, [r3, #116] 
    0xe0019260     0x54    ldr r4, [r2, #8]
    0xe0019264     0x58    cmp r1, r4
    0xe0019268     0x5c    bcc e0019344 <decodeSetPriority+0x138>
    0xe001926c     0x60    ldr r3, [r2, #80] 
    0xe0019270     0x64    mov r0, r2
    0xe0019274     0x68    bic r3, r3, #15
    0xe0019278     0x6c    orr r3, r3, #2
    0xe001927c     0x70    str r3, [r2, #80] 
    0xe0019280     0x74    bl e0013114 <setThreadState.part.166>
    0xe0019284     0x78    add ip, sp, #56 
    0xe0019288     0x7c    mov r3, #0
    0xe001928c     0x80    str r3, [sp, #56]     ; stack access
    0xe0019290     0x84    str r3, [sp, #60]     ; stack access
    0xe0019294     0x88    add lr, sp, #32
    0xe0019298     0x8c    ldm ip, {r0, r1}      ; stack access
    0xe001929c     0x90    mov r2, #1
    0xe00192a0     0x94    str r3, [sp, #40]     ; stack access
    0xe00192a4     0x98    str r2, [sp, #44]     ; stack access
    0xe00192a8     0x9c    add r2, sp, #16
    0xe00192ac     0xa0    stm lr, {r0, r1}      ; stack access
    0xe00192b0     0xa4    ldm ip, {r0, r1}      ; stack access
    0xe00192b4     0xa8    str r3, [sp, #28]     ; stack access
    0xe00192b8     0xac    str r3, [sp, #24]     ; stack access
    0xe00192bc     0xb0    stm r2, {r0, r1}      ; stack access
    0xe00192c0     0xb4    mov r2, r3
    0xe00192c4     0xb8    ldm ip, {r0, r1}      ; stack access
    0xe00192c8     0xbc    ldr ip, [sp, #48]     ; stack access
    0xe00192cc     0xc0    str r3, [sp, #12]     ; stack access
    0xe00192d0     0xc4    stmib sp, {r0, r1}    ; stack access
    0xe00192d4     0xc8    mov r1, r3
    0xe00192d8     0xcc    str r4, [sp]          ; stack access
    0xe00192dc     0xd0    bic r0, ip, #15
    0xe00192e0     0xd4    bl e0018d60 <invokeTCB_ThreadControl>
    0xe00192e4     0xd8    add sp, sp, #64 
    0xe00192e8     0xdc    pop {r4, lr}          ; stack access
    0xe00192ec     0xe0    add sp, sp, #8
    0xe00192f0     0xe4    bx lr
    0xe00192f4     0xe8    movw r3, #36896 
    0xe00192f8     0xec    movt r3, #57346 
    0xe00192fc     0xf0    mov r1, #2
    0xe0019300     0xf4    mov r2, #1
    0xe0019304     0xf8    mov r0, #3
    0xe0019308     0xfc    str r1, [r3, #24]
    0xe001930c    0x100    str r2, [r3, #4]
    0xe0019310    0x104    add sp, sp, #64 
    0xe0019314    0x108    pop {r4, lr}          ; stack access
    0xe0019318    0x10c    add sp, sp, #8
    0xe001931c    0x110    bx lr
    0xe0019320    0x114    movw r3, #36896 
    0xe0019324    0x118    movt r3, #57346 
    0xe0019328    0x11c    mov r2, #7
    0xe001932c    0x120    mov r0, #3
    0xe0019330    0x124    str r2, [r3, #24]
    0xe0019334    0x128    add sp, sp, #64 
    0xe0019338    0x12c    pop {r4, lr}          ; stack access
    0xe001933c    0x130    add sp, sp, #8
    0xe0019340    0x134    bx lr
    0xe0019344    0x138    movw r3, #36896 
    0xe0019348    0x13c    movt r3, #57346 
    0xe001934c    0x140    mov r0, #3
    0xe0019350    0x144    mov ip, #4
    0xe0019354    0x148    mov r2, #0
    0xe0019358    0x14c    str r1, [r3, #12]
    0xe001935c    0x150    str ip, [r3, #24]
    0xe0019360    0x154    str r2, [r3, #8]
    0xe0019364    0x158    add sp, sp, #64 
    0xe0019368    0x15c    pop {r4, lr}          ; stack access
    0xe001936c    0x160    add sp, sp, #8
    0xe0019370    0x164    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
90 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetPriority` has 142 nodes.

Section decodeUnbindNotification (212 of 299)
=============================================

Deriving specifications
-----------------------

Section `decodeUnbindNotification` consists of 30 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `decodeUnbindNotification`:

    0xe0018cc8     0x0    push {r4, lr}         ; stack access
    0xe0018ccc     0x4    sub sp, sp, #8
    0xe0018cd0     0x8    add r3, sp, #8
    0xe0018cd4     0xc    stmdb r3, {r0, r1}    ; stack access
    0xe0018cd8    0x10    ldr r4, [sp]          ; stack access
    0xe0018cdc    0x14    bic r4, r4, #15
    0xe0018ce0    0x18    ldr r3, [r4, #92] 
    0xe0018ce4    0x1c    cmp r3, #0
    0xe0018ce8    0x20    beq e0018d24 <decodeUnbindNotification+0x5c>
    0xe0018cec    0x24    movw r3, #13900 
    0xe0018cf0    0x28    movt r3, #57347 
    0xe0018cf4    0x2c    ldr r2, [r3]
    0xe0018cf8    0x30    ldr r3, [r2, #80] 
    0xe0018cfc    0x34    mov r0, r2
    0xe0018d00    0x38    bic r3, r3, #15
    0xe0018d04    0x3c    orr r3, r3, #2
    0xe0018d08    0x40    str r3, [r2, #80] 
    0xe0018d0c    0x44    bl e0013114 <setThreadState.part.166>
    0xe0018d10    0x48    mov r0, r4
    0xe0018d14    0x4c    bl e0010908 <invokeTCB_NotificationControl.part.179>
    0xe0018d18    0x50    mov r0, #0
    0xe0018d1c    0x54    add sp, sp, #8
    0xe0018d20    0x58    pop {r4, pc}          ; stack access
    0xe0018d24    0x5c    movw r3, #36896 
    0xe0018d28    0x60    movt r3, #57346 
    0xe0018d2c    0x64    mov r2, #3
    0xe0018d30    0x68    mov r0, r2
    0xe0018d34    0x6c    str r2, [r3, #24]
    0xe0018d38    0x70    add sp, sp, #8
    0xe0018d3c    0x74    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeUnbindNotification` has 44 nodes.

Section decodeBindNotification (213 of 299)
===========================================

Deriving specifications
-----------------------

Section `decodeBindNotification` consists of 72 instructions.
 STMIB;3,2...+


Stack analysis
---------------

7 stack accesses found. Annotated code for `decodeBindNotification`:

    0xe0018ba8      0x0    sub sp, sp, #8
    0xe0018bac      0x4    push {r4, r5, r6, lr}  ; stack access
    0xe0018bb0      0x8    sub sp, sp, #8
    0xe0018bb4      0xc    add ip, sp, #20
    0xe0018bb8     0x10    stmib ip, {r2, r3}    ; stack access
    0xe0018bbc     0x14    add r2, sp, #8
    0xe0018bc0     0x18    ldr r3, [sp, #24]     ; stack access
    0xe0018bc4     0x1c    stmdb r2, {r0, r1}    ; stack access
    0xe0018bc8     0x20    cmp r3, #0
    0xe0018bcc     0x24    beq e0018c94 <decodeBindNotification+0xec>
    0xe0018bd0     0x28    ldr r4, [sp]          ; stack access
    0xe0018bd4     0x2c    bic r4, r4, #15
    0xe0018bd8     0x30    ldr r2, [r4, #92] 
    0xe0018bdc     0x34    cmp r2, #0
    0xe0018be0     0x38    beq e0018c08 <decodeBindNotification+0x60>
    0xe0018be4     0x3c    mov r2, #3
    0xe0018be8     0x40    movw r3, #36896 
    0xe0018bec     0x44    movt r3, #57346 
    0xe0018bf0     0x48    mov r0, r2
    0xe0018bf4     0x4c    str r2, [r3, #24]
    0xe0018bf8     0x50    add sp, sp, #8
    0xe0018bfc     0x54    pop {r4, r5, r6, lr}  ; stack access
    0xe0018c00     0x58    add sp, sp, #8
    0xe0018c04     0x5c    bx lr
    0xe0018c08     0x60    ldr r2, [r3]
    0xe0018c0c     0x64    and r1, r2, #14
    0xe0018c10     0x68    cmp r1, #14
    0xe0018c14     0x6c    andne r1, r2, #15
    0xe0018c18     0x70    uxtbeq r1, r2
    0xe0018c1c     0x74    cmp r1, #6
    0xe0018c20     0x78    bne e0018be4 <decodeBindNotification+0x3c>
    0xe0018c24     0x7c    ldr r3, [r3, #4]
    0xe0018c28     0x80    tst r3, #2
    0xe0018c2c     0x84    beq e0018be4 <decodeBindNotification+0x3c>
    0xe0018c30     0x88    bic r6, r2, #15
    0xe0018c34     0x8c    ldr r3, [r6, #4]
    0xe0018c38     0x90    bics r3, r3, #15
    0xe0018c3c     0x94    bne e0018be4 <decodeBindNotification+0x3c>
    0xe0018c40     0x98    ldr r0, [r6, #12]
    0xe0018c44     0x9c    bics r5, r0, #15
    0xe0018c48     0xa0    bne e0018be4 <decodeBindNotification+0x3c>
    0xe0018c4c     0xa4    movw r3, #13900 
    0xe0018c50     0xa8    movt r3, #57347 
    0xe0018c54     0xac    ldr r2, [r3]
    0xe0018c58     0xb0    ldr r3, [r2, #80] 
    0xe0018c5c     0xb4    mov r0, r2
    0xe0018c60     0xb8    bic r3, r3, #15
    0xe0018c64     0xbc    orr r3, r3, #2
    0xe0018c68     0xc0    str r3, [r2, #80] 
    0xe0018c6c     0xc4    bl e0013114 <setThreadState.part.166>
    0xe0018c70     0xc8    cmp r6, #0
    0xe0018c74     0xcc    beq e0018cb8 <decodeBindNotification+0x110>
    0xe0018c78     0xd0    ldr r3, [r6, #12]
    0xe0018c7c     0xd4    mov r0, r5
    0xe0018c80     0xd8    and r3, r3, #15
    0xe0018c84     0xdc    orr r3, r3, r4
    0xe0018c88     0xe0    str r3, [r6, #12]
    0xe0018c8c     0xe4    str r6, [r4, #92] 
    0xe0018c90     0xe8    b e0018bf8 <decodeBindNotification+0x50>
    0xe0018c94     0xec    movw r3, #36896 
    0xe0018c98     0xf0    movt r3, #57346 
    0xe0018c9c     0xf4    mov r2, #7
    0xe0018ca0     0xf8    mov r0, #3
    0xe0018ca4     0xfc    str r2, [r3, #24]
    0xe0018ca8    0x100    add sp, sp, #8
    0xe0018cac    0x104    pop {r4, r5, r6, lr}  ; stack access
    0xe0018cb0    0x108    add sp, sp, #8
    0xe0018cb4    0x10c    bx lr
    0xe0018cb8    0x110    mov r0, r4
    0xe0018cbc    0x114    bl e0010908 <invokeTCB_NotificationControl.part.179>
    0xe0018cc0    0x118    mov r0, r6
    0xe0018cc4    0x11c    b e0018bf8 <decodeBindNotification+0x50>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
72 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeBindNotification` has 114 nodes.

Section decodeDomainInvocation (214 of 299)
===========================================

Deriving specifications
-----------------------

Section `decodeDomainInvocation` consists of 70 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `decodeDomainInvocation`:

    0xe0018a90      0x0    sub sp, sp, #8
    0xe0018a94      0x4    cmp r0, #29
    0xe0018a98      0x8    push {r4, r5, r6, lr}  ; stack access
    0xe0018a9c      0xc    add r0, sp, #12
    0xe0018aa0     0x10    stmib r0, {r2, r3}    ; stack access
    0xe0018aa4     0x14    bne e0018b88 <decodeDomainInvocation+0xf8>
    0xe0018aa8     0x18    cmp r1, #0
    0xe0018aac     0x1c    beq e0018b68 <decodeDomainInvocation+0xd8>
    0xe0018ab0     0x20    movw r3, #13900 
    0xe0018ab4     0x24    movt r3, #57347 
    0xe0018ab8     0x28    ldr r3, [r3]
    0xe0018abc     0x2c    ldr r4, [r3, #8]
    0xe0018ac0     0x30    cmp r4, #15
    0xe0018ac4     0x34    bhi e0018b24 <decodeDomainInvocation+0x94>
    0xe0018ac8     0x38    ldr r2, [sp, #16]     ; stack access
    0xe0018acc     0x3c    cmp r2, #0
    0xe0018ad0     0x40    beq e0018b68 <decodeDomainInvocation+0xd8>
    0xe0018ad4     0x44    ldr r5, [r2]
    0xe0018ad8     0x48    and r2, r5, #14
    0xe0018adc     0x4c    cmp r2, #14
    0xe0018ae0     0x50    andne r2, r5, #15
    0xe0018ae4     0x54    uxtbeq r2, r5
    0xe0018ae8     0x58    cmp r2, #12
    0xe0018aec     0x5c    bne e0018b4c <decodeDomainInvocation+0xbc>
    0xe0018af0     0x60    ldr r2, [r3, #80] 
    0xe0018af4     0x64    mov r0, r3
    0xe0018af8     0x68    bic r2, r2, #15
    0xe0018afc     0x6c    orr r2, r2, #2
    0xe0018b00     0x70    str r2, [r3, #80] 
    0xe0018b04     0x74    bl e0013114 <setThreadState.part.166>
    0xe0018b08     0x78    bic r0, r5, #15
    0xe0018b0c     0x7c    mov r1, r4
    0xe0018b10     0x80    bl e0016714 <setDomain>
    0xe0018b14     0x84    mov r0, #0
    0xe0018b18     0x88    pop {r4, r5, r6, lr}  ; stack access
    0xe0018b1c     0x8c    add sp, sp, #8
    0xe0018b20     0x90    bx lr
    0xe0018b24     0x94    pop {r4, r5, r6, lr}  ; stack access
    0xe0018b28     0x98    movw r3, #36896 
    0xe0018b2c     0x9c    movt r3, #57346 
    0xe0018b30     0xa0    mov r1, #1
    0xe0018b34     0xa4    mov r2, #0
    0xe0018b38     0xa8    mov r0, #3
    0xe0018b3c     0xac    str r1, [r3, #24]
    0xe0018b40     0xb0    add sp, sp, #8
    0xe0018b44     0xb4    str r2, [r3]
    0xe0018b48     0xb8    bx lr
    0xe0018b4c     0xbc    movw r3, #36896 
    0xe0018b50     0xc0    movt r3, #57346 
    0xe0018b54     0xc4    mov r2, #1
    0xe0018b58     0xc8    mov r0, #3
    0xe0018b5c     0xcc    str r2, [r3, #24]
    0xe0018b60     0xd0    str r2, [r3]
    0xe0018b64     0xd4    b e0018b18 <decodeDomainInvocation+0x88>
    0xe0018b68     0xd8    pop {r4, r5, r6, lr}  ; stack access
    0xe0018b6c     0xdc    movw r3, #36896 
    0xe0018b70     0xe0    movt r3, #57346 
    0xe0018b74     0xe4    mov r2, #7
    0xe0018b78     0xe8    mov r0, #3
    0xe0018b7c     0xec    str r2, [r3, #24]
    0xe0018b80     0xf0    add sp, sp, #8
    0xe0018b84     0xf4    bx lr
    0xe0018b88     0xf8    pop {r4, r5, r6, lr}  ; stack access
    0xe0018b8c     0xfc    movw r3, #36896 
    0xe0018b90    0x100    movt r3, #57346 
    0xe0018b94    0x104    mov r2, #3
    0xe0018b98    0x108    mov r0, r2
    0xe0018b9c    0x10c    str r2, [r3, #24]
    0xe0018ba0    0x110    add sp, sp, #8
    0xe0018ba4    0x114    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
70 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeDomainInvocation` has 108 nodes.

Section c_handle_vm_fault (215 of 299)
======================================

Deriving specifications
-----------------------

Section `c_handle_vm_fault` consists of 10 instructions.
Skipping ee1d2f50 mrc 15, 0, r2, cr13, cr0, {2}
Skipping ee1d2f70 mrc 15, 0, r2, cr13, cr0, {3}


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_vm_fault`:

    0xe00185f4     0x0    movw r3, #13900 
    0xe00185f8     0x4    movt r3, #57347 
    0xe00185fc     0x8    push {r4, lr}         ; stack access
    0xe0018600     0xc    ldr r3, [r3]
    0xe0018604    0x10    mrc 15, 0, r2, cr13, cr0, {2}
    0xe0018608    0x14    str r2, [r3, #72] 
    0xe001860c    0x18    mrc 15, 0, r2, cr13, cr0, {3}
    0xe0018610    0x1c    str r2, [r3, #76] 
    0xe0018614    0x20    bl e00185bc <handleVMFaultEvent>
    0xe0018618    0x24    bl e0010a10 <restore_user_context>

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_vm_fault` has 18 nodes.

Section handleFault (216 of 299)
================================

Deriving specifications
-----------------------

Section `handleFault` consists of 16 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `handleFault`:

    0xe0018508     0x0    push {r4, lr}         ; stack access
    0xe001850c     0x4    mov r4, r0
    0xe0018510     0x8    bl e00183f0 <sendFaultIPC>
    0xe0018514     0xc    cmp r0, #0
    0xe0018518    0x10    popeq {r4, pc}        ; stack access
    0xe001851c    0x14    movw r2, #13900 
    0xe0018520    0x18    movt r2, #57347 
    0xe0018524    0x1c    ldr r3, [r4, #80] 
    0xe0018528    0x20    ldr r2, [r2]
    0xe001852c    0x24    bic r3, r3, #15
    0xe0018530    0x28    str r3, [r4, #80] 
    0xe0018534    0x2c    cmp r4, r2
    0xe0018538    0x30    popne {r4, pc}        ; stack access
    0xe001853c    0x34    mov r0, r4
    0xe0018540    0x38    pop {r4, lr}          ; stack access
    0xe0018544    0x3c    b e0013114 <setThreadState.part.166>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleFault` has 29 nodes.

Section sendFaultIPC (217 of 299)
=================================

Deriving specifications
-----------------------

Section `sendFaultIPC` consists of 70 instructions.
 LDMIA;12,2...+


Stack analysis
---------------

8 stack accesses found. Annotated code for `sendFaultIPC`:

    0xe00183f0      0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe00183f4      0x4    movw r4, #36884 
    0xe00183f8      0x8    ldr r7, [r0, #128] 
    0xe00183fc      0xc    sub sp, sp, #28
    0xe0018400     0x10    movt r4, #57346 
    0xe0018404     0x14    mov r1, r0
    0xe0018408     0x18    mov r6, r0
    0xe001840c     0x1c    add r0, sp, #16
    0xe0018410     0x20    mov r2, r7
    0xe0018414     0x24    ldr r9, [r4]
    0xe0018418     0x28    ldr r8, [r4, #4]
    0xe001841c     0x2c    bl e0012d38 <lookupSlot>
    0xe0018420     0x30    ldr r5, [sp, #16]     ; stack access
    0xe0018424     0x34    cmp r5, #0
    0xe0018428     0x38    bne e0018478 <sendFaultIPC+0x88>
    0xe001842c     0x3c    ldr r3, [sp, #20]     ; stack access
    0xe0018430     0x40    ldm r3, {r2, ip}
    0xe0018434     0x44    and r3, r2, #14
    0xe0018438     0x48    cmp r3, #14
    0xe001843c     0x4c    andne r3, r2, #15
    0xe0018440     0x50    beq e0018500 <sendFaultIPC+0x110>
    0xe0018444     0x54    cmp r3, #4
    0xe0018448     0x58    beq e001849c <sendFaultIPC+0xac>
    0xe001844c     0x5c    mov r2, #1
    0xe0018450     0x60    movw r3, #32768 
    0xe0018454     0x64    movt r3, #57346 
    0xe0018458     0x68    mov r5, r2
    0xe001845c     0x6c    mov r1, #0
    0xe0018460     0x70    str r2, [r4]
    0xe0018464     0x74    stm r3, {r2, r7}
    0xe0018468     0x78    str r1, [r4, #4]
    0xe001846c     0x7c    mov r0, r5
    0xe0018470     0x80    add sp, sp, #28
    0xe0018474     0x84    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0018478     0x88    mov r2, #1
    0xe001847c     0x8c    movw r3, #32768 
    0xe0018480     0x90    movt r3, #57346 
    0xe0018484     0x94    mov r5, r2
    0xe0018488     0x98    mov r0, r5
    0xe001848c     0x9c    str r7, [r3, #4]
    0xe0018490     0xa0    str r2, [r3]
    0xe0018494     0xa4    add sp, sp, #28
    0xe0018498     0xa8    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe001849c     0xac    tst ip, #1
    0xe00184a0     0xb0    beq e001844c <sendFaultIPC+0x5c>
    0xe00184a4     0xb4    lsr r3, ip, #2
    0xe00184a8     0xb8    orr r1, r3, ip, lsr #3
    0xe00184ac     0xbc    tst r1, #1
    0xe00184b0     0xc0    beq e001844c <sendFaultIPC+0x5c>
    0xe00184b4     0xc4    movw r1, #32768 
    0xe00184b8     0xc8    movt r1, #57346 
    0xe00184bc     0xcc    add lr, r6, #96 
    0xe00184c0     0xd0    bic ip, ip, #15
    0xe00184c4     0xd4    ldm r1, {r0, r1}
    0xe00184c8     0xd8    lsr r2, r2, #4
    0xe00184cc     0xdc    and r4, r0, #15
    0xe00184d0     0xe0    stm lr, {r0, r1}
    0xe00184d4     0xe4    mov r1, #1
    0xe00184d8     0xe8    cmp r4, #1
    0xe00184dc     0xec    and r3, r3, r1
    0xe00184e0     0xf0    streq r9, [r6, #104] 
    0xe00184e4     0xf4    mov r0, r1
    0xe00184e8     0xf8    streq r8, [r6, #108] 
    0xe00184ec     0xfc    str r6, [sp, #4]      ; stack access
    0xe00184f0    0x100    str ip, [sp, #8]      ; stack access
    0xe00184f4    0x104    str r1, [sp]          ; stack access
    0xe00184f8    0x108    bl e00181f0 <sendIPC>
    0xe00184fc    0x10c    b e001846c <sendFaultIPC+0x7c>
    0xe0018500    0x110    uxtb r3, r2
    0xe0018504    0x114    b e0018444 <sendFaultIPC+0x54>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
70 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendFaultIPC` has 109 nodes.

Section handleReply (218 of 299)
================================

Deriving specifications
-----------------------

Section `handleReply` consists of 22 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `handleReply`:

    0xe0018170     0x0    movw r3, #13900 
    0xe0018174     0x4    movt r3, #57347 
    0xe0018178     0x8    ldr r0, [r3]
    0xe001817c     0xc    bic r3, r0, #508 
    0xe0018180    0x10    bic r3, r3, #3
    0xe0018184    0x14    add r2, r3, #48 
    0xe0018188    0x18    ldr r1, [r3, #48] 
    0xe001818c    0x1c    and r3, r1, #14
    0xe0018190    0x20    cmp r3, #14
    0xe0018194    0x24    andne r3, r1, #15
    0xe0018198    0x28    uxtbeq r3, r1
    0xe001819c    0x2c    cmp r3, #0
    0xe00181a0    0x30    bxeq lr
    0xe00181a4    0x34    cmp r3, #8
    0xe00181a8    0x38    bne e00181c0 <handleReply+0x50>
    0xe00181ac    0x3c    tst r1, #16
    0xe00181b0    0x40    bne e00181c0 <handleReply+0x50>
    0xe00181b4    0x44    ubfx r3, r1, #5, #1
    0xe00181b8    0x48    bic r1, r1, #63 
    0xe00181bc    0x4c    b e0018080 <doReplyTransfer>
    0xe00181c0    0x50    push {r4, lr}         ; stack access
    0xe00181c4    0x54    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleReply` has 38 nodes.

Section setupCallerCap (219 of 299)
===================================

Deriving specifications
-----------------------

Section `setupCallerCap` consists of 35 instructions.


Stack analysis
---------------

7 stack accesses found. Annotated code for `setupCallerCap`:

    0xe0017bf0     0x0    movw r3, #13900 
    0xe0017bf4     0x4    movt r3, #57347 
    0xe0017bf8     0x8    ldr ip, [r0, #80] 
    0xe0017bfc     0xc    ldr r3, [r3]
    0xe0017c00    0x10    bic ip, ip, #15
    0xe0017c04    0x14    cmp r0, r3
    0xe0017c08    0x18    orr ip, ip, #5
    0xe0017c0c    0x1c    push {r4, lr}         ; stack access
    0xe0017c10    0x20    mov r4, r0
    0xe0017c14    0x24    sub sp, sp, #16
    0xe0017c18    0x28    str ip, [r0, #80] 
    0xe0017c1c    0x2c    beq e0017c6c <setupCallerCap+0x7c>
    0xe0017c20    0x30    lsl ip, r2, #5
    0xe0017c24    0x34    mov r2, #65024 
    0xe0017c28    0x38    movt r2, #65535 
    0xe0017c2c    0x3c    and ip, ip, #32
    0xe0017c30    0x40    and r3, r1, r2
    0xe0017c34    0x44    mov r1, #0
    0xe0017c38    0x48    str r1, [sp, #12]     ; stack access
    0xe0017c3c    0x4c    add r1, sp, #16
    0xe0017c40    0x50    bic r0, r4, #63 
    0xe0017c44    0x54    and r2, r2, r4
    0xe0017c48    0x58    orr ip, ip, #8
    0xe0017c4c    0x5c    add r3, r3, #48 
    0xe0017c50    0x60    orr ip, ip, r0
    0xe0017c54    0x64    add r2, r2, #32
    0xe0017c58    0x68    str ip, [sp, #8]      ; stack access
    0xe0017c5c    0x6c    ldmdb r1, {r0, r1}    ; stack access
    0xe0017c60    0x70    add sp, sp, #16
    0xe0017c64    0x74    pop {r4, lr}          ; stack access
    0xe0017c68    0x78    b e0013308 <cteInsert>
    0xe0017c6c    0x7c    stm sp, {r1, r2}      ; stack access
    0xe0017c70    0x80    bl e0013114 <setThreadState.part.166>
    0xe0017c74    0x84    ldm sp, {r1, r2}      ; stack access
    0xe0017c78    0x88    b e0017c20 <setupCallerCap+0x30>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
35 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setupCallerCap` has 49 nodes.

Section invokeIRQHandler_SetIRQHandler (220 of 299)
===================================================

Deriving specifications
-----------------------

Section `invokeIRQHandler_SetIRQHandler` consists of 16 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `invokeIRQHandler_SetIRQHandler`:

    0xe0017920     0x0    movw ip, #8192 
    0xe0017924     0x4    movt ip, #57347 
    0xe0017928     0x8    push {r4, r5, r6, lr}  ; stack access
    0xe001792c     0xc    add r4, ip, r0, lsl #4
    0xe0017930    0x10    sub sp, sp, #8
    0xe0017934    0x14    mov r6, r3
    0xe0017938    0x18    mov r0, r4
    0xe001793c    0x1c    mov r5, sp
    0xe0017940    0x20    stm r5, {r1, r2}      ; stack access
    0xe0017944    0x24    bl e00173d0 <cteDeleteOne>
    0xe0017948    0x28    mov r3, r4
    0xe001794c    0x2c    mov r2, r6
    0xe0017950    0x30    ldm r5, {r0, r1}      ; stack access
    0xe0017954    0x34    add sp, sp, #8
    0xe0017958    0x38    pop {r4, r5, r6, lr}  ; stack access
    0xe001795c    0x3c    b e0013308 <cteInsert>

Proving inst theorems
---------------------

16 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeIRQHandler_SetIRQHandler` has 22 nodes.

Section chooseThread (221 of 299)
=================================

Deriving specifications
-----------------------

Section `chooseThread` consists of 45 instructions.
Skipping e1830f91 strex r0, r1, [r3]


Stack analysis
---------------

3 stack accesses found. Annotated code for `chooseThread`:

    0xe0016488     0x0    movw r3, #12288 
    0xe001648c     0x4    movt r3, #57347 
    0xe0016490     0x8    movw r2, #12808 
    0xe0016494     0xc    movt r2, #57347 
    0xe0016498    0x10    ldr r1, [r3]
    0xe001649c    0x14    push {r4, lr}         ; stack access
    0xe00164a0    0x18    sub sp, sp, #8
    0xe00164a4    0x1c    ldr r2, [r2, r1, lsl #2]
    0xe00164a8    0x20    cmp r2, #0
    0xe00164ac    0x24    beq e0016514 <chooseThread+0x8c>
    0xe00164b0    0x28    clz r2, r2
    0xe00164b4    0x2c    movw r3, #12292 
    0xe00164b8    0x30    rsb r2, r2, #31
    0xe00164bc    0x34    movt r3, #57347 
    0xe00164c0    0x38    rsb ip, r2, #7
    0xe00164c4    0x3c    movw r0, #38092 
    0xe00164c8    0x40    add ip, ip, r1, lsl #3
    0xe00164cc    0x44    movt r0, #57346 
    0xe00164d0    0x48    ldr r3, [r3, ip, lsl #2]
    0xe00164d4    0x4c    clz r3, r3
    0xe00164d8    0x50    rsb r3, r3, #31
    0xe00164dc    0x54    orr r3, r3, r2, lsl #5
    0xe00164e0    0x58    add r3, r3, r1, lsl #8
    0xe00164e4    0x5c    ldr r4, [r0, r3, lsl #3]
    0xe00164e8    0x60    mov r0, r4
    0xe00164ec    0x64    bl e0011294 <setVMRoot>
    0xe00164f0    0x68    add r3, sp, #4
    0xe00164f4    0x6c    strex r0, r1, [r3]
    0xe00164f8    0x70    mov r0, r4
    0xe00164fc    0x74    bl e0016384 <tcbSchedDequeue>
    0xe0016500    0x78    movw r3, #13900 
    0xe0016504    0x7c    movt r3, #57347 
    0xe0016508    0x80    str r4, [r3]
    0xe001650c    0x84    add sp, sp, #8
    0xe0016510    0x88    pop {r4, pc}          ; stack access
    0xe0016514    0x8c    movw r4, #36880 
    0xe0016518    0x90    movt r4, #57346 
    0xe001651c    0x94    ldr r0, [r4]
    0xe0016520    0x98    bl e0011294 <setVMRoot>
    0xe0016524    0x9c    ldr r2, [r4]
    0xe0016528    0xa0    movw r3, #13900 
    0xe001652c    0xa4    movt r3, #57347 
    0xe0016530    0xa8    str r2, [r3]
    0xe0016534    0xac    add sp, sp, #8
    0xe0016538    0xb0    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
45 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `chooseThread` has 62 nodes.

Section switchToThread (222 of 299)
===================================

Deriving specifications
-----------------------

Section `switchToThread` consists of 13 instructions.
Skipping e1830f91 strex r0, r1, [r3]


Stack analysis
---------------

2 stack accesses found. Annotated code for `switchToThread`:

    0xe0016454     0x0    push {r4, lr}         ; stack access
    0xe0016458     0x4    sub sp, sp, #8
    0xe001645c     0x8    mov r4, r0
    0xe0016460     0xc    bl e0011294 <setVMRoot>
    0xe0016464    0x10    add r3, sp, #4
    0xe0016468    0x14    strex r0, r1, [r3]
    0xe001646c    0x18    mov r0, r4
    0xe0016470    0x1c    bl e0016384 <tcbSchedDequeue>
    0xe0016474    0x20    movw r3, #13900 
    0xe0016478    0x24    movt r3, #57347 
    0xe001647c    0x28    str r4, [r3]
    0xe0016480    0x2c    add sp, sp, #8
    0xe0016484    0x30    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

13 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `switchToThread` has 19 nodes.

Section createNewObjects (223 of 299)
=====================================

Deriving specifications
-----------------------

Section `createNewObjects` consists of 55 instructions.


Stack analysis
---------------

13 stack accesses found. Annotated code for `createNewObjects`:

    0xe0016288     0x0    sub sp, sp, #8
    0xe001628c     0x4    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0016290     0x8    sub sp, sp, #20
    0xe0016294     0xc    mov r6, r1
    0xe0016298    0x10    add r1, sp, #52 
    0xe001629c    0x14    ldr r9, [sp, #64]     ; stack access
    0xe00162a0    0x18    mov sl, r0
    0xe00162a4    0x1c    stmib r1, {r2, r3}    ; stack access
    0xe00162a8    0x20    ldr r1, [sp, #72]     ; stack access
    0xe00162ac    0x24    bl e0014258 <getObjectSize>
    0xe00162b0    0x28    cmp r9, #0
    0xe00162b4    0x2c    beq e0016354 <createNewObjects+0xcc>
    0xe00162b8    0x30    ldr r3, [sp, #60]     ; stack access
    0xe00162bc    0x34    mov r8, #1
    0xe00162c0    0x38    ldr r4, [sp, #56]     ; stack access
    0xe00162c4    0x3c    lsl r8, r8, r0
    0xe00162c8    0x40    ldr r5, [sp, #68]     ; stack access
    0xe00162cc    0x44    bic fp, r6, #7
    0xe00162d0    0x48    add r4, r4, r3, lsl #4
    0xe00162d4    0x4c    mov r7, #0
    0xe00162d8    0x50    ldr r3, [sp, #76]     ; stack access
    0xe00162dc    0x54    mov r2, r5
    0xe00162e0    0x58    mov r1, sl
    0xe00162e4    0x5c    add r0, sp, #8
    0xe00162e8    0x60    add r7, r7, #1
    0xe00162ec    0x64    add r5, r5, r8
    0xe00162f0    0x68    str r3, [sp]          ; stack access
    0xe00162f4    0x6c    ldr r3, [sp, #72]     ; stack access
    0xe00162f8    0x70    bl e0016168 <createObject>
    0xe00162fc    0x74    ldr r2, [r6, #12]
    0xe0016300    0x78    ldr r3, [sp, #8]      ; stack access
    0xe0016304    0x7c    bic r0, r4, #7
    0xe0016308    0x80    bic r2, r2, #7
    0xe001630c    0x84    ldr ip, [sp, #12]     ; stack access
    0xe0016310    0x88    cmp r2, #0
    0xe0016314    0x8c    str fp, [r4, #8]
    0xe0016318    0x90    orr r1, r2, #3
    0xe001631c    0x94    str r3, [r4]
    0xe0016320    0x98    str r1, [r4, #12]
    0xe0016324    0x9c    add r4, r4, #16
    0xe0016328    0xa0    str ip, [r4, #-12]
    0xe001632c    0xa4    ldrne r1, [r2, #8]
    0xe0016330    0xa8    andne r1, r1, #7
    0xe0016334    0xac    orrne r1, r1, r0
    0xe0016338    0xb0    strne r1, [r2, #8]
    0xe001633c    0xb4    ldr r3, [r6, #12]
    0xe0016340    0xb8    cmp r9, r7
    0xe0016344    0xbc    and r3, r3, #7
    0xe0016348    0xc0    orr r3, r3, r0
    0xe001634c    0xc4    str r3, [r6, #12]
    0xe0016350    0xc8    bne e00162d8 <createNewObjects+0x50>
    0xe0016354    0xcc    add sp, sp, #20
    0xe0016358    0xd0    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001635c    0xd4    add sp, sp, #8
    0xe0016360    0xd8    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
55 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `createNewObjects` has 92 nodes.

Section maskCapRights (224 of 299)
==================================

Deriving specifications
-----------------------

Section `maskCapRights` consists of 131 instructions.
Switch found.


Stack analysis
---------------

Section `maskCapRights` expects pointer to stack in r0.
17 stack accesses found. Annotated code for `maskCapRights`:

    0xe0015f5c      0x0    push {r4, lr}         ; stack access
    0xe0015f60      0x4    sub sp, sp, #8
    0xe0015f64      0x8    mov r4, r0
    0xe0015f68      0xc    mov ip, sp
    0xe0015f6c     0x10    stm ip, {r2, r3}      ; stack access
    0xe0015f70     0x14    mov r3, r2
    0xe0015f74     0x18    and r2, r2, #14
    0xe0015f78     0x1c    cmp r2, #14
    0xe0015f7c     0x20    andne r2, r3, #15
    0xe0015f80     0x24    uxtbeq r2, r3
    0xe0015f84     0x28    tst r2, #1
    0xe0015f88     0x2c    bne e0016098 <maskCapRights+0x13c>
    0xe0015f8c     0x30    ldr r0, [sp, #4]      ; stack access
    0xe0015f90     0x34    cmp r2, #62 
    0xe0015f94     0x38    ldrls pc, [pc, r2, lsl #2]
    0xe0015f98     0x3c    b e0016164 <maskCapRights+0x208>
    0xe0015f9c     0x40    .word 0xe00160d8
    0xe0015fa0     0x44    .word 0xe0016164
    0xe0015fa4     0x48    .word 0xe00160d8
    0xe0015fa8     0x4c    .word 0xe0016164
    0xe0015fac     0x50    .word 0xe00160ec
    0xe0015fb0     0x54    .word 0xe0016164
    0xe0015fb4     0x58    .word 0xe0016134
    0xe0015fb8     0x5c    .word 0xe0016164
    0xe0015fbc     0x60    .word 0xe00160ac
    0xe0015fc0     0x64    .word 0xe0016164
    0xe0015fc4     0x68    .word 0xe00160d8
    0xe0015fc8     0x6c    .word 0xe0016164
    0xe0015fcc     0x70    .word 0xe00160d8
    0xe0015fd0     0x74    .word 0xe0016164
    0xe0015fd4     0x78    .word 0xe00160d8
    0xe0015fd8     0x7c    .word 0xe0016164
    0xe0015fdc     0x80    .word 0xe0016164
    0xe0015fe0     0x84    .word 0xe0016164
    0xe0015fe4     0x88    .word 0xe0016164
    0xe0015fe8     0x8c    .word 0xe0016164
    0xe0015fec     0x90    .word 0xe0016164
    0xe0015ff0     0x94    .word 0xe0016164
    0xe0015ff4     0x98    .word 0xe0016164
    0xe0015ff8     0x9c    .word 0xe0016164
    0xe0015ffc     0xa0    .word 0xe0016164
    0xe0016000     0xa4    .word 0xe0016164
    0xe0016004     0xa8    .word 0xe0016164
    0xe0016008     0xac    .word 0xe0016164
    0xe001600c     0xb0    .word 0xe0016164
    0xe0016010     0xb4    .word 0xe0016164
    0xe0016014     0xb8    .word 0xe00160d8
    0xe0016018     0xbc    .word 0xe0016164
    0xe001601c     0xc0    .word 0xe0016164
    0xe0016020     0xc4    .word 0xe0016164
    0xe0016024     0xc8    .word 0xe0016164
    0xe0016028     0xcc    .word 0xe0016164
    0xe001602c     0xd0    .word 0xe0016164
    0xe0016030     0xd4    .word 0xe0016164
    0xe0016034     0xd8    .word 0xe0016164
    0xe0016038     0xdc    .word 0xe0016164
    0xe001603c     0xe0    .word 0xe0016164
    0xe0016040     0xe4    .word 0xe0016164
    0xe0016044     0xe8    .word 0xe0016164
    0xe0016048     0xec    .word 0xe0016164
    0xe001604c     0xf0    .word 0xe0016164
    0xe0016050     0xf4    .word 0xe0016164
    0xe0016054     0xf8    .word 0xe00160d8
    0xe0016058     0xfc    .word 0xe0016164
    0xe001605c    0x100    .word 0xe0016164
    0xe0016060    0x104    .word 0xe0016164
    0xe0016064    0x108    .word 0xe0016164
    0xe0016068    0x10c    .word 0xe0016164
    0xe001606c    0x110    .word 0xe0016164
    0xe0016070    0x114    .word 0xe0016164
    0xe0016074    0x118    .word 0xe0016164
    0xe0016078    0x11c    .word 0xe0016164
    0xe001607c    0x120    .word 0xe0016164
    0xe0016080    0x124    .word 0xe0016164
    0xe0016084    0x128    .word 0xe0016164
    0xe0016088    0x12c    .word 0xe0016164
    0xe001608c    0x130    .word 0xe0016164
    0xe0016090    0x134    .word 0xe0016164
    0xe0016094    0x138    .word 0xe00160d8
    0xe0016098    0x13c    ldm ip, {r2, r3}      ; stack access
    0xe001609c    0x140    bl e0011974 <Arch_maskCapRights>
    0xe00160a0    0x144    mov r0, r4
    0xe00160a4    0x148    add sp, sp, #8
    0xe00160a8    0x14c    pop {r4, pc}          ; stack access
    0xe00160ac    0x150    lsr r2, r3, #5
    0xe00160b0    0x154    bic r3, r3, #32
    0xe00160b4    0x158    and r1, r2, r1, lsr #2
    0xe00160b8    0x15c    str r0, [r4, #4]      ; stack access
    0xe00160bc    0x160    mov r0, r4
    0xe00160c0    0x164    lsl r1, r1, #5
    0xe00160c4    0x168    and r1, r1, #32
    0xe00160c8    0x16c    orr r3, r1, r3
    0xe00160cc    0x170    str r3, [r4]          ; stack access
    0xe00160d0    0x174    add sp, sp, #8
    0xe00160d4    0x178    pop {r4, pc}          ; stack access
    0xe00160d8    0x17c    str r0, [r4, #4]      ; stack access
    0xe00160dc    0x180    mov r0, r4
    0xe00160e0    0x184    str r3, [r4]          ; stack access
    0xe00160e4    0x188    add sp, sp, #8
    0xe00160e8    0x18c    pop {r4, pc}          ; stack access
    0xe00160ec    0x190    mvn r2, r1, lsl #31
    0xe00160f0    0x194    bic ip, r0, #2
    0xe00160f4    0x198    mvn r2, r2, lsr #31
    0xe00160f8    0x19c    and ip, ip, r2
    0xe00160fc    0x1a0    and r2, r1, r0
    0xe0016100    0x1a4    str r3, [r4]          ; stack access
    0xe0016104    0x1a8    and r3, r2, #2
    0xe0016108    0x1ac    and r1, r1, r0
    0xe001610c    0x1b0    orr r3, r3, ip
    0xe0016110    0x1b4    and r2, r2, #4
    0xe0016114    0x1b8    bic r3, r3, #12
    0xe0016118    0x1bc    and r1, r1, #8
    0xe001611c    0x1c0    orr r3, r3, r2
    0xe0016120    0x1c4    mov r0, r4
    0xe0016124    0x1c8    orr r1, r3, r1
    0xe0016128    0x1cc    str r1, [r4, #4]      ; stack access
    0xe001612c    0x1d0    add sp, sp, #8
    0xe0016130    0x1d4    pop {r4, pc}          ; stack access
    0xe0016134    0x1d8    mvn r2, r1, lsl #31
    0xe0016138    0x1dc    and r1, r1, r0
    0xe001613c    0x1e0    bic r0, r0, #2
    0xe0016140    0x1e4    mvn r2, r2, lsr #31
    0xe0016144    0x1e8    and r1, r1, #2
    0xe0016148    0x1ec    and r2, r2, r0
    0xe001614c    0x1f0    orr r1, r1, r2
    0xe0016150    0x1f4    mov r0, r4
    0xe0016154    0x1f8    str r3, [r4]          ; stack access
    0xe0016158    0x1fc    str r1, [r4, #4]      ; stack access
    0xe001615c    0x200    add sp, sp, #8
    0xe0016160    0x204    pop {r4, pc}          ; stack access
    0xe0016164    0x208    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
68 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `maskCapRights` has 283 nodes.

Section sameObjectAs (225 of 299)
=================================

Deriving specifications
-----------------------

Section `sameObjectAs` consists of 42 instructions.


Stack analysis
---------------

11 stack accesses found. Annotated code for `sameObjectAs`:

    0xe0014c9c     0x0    push {lr}             ; stack access
    0xe0014ca0     0x4    sub sp, sp, #20
    0xe0014ca4     0x8    add ip, sp, #8
    0xe0014ca8     0xc    mov lr, sp
    0xe0014cac    0x10    stm lr, {r2, r3}      ; stack access
    0xe0014cb0    0x14    and r3, r0, #14
    0xe0014cb4    0x18    cmp r3, #14
    0xe0014cb8    0x1c    stm ip, {r0, r1}      ; stack access
    0xe0014cbc    0x20    andne r3, r0, #15
    0xe0014cc0    0x24    uxtbeq r3, r0
    0xe0014cc4    0x28    cmp r3, #2
    0xe0014cc8    0x2c    beq e0014d24 <sameObjectAs+0x88>
    0xe0014ccc    0x30    cmp r3, #14
    0xe0014cd0    0x34    ldr r2, [sp]          ; stack access
    0xe0014cd4    0x38    beq e0014d0c <sameObjectAs+0x70>
    0xe0014cd8    0x3c    tst r3, #1
    0xe0014cdc    0x40    beq e0014cf8 <sameObjectAs+0x5c>
    0xe0014ce0    0x44    and r3, r2, #14
    0xe0014ce4    0x48    cmp r3, #14
    0xe0014ce8    0x4c    andne r2, r2, #15
    0xe0014cec    0x50    uxtbeq r2, r2
    0xe0014cf0    0x54    tst r2, #1
    0xe0014cf4    0x58    bne e0014d30 <sameObjectAs+0x94>
    0xe0014cf8    0x5c    ldm lr, {r2, r3}      ; stack access
    0xe0014cfc    0x60    ldm ip, {r0, r1}      ; stack access
    0xe0014d00    0x64    add sp, sp, #20
    0xe0014d04    0x68    pop {lr}              ; stack access
    0xe0014d08    0x6c    b e0014300 <sameRegionAs>
    0xe0014d0c    0x70    and r3, r2, #14
    0xe0014d10    0x74    cmp r3, #14
    0xe0014d14    0x78    bne e0014cf8 <sameObjectAs+0x5c>
    0xe0014d18    0x7c    uxtb r2, r2
    0xe0014d1c    0x80    cmp r2, #30
    0xe0014d20    0x84    bne e0014cf8 <sameObjectAs+0x5c>
    0xe0014d24    0x88    mov r0, #0
    0xe0014d28    0x8c    add sp, sp, #20
    0xe0014d2c    0x90    pop {pc}              ; stack access
    0xe0014d30    0x94    ldm lr, {r2, r3}      ; stack access
    0xe0014d34    0x98    ldm ip, {r0, r1}      ; stack access
    0xe0014d38    0x9c    add sp, sp, #20
    0xe0014d3c    0xa0    pop {lr}              ; stack access
    0xe0014d40    0xa4    b e0011d38 <Arch_sameObjectAs>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
42 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sameObjectAs` has 75 nodes.

Section deriveCap (226 of 299)
==============================

Deriving specifications
-----------------------

Section `deriveCap` consists of 42 instructions.
 MOVNE (reg)....+++
 STMIA;6,4,0....+


Stack analysis
---------------

Section `deriveCap` expects pointer to stack in r0.
7 stack accesses found. Annotated code for `deriveCap`:

    0xe0014bf4     0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0014bf8     0x4    sub sp, sp, #12
    0xe0014bfc     0x8    mov r5, r0
    0xe0014c00     0xc    mov r4, r2
    0xe0014c04    0x10    mov ip, sp
    0xe0014c08    0x14    stm ip, {r2, r3}      ; stack access
    0xe0014c0c    0x18    and r3, r2, #14
    0xe0014c10    0x1c    cmp r3, #14
    0xe0014c14    0x20    andne r3, r2, #15
    0xe0014c18    0x24    uxtbeq r3, r2
    0xe0014c1c    0x28    ands r7, r3, #1
    0xe0014c20    0x2c    bne e0014c88 <deriveCap+0x94>
    0xe0014c24    0x30    cmp r3, #8
    0xe0014c28    0x34    ldr r6, [sp, #4]      ; stack access
    0xe0014c2c    0x38    beq e0014c78 <deriveCap+0x84>
    0xe0014c30    0x3c    bhi e0014c60 <deriveCap+0x6c>
    0xe0014c34    0x40    cmp r3, #2
    0xe0014c38    0x44    bne e0014c70 <deriveCap+0x7c>
    0xe0014c3c    0x48    mov r0, r1
    0xe0014c40    0x4c    bl e0014bbc <ensureNoChildren>
    0xe0014c44    0x50    cmp r0, #0
    0xe0014c48    0x54    movne r4, r7
    0xe0014c4c    0x58    movne r6, r4
    0xe0014c50    0x5c    stm r5, {r0, r4, r6}  ; stack access
    0xe0014c54    0x60    mov r0, r5
    0xe0014c58    0x64    add sp, sp, #12
    0xe0014c5c    0x68    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe0014c60    0x6c    cmp r3, #14
    0xe0014c64    0x70    beq e0014c78 <deriveCap+0x84>
    0xe0014c68    0x74    cmp r3, #46 
    0xe0014c6c    0x78    beq e0014c78 <deriveCap+0x84>
    0xe0014c70    0x7c    mov r0, #0
    0xe0014c74    0x80    b e0014c50 <deriveCap+0x5c>
    0xe0014c78    0x84    mov r6, #0
    0xe0014c7c    0x88    mov r4, r6
    0xe0014c80    0x8c    mov r0, r6
    0xe0014c84    0x90    b e0014c50 <deriveCap+0x5c>
    0xe0014c88    0x94    ldm ip, {r2, r3}      ; stack access
    0xe0014c8c    0x98    bl e0011840 <Arch_deriveCap>
    0xe0014c90    0x9c    mov r0, r5
    0xe0014c94    0xa0    add sp, sp, #12
    0xe0014c98    0xa4    pop {r4, r5, r6, r7, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
42 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deriveCap` has 71 nodes.

Section getReceiveSlots (227 of 299)
====================================

Deriving specifications
-----------------------

Section `getReceiveSlots` consists of 40 instructions.


Stack analysis
---------------

11 stack accesses found. Annotated code for `getReceiveSlots`:

    0xe0013878     0x0    subs r3, r1, #0
    0xe001387c     0x4    beq e0013910 <getReceiveSlots+0x98>
    0xe0013880     0x8    push {r4, r5, r6, lr}  ; stack access
    0xe0013884     0xc    sub sp, sp, #24
    0xe0013888    0x10    add r4, sp, #16
    0xe001388c    0x14    mov r1, r0
    0xe0013890    0x18    ldr r2, [r3, #500] 
    0xe0013894    0x1c    mov r0, r4
    0xe0013898    0x20    ldr r5, [r3, #504] 
    0xe001389c    0x24    ldr r6, [r3, #508] 
    0xe00138a0    0x28    bl e0012d38 <lookupSlot>
    0xe00138a4    0x2c    ldr r1, [sp, #16]     ; stack access
    0xe00138a8    0x30    cmp r1, #0
    0xe00138ac    0x34    bne e0013904 <getReceiveSlots+0x8c>
    0xe00138b0    0x38    ldr r3, [sp, #20]     ; stack access
    0xe00138b4    0x3c    add r0, sp, #8
    0xe00138b8    0x40    ldrd r2, [r3]
    0xe00138bc    0x44    str r6, [sp, #4]      ; stack access
    0xe00138c0    0x48    str r5, [sp]          ; stack access
    0xe00138c4    0x4c    strd r2, [sp, #16]    ; stack access
    0xe00138c8    0x50    ldm r4, {r2, r3}      ; stack access
    0xe00138cc    0x54    bl e0012e24 <lookupSlotForCNodeOp>
    0xe00138d0    0x58    ldr r3, [sp, #8]      ; stack access
    0xe00138d4    0x5c    cmp r3, #0
    0xe00138d8    0x60    bne e0013904 <getReceiveSlots+0x8c>
    0xe00138dc    0x64    ldr r0, [sp, #12]     ; stack access
    0xe00138e0    0x68    ldr r3, [r0]
    0xe00138e4    0x6c    and r2, r3, #14
    0xe00138e8    0x70    cmp r2, #14
    0xe00138ec    0x74    andne r3, r3, #15
    0xe00138f0    0x78    uxtbeq r3, r3
    0xe00138f4    0x7c    cmp r3, #0
    0xe00138f8    0x80    bne e0013904 <getReceiveSlots+0x8c>
    0xe00138fc    0x84    add sp, sp, #24
    0xe0013900    0x88    pop {r4, r5, r6, pc}  ; stack access
    0xe0013904    0x8c    mov r0, #0
    0xe0013908    0x90    add sp, sp, #24
    0xe001390c    0x94    pop {r4, r5, r6, pc}  ; stack access
    0xe0013910    0x98    mov r0, #0
    0xe0013914    0x9c    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
40 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `getReceiveSlots` has 71 nodes.

Section invokeCNodeRotate (228 of 299)
======================================

Deriving specifications
-----------------------

Section `invokeCNodeRotate` consists of 32 instructions.


Stack analysis
---------------

17 stack accesses found. Annotated code for `invokeCNodeRotate`:

    0xe00136d0     0x0    push {r4, r5, lr}     ; stack access
    0xe00136d4     0x4    sub sp, sp, #28
    0xe00136d8     0x8    add r4, sp, #16
    0xe00136dc     0xc    add ip, sp, #8
    0xe00136e0    0x10    ldr r5, [sp, #40]     ; stack access
    0xe00136e4    0x14    ldr lr, [sp, #48]     ; stack access
    0xe00136e8    0x18    stm r4, {r0, r1}      ; stack access
    0xe00136ec    0x1c    cmp r5, lr
    0xe00136f0    0x20    stm ip, {r2, r3}      ; stack access
    0xe00136f4    0x24    beq e0013724 <invokeCNodeRotate+0x54>
    0xe00136f8    0x28    mov r3, lr
    0xe00136fc    0x2c    ldm ip, {r0, r1}      ; stack access
    0xe0013700    0x30    ldr r2, [sp, #44]     ; stack access
    0xe0013704    0x34    bl e00134f8 <cteMove>
    0xe0013708    0x38    ldm r4, {r0, r1}      ; stack access
    0xe001370c    0x3c    ldr r3, [sp, #44]     ; stack access
    0xe0013710    0x40    mov r2, r5
    0xe0013714    0x44    bl e00134f8 <cteMove>
    0xe0013718    0x48    mov r0, #0
    0xe001371c    0x4c    add sp, sp, #28
    0xe0013720    0x50    pop {r4, r5, pc}      ; stack access
    0xe0013724    0x54    ldr r1, [sp, #12]     ; stack access
    0xe0013728    0x58    mov r2, r5
    0xe001372c    0x5c    ldr r3, [sp, #44]     ; stack access
    0xe0013730    0x60    str r1, [sp]          ; stack access
    0xe0013734    0x64    str r3, [sp, #4]      ; stack access
    0xe0013738    0x68    ldr r3, [sp, #8]      ; stack access
    0xe001373c    0x6c    ldm r4, {r0, r1}      ; stack access
    0xe0013740    0x70    bl e0013610 <cteSwap>
    0xe0013744    0x74    mov r0, #0
    0xe0013748    0x78    add sp, sp, #28
    0xe001374c    0x7c    pop {r4, r5, pc}      ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeRotate` has 54 nodes.

Section invokeCNodeSaveCaller (229 of 299)
==========================================

Deriving specifications
-----------------------

Section `invokeCNodeSaveCaller` consists of 32 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `invokeCNodeSaveCaller`:

    0xe0013590     0x0    movw r2, #13900 
    0xe0013594     0x4    movt r2, #57347 
    0xe0013598     0x8    mov r3, r0
    0xe001359c     0xc    ldr r2, [r2]
    0xe00135a0    0x10    push {r4, lr}         ; stack access
    0xe00135a4    0x14    bic r2, r2, #508 
    0xe00135a8    0x18    bic r2, r2, #3
    0xe00135ac    0x1c    sub sp, sp, #8
    0xe00135b0    0x20    add r2, r2, #48 
    0xe00135b4    0x24    mov lr, sp
    0xe00135b8    0x28    ldm r2, {r0, r1}
    0xe00135bc    0x2c    and r4, r0, #14
    0xe00135c0    0x30    cmp r4, #14
    0xe00135c4    0x34    stm lr, {r0, r1}      ; stack access
    0xe00135c8    0x38    andne r1, r0, #15
    0xe00135cc    0x3c    uxtbeq r1, r0
    0xe00135d0    0x40    cmp r1, #0
    0xe00135d4    0x44    beq e00135e8 <invokeCNodeSaveCaller+0x58>
    0xe00135d8    0x48    cmp r1, #8
    0xe00135dc    0x4c    bne e001360c <invokeCNodeSaveCaller+0x7c>
    0xe00135e0    0x50    tst r0, #16
    0xe00135e4    0x54    beq e00135f4 <invokeCNodeSaveCaller+0x64>
    0xe00135e8    0x58    mov r0, #0
    0xe00135ec    0x5c    add sp, sp, #8
    0xe00135f0    0x60    pop {r4, pc}          ; stack access
    0xe00135f4    0x64    str r0, [sp]          ; stack access
    0xe00135f8    0x68    ldm lr, {r0, r1}      ; stack access
    0xe00135fc    0x6c    bl e00134f8 <cteMove>
    0xe0013600    0x70    mov r0, #0
    0xe0013604    0x74    add sp, sp, #8
    0xe0013608    0x78    pop {r4, pc}          ; stack access
    0xe001360c    0x7c    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
32 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeCNodeSaveCaller` has 52 nodes.

Section timerTick (230 of 299)
==============================

Deriving specifications
-----------------------

Section `timerTick` consists of 31 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `timerTick`:

    0xe0013264     0x0    movw r3, #13900 
    0xe0013268     0x4    movt r3, #57347 
    0xe001326c     0x8    push {r4, lr}         ; stack access
    0xe0013270     0xc    ldr r0, [r3]
    0xe0013274    0x10    ldr r3, [r0, #80] 
    0xe0013278    0x14    and r3, r3, #15
    0xe001327c    0x18    cmp r3, #1
    0xe0013280    0x1c    bne e0013298 <timerTick+0x34>
    0xe0013284    0x20    ldr r3, [r0, #124] 
    0xe0013288    0x24    cmp r3, #1
    0xe001328c    0x28    bls e00132bc <timerTick+0x58>
    0xe0013290    0x2c    sub r3, r3, #1
    0xe0013294    0x30    str r3, [r0, #124] 
    0xe0013298    0x34    movw r2, #5324 
    0xe001329c    0x38    movt r2, #57347 
    0xe00132a0    0x3c    ldr r3, [r2]
    0xe00132a4    0x40    sub r3, r3, #1
    0xe00132a8    0x44    str r3, [r2]
    0xe00132ac    0x48    cmp r3, #0
    0xe00132b0    0x4c    popne {r4, pc}        ; stack access
    0xe00132b4    0x50    pop {r4, lr}          ; stack access
    0xe00132b8    0x54    b e0013098 <rescheduleRequired>
    0xe00132bc    0x58    ldr r3, [r0, #84] 
    0xe00132c0    0x5c    mov r2, #5
    0xe00132c4    0x60    str r2, [r0, #124] 
    0xe00132c8    0x64    tst r3, #1
    0xe00132cc    0x68    beq e00132d8 <timerTick+0x74>
    0xe00132d0    0x6c    bl e0013098 <rescheduleRequired>
    0xe00132d4    0x70    b e0013298 <timerTick+0x34>
    0xe00132d8    0x74    bl e0010870 <tcbSchedAppend.part.171>
    0xe00132dc    0x78    b e00132d0 <timerTick+0x6c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
31 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `timerTick` has 53 nodes.

Section possibleSwitchTo (231 of 299)
=====================================

Deriving specifications
-----------------------

Section `possibleSwitchTo` consists of 30 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `possibleSwitchTo`:

    0xe00131ec     0x0    movw r3, #12288 
    0xe00131f0     0x4    movt r3, #57347 
    0xe00131f4     0x8    ldr r2, [r0, #112] 
    0xe00131f8     0xc    ldr r3, [r3]
    0xe00131fc    0x10    cmp r2, r3
    0xe0013200    0x14    beq e0013214 <possibleSwitchTo+0x28>
    0xe0013204    0x18    ldr r3, [r0, #84] 
    0xe0013208    0x1c    tst r3, #1
    0xe001320c    0x20    bxne lr
    0xe0013210    0x24    b e00107d8 <tcbSchedEnqueue.part.164>
    0xe0013214    0x28    movw r3, #36892 
    0xe0013218    0x2c    movt r3, #57346 
    0xe001321c    0x30    ldr r2, [r3]
    0xe0013220    0x34    cmp r2, #0
    0xe0013224    0x38    beq e0013250 <possibleSwitchTo+0x64>
    0xe0013228    0x3c    push {lr}             ; stack access
    0xe001322c    0x40    sub sp, sp, #12
    0xe0013230    0x44    str r0, [sp, #4]      ; stack access
    0xe0013234    0x48    bl e0013098 <rescheduleRequired>
    0xe0013238    0x4c    ldr r0, [sp, #4]      ; stack access
    0xe001323c    0x50    ldr r3, [r0, #84] 
    0xe0013240    0x54    tst r3, #1
    0xe0013244    0x58    beq e0013258 <possibleSwitchTo+0x6c>
    0xe0013248    0x5c    add sp, sp, #12
    0xe001324c    0x60    pop {pc}              ; stack access
    0xe0013250    0x64    str r0, [r3]
    0xe0013254    0x68    bx lr
    0xe0013258    0x6c    add sp, sp, #12
    0xe001325c    0x70    pop {lr}              ; stack access
    0xe0013260    0x74    b e00107d8 <tcbSchedEnqueue.part.164>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `possibleSwitchTo` has 54 nodes.

Section activateThread (232 of 299)
===================================

Deriving specifications
-----------------------

Section `activateThread` consists of 20 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `activateThread`:

    0xe001319c     0x0    movw r3, #13900 
    0xe00131a0     0x4    movt r3, #57347 
    0xe00131a4     0x8    ldr r2, [r3]
    0xe00131a8     0xc    ldr r3, [r2, #80] 
    0xe00131ac    0x10    and r1, r3, #15
    0xe00131b0    0x14    cmp r1, #2
    0xe00131b4    0x18    beq e00131d0 <activateThread+0x34>
    0xe00131b8    0x1c    cmp r1, #7
    0xe00131bc    0x20    bxeq lr
    0xe00131c0    0x24    cmp r1, #1
    0xe00131c4    0x28    bxeq lr
    0xe00131c8    0x2c    push {r4, lr}         ; stack access
    0xe00131cc    0x30    bl e0010a3c <halt>
    0xe00131d0    0x34    ldr r1, [r2, #68] 
    0xe00131d4    0x38    bic r3, r3, #15
    0xe00131d8    0x3c    orr r3, r3, #1
    0xe00131dc    0x40    mov r0, r2
    0xe00131e0    0x44    str r3, [r2, #80] 
    0xe00131e4    0x48    str r1, [r2, #60] 
    0xe00131e8    0x4c    b e0013114 <setThreadState.part.166>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
20 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `activateThread` has 36 nodes.

Section arch_clean_invalidate_caches (233 of 299)
=================================================

Deriving specifications
-----------------------

Section `arch_clean_invalidate_caches` consists of 45 instructions.
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee073f15 mcr 15, 0, r3, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping f57ff05f dmb sy
Skipping f57ff05f dmb sy
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee074f15 mcr 15, 0, r4, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `arch_clean_invalidate_caches`:

    0xe00129d0     0x0    push {r4, lr}         ; stack access
    0xe00129d4     0x4    dsb sy
    0xe00129d8     0x8    bl e00120a8 <clean_D_PoU>
    0xe00129dc     0xc    dsb sy
    0xe00129e0    0x10    mov r3, #0
    0xe00129e4    0x14    mcr 15, 0, r3, cr7, cr5, {0}
    0xe00129e8    0x18    isb sy
    0xe00129ec    0x1c    dsb sy
    0xe00129f0    0x20    movw r3, #12543 
    0xe00129f4    0x24    movt r3, #65520 
    0xe00129f8    0x28    movw r1, #65535 
    0xe00129fc    0x2c    mov r2, r3
    0xe0012a00    0x30    str r1, [r3, #1725] 
    0xe0012a04    0x34    ldr r3, [r2, #1725] 
    0xe0012a08    0x38    cmp r3, #0
    0xe0012a0c    0x3c    bne e0012a04 <arch_clean_invalidate_caches+0x34>
    0xe0012a10    0x40    dmb sy
    0xe0012a14    0x44    movw r1, #12543 
    0xe0012a18    0x48    movt r1, #65520 
    0xe0012a1c    0x4c    str r3, [r2, #1585] 
    0xe0012a20    0x50    ldr r3, [r1, #1585] 
    0xe0012a24    0x54    tst r3, #1
    0xe0012a28    0x58    bne e0012a20 <arch_clean_invalidate_caches+0x50>
    0xe0012a2c    0x5c    movw r2, #12543 
    0xe0012a30    0x60    movt r2, #65520 
    0xe0012a34    0x64    movw r3, #65535 
    0xe0012a38    0x68    str r3, [r1, #1661] 
    0xe0012a3c    0x6c    ldr r3, [r2, #1661] 
    0xe0012a40    0x70    cmp r3, #0
    0xe0012a44    0x74    bne e0012a3c <arch_clean_invalidate_caches+0x6c>
    0xe0012a48    0x78    dmb sy
    0xe0012a4c    0x7c    movw r1, #12543 
    0xe0012a50    0x80    movt r1, #65520 
    0xe0012a54    0x84    str r3, [r2, #1585] 
    0xe0012a58    0x88    ldr r3, [r1, #1585] 
    0xe0012a5c    0x8c    ands r4, r3, #1
    0xe0012a60    0x90    bne e0012a58 <arch_clean_invalidate_caches+0x88>
    0xe0012a64    0x94    dsb sy
    0xe0012a68    0x98    bl e0012410 <cleanInvalidate_D_PoC>
    0xe0012a6c    0x9c    dsb sy
    0xe0012a70    0xa0    mcr 15, 0, r4, cr7, cr5, {0}
    0xe0012a74    0xa4    isb sy
    0xe0012a78    0xa8    dsb sy
    0xe0012a7c    0xac    isb sy
    0xe0012a80    0xb0    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
45 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arch_clean_invalidate_caches` has 78 nodes.

Section deleteASID (234 of 299)
===============================

Deriving specifications
-----------------------

Section `deleteASID` consists of 30 instructions.
 LDMIAEQ (wb);15,8,7,6,5,4..++
 LDMIANE (wb);15,8,7,6,5,4..++
 STRNE (+reg,pre)........++++++


Stack analysis
---------------

4 stack accesses found. Annotated code for `deleteASID`:

    0xe001225c     0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0012260     0x4    movw r4, #37576 
    0xe0012264     0x8    lsr r7, r0, #10
    0xe0012268     0xc    movt r4, #57346 
    0xe001226c    0x10    ldr r6, [r4, r7, lsl #2]
    0xe0012270    0x14    cmp r6, #0
    0xe0012274    0x18    popeq {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0012278    0x1c    ubfx r5, r0, #0, #10
    0xe001227c    0x20    ldr r3, [r6, r5, lsl #2]
    0xe0012280    0x24    cmp r3, r1
    0xe0012284    0x28    popne {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0012288    0x2c    bl e0012160 <flushSpace>
    0xe001228c    0x30    ldr r3, [r4, r7, lsl #2]
    0xe0012290    0x34    ldr r3, [r3, r5, lsl #2]
    0xe0012294    0x38    add r3, r3, #12288 
    0xe0012298    0x3c    ldr r2, [r3, #4032] 
    0xe001229c    0x40    tst r2, #8388608 
    0xe00122a0    0x44    lsrne r2, r2, #24
    0xe00122a4    0x48    movwne r1, #12872 
    0xe00122a8    0x4c    movne r0, #0
    0xe00122ac    0x50    movtne r1, #57347 
    0xe00122b0    0x54    strne r0, [r1, r2, lsl #2]
    0xe00122b4    0x58    movw r2, #13900 
    0xe00122b8    0x5c    movt r2, #57347 
    0xe00122bc    0x60    mov r1, #0
    0xe00122c0    0x64    str r1, [r3, #4032] 
    0xe00122c4    0x68    ldr r0, [r2]
    0xe00122c8    0x6c    str r1, [r6, r5, lsl #2]
    0xe00122cc    0x70    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe00122d0    0x74    b e0011294 <setVMRoot>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteASID` has 59 nodes.

Section deleteASIDPool (235 of 299)
===================================

Deriving specifications
-----------------------

Section `deleteASIDPool` consists of 39 instructions.
 LDMIANE (wb);15,10,9,8,7,6,5,4..++
 LDMIA (wb);14,10,9,8,7,6,5,4.+


Stack analysis
---------------

3 stack accesses found. Annotated code for `deleteASIDPool`:

    0xe00121c0     0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe00121c4     0x4    movw r8, #37576 
    0xe00121c8     0x8    lsr sl, r0, #10
    0xe00121cc     0xc    movt r8, #57346 
    0xe00121d0    0x10    ldr r5, [r8, sl, lsl #2]
    0xe00121d4    0x14    cmp r5, r1
    0xe00121d8    0x18    popne {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe00121dc    0x1c    add r6, r5, #4080 
    0xe00121e0    0x20    movw r9, #12872 
    0xe00121e4    0x24    sub r5, r5, #4
    0xe00121e8    0x28    add r6, r6, #12
    0xe00121ec    0x2c    movt r9, #57347 
    0xe00121f0    0x30    mov r4, r0
    0xe00121f4    0x34    mov r7, #0
    0xe00121f8    0x38    ldr r3, [r5, #4]!
    0xe00121fc    0x3c    mov r0, r4
    0xe0012200    0x40    cmp r3, #0
    0xe0012204    0x44    beq e0012234 <deleteASIDPool+0x74>
    0xe0012208    0x48    bl e0012160 <flushSpace>
    0xe001220c    0x4c    lsr r2, r4, #10
    0xe0012210    0x50    ubfx r3, r4, #0, #10
    0xe0012214    0x54    ldr r2, [r8, r2, lsl #2]
    0xe0012218    0x58    ldr r3, [r2, r3, lsl #2]
    0xe001221c    0x5c    add r3, r3, #12288 
    0xe0012220    0x60    ldr r2, [r3, #4032] 
    0xe0012224    0x64    str r7, [r3, #4032] 
    0xe0012228    0x68    tst r2, #8388608 
    0xe001222c    0x6c    lsr r2, r2, #24
    0xe0012230    0x70    strne r7, [r9, r2, lsl #2]
    0xe0012234    0x74    cmp r5, r6
    0xe0012238    0x78    add r4, r4, #1
    0xe001223c    0x7c    bne e00121f8 <deleteASIDPool+0x38>
    0xe0012240    0x80    movw r3, #13900 
    0xe0012244    0x84    movt r3, #57347 
    0xe0012248    0x88    mov r2, #0
    0xe001224c    0x8c    str r2, [r8, sl, lsl #2]
    0xe0012250    0x90    ldr r0, [r3]
    0xe0012254    0x94    pop {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0012258    0x98    b e0011294 <setVMRoot>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
39 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `deleteASIDPool` has 61 nodes.

Section unmapPageTable (236 of 299)
===================================

Deriving specifications
-----------------------

Section `unmapPageTable` consists of 18 instructions.
Skipping ee072f3b mcr 15, 0, r2, cr7, cr11, {1}
Skipping f57ff05f dmb sy


Stack analysis
---------------

3 stack accesses found. Annotated code for `unmapPageTable`:

    0xe00117a4     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00117a8     0x4    mov r6, r2
    0xe00117ac     0x8    mov r5, r0
    0xe00117b0     0xc    mov r4, r1
    0xe00117b4    0x10    bl e0011134 <pageTableMapped>
    0xe00117b8    0x14    subs r2, r0, #0
    0xe00117bc    0x18    popeq {r4, r5, r6, pc}  ; stack access
    0xe00117c0    0x1c    lsr r1, r4, #20
    0xe00117c4    0x20    mov r3, #0
    0xe00117c8    0x24    str r3, [r2, r1, lsl #2]
    0xe00117cc    0x28    add r2, r2, r1, lsl #2
    0xe00117d0    0x2c    mcr 15, 0, r2, cr7, cr11, {1}
    0xe00117d4    0x30    dmb sy
    0xe00117d8    0x34    mov r3, r6
    0xe00117dc    0x38    mov r2, r4
    0xe00117e0    0x3c    mov r1, r5
    0xe00117e4    0x40    pop {r4, r5, r6, lr}  ; stack access
    0xe00117e8    0x44    b e0011740 <flushTable>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unmapPageTable` has 28 nodes.

Section flushTable (237 of 299)
===============================

Deriving specifications
-----------------------

Section `flushTable` consists of 25 instructions.
Skipping f57ff04f dsb sy
Skipping ee083f57 mcr 15, 0, r3, cr8, cr7, {2}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

4 stack accesses found. Annotated code for `flushTable`:

    0xe0011740     0x0    push {r4, lr}         ; stack access
    0xe0011744     0x4    mov r4, r1
    0xe0011748     0x8    bl e001137c <setVMRootForFlush>
    0xe001174c     0xc    lsr r2, r4, #10
    0xe0011750    0x10    movw r3, #37576 
    0xe0011754    0x14    movt r3, #57346 
    0xe0011758    0x18    ubfx r4, r4, #0, #10
    0xe001175c    0x1c    ldr r3, [r3, r2, lsl #2]
    0xe0011760    0x20    ldr r3, [r3, r4, lsl #2]
    0xe0011764    0x24    add r3, r3, #12288 
    0xe0011768    0x28    ldr r3, [r3, #4032] 
    0xe001176c    0x2c    tst r3, #8388608 
    0xe0011770    0x30    popeq {r4, pc}        ; stack access
    0xe0011774    0x34    dsb sy
    0xe0011778    0x38    lsr r3, r3, #24
    0xe001177c    0x3c    mcr 15, 0, r3, cr8, cr7, {2}
    0xe0011780    0x40    dsb sy
    0xe0011784    0x44    isb sy
    0xe0011788    0x48    cmp r0, #0
    0xe001178c    0x4c    popeq {r4, pc}        ; stack access
    0xe0011790    0x50    movw r3, #13900 
    0xe0011794    0x54    movt r3, #57347 
    0xe0011798    0x58    pop {r4, lr}          ; stack access
    0xe001179c    0x5c    ldr r0, [r3]
    0xe00117a0    0x60    b e0011294 <setVMRoot>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
25 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `flushTable` has 43 nodes.

Section flushPage (238 of 299)
==============================

Deriving specifications
-----------------------

Section `flushPage` consists of 30 instructions.
Skipping f57ff04f dsb sy
Skipping ee083f37 mcr 15, 0, r3, cr8, cr7, {1}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

4 stack accesses found. Annotated code for `flushPage`:

    0xe00114b8     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe00114bc     0x4    mov r0, r1
    0xe00114c0     0x8    mov r4, r2
    0xe00114c4     0xc    mov r1, r2
    0xe00114c8    0x10    mov r5, r3
    0xe00114cc    0x14    bl e001137c <setVMRootForFlush>
    0xe00114d0    0x18    lsr r2, r4, #10
    0xe00114d4    0x1c    movw r3, #37576 
    0xe00114d8    0x20    movt r3, #57346 
    0xe00114dc    0x24    ubfx r4, r4, #0, #10
    0xe00114e0    0x28    ldr r3, [r3, r2, lsl #2]
    0xe00114e4    0x2c    ldr r3, [r3, r4, lsl #2]
    0xe00114e8    0x30    add r3, r3, #12288 
    0xe00114ec    0x34    ldr r2, [r3, #4032] 
    0xe00114f0    0x38    tst r2, #8388608 
    0xe00114f4    0x3c    popeq {r4, r5, r6, pc}  ; stack access
    0xe00114f8    0x40    dsb sy
    0xe00114fc    0x44    bic r3, r5, #4080 
    0xe0011500    0x48    bic r3, r3, #15
    0xe0011504    0x4c    orr r3, r3, r2, lsr #24
    0xe0011508    0x50    mcr 15, 0, r3, cr8, cr7, {1}
    0xe001150c    0x54    dsb sy
    0xe0011510    0x58    isb sy
    0xe0011514    0x5c    cmp r0, #0
    0xe0011518    0x60    popeq {r4, r5, r6, pc}  ; stack access
    0xe001151c    0x64    movw r3, #13900 
    0xe0011520    0x68    movt r3, #57347 
    0xe0011524    0x6c    pop {r4, r5, r6, lr}  ; stack access
    0xe0011528    0x70    ldr r0, [r3]
    0xe001152c    0x74    b e0011294 <setVMRoot>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
30 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `flushPage` has 48 nodes.

Section setVMRoot (239 of 299)
==============================

Deriving specifications
-----------------------

Section `setVMRoot` consists of 47 instructions.
Skipping f57ff04f dsb sy
Skipping ee024f10 mcr 15, 0, r4, cr2, cr0, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping ee024f10 mcr 15, 0, r4, cr2, cr0, {0}
Skipping f57ff06f isb sy
Skipping ee0d0f30 mcr 15, 0, r0, cr13, cr0, {1}
Skipping f57ff06f isb sy
Skipping ee026f10 mcr 15, 0, r6, cr2, cr0, {0}
Skipping f57ff06f isb sy


Stack analysis
---------------

4 stack accesses found. Annotated code for `setVMRoot`:

    0xe0011294     0x0    bic r0, r0, #508 
    0xe0011298     0x4    bic r0, r0, #3
    0xe001129c     0x8    push {r4, r5, r6, r7, lr}  ; stack access
    0xe00112a0     0xc    add r1, r0, #16
    0xe00112a4    0x10    ldr r2, [r0, #16]
    0xe00112a8    0x14    sub sp, sp, #12
    0xe00112ac    0x18    and r3, r2, #14
    0xe00112b0    0x1c    cmp r3, #14
    0xe00112b4    0x20    andne r3, r2, #15
    0xe00112b8    0x24    uxtbeq r3, r2
    0xe00112bc    0x28    cmp r3, #9
    0xe00112c0    0x2c    ldr r3, [pc, #132] 
    0xe00112c4    0x30    orr r4, r3, #24
    0xe00112c8    0x34    beq e00112e0 <setVMRoot+0x4c>
    0xe00112cc    0x38    dsb sy
    0xe00112d0    0x3c    mcr 15, 0, r4, cr2, cr0, {0}
    0xe00112d4    0x40    isb sy
    0xe00112d8    0x44    add sp, sp, #12
    0xe00112dc    0x48    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe00112e0    0x4c    tst r2, #16
    0xe00112e4    0x50    beq e00112cc <setVMRoot+0x38>
    0xe00112e8    0x54    ldr r7, [r1, #4]
    0xe00112ec    0x58    mov r0, sp
    0xe00112f0    0x5c    bic r5, r2, #16320 
    0xe00112f4    0x60    ubfx r7, r7, #0, #17
    0xe00112f8    0x64    bic r5, r5, #63 
    0xe00112fc    0x68    mov r1, r7
    0xe0011300    0x6c    bl e0010cf8 <findPDForASID>
    0xe0011304    0x70    ldr r3, [sp]          ; stack access
    0xe0011308    0x74    cmp r3, #0
    0xe001130c    0x78    bne e00112cc <setVMRoot+0x38>
    0xe0011310    0x7c    ldr r6, [sp, #4]      ; stack access
    0xe0011314    0x80    cmp r6, r5
    0xe0011318    0x84    bne e00112cc <setVMRoot+0x38>
    0xe001131c    0x88    mov r0, r7
    0xe0011320    0x8c    bl e0011230 <getHWASID>
    0xe0011324    0x90    dsb sy
    0xe0011328    0x94    mcr 15, 0, r4, cr2, cr0, {0}
    0xe001132c    0x98    isb sy
    0xe0011330    0x9c    mcr 15, 0, r0, cr13, cr0, {1}
    0xe0011334    0xa0    isb sy
    0xe0011338    0xa4    add r6, r6, #805306368 
    0xe001133c    0xa8    orr r6, r6, #24
    0xe0011340    0xac    mcr 15, 0, r6, cr2, cr0, {0}
    0xe0011344    0xb0    isb sy
    0xe0011348    0xb4    b e00112d8 <setVMRoot+0x44>
    0xe001134c    0xb8    .word 0x10024000

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
46 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setVMRoot` has 76 nodes.

Section handleFaultReply (240 of 299)
=====================================

Deriving specifications
-----------------------

Section `handleFaultReply` consists of 105 instructions.


Stack analysis
---------------

4 stack accesses found. Annotated code for `handleFaultReply`:

    0xe0010e58      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0010e5c      0x4    mov r5, r0
    0xe0010e60      0x8    ldr r6, [r1, #4]
    0xe0010e64      0xc    ldr r0, [r0, #96] 
    0xe0010e68     0x10    and r3, r6, #127 
    0xe0010e6c     0x14    cmp r3, #120 
    0xe0010e70     0x18    lsr r6, r6, #12
    0xe0010e74     0x1c    and r0, r0, #15
    0xe0010e78     0x20    bls e0010efc <handleFaultReply+0xa4>
    0xe0010e7c     0x24    cmp r0, #2
    0xe0010e80     0x28    beq e0010f24 <handleFaultReply+0xcc>
    0xe0010e84     0x2c    cmp r0, #3
    0xe0010e88     0x30    bne e0010f0c <handleFaultReply+0xb4>
    0xe0010e8c     0x34    mov r3, #120 
    0xe0010e90     0x38    cmp r3, #3
    0xe0010e94     0x3c    movcc lr, r3
    0xe0010e98     0x40    movcs lr, #3
    0xe0010e9c     0x44    cmp r3, #0
    0xe0010ea0     0x48    beq e0010ef0 <handleFaultReply+0x98>
    0xe0010ea4     0x4c    mov r3, #0
    0xe0010ea8     0x50    ldr r2, [r1, #8]
    0xe0010eac     0x54    add r3, r3, #1
    0xe0010eb0     0x58    ldr ip, [pc, #316] 
    0xe0010eb4     0x5c    cmp lr, r3
    0xe0010eb8     0x60    mov r0, #17
    0xe0010ebc     0x64    add r4, ip, #44 
    0xe0010ec0     0x68    str r2, [r5, r0, lsl #2]
    0xe0010ec4     0x6c    bls e0010ef0 <handleFaultReply+0x98>
    0xe0010ec8     0x70    ldr r2, [r4, r3, lsl #2]
    0xe0010ecc     0x74    add r3, r3, #1
    0xe0010ed0     0x78    ldr r0, [ip], #4
    0xe0010ed4     0x7c    ldr r2, [r1, r2, lsl #2]
    0xe0010ed8     0x80    cmp r0, #16
    0xe0010edc     0x84    andeq r2, r2, #-134217728 
    0xe0010ee0     0x88    orreq r2, r2, #336 
    0xe0010ee4     0x8c    cmp lr, r3
    0xe0010ee8     0x90    str r2, [r5, r0, lsl #2]
    0xe0010eec     0x94    bhi e0010ec8 <handleFaultReply+0x70>
    0xe0010ef0     0x98    clz r0, r6
    0xe0010ef4     0x9c    lsr r0, r0, #5
    0xe0010ef8     0xa0    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0010efc     0xa4    cmp r0, #2
    0xe0010f00     0xa8    beq e0010fcc <handleFaultReply+0x174>
    0xe0010f04     0xac    cmp r0, #3
    0xe0010f08     0xb0    beq e0010e90 <handleFaultReply+0x38>
    0xe0010f0c     0xb4    cmp r0, #1
    0xe0010f10     0xb8    popeq {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0010f14     0xbc    cmp r0, #5
    0xe0010f18     0xc0    bne e0010ff0 <handleFaultReply+0x198>
    0xe0010f1c     0xc4    mov r0, #1
    0xe0010f20     0xc8    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0010f24     0xcc    mov ip, #4
    0xe0010f28     0xd0    mov r7, #12
    0xe0010f2c     0xd4    mov r4, #0
    0xe0010f30     0xd8    ldr r3, [r1, #8]
    0xe0010f34     0xdc    mov r2, r4
    0xe0010f38     0xe0    add r4, r4, #1
    0xe0010f3c     0xe4    cmp r4, ip
    0xe0010f40     0xe8    movw r0, #46024 
    0xe0010f44     0xec    movt r0, #57345 
    0xe0010f48     0xf0    str r3, [r5, r2, lsl #2]
    0xe0010f4c     0xf4    add lr, r0, #96 
    0xe0010f50     0xf8    bcs e0010f7c <handleFaultReply+0x124>
    0xe0010f54     0xfc    ldr r3, [lr, r4, lsl #2]
    0xe0010f58    0x100    ldr r2, [r0, r4, lsl #2]
    0xe0010f5c    0x104    add r4, r4, #1
    0xe0010f60    0x108    ldr r3, [r1, r3, lsl #2]
    0xe0010f64    0x10c    cmp r2, #16
    0xe0010f68    0x110    andeq r3, r3, #-134217728 
    0xe0010f6c    0x114    orreq r3, r3, #336 
    0xe0010f70    0x118    cmp r4, ip
    0xe0010f74    0x11c    str r3, [r5, r2, lsl #2]
    0xe0010f78    0x120    bcc e0010f54 <handleFaultReply+0xfc>
    0xe0010f7c    0x124    cmp r4, r7
    0xe0010f80    0x128    bcs e0010ef0 <handleFaultReply+0x98>
    0xe0010f84    0x12c    mov r0, #0
    0xe0010f88    0x130    bl e0010d50 <lookupIPCBuffer>
    0xe0010f8c    0x134    cmp r0, #0
    0xe0010f90    0x138    beq e0010ef0 <handleFaultReply+0x98>
    0xe0010f94    0x13c    ldr r3, [pc, #92] 
    0xe0010f98    0x140    lsl r4, r4, #2
    0xe0010f9c    0x144    add r7, r0, r7, lsl #2
    0xe0010fa0    0x148    add r0, r0, r4
    0xe0010fa4    0x14c    add r4, r4, r3
    0xe0010fa8    0x150    ldr r2, [r4, #4]!
    0xe0010fac    0x154    ldr r3, [r0, #4]!
    0xe0010fb0    0x158    cmp r2, #16
    0xe0010fb4    0x15c    andeq r3, r3, #-134217728 
    0xe0010fb8    0x160    orreq r3, r3, #336 
    0xe0010fbc    0x164    cmp r0, r7
    0xe0010fc0    0x168    str r3, [r5, r2, lsl #2]
    0xe0010fc4    0x16c    bne e0010fa8 <handleFaultReply+0x150>
    0xe0010fc8    0x170    b e0010ef0 <handleFaultReply+0x98>
    0xe0010fcc    0x174    cmp r3, #12
    0xe0010fd0    0x178    movcc r7, r3
    0xe0010fd4    0x17c    movcs r7, #12
    0xe0010fd8    0x180    cmp r3, #4
    0xe0010fdc    0x184    movcc ip, r3
    0xe0010fe0    0x188    movcs ip, #4
    0xe0010fe4    0x18c    cmp r3, #0
    0xe0010fe8    0x190    bne e0010f2c <handleFaultReply+0xd4>
    0xe0010fec    0x194    b e0010ef0 <handleFaultReply+0x98>
    0xe0010ff0    0x198    bl e0010a3c <halt>
    0xe0010ff4    0x19c    .word 0xe001b3fc
    0xe0010ff8    0x1a0    .word 0xe001b3c4

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
103 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleFaultReply` has 182 nodes.

Section c_handle_undefined_instruction (241 of 299)
===================================================

Deriving specifications
-----------------------

Section `c_handle_undefined_instruction` consists of 12 instructions.
Skipping ee1d2f50 mrc 15, 0, r2, cr13, cr0, {2}
Skipping ee1d2f70 mrc 15, 0, r2, cr13, cr0, {3}


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_undefined_instruction`:

    0xe0010148     0x0    movw r3, #13900 
    0xe001014c     0x4    movt r3, #57347 
    0xe0010150     0x8    push {r4, lr}         ; stack access
    0xe0010154     0xc    ldr r3, [r3]
    0xe0010158    0x10    mrc 15, 0, r2, cr13, cr0, {2}
    0xe001015c    0x14    str r2, [r3, #72] 
    0xe0010160    0x18    mrc 15, 0, r2, cr13, cr0, {3}
    0xe0010164    0x1c    mov r1, #0
    0xe0010168    0x20    str r2, [r3, #76] 
    0xe001016c    0x24    mov r0, r1
    0xe0010170    0x28    bl e0018580 <handleUserLevelFault>
    0xe0010174    0x2c    bl e0010a10 <restore_user_context>

Proving inst theorems
---------------------

12 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_undefined_instruction` has 20 nodes.

Section c_handle_interrupt (242 of 299)
=======================================

Deriving specifications
-----------------------

Section `c_handle_interrupt` consists of 10 instructions.
Skipping ee1d2f50 mrc 15, 0, r2, cr13, cr0, {2}
Skipping ee1d2f70 mrc 15, 0, r2, cr13, cr0, {3}


Stack analysis
---------------

1 stack accesses found. Annotated code for `c_handle_interrupt`:

    0xe0010120     0x0    movw r3, #13900 
    0xe0010124     0x4    movt r3, #57347 
    0xe0010128     0x8    push {r4, lr}         ; stack access
    0xe001012c     0xc    ldr r3, [r3]
    0xe0010130    0x10    mrc 15, 0, r2, cr13, cr0, {2}
    0xe0010134    0x14    str r2, [r3, #72] 
    0xe0010138    0x18    mrc 15, 0, r2, cr13, cr0, {3}
    0xe001013c    0x1c    str r2, [r3, #76] 
    0xe0010140    0x20    bl e00178b4 <handleInterruptEntry>
    0xe0010144    0x24    bl e0010a10 <restore_user_context>

Proving inst theorems
---------------------

10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `c_handle_interrupt` has 18 nodes.

Section arm_data_abort_exception (243 of 299)
=============================================

Deriving specifications
-----------------------

Section `arm_data_abort_exception` consists of 10 instructions.
Skipping f8cd0513 srsia sp, #19
Skipping f1020013 cps #19
Skipping e94d7fff stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
 LDMIA;9,8...+
Skipping ee1ddf90 mrc 15, 0, sp, cr13, cr0, {4}


Stack analysis
---------------

2 stack accesses found. Annotated code for `arm_data_abort_exception`:

    0xe00100b8     0x0    srsia sp, #19
    0xe00100bc     0x4    cps #19
    0xe00100c0     0x8    stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    0xe00100c4     0xc    ldm sp, {r8, r9}      ; stack access
    0xe00100c8    0x10    tst r9, #15
    0xe00100cc    0x14    sub r8, r8, #8
    0xe00100d0    0x18    bne e00100e0 <kernel_data_fault>
    0xe00100d4    0x1c    str r8, [sp, #8]      ; stack access
    0xe00100d8    0x20    mrc 15, 0, sp, cr13, cr0, {4}
    0xe00100dc    0x24    b e0010178 <c_handle_data_fault>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_data_abort_exception` has 21 nodes.

Section arm_prefetch_abort_exception (244 of 299)
=================================================

Deriving specifications
-----------------------

Section `arm_prefetch_abort_exception` consists of 10 instructions.
Skipping f8cd0513 srsia sp, #19
Skipping f1020013 cps #19
Skipping e94d7fff stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
Skipping ee1ddf90 mrc 15, 0, sp, cr13, cr0, {4}


Stack analysis
---------------

2 stack accesses found. Annotated code for `arm_prefetch_abort_exception`:

    0xe0010088     0x0    srsia sp, #19
    0xe001008c     0x4    cps #19
    0xe0010090     0x8    stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    0xe0010094     0xc    ldm sp, {r8, r9}      ; stack access
    0xe0010098    0x10    tst r9, #15
    0xe001009c    0x14    sub r8, r8, #4
    0xe00100a0    0x18    bne e00100b0 <kernel_prefetch_fault>
    0xe00100a4    0x1c    str r8, [sp, #8]      ; stack access
    0xe00100a8    0x20    mrc 15, 0, sp, cr13, cr0, {4}
    0xe00100ac    0x24    b e0010184 <c_handle_instruction_fault>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
10 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_prefetch_abort_exception` has 21 nodes.

Section create_frames_of_region (245 of 299)
============================================

Deriving specifications
-----------------------

Section `create_frames_of_region` consists of 70 instructions.


Stack analysis
---------------

Section `create_frames_of_region` expects pointer to stack in r0.
31 stack accesses found. Annotated code for `create_frames_of_region`:

    0xe0002230      0x0    sub sp, sp, #8
    0xe0002234      0x4    movw ip, #46848 
    0xe0002238      0x8    movt ip, #57345 
    0xe000223c      0xc    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0002240     0x10    sub sp, sp, #52 
    0xe0002244     0x14    add r6, sp, #32
    0xe0002248     0x18    ldr r8, [sp, #104]    ; stack access
    0xe000224c     0x1c    ldr r4, [sp, #100]    ; stack access
    0xe0002250     0x20    str r3, [sp, #92]     ; stack access
    0xe0002254     0x24    ldr r3, [ip, #128] 
    0xe0002258     0x28    cmp r8, r4
    0xe000225c     0x2c    str ip, [sp, #28]     ; stack access
    0xe0002260     0x30    str r0, [sp, #20]     ; stack access
    0xe0002264     0x34    str r3, [sp, #24]     ; stack access
    0xe0002268     0x38    stm r6, {r1, r2}      ; stack access
    0xe000226c     0x3c    ldr r9, [sp, #108]    ; stack access
    0xe0002270     0x40    bls e0002340 <create_frames_of_region+0x110>
    0xe0002274     0x44    movw r7, #65520 
    0xe0002278     0x48    add r5, sp, #40 
    0xe000227c     0x4c    movt r7, #255 
    0xe0002280     0x50    mov sl, #3145728 
    0xe0002284     0x54    mov fp, #1
    0xe0002288     0x58    b e00022ac <create_frames_of_region+0x7c>
    0xe000228c     0x5c    ldm r5, {r2, r3}      ; stack access
    0xe0002290     0x60    add r4, r4, #4096 
    0xe0002294     0x64    ldm r6, {r0, r1}      ; stack access
    0xe0002298     0x68    bl e0001ba8 <provide_cap>
    0xe000229c     0x6c    cmp r0, #0
    0xe00022a0     0x70    beq e00022fc <create_frames_of_region+0xcc>
    0xe00022a4     0x74    cmp r8, r4
    0xe00022a8     0x78    bls e0002320 <create_frames_of_region+0xf0>
    0xe00022ac     0x7c    cmp r9, #0
    0xe00022b0     0x80    and r3, r7, r4, lsr #8
    0xe00022b4     0x84    orr r3, r3, #1
    0xe00022b8     0x88    streq sl, [sp, #44]   ; stack access
    0xe00022bc     0x8c    streq r3, [sp, #40]   ; stack access
    0xe00022c0     0x90    beq e000228c <create_frames_of_region+0x5c>
    0xe00022c4     0x94    ldr r3, [sp, #112]    ; stack access
    0xe00022c8     0x98    add r2, sp, #92 
    0xe00022cc     0x9c    str fp, [sp, #12]     ; stack access
    0xe00022d0     0xa0    mov ip, #0
    0xe00022d4     0xa4    rsb r3, r3, #805306368 
    0xe00022d8     0xa8    str fp, [sp, #4]      ; stack access
    0xe00022dc     0xac    add r3, r3, r4
    0xe00022e0     0xb0    mov r0, r5
    0xe00022e4     0xb4    str r3, [sp]          ; stack access
    0xe00022e8     0xb8    mov r3, r4
    0xe00022ec     0xbc    ldm r2, {r1, r2}      ; stack access
    0xe00022f0     0xc0    str ip, [sp, #8]      ; stack access
    0xe00022f4     0xc4    bl e0000440 <create_mapped_it_frame_cap>
    0xe00022f8     0xc8    b e000228c <create_frames_of_region+0x5c>
    0xe00022fc     0xcc    ldr r3, [sp, #20]     ; stack access
    0xe0002300     0xd0    str r0, [r3]          ; indirect stack access
    0xe0002304     0xd4    str r0, [r3, #4]      ; indirect stack access
    0xe0002308     0xd8    str r0, [r3, #8]      ; indirect stack access
    0xe000230c     0xdc    ldr r0, [sp, #20]     ; stack access
    0xe0002310     0xe0    add sp, sp, #52 
    0xe0002314     0xe4    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0002318     0xe8    add sp, sp, #8
    0xe000231c     0xec    bx lr
    0xe0002320     0xf0    ldr r3, [sp, #28]     ; stack access
    0xe0002324     0xf4    ldr r2, [r3, #128] 
    0xe0002328     0xf8    ldr r1, [sp, #20]     ; stack access
    0xe000232c     0xfc    ldr r3, [sp, #24]     ; stack access
    0xe0002330    0x100    str r3, [r1]          ; indirect stack access
    0xe0002334    0x104    mov r3, #1
    0xe0002338    0x108    strd r2, [r1, #4]     ; indirect stack access
    0xe000233c    0x10c    b e000230c <create_frames_of_region+0xdc>
    0xe0002340    0x110    ldr r2, [sp, #24]     ; stack access
    0xe0002344    0x114    b e0002328 <create_frames_of_region+0xf8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
70 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_frames_of_region` has 118 nodes.

Section activate_global_pd (246 of 299)
=======================================

Deriving specifications
-----------------------

Section `activate_global_pd` consists of 24 instructions.
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee072f15 mcr 15, 0, r2, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee023f10 mcr 15, 0, r3, cr2, cr0, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping ee082f17 mcr 15, 0, r2, cr8, cr7, {0}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

2 stack accesses found. Annotated code for `activate_global_pd`:

    0xe0000a34     0x0    push {r4, lr}         ; stack access
    0xe0000a38     0x4    dsb sy
    0xe0000a3c     0x8    bl e0012410 <cleanInvalidate_D_PoC>
    0xe0000a40     0xc    dsb sy
    0xe0000a44    0x10    mov r2, #0
    0xe0000a48    0x14    mcr 15, 0, r2, cr7, cr5, {0}
    0xe0000a4c    0x18    isb sy
    0xe0000a50    0x1c    dsb sy
    0xe0000a54    0x20    dsb sy
    0xe0000a58    0x24    ldr r3, [pc, #48] 
    0xe0000a5c    0x28    orr r3, r3, #24
    0xe0000a60    0x2c    mcr 15, 0, r3, cr2, cr0, {0}
    0xe0000a64    0x30    isb sy
    0xe0000a68    0x34    dsb sy
    0xe0000a6c    0x38    mcr 15, 0, r2, cr8, cr7, {0}
    0xe0000a70    0x3c    dsb sy
    0xe0000a74    0x40    isb sy
    0xe0000a78    0x44    mov r0, #-536870912 
    0xe0000a7c    0x48    bl e0012544 <lockTLBEntry>
    0xe0000a80    0x4c    mov r0, #0
    0xe0000a84    0x50    pop {r4, lr}          ; stack access
    0xe0000a88    0x54    movt r0, #65535 
    0xe0000a8c    0x58    b e0012544 <lockTLBEntry>
    0xe0000a90    0x5c    .word 0x10024000

Proving inst theorems
---------------------

23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `activate_global_pd` has 40 nodes.

Section slowpath (247 of 299)
=============================

Deriving specifications
-----------------------

Section `slowpath` consists of 7 instructions.


Stack analysis
---------------

1 stack accesses found. Annotated code for `slowpath`:

    0xe001b068     0x0    cmn r0, #9
    0xe001b06c     0x4    push {r4, lr}         ; stack access
    0xe001b070     0x8    bls e001b07c <slowpath+0x14>
    0xe001b074     0xc    bl e001af48 <handleSyscall>
    0xe001b078    0x10    bl e0010a10 <restore_user_context>
    0xe001b07c    0x14    bl e0018548 <handleUnknownSyscall>
    0xe001b080    0x18    b e001b078 <slowpath+0x10>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
7 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `slowpath` has 13 nodes.

Section invokeUntyped_Retype (248 of 299)
=========================================

Deriving specifications
-----------------------

Section `invokeUntyped_Retype` consists of 116 instructions.
 MOVHI (reg)....+++
 ORRLS (imm)....+++
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy


Stack analysis
---------------

15 stack accesses found. Annotated code for `invokeUntyped_Retype`:

    0xe001a454      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001a458      0x4    cmp r1, #0
    0xe001a45c      0x8    ldr r9, [r0]
    0xe001a460      0xc    mov fp, r2
    0xe001a464     0x10    ldr r2, [r0, #4]
    0xe001a468     0x14    sub sp, sp, #28
    0xe001a46c     0x18    mov r6, r0
    0xe001a470     0x1c    mov sl, r3
    0xe001a474     0x20    bic r7, r9, #15
    0xe001a478     0x24    and r8, r2, #63 
    0xe001a47c     0x28    beq e001a50c <invokeUntyped_Retype+0xb8>
    0xe001a480     0x2c    lsr r3, r2, #6
    0xe001a484     0x30    lsls r3, r3, #4
    0xe001a488     0x34    beq e001a50c <invokeUntyped_Retype+0xb8>
    0xe001a48c     0x38    and r1, r2, #31
    0xe001a490     0x3c    ubfx r2, r2, #5, #1
    0xe001a494     0x40    cmp r1, #7
    0xe001a498     0x44    movhi r4, r2
    0xe001a49c     0x48    orrls r4, r2, #1
    0xe001a4a0     0x4c    cmp r4, #0
    0xe001a4a4     0x50    beq e001a568 <invokeUntyped_Retype+0x114>
    0xe001a4a8     0x54    cmp r2, #0
    0xe001a4ac     0x58    bne e001a504 <invokeUntyped_Retype+0xb0>
    0xe001a4b0     0x5c    mov r0, #1
    0xe001a4b4     0x60    lsl r0, r0, r1
    0xe001a4b8     0x64    mov r1, r7
    0xe001a4bc     0x68    mov r3, r0
    0xe001a4c0     0x6c    subs r3, r3, #4
    0xe001a4c4     0x70    str r2, [r1], #4
    0xe001a4c8     0x74    bne e001a4c0 <invokeUntyped_Retype+0x6c>
    0xe001a4cc     0x78    sub r2, r7, #1
    0xe001a4d0     0x7c    lsr r3, r7, #5
    0xe001a4d4     0x80    add r2, r2, r0
    0xe001a4d8     0x84    lsr r2, r2, #5
    0xe001a4dc     0x88    add r2, r2, #1
    0xe001a4e0     0x8c    cmp r3, r2
    0xe001a4e4     0x90    bcs e001a504 <invokeUntyped_Retype+0xb0>
    0xe001a4e8     0x94    lsl r3, r3, #5
    0xe001a4ec     0x98    lsl r2, r2, #5
    0xe001a4f0     0x9c    mcr 15, 0, r3, cr7, cr11, {1}
    0xe001a4f4     0xa0    dmb sy
    0xe001a4f8     0xa4    add r3, r3, #32
    0xe001a4fc     0xa8    cmp r2, r3
    0xe001a500     0xac    bne e001a4f0 <invokeUntyped_Retype+0x9c>
    0xe001a504     0xb0    str r9, [r6]
    0xe001a508     0xb4    str r8, [r6, #4]
    0xe001a50c     0xb8    ldr r1, [sp, #64]     ; stack access
    0xe001a510     0xbc    mov r0, sl
    0xe001a514     0xc0    bl e0014258 <getObjectSize>
    0xe001a518     0xc4    ldr lr, [sp, #76]     ; stack access
    0xe001a51c     0xc8    ldr r2, [sp, #80]     ; stack access
    0xe001a520     0xcc    sub ip, fp, r7
    0xe001a524     0xd0    add r3, sp, #68 
    0xe001a528     0xd4    str fp, [sp, #4]      ; stack access
    0xe001a52c     0xd8    str lr, [sp]          ; stack access
    0xe001a530     0xdc    mov r1, r6
    0xe001a534     0xe0    str r2, [sp, #12]     ; stack access
    0xe001a538     0xe4    ldr r2, [sp, #64]     ; stack access
    0xe001a53c     0xe8    str r2, [sp, #8]      ; stack access
    0xe001a540     0xec    ldm r3, {r2, r3}      ; stack access
    0xe001a544     0xf0    add ip, ip, lr, lsl r0
    0xe001a548     0xf4    mov r0, sl
    0xe001a54c     0xf8    lsr ip, ip, #4
    0xe001a550     0xfc    orr ip, r8, ip, lsl #6
    0xe001a554    0x100    str ip, [r6, #4]
    0xe001a558    0x104    bl e0016288 <createNewObjects>
    0xe001a55c    0x108    mov r0, #0
    0xe001a560    0x10c    add sp, sp, #28
    0xe001a564    0x110    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe001a568    0x114    sub r3, r3, #1
    0xe001a56c    0x118    movw r1, #12804 
    0xe001a570    0x11c    bic r2, r3, #255 
    0xe001a574    0x120    movt r1, #57347 
    0xe001a578    0x124    add r5, r7, r2
    0xe001a57c    0x128    add r0, r5, #256 
    0xe001a580    0x12c    mov r3, r5
    0xe001a584    0x130    str r4, [r3], #4
    0xe001a588    0x134    cmp r0, r3
    0xe001a58c    0x138    bne e001a584 <invokeUntyped_Retype+0x130>
    0xe001a590    0x13c    add r0, r5, #255 
    0xe001a594    0x140    lsr r3, r5, #5
    0xe001a598    0x144    lsr r0, r0, #5
    0xe001a59c    0x148    add r0, r0, #1
    0xe001a5a0    0x14c    cmp r0, r3
    0xe001a5a4    0x150    bls e001a5c4 <invokeUntyped_Retype+0x170>
    0xe001a5a8    0x154    lsl r3, r3, #5
    0xe001a5ac    0x158    lsl r0, r0, #5
    0xe001a5b0    0x15c    mcr 15, 0, r3, cr7, cr11, {1}
    0xe001a5b4    0x160    dmb sy
    0xe001a5b8    0x164    add r3, r3, #32
    0xe001a5bc    0x168    cmp r0, r3
    0xe001a5c0    0x16c    bne e001a5b0 <invokeUntyped_Retype+0x15c>
    0xe001a5c4    0x170    ldr r0, [r1]
    0xe001a5c8    0x174    lsr r3, r2, #4
    0xe001a5cc    0x178    str r9, [r6]
    0xe001a5d0    0x17c    add r0, r0, #1
    0xe001a5d4    0x180    orr r3, r8, r3, lsl #6
    0xe001a5d8    0x184    cmp r0, #99 
    0xe001a5dc    0x188    str r0, [r1]
    0xe001a5e0    0x18c    str r3, [r6, #4]
    0xe001a5e4    0x190    bhi e001a604 <invokeUntyped_Retype+0x1b0>
    0xe001a5e8    0x194    sub r2, r2, #256 
    0xe001a5ec    0x198    sub r5, r5, #256 
    0xe001a5f0    0x19c    cmn r2, #256 
    0xe001a5f4    0x1a0    bne e001a57c <invokeUntyped_Retype+0x128>
    0xe001a5f8    0x1a4    ldr r8, [r6, #4]
    0xe001a5fc    0x1a8    and r8, r8, #63 
    0xe001a600    0x1ac    b e001a50c <invokeUntyped_Retype+0xb8>
    0xe001a604    0x1b0    str r1, [sp, #20]     ; stack access
    0xe001a608    0x1b4    str r2, [sp, #16]     ; stack access
    0xe001a60c    0x1b8    bl e00107a8 <preemptionPoint.part.161>
    0xe001a610    0x1bc    ldr r2, [sp, #16]     ; stack access
    0xe001a614    0x1c0    ldr r1, [sp, #20]     ; stack access
    0xe001a618    0x1c4    cmp r0, #0
    0xe001a61c    0x1c8    beq e001a5e8 <invokeUntyped_Retype+0x194>
    0xe001a620    0x1cc    b e001a560 <invokeUntyped_Retype+0x10c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
116 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeUntyped_Retype` has 180 nodes.

Section invokeTCB_ReadRegisters (249 of 299)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_ReadRegisters` consists of 103 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `invokeTCB_ReadRegisters`:

    0xe0019ba0      0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0019ba4      0x4    cmp r1, #0
    0xe0019ba8      0x8    movw r7, #13900 
    0xe0019bac      0xc    movt r7, #57347 
    0xe0019bb0     0x10    mov r5, r2
    0xe0019bb4     0x14    mov r6, r0
    0xe0019bb8     0x18    ldr r4, [r7]
    0xe0019bbc     0x1c    bne e0019ce4 <invokeTCB_ReadRegisters+0x144>
    0xe0019bc0     0x20    ldr r3, [sp, #32]     ; stack access
    0xe0019bc4     0x24    ldr r8, [r4, #80] 
    0xe0019bc8     0x28    cmp r3, #0
    0xe0019bcc     0x2c    bic r8, r8, #15
    0xe0019bd0     0x30    orr r7, r8, #1
    0xe0019bd4     0x34    movne r9, r4
    0xe0019bd8     0x38    beq e0019d08 <invokeTCB_ReadRegisters+0x168>
    0xe0019bdc     0x3c    mov r1, r4
    0xe0019be0     0x40    mov r0, #1
    0xe0019be4     0x44    bl e0010d50 <lookupIPCBuffer>
    0xe0019be8     0x48    cmp r5, #0
    0xe0019bec     0x4c    mov r3, #0
    0xe0019bf0     0x50    str r3, [r4]
    0xe0019bf4     0x54    beq e0019cbc <invokeTCB_ReadRegisters+0x11c>
    0xe0019bf8     0x58    ldr r3, [r6, #68] 
    0xe0019bfc     0x5c    cmp r5, #1
    0xe0019c00     0x60    str r3, [r4, #8]
    0xe0019c04     0x64    bls e0019d1c <invokeTCB_ReadRegisters+0x17c>
    0xe0019c08     0x68    ldr r3, [r6, #52] 
    0xe0019c0c     0x6c    cmp r5, #2
    0xe0019c10     0x70    str r3, [r4, #12]
    0xe0019c14     0x74    beq e0019cbc <invokeTCB_ReadRegisters+0x11c>
    0xe0019c18     0x78    ldr r3, [r6, #64] 
    0xe0019c1c     0x7c    cmp r5, #3
    0xe0019c20     0x80    str r3, [r4, #16]
    0xe0019c24     0x84    beq e0019cbc <invokeTCB_ReadRegisters+0x11c>
    0xe0019c28     0x88    ldr r3, [r6]
    0xe0019c2c     0x8c    cmp r5, #4
    0xe0019c30     0x90    str r3, [r4, #20]
    0xe0019c34     0x94    beq e0019cbc <invokeTCB_ReadRegisters+0x11c>
    0xe0019c38     0x98    cmp r0, #0
    0xe0019c3c     0x9c    orr r7, r8, #1
    0xe0019c40     0xa0    moveq r3, #4
    0xe0019c44     0xa4    beq e0019cc8 <invokeTCB_ReadRegisters+0x128>
    0xe0019c48     0xa8    ldr ip, [pc, #228] 
    0xe0019c4c     0xac    add r2, r0, #16
    0xe0019c50     0xb0    mov r1, #1
    0xe0019c54     0xb4    mov r3, #4
    0xe0019c58     0xb8    b e0019c60 <invokeTCB_ReadRegisters+0xc0>
    0xe0019c5c     0xbc    ldr r1, [ip, r3, lsl #2]
    0xe0019c60     0xc0    add r3, r3, #1
    0xe0019c64     0xc4    ldr r1, [r6, r1, lsl #2]
    0xe0019c68     0xc8    cmp r3, #9
    0xe0019c6c     0xcc    cmpls r3, r5
    0xe0019c70     0xd0    str r1, [r2, #4]!
    0xe0019c74     0xd4    bcc e0019c5c <invokeTCB_ReadRegisters+0xbc>
    0xe0019c78     0xd8    cmp r5, #10
    0xe0019c7c     0xdc    movls r0, #0
    0xe0019c80     0xe0    bls e0019cc8 <invokeTCB_ReadRegisters+0x128>
    0xe0019c84     0xe4    ldr lr, [pc, #172] 
    0xe0019c88     0xe8    sub r5, r5, #10
    0xe0019c8c     0xec    add r1, r0, #40 
    0xe0019c90     0xf0    mov ip, #2
    0xe0019c94     0xf4    mov r0, #0
    0xe0019c98     0xf8    ldr ip, [r6, ip, lsl #2]
    0xe0019c9c     0xfc    add r0, r0, #1
    0xe0019ca0    0x100    cmp r0, #9
    0xe0019ca4    0x104    str ip, [r1, #4]!
    0xe0019ca8    0x108    beq e0019cc8 <invokeTCB_ReadRegisters+0x128>
    0xe0019cac    0x10c    cmp r0, r5
    0xe0019cb0    0x110    beq e0019cc8 <invokeTCB_ReadRegisters+0x128>
    0xe0019cb4    0x114    ldr ip, [lr, #4]!
    0xe0019cb8    0x118    b e0019c98 <invokeTCB_ReadRegisters+0xf8>
    0xe0019cbc    0x11c    mov r3, r5
    0xe0019cc0    0x120    cmp r0, #0
    0xe0019cc4    0x124    bne e0019c78 <invokeTCB_ReadRegisters+0xd8>
    0xe0019cc8    0x128    add r0, r0, r3
    0xe0019ccc    0x12c    str r0, [r4, #4]
    0xe0019cd0    0x130    cmp r4, r9
    0xe0019cd4    0x134    str r7, [r4, #80] 
    0xe0019cd8    0x138    beq e0019d0c <invokeTCB_ReadRegisters+0x16c>
    0xe0019cdc    0x13c    mov r0, #0
    0xe0019ce0    0x140    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe0019ce4    0x144    bl e00167b4 <suspend>
    0xe0019ce8    0x148    ldr r3, [sp, #32]     ; stack access
    0xe0019cec    0x14c    ldr r9, [r7]
    0xe0019cf0    0x150    cmp r3, #0
    0xe0019cf4    0x154    bne e0019d24 <invokeTCB_ReadRegisters+0x184>
    0xe0019cf8    0x158    ldr r7, [r4, #80] 
    0xe0019cfc    0x15c    bic r7, r7, #15
    0xe0019d00    0x160    orr r7, r7, #1
    0xe0019d04    0x164    b e0019cd0 <invokeTCB_ReadRegisters+0x130>
    0xe0019d08    0x168    str r7, [r4, #80] 
    0xe0019d0c    0x16c    mov r0, r4
    0xe0019d10    0x170    bl e0013114 <setThreadState.part.166>
    0xe0019d14    0x174    mov r0, #0
    0xe0019d18    0x178    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe0019d1c    0x17c    mov r3, #1
    0xe0019d20    0x180    b e0019cc0 <invokeTCB_ReadRegisters+0x120>
    0xe0019d24    0x184    ldr r8, [r4, #80] 
    0xe0019d28    0x188    bic r8, r8, #15
    0xe0019d2c    0x18c    orr r7, r8, #1
    0xe0019d30    0x190    b e0019bdc <invokeTCB_ReadRegisters+0x3c>
    0xe0019d34    0x194    .word 0xe001b458
    0xe0019d38    0x198    .word 0xe001b480

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
101 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_ReadRegisters` has 171 nodes.

Section invokeTCB_CopyRegisters (250 of 299)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_CopyRegisters` consists of 53 instructions.


Stack analysis
---------------

5 stack accesses found. Annotated code for `invokeTCB_CopyRegisters`:

    0xe00199e8     0x0    cmp r2, #0
    0xe00199ec     0x4    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe00199f0     0x8    mov r4, r0
    0xe00199f4     0xc    mov r5, r1
    0xe00199f8    0x10    mov r8, r3
    0xe00199fc    0x14    ldr r7, [sp, #24]     ; stack access
    0xe0019a00    0x18    ldr r6, [sp, #28]     ; stack access
    0xe0019a04    0x1c    bne e0019a8c <invokeTCB_CopyRegisters+0xa4>
    0xe0019a08    0x20    cmp r8, #0
    0xe0019a0c    0x24    bne e0019a9c <invokeTCB_CopyRegisters+0xb4>
    0xe0019a10    0x28    cmp r7, #0
    0xe0019a14    0x2c    beq e0019a44 <invokeTCB_CopyRegisters+0x5c>
    0xe0019a18    0x30    ldr r2, [pc, #148] 
    0xe0019a1c    0x34    mov r3, #17
    0xe0019a20    0x38    add r0, r2, #36 
    0xe0019a24    0x3c    b e0019a2c <invokeTCB_CopyRegisters+0x44>
    0xe0019a28    0x40    ldr r3, [r2, #4]!
    0xe0019a2c    0x44    ldr r1, [r5, r3, lsl #2]
    0xe0019a30    0x48    cmp r2, r0
    0xe0019a34    0x4c    str r1, [r4, r3, lsl #2]
    0xe0019a38    0x50    bne e0019a28 <invokeTCB_CopyRegisters+0x40>
    0xe0019a3c    0x54    ldr r3, [r4, #68] 
    0xe0019a40    0x58    str r3, [r4, #60] 
    0xe0019a44    0x5c    cmp r6, #0
    0xe0019a48    0x60    beq e0019a70 <invokeTCB_CopyRegisters+0x88>
    0xe0019a4c    0x64    ldr r2, [pc, #100] 
    0xe0019a50    0x68    mov r3, #2
    0xe0019a54    0x6c    add r0, r2, #32
    0xe0019a58    0x70    b e0019a60 <invokeTCB_CopyRegisters+0x78>
    0xe0019a5c    0x74    ldr r3, [r2, #4]!
    0xe0019a60    0x78    ldr r1, [r5, r3, lsl #2]
    0xe0019a64    0x7c    cmp r2, r0
    0xe0019a68    0x80    str r1, [r4, r3, lsl #2]
    0xe0019a6c    0x84    bne e0019a5c <invokeTCB_CopyRegisters+0x74>
    0xe0019a70    0x88    movw r3, #13900 
    0xe0019a74    0x8c    movt r3, #57347 
    0xe0019a78    0x90    ldr r3, [r3]
    0xe0019a7c    0x94    cmp r3, r4
    0xe0019a80    0x98    beq e0019aa8 <invokeTCB_CopyRegisters+0xc0>
    0xe0019a84    0x9c    mov r0, #0
    0xe0019a88    0xa0    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0019a8c    0xa4    mov r0, r1
    0xe0019a90    0xa8    bl e00167b4 <suspend>
    0xe0019a94    0xac    cmp r8, #0
    0xe0019a98    0xb0    beq e0019a10 <invokeTCB_CopyRegisters+0x28>
    0xe0019a9c    0xb4    mov r0, r4
    0xe0019aa0    0xb8    bl e0017514 <restart>
    0xe0019aa4    0xbc    b e0019a10 <invokeTCB_CopyRegisters+0x28>
    0xe0019aa8    0xc0    bl e0013098 <rescheduleRequired>
    0xe0019aac    0xc4    mov r0, #0
    0xe0019ab0    0xc8    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0019ab4    0xcc    .word 0xe001b458
    0xe0019ab8    0xd0    .word 0xe001b480

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
51 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_CopyRegisters` has 86 nodes.

Section handleUserLevelFault (251 of 299)
=========================================

Deriving specifications
-----------------------

Section `handleUserLevelFault` consists of 15 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleUserLevelFault`:

    0xe0018580     0x0    movw r3, #32768 
    0xe0018584     0x4    movw r2, #13900 
    0xe0018588     0x8    movt r3, #57346 
    0xe001858c     0xc    movt r2, #57347 
    0xe0018590    0x10    lsl r1, r1, #4
    0xe0018594    0x14    push {r4, lr}         ; stack access
    0xe0018598    0x18    orr r1, r1, #3
    0xe001859c    0x1c    str r0, [r3, #4]
    0xe00185a0    0x20    str r1, [r3]
    0xe00185a4    0x24    ldr r0, [r2]
    0xe00185a8    0x28    bl e0018508 <handleFault>
    0xe00185ac    0x2c    bl e00165a8 <schedule>
    0xe00185b0    0x30    bl e001319c <activateThread>
    0xe00185b4    0x34    mov r0, #0
    0xe00185b8    0x38    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

15 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleUserLevelFault` has 23 nodes.

Section handleUnknownSyscall (252 of 299)
=========================================

Deriving specifications
-----------------------

Section `handleUnknownSyscall` consists of 14 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleUnknownSyscall`:

    0xe0018548     0x0    movw r3, #32768 
    0xe001854c     0x4    movw r2, #13900 
    0xe0018550     0x8    movt r3, #57346 
    0xe0018554     0xc    movt r2, #57347 
    0xe0018558    0x10    push {r4, lr}         ; stack access
    0xe001855c    0x14    mov r1, #2
    0xe0018560    0x18    str r0, [r3, #4]
    0xe0018564    0x1c    str r1, [r3]
    0xe0018568    0x20    ldr r0, [r2]
    0xe001856c    0x24    bl e0018508 <handleFault>
    0xe0018570    0x28    bl e00165a8 <schedule>
    0xe0018574    0x2c    bl e001319c <activateThread>
    0xe0018578    0x30    mov r0, #0
    0xe001857c    0x34    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleUnknownSyscall` has 22 nodes.

Section doIPCTransfer (253 of 299)
==================================

Deriving specifications
-----------------------

Section `doIPCTransfer` consists of 38 instructions.
 STMIB;7,5...+


Stack analysis
---------------

6 stack accesses found. Annotated code for `doIPCTransfer`:

    0xe0017fe8     0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe0017fec     0x4    sub sp, sp, #20
    0xe0017ff0     0x8    mov r4, r0
    0xe0017ff4     0xc    mov r8, r1
    0xe0017ff8    0x10    ldr r5, [sp, #48]     ; stack access
    0xe0017ffc    0x14    mov r0, #1
    0xe0018000    0x18    mov r6, r2
    0xe0018004    0x1c    mov r9, r3
    0xe0018008    0x20    mov r1, r5
    0xe001800c    0x24    bl e0010d50 <lookupIPCBuffer>
    0xe0018010    0x28    mov r7, r0
    0xe0018014    0x2c    ldr r0, [r4, #96] 
    0xe0018018    0x30    ands r0, r0, #15
    0xe001801c    0x34    bne e001804c <doIPCTransfer+0x64>
    0xe0018020    0x38    mov r1, r4
    0xe0018024    0x3c    bl e0010d50 <lookupIPCBuffer>
    0xe0018028    0x40    stmib sp, {r5, r7}    ; stack access
    0xe001802c    0x44    mov r3, r6
    0xe0018030    0x48    str r9, [sp]          ; stack access
    0xe0018034    0x4c    mov r2, r8
    0xe0018038    0x50    mov r1, r0
    0xe001803c    0x54    mov r0, r4
    0xe0018040    0x58    bl e0017d50 <doNormalTransfer>
    0xe0018044    0x5c    add sp, sp, #20
    0xe0018048    0x60    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe001804c    0x64    mov r2, r7
    0xe0018050    0x68    mov r1, r5
    0xe0018054    0x6c    mov r0, r4
    0xe0018058    0x70    bl e0010a8c <setMRs_fault>
    0xe001805c    0x74    ldr r3, [r4, #96] 
    0xe0018060    0x78    str r6, [r5]
    0xe0018064    0x7c    lsl r3, r3, #12
    0xe0018068    0x80    uxth r3, r3
    0xe001806c    0x84    and r0, r0, #127 
    0xe0018070    0x88    orr r3, r3, r0
    0xe0018074    0x8c    str r3, [r5, #4]
    0xe0018078    0x90    add sp, sp, #20
    0xe001807c    0x94    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doIPCTransfer` has 54 nodes.

Section decodeIRQHandlerInvocation (254 of 299)
===============================================

Deriving specifications
-----------------------

Section `decodeIRQHandlerInvocation` consists of 115 instructions.


Stack analysis
---------------

10 stack accesses found. Annotated code for `decodeIRQHandlerInvocation`:

    0xe0017974      0x0    sub sp, sp, #8
    0xe0017978      0x4    cmp r0, #27
    0xe001797c      0x8    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0017980      0xc    sub sp, sp, #12
    0xe0017984     0x10    mov r4, r1
    0xe0017988     0x14    add r1, sp, #28
    0xe001798c     0x18    stmib r1, {r2, r3}    ; stack access
    0xe0017990     0x1c    beq e0017a6c <decodeIRQHandlerInvocation+0xf8>
    0xe0017994     0x20    cmp r0, #28
    0xe0017998     0x24    beq e0017a24 <decodeIRQHandlerInvocation+0xb0>
    0xe001799c     0x28    cmp r0, #26
    0xe00179a0     0x2c    beq e00179c8 <decodeIRQHandlerInvocation+0x54>
    0xe00179a4     0x30    mov r2, #3
    0xe00179a8     0x34    movw r3, #36896 
    0xe00179ac     0x38    movt r3, #57346 
    0xe00179b0     0x3c    mov r0, r2
    0xe00179b4     0x40    str r2, [r3, #24]
    0xe00179b8     0x44    add sp, sp, #12
    0xe00179bc     0x48    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe00179c0     0x4c    add sp, sp, #8
    0xe00179c4     0x50    bx lr
    0xe00179c8     0x54    movw r3, #13900 
    0xe00179cc     0x58    movt r3, #57347 
    0xe00179d0     0x5c    ldr r2, [r3]
    0xe00179d4     0x60    ldr r3, [r2, #80] 
    0xe00179d8     0x64    mov r0, r2
    0xe00179dc     0x68    bic r3, r3, #15
    0xe00179e0     0x6c    orr r3, r3, #2
    0xe00179e4     0x70    str r3, [r2, #80] 
    0xe00179e8     0x74    bl e0013114 <setThreadState.part.166>
    0xe00179ec     0x78    lsr r0, r4, #5
    0xe00179f0     0x7c    movw r2, #4607 
    0xe00179f4     0x80    movt r2, #65520 
    0xe00179f8     0x84    lsl r0, r0, #2
    0xe00179fc     0x88    mov r1, #1
    0xe0017a00     0x8c    add r2, r0, r2
    0xe0017a04     0x90    and r4, r4, #31
    0xe0017a08     0x94    lsl r4, r1, r4
    0xe0017a0c     0x98    mov r0, #0
    0xe0017a10     0x9c    str r4, [r2, #-255] 
    0xe0017a14     0xa0    add sp, sp, #12
    0xe0017a18     0xa4    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0017a1c     0xa8    add sp, sp, #8
    0xe0017a20     0xac    bx lr
    0xe0017a24     0xb0    movw r3, #13900 
    0xe0017a28     0xb4    movt r3, #57347 
    0xe0017a2c     0xb8    ldr r2, [r3]
    0xe0017a30     0xbc    ldr r3, [r2, #80] 
    0xe0017a34     0xc0    mov r0, r2
    0xe0017a38     0xc4    bic r3, r3, #15
    0xe0017a3c     0xc8    orr r3, r3, #2
    0xe0017a40     0xcc    str r3, [r2, #80] 
    0xe0017a44     0xd0    bl e0013114 <setThreadState.part.166>
    0xe0017a48     0xd4    movw r0, #8192 
    0xe0017a4c     0xd8    movt r0, #57347 
    0xe0017a50     0xdc    add r0, r0, r4, lsl #4
    0xe0017a54     0xe0    bl e00173d0 <cteDeleteOne>
    0xe0017a58     0xe4    mov r0, #0
    0xe0017a5c     0xe8    add sp, sp, #12
    0xe0017a60     0xec    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0017a64     0xf0    add sp, sp, #8
    0xe0017a68     0xf4    bx lr
    0xe0017a6c     0xf8    ldr r5, [sp, #32]     ; stack access
    0xe0017a70     0xfc    cmp r5, #0
    0xe0017a74    0x100    beq e0017b28 <decodeIRQHandlerInvocation+0x1b4>
    0xe0017a78    0x104    ldr r6, [r5]
    0xe0017a7c    0x108    and r3, r6, #14
    0xe0017a80    0x10c    cmp r3, #14
    0xe0017a84    0x110    andne r3, r6, #15
    0xe0017a88    0x114    uxtbeq r3, r6
    0xe0017a8c    0x118    cmp r3, #6
    0xe0017a90    0x11c    bne e0017afc <decodeIRQHandlerInvocation+0x188>
    0xe0017a94    0x120    ldr r7, [r5, #4]
    0xe0017a98    0x124    tst r7, #1
    0xe0017a9c    0x128    beq e0017afc <decodeIRQHandlerInvocation+0x188>
    0xe0017aa0    0x12c    movw r3, #13900 
    0xe0017aa4    0x130    movt r3, #57347 
    0xe0017aa8    0x134    ldr r2, [r3]
    0xe0017aac    0x138    ldr r3, [r2, #80] 
    0xe0017ab0    0x13c    mov r0, r2
    0xe0017ab4    0x140    bic r3, r3, #15
    0xe0017ab8    0x144    orr r3, r3, #2
    0xe0017abc    0x148    str r3, [r2, #80] 
    0xe0017ac0    0x14c    bl e0013114 <setThreadState.part.166>
    0xe0017ac4    0x150    movw r3, #8192 
    0xe0017ac8    0x154    movt r3, #57347 
    0xe0017acc    0x158    str r6, [sp]          ; stack access
    0xe0017ad0    0x15c    add r4, r3, r4, lsl #4
    0xe0017ad4    0x160    str r7, [sp, #4]      ; stack access
    0xe0017ad8    0x164    mov r0, r4
    0xe0017adc    0x168    bl e00173d0 <cteDeleteOne>
    0xe0017ae0    0x16c    add r1, sp, #8
    0xe0017ae4    0x170    mov r3, r4
    0xe0017ae8    0x174    mov r2, r5
    0xe0017aec    0x178    ldmdb r1, {r0, r1}    ; stack access
    0xe0017af0    0x17c    bl e0013308 <cteInsert>
    0xe0017af4    0x180    mov r0, #0
    0xe0017af8    0x184    b e00179b8 <decodeIRQHandlerInvocation+0x44>
    0xe0017afc    0x188    movw r3, #36896 
    0xe0017b00    0x18c    movt r3, #57346 
    0xe0017b04    0x190    mov r1, #2
    0xe0017b08    0x194    mov r2, #0
    0xe0017b0c    0x198    mov r0, #3
    0xe0017b10    0x19c    str r1, [r3, #24]
    0xe0017b14    0x1a0    str r2, [r3, #4]
    0xe0017b18    0x1a4    add sp, sp, #12
    0xe0017b1c    0x1a8    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0017b20    0x1ac    add sp, sp, #8
    0xe0017b24    0x1b0    bx lr
    0xe0017b28    0x1b4    movw r3, #36896 
    0xe0017b2c    0x1b8    movt r3, #57346 
    0xe0017b30    0x1bc    mov r2, #7
    0xe0017b34    0x1c0    mov r0, #3
    0xe0017b38    0x1c4    str r2, [r3, #24]
    0xe0017b3c    0x1c8    b e00179b8 <decodeIRQHandlerInvocation+0x44>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
115 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeIRQHandlerInvocation` has 167 nodes.

Section handleInterruptEntry (255 of 299)
=========================================

Deriving specifications
-----------------------

Section `handleInterruptEntry` consists of 23 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleInterruptEntry`:

    0xe00178b4     0x0    movw r3, #46264 
    0xe00178b8     0x4    movt r3, #57345 
    0xe00178bc     0x8    push {r4, lr}         ; stack access
    0xe00178c0     0xc    ldr r0, [r3]
    0xe00178c4    0x10    ubfx r0, r0, #0, #10
    0xe00178c8    0x14    cmp r0, #1020 
    0xe00178cc    0x18    bcc e00178fc <handleInterruptEntry+0x48>
    0xe00178d0    0x1c    movw r2, #8703 
    0xe00178d4    0x20    movt r2, #65520 
    0xe00178d8    0x24    ldr r2, [r2, #-243] 
    0xe00178dc    0x28    ubfx r0, r2, #0, #10
    0xe00178e0    0x2c    cmp r0, #1020 
    0xe00178e4    0x30    str r2, [r3]
    0xe00178e8    0x34    bcc e00178fc <handleInterruptEntry+0x48>
    0xe00178ec    0x38    bl e00165a8 <schedule>
    0xe00178f0    0x3c    bl e001319c <activateThread>
    0xe00178f4    0x40    mov r0, #0
    0xe00178f8    0x44    pop {r4, pc}          ; stack access
    0xe00178fc    0x48    ldr r3, [r3, #4]
    0xe0017900    0x4c    cmp r3, r0
    0xe0017904    0x50    beq e00178ec <handleInterruptEntry+0x38>
    0xe0017908    0x54    bl e001771c <handleInterrupt>
    0xe001790c    0x58    b e00178ec <handleInterruptEntry+0x38>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInterruptEntry` has 38 nodes.

Section handleInterrupt (256 of 299)
====================================

Deriving specifications
-----------------------

Section `handleInterrupt` consists of 102 instructions.
Switch found.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleInterrupt`:

    0xe001771c      0x0    cmp r0, #159 
    0xe0017720      0x4    bhi e0017840 <handleInterrupt+0x124>
    0xe0017724      0x8    movw r3, #36936 
    0xe0017728      0xc    movt r3, #57346 
    0xe001772c     0x10    push {r4, lr}         ; stack access
    0xe0017730     0x14    mov r4, r0
    0xe0017734     0x18    ldr r3, [r3, r0, lsl #2]
    0xe0017738     0x1c    cmp r3, #3
    0xe001773c     0x20    ldrls pc, [pc, r3, lsl #2]
    0xe0017740     0x24    b e00178b0 <handleInterrupt+0x194>
    0xe0017744     0x28    .word 0xe0017818
    0xe0017748     0x2c    .word 0xe00177d8
    0xe001774c     0x30    .word 0xe0017754
    0xe0017750     0x34    .word 0xe0017768
    0xe0017754     0x38    bl e0013264 <timerTick>
    0xe0017758     0x3c    movw r3, #9983 
    0xe001775c     0x40    movt r3, #65520 
    0xe0017760     0x44    mov r2, #1
    0xe0017764     0x48    str r2, [r3, #-243] 
    0xe0017768     0x4c    lsr r2, r4, #4
    0xe001776c     0x50    movw r1, #4351 
    0xe0017770     0x54    add r2, r2, #768 
    0xe0017774     0x58    movt r1, #65520 
    0xe0017778     0x5c    and r3, r4, #15
    0xe001777c     0x60    add r2, r1, r2, lsl #2
    0xe0017780     0x64    lsl r3, r3, #1
    0xe0017784     0x68    ldr r2, [r2, #-255] 
    0xe0017788     0x6c    add r3, r3, #1
    0xe001778c     0x70    lsr r3, r2, r3
    0xe0017790     0x74    tst r3, #1
    0xe0017794     0x78    beq e00177b4 <handleInterrupt+0x98>
    0xe0017798     0x7c    lsr r3, r4, #5
    0xe001779c     0x80    mov r0, #1
    0xe00177a0     0x84    add r3, r3, #160 
    0xe00177a4     0x88    and r4, r4, #31
    0xe00177a8     0x8c    lsl r4, r0, r4
    0xe00177ac     0x90    add r1, r1, r3, lsl #2
    0xe00177b0     0x94    str r4, [r1, #-255] 
    0xe00177b4     0x98    movw r3, #46264 
    0xe00177b8     0x9c    movt r3, #57345 
    0xe00177bc     0xa0    movw r2, #8703 
    0xe00177c0     0xa4    movt r2, #65520 
    0xe00177c4     0xa8    ldr r0, [r3]
    0xe00177c8     0xac    movw r1, #1023 
    0xe00177cc     0xb0    str r0, [r2, #-239] 
    0xe00177d0     0xb4    str r1, [r3]
    0xe00177d4     0xb8    pop {r4, pc}          ; stack access
    0xe00177d8     0xbc    movw r3, #8192 
    0xe00177dc     0xc0    movt r3, #57347 
    0xe00177e0     0xc4    add r2, r3, r0, lsl #4
    0xe00177e4     0xc8    ldr r0, [r3, r0, lsl #4]
    0xe00177e8     0xcc    and r3, r0, #14
    0xe00177ec     0xd0    cmp r3, #14
    0xe00177f0     0xd4    andne r3, r0, #15
    0xe00177f4     0xd8    uxtbeq r3, r0
    0xe00177f8     0xdc    cmp r3, #6
    0xe00177fc     0xe0    bne e0017818 <handleInterrupt+0xfc>
    0xe0017800     0xe4    ldr r1, [r2, #4]
    0xe0017804     0xe8    tst r1, #1
    0xe0017808     0xec    beq e0017818 <handleInterrupt+0xfc>
    0xe001780c     0xf0    lsr r1, r1, #4
    0xe0017810     0xf4    bic r0, r0, #15
    0xe0017814     0xf8    bl e00175d8 <sendSignal>
    0xe0017818     0xfc    lsr r3, r4, #5
    0xe001781c    0x100    movw r2, #4735 
    0xe0017820    0x104    movt r2, #65520 
    0xe0017824    0x108    and r0, r4, #31
    0xe0017828    0x10c    lsl r3, r3, #2
    0xe001782c    0x110    mov r1, #1
    0xe0017830    0x114    add r2, r3, r2
    0xe0017834    0x118    lsl r3, r1, r0
    0xe0017838    0x11c    str r3, [r2, #-255] 
    0xe001783c    0x120    b e0017768 <handleInterrupt+0x4c>
    0xe0017840    0x124    lsr r3, r0, #5
    0xe0017844    0x128    lsr r1, r0, #4
    0xe0017848    0x12c    movw r2, #7423 
    0xe001784c    0x130    movt r2, #65520 
    0xe0017850    0x134    lsl r1, r1, #2
    0xe0017854    0x138    lsl r3, r3, #2
    0xe0017858    0x13c    sub r3, r3, #1044480 
    0xe001785c    0x140    add r2, r1, r2
    0xe0017860    0x144    and ip, r0, #31
    0xe0017864    0x148    mov r1, #1
    0xe0017868    0x14c    and r0, r0, #15
    0xe001786c    0x150    lsl r1, r1, ip
    0xe0017870    0x154    str r1, [r3, #384] 
    0xe0017874    0x158    ldr r2, [r2, #-255] 
    0xe0017878    0x15c    lsl r0, r0, #1
    0xe001787c    0x160    add r0, r0, #1
    0xe0017880    0x164    lsr r0, r2, r0
    0xe0017884    0x168    movw r2, #8703 
    0xe0017888    0x16c    tst r0, #1
    0xe001788c    0x170    strne r1, [r3, #640] 
    0xe0017890    0x174    movw r3, #46264 
    0xe0017894    0x178    movt r3, #57345 
    0xe0017898    0x17c    movt r2, #65520 
    0xe001789c    0x180    movw r1, #1023 
    0xe00178a0    0x184    ldr r0, [r3]
    0xe00178a4    0x188    str r0, [r2, #-239] 
    0xe00178a8    0x18c    str r1, [r3]
    0xe00178ac    0x190    bx lr
    0xe00178b0    0x194    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
98 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInterrupt` has 147 nodes.

Section sendSignal (257 of 299)
===============================

Deriving specifications
-----------------------

Section `sendSignal` consists of 81 instructions.


Stack analysis
---------------

8 stack accesses found. Annotated code for `sendSignal`:

    0xe00175d8      0x0    ldr r3, [r0]
    0xe00175dc      0x4    push {r4, r5, lr}     ; stack access
    0xe00175e0      0x8    and r2, r3, #3
    0xe00175e4      0xc    cmp r2, #1
    0xe00175e8     0x10    sub sp, sp, #12
    0xe00175ec     0x14    beq e0017640 <sendSignal+0x68>
    0xe00175f0     0x18    bcc e001760c <sendSignal+0x34>
    0xe00175f4     0x1c    cmp r2, #2
    0xe00175f8     0x20    ldreq r3, [r0, #8]
    0xe00175fc     0x24    orreq r1, r3, r1
    0xe0017600     0x28    streq r1, [r0, #8]
    0xe0017604     0x2c    add sp, sp, #12
    0xe0017608     0x30    pop {r4, r5, pc}      ; stack access
    0xe001760c     0x34    ldr r2, [r0, #12]
    0xe0017610     0x38    bics r4, r2, #15
    0xe0017614     0x3c    beq e0017628 <sendSignal+0x50>
    0xe0017618     0x40    ldr r2, [r4, #80] 
    0xe001761c     0x44    and r2, r2, #15
    0xe0017620     0x48    cmp r2, #3
    0xe0017624     0x4c    beq e00176d0 <sendSignal+0xf8>
    0xe0017628     0x50    bic r3, r3, #3
    0xe001762c     0x54    str r1, [r0, #8]
    0xe0017630     0x58    orr r3, r3, #2
    0xe0017634     0x5c    str r3, [r0]
    0xe0017638     0x60    add sp, sp, #12
    0xe001763c     0x64    pop {r4, r5, pc}      ; stack access
    0xe0017640     0x68    ldr ip, [r0, #4]
    0xe0017644     0x6c    bic r4, ip, #15
    0xe0017648     0x70    and ip, ip, #15
    0xe001764c     0x74    ldr r2, [r4, #148] 
    0xe0017650     0x78    ldr lr, [r4, #144] 
    0xe0017654     0x7c    cmp r2, #0
    0xe0017658     0x80    strne lr, [r2, #144] 
    0xe001765c     0x84    moveq r5, lr
    0xe0017660     0x88    ldrne r5, [r4, #144] 
    0xe0017664     0x8c    movne lr, r4
    0xe0017668     0x90    cmp r5, #0
    0xe001766c     0x94    strne r2, [r5, #148] 
    0xe0017670     0x98    bicne r2, r3, #15
    0xe0017674     0x9c    bic r2, r2, #15
    0xe0017678     0xa0    and r3, r3, #15
    0xe001767c     0xa4    orr r3, r3, r2
    0xe0017680     0xa8    movw r2, #13900 
    0xe0017684     0xac    movt r2, #57347 
    0xe0017688     0xb0    cmp lr, #0
    0xe001768c     0xb4    bic lr, lr, #15
    0xe0017690     0xb8    biceq r3, r3, #3
    0xe0017694     0xbc    ldr r2, [r2]
    0xe0017698     0xc0    orr ip, ip, lr
    0xe001769c     0xc4    str r3, [r0]
    0xe00176a0     0xc8    str ip, [r0, #4]
    0xe00176a4     0xcc    cmp r4, r2
    0xe00176a8     0xd0    ldr r3, [r4, #80] 
    0xe00176ac     0xd4    bic r3, r3, #15
    0xe00176b0     0xd8    orr r3, r3, #1
    0xe00176b4     0xdc    str r3, [r4, #80] 
    0xe00176b8     0xe0    beq e0017714 <sendSignal+0x13c>
    0xe00176bc     0xe4    str r1, [r4]
    0xe00176c0     0xe8    mov r0, r4
    0xe00176c4     0xec    add sp, sp, #12
    0xe00176c8     0xf0    pop {r4, r5, lr}      ; stack access
    0xe00176cc     0xf4    b e00131ec <possibleSwitchTo>
    0xe00176d0     0xf8    mov r0, r4
    0xe00176d4     0xfc    str r1, [sp, #4]      ; stack access
    0xe00176d8    0x100    bl e0017438 <cancelIPC>
    0xe00176dc    0x104    movw r2, #13900 
    0xe00176e0    0x108    movt r2, #57347 
    0xe00176e4    0x10c    ldr r3, [r4, #80] 
    0xe00176e8    0x110    ldr r1, [sp, #4]      ; stack access
    0xe00176ec    0x114    ldr r2, [r2]
    0xe00176f0    0x118    bic r3, r3, #15
    0xe00176f4    0x11c    orr r3, r3, #1
    0xe00176f8    0x120    str r3, [r4, #80] 
    0xe00176fc    0x124    cmp r4, r2
    0xe0017700    0x128    bne e00176bc <sendSignal+0xe4>
    0xe0017704    0x12c    mov r0, r4
    0xe0017708    0x130    bl e0013114 <setThreadState.part.166>
    0xe001770c    0x134    ldr r1, [sp, #4]      ; stack access
    0xe0017710    0x138    b e00176bc <sendSignal+0xe4>
    0xe0017714    0x13c    str r1, [sp, #4]      ; stack access
    0xe0017718    0x140    b e0017704 <sendSignal+0x12c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
81 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendSignal` has 146 nodes.

Section cancelIPC (258 of 299)
==============================

Deriving specifications
-----------------------

Section `cancelIPC` consists of 55 instructions.
Switch found.


Stack analysis
---------------

3 stack accesses found. Annotated code for `cancelIPC`:

    0xe0017438     0x0    ldr r1, [r0, #80] 
    0xe001743c     0x4    and r3, r1, #15
    0xe0017440     0x8    sub r3, r3, #3
    0xe0017444     0xc    cmp r3, #3
    0xe0017448    0x10    ldrls pc, [pc, r3, lsl #2]
    0xe001744c    0x14    b e0017510 <cancelIPC+0xd8>
    0xe0017450    0x18    .word 0xe001748c
    0xe0017454    0x1c    .word 0xe001748c
    0xe0017458    0x20    .word 0xe0017468
    0xe001745c    0x24    .word 0xe0017460
    0xe0017460    0x28    bic r1, r1, #15
    0xe0017464    0x2c    b e0014148 <cancelSignal>
    0xe0017468    0x30    bic r3, r0, #508 
    0xe001746c    0x34    mov r2, #0
    0xe0017470    0x38    bic r3, r3, #3
    0xe0017474    0x3c    str r2, [r0, #96] 
    0xe0017478    0x40    str r2, [r0, #100] 
    0xe001747c    0x44    ldr r0, [r3, #44] 
    0xe0017480    0x48    bics r0, r0, #7
    0xe0017484    0x4c    bxeq lr
    0xe0017488    0x50    b e00173d0 <cteDeleteOne>
    0xe001748c    0x54    ldr r3, [r0, #148] 
    0xe0017490    0x58    bic r1, r1, #15
    0xe0017494    0x5c    push {r4, lr}         ; stack access
    0xe0017498    0x60    cmp r3, #0
    0xe001749c    0x64    ldr r4, [r0, #144] 
    0xe00174a0    0x68    ldm r1, {r2, ip}
    0xe00174a4    0x6c    strne r4, [r3, #144] 
    0xe00174a8    0x70    bicne lr, ip, #15
    0xe00174ac    0x74    ldrne r4, [r0, #144] 
    0xe00174b0    0x78    moveq lr, r4
    0xe00174b4    0x7c    and ip, ip, #15
    0xe00174b8    0x80    cmp r4, #0
    0xe00174bc    0x84    strne r3, [r4, #148] 
    0xe00174c0    0x88    bicne r3, r2, #15
    0xe00174c4    0x8c    bic r3, r3, #15
    0xe00174c8    0x90    and r2, r2, #15
    0xe00174cc    0x94    orr r3, r2, r3
    0xe00174d0    0x98    movw r2, #13900 
    0xe00174d4    0x9c    movt r2, #57347 
    0xe00174d8    0xa0    cmp lr, #0
    0xe00174dc    0xa4    bic lr, lr, #15
    0xe00174e0    0xa8    biceq r3, r3, #3
    0xe00174e4    0xac    ldr r2, [r2]
    0xe00174e8    0xb0    orr ip, ip, lr
    0xe00174ec    0xb4    str r3, [r1]
    0xe00174f0    0xb8    str ip, [r1, #4]
    0xe00174f4    0xbc    cmp r0, r2
    0xe00174f8    0xc0    ldr r3, [r0, #80] 
    0xe00174fc    0xc4    bic r3, r3, #15
    0xe0017500    0xc8    str r3, [r0, #80] 
    0xe0017504    0xcc    popne {r4, pc}        ; stack access
    0xe0017508    0xd0    pop {r4, lr}          ; stack access
    0xe001750c    0xd4    b e0013114 <setThreadState.part.166>
    0xe0017510    0xd8    bx lr

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
51 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelIPC` has 105 nodes.

Section cteDeleteOne (259 of 299)
=================================

Deriving specifications
-----------------------

Section `cteDeleteOne` consists of 26 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `cteDeleteOne`:

    0xe00173d0     0x0    ldr r3, [r0]
    0xe00173d4     0x4    and r2, r3, #14
    0xe00173d8     0x8    cmp r2, #14
    0xe00173dc     0xc    andne r3, r3, #15
    0xe00173e0    0x10    uxtbeq r3, r3
    0xe00173e4    0x14    cmp r3, #0
    0xe00173e8    0x18    bxeq lr
    0xe00173ec    0x1c    push {r4, lr}         ; stack access
    0xe00173f0    0x20    sub sp, sp, #32
    0xe00173f4    0x24    mov r4, r0
    0xe00173f8    0x28    bl e0014d44 <isFinalCapability>
    0xe00173fc    0x2c    ldm r4, {r1, r2}
    0xe0017400    0x30    mov r3, #1
    0xe0017404    0x34    str r3, [sp]          ; stack access
    0xe0017408    0x38    mov r3, r0
    0xe001740c    0x3c    add r0, sp, #16
    0xe0017410    0x40    bl e0016810 <finaliseCap>
    0xe0017414    0x44    add r3, sp, #8
    0xe0017418    0x48    mov r2, #0
    0xe001741c    0x4c    mov r0, r4
    0xe0017420    0x50    str r2, [sp, #8]      ; stack access
    0xe0017424    0x54    str r2, [sp, #12]     ; stack access
    0xe0017428    0x58    ldm r3, {r1, r2}      ; stack access
    0xe001742c    0x5c    add sp, sp, #32
    0xe0017430    0x60    pop {r4, lr}          ; stack access
    0xe0017434    0x64    b e0010928 <emptySlot>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
26 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteDeleteOne` has 44 nodes.

Section cteRevoke (260 of 299)
==============================

Deriving specifications
-----------------------

Section `cteRevoke` consists of 34 instructions.
 LDMIANE (wb);15,6,5,4..++


Stack analysis
---------------

4 stack accesses found. Annotated code for `cteRevoke`:

    0xe0016cc0     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0016cc4     0x4    ldr r4, [r0, #12]
    0xe0016cc8     0x8    bics r4, r4, #7
    0xe0016ccc     0xc    beq e0016d40 <cteRevoke+0x80>
    0xe0016cd0    0x10    movw r6, #12804 
    0xe0016cd4    0x14    mov r5, r0
    0xe0016cd8    0x18    movt r6, #57347 
    0xe0016cdc    0x1c    b e0016cec <cteRevoke+0x2c>
    0xe0016ce0    0x20    ldr r4, [r5, #12]
    0xe0016ce4    0x24    bics r4, r4, #7
    0xe0016ce8    0x28    beq e0016d40 <cteRevoke+0x80>
    0xe0016cec    0x2c    mov r1, r4
    0xe0016cf0    0x30    mov r0, r5
    0xe0016cf4    0x34    bl e0014b14 <isMDBParentOf>
    0xe0016cf8    0x38    mov r1, #1
    0xe0016cfc    0x3c    cmp r0, #0
    0xe0016d00    0x40    mov r0, r4
    0xe0016d04    0x44    beq e0016d40 <cteRevoke+0x80>
    0xe0016d08    0x48    bl e0016a68 <cteDelete>
    0xe0016d0c    0x4c    cmp r0, #0
    0xe0016d10    0x50    popne {r4, r5, r6, pc}  ; stack access
    0xe0016d14    0x54    ldr r3, [r6]
    0xe0016d18    0x58    add r3, r3, #1
    0xe0016d1c    0x5c    str r3, [r6]
    0xe0016d20    0x60    cmp r3, #99 
    0xe0016d24    0x64    bls e0016ce0 <cteRevoke+0x20>
    0xe0016d28    0x68    bl e00107a8 <preemptionPoint.part.161>
    0xe0016d2c    0x6c    cmp r0, #0
    0xe0016d30    0x70    popne {r4, r5, r6, pc}  ; stack access
    0xe0016d34    0x74    ldr r4, [r5, #12]
    0xe0016d38    0x78    bics r4, r4, #7
    0xe0016d3c    0x7c    bne e0016cec <cteRevoke+0x2c>
    0xe0016d40    0x80    mov r0, #0
    0xe0016d44    0x84    pop {r4, r5, r6, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
34 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteRevoke` has 60 nodes.

Section suspend (261 of 299)
============================

Deriving specifications
-----------------------

Section `suspend` consists of 23 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `suspend`:

    0xe00167b4     0x0    push {r4, lr}         ; stack access
    0xe00167b8     0x4    mov r4, r0
    0xe00167bc     0x8    bl e0017438 <cancelIPC>
    0xe00167c0     0xc    ldr r3, [r4, #80] 
    0xe00167c4    0x10    and r2, r3, #15
    0xe00167c8    0x14    bic r3, r3, #15
    0xe00167cc    0x18    cmp r2, #1
    0xe00167d0    0x1c    str r3, [r4, #80] 
    0xe00167d4    0x20    ldreq r2, [r4, #60] 
    0xe00167d8    0x24    streq r2, [r4, #68] 
    0xe00167dc    0x28    movw r2, #13900 
    0xe00167e0    0x2c    movt r2, #57347 
    0xe00167e4    0x30    ldr r3, [r2]
    0xe00167e8    0x34    cmp r4, r3
    0xe00167ec    0x38    beq e00167fc <suspend+0x48>
    0xe00167f0    0x3c    mov r0, r4
    0xe00167f4    0x40    pop {r4, lr}          ; stack access
    0xe00167f8    0x44    b e0016384 <tcbSchedDequeue>
    0xe00167fc    0x48    mov r0, r4
    0xe0016800    0x4c    bl e0013114 <setThreadState.part.166>
    0xe0016804    0x50    mov r0, r4
    0xe0016808    0x54    pop {r4, lr}          ; stack access
    0xe001680c    0x58    b e0016384 <tcbSchedDequeue>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
23 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `suspend` has 41 nodes.

Section setPriority (262 of 299)
================================

Deriving specifications
-----------------------

Section `setPriority` consists of 18 instructions.
 LDMIAHI (wb);15,6,5,4..++


Stack analysis
---------------

4 stack accesses found. Annotated code for `setPriority`:

    0xe001676c     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0016770     0x4    mov r5, r1
    0xe0016774     0x8    bl e0016384 <tcbSchedDequeue>
    0xe0016778     0xc    ldr r3, [r0, #80] 
    0xe001677c    0x10    str r5, [r0, #120] 
    0xe0016780    0x14    and r3, r3, #15
    0xe0016784    0x18    sub r3, r3, #1
    0xe0016788    0x1c    cmp r3, #1
    0xe001678c    0x20    pophi {r4, r5, r6, pc}  ; stack access
    0xe0016790    0x24    movw r3, #13900 
    0xe0016794    0x28    movt r3, #57347 
    0xe0016798    0x2c    ldr r3, [r3]
    0xe001679c    0x30    cmp r0, r3
    0xe00167a0    0x34    beq e00167ac <setPriority+0x40>
    0xe00167a4    0x38    pop {r4, r5, r6, lr}  ; stack access
    0xe00167a8    0x3c    b e00131ec <possibleSwitchTo>
    0xe00167ac    0x40    pop {r4, r5, r6, lr}  ; stack access
    0xe00167b0    0x44    b e0013098 <rescheduleRequired>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setPriority` has 32 nodes.

Section setDomain (263 of 299)
==============================

Deriving specifications
-----------------------

Section `setDomain` consists of 22 instructions.


Stack analysis
---------------

3 stack accesses found. Annotated code for `setDomain`:

    0xe0016714     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0016718     0x4    mov r5, r1
    0xe001671c     0x8    mov r4, r0
    0xe0016720     0xc    bl e0016384 <tcbSchedDequeue>
    0xe0016724    0x10    ldr r3, [r0, #80] 
    0xe0016728    0x14    str r5, [r0, #112] 
    0xe001672c    0x18    and r3, r3, #15
    0xe0016730    0x1c    sub r3, r3, #1
    0xe0016734    0x20    cmp r3, #1
    0xe0016738    0x24    bhi e0016748 <setDomain+0x34>
    0xe001673c    0x28    ldr r3, [r0, #84] 
    0xe0016740    0x2c    tst r3, #1
    0xe0016744    0x30    beq e0016764 <setDomain+0x50>
    0xe0016748    0x34    movw r3, #13900 
    0xe001674c    0x38    movt r3, #57347 
    0xe0016750    0x3c    ldr r3, [r3]
    0xe0016754    0x40    cmp r3, r4
    0xe0016758    0x44    popne {r4, r5, r6, pc}  ; stack access
    0xe001675c    0x48    pop {r4, r5, r6, lr}  ; stack access
    0xe0016760    0x4c    b e0013098 <rescheduleRequired>
    0xe0016764    0x50    bl e00107d8 <tcbSchedEnqueue.part.164>
    0xe0016768    0x54    b e0016748 <setDomain+0x34>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
22 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `setDomain` has 38 nodes.

Section cancelAllSignals (264 of 299)
=====================================

Deriving specifications
-----------------------

Section `cancelAllSignals` consists of 38 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `cancelAllSignals`:

    0xe00140b0     0x0    ldr r3, [r0]
    0xe00140b4     0x4    and r2, r3, #3
    0xe00140b8     0x8    cmp r2, #1
    0xe00140bc     0xc    bxne lr
    0xe00140c0    0x10    ldr r2, [r0, #4]
    0xe00140c4    0x14    and r3, r3, #12
    0xe00140c8    0x18    push {r4, r5, r6, lr}  ; stack access
    0xe00140cc    0x1c    bics r4, r2, #15
    0xe00140d0    0x20    str r3, [r0]
    0xe00140d4    0x24    and r2, r2, #15
    0xe00140d8    0x28    str r2, [r0, #4]
    0xe00140dc    0x2c    beq e0014134 <cancelAllSignals+0x84>
    0xe00140e0    0x30    movw r5, #13900 
    0xe00140e4    0x34    movt r5, #57347 
    0xe00140e8    0x38    b e00140f8 <cancelAllSignals+0x48>
    0xe00140ec    0x3c    ldr r4, [r4, #144] 
    0xe00140f0    0x40    cmp r4, #0
    0xe00140f4    0x44    beq e0014134 <cancelAllSignals+0x84>
    0xe00140f8    0x48    ldr r2, [r5]
    0xe00140fc    0x4c    ldr r3, [r4, #80] 
    0xe0014100    0x50    cmp r2, r4
    0xe0014104    0x54    bic r3, r3, #15
    0xe0014108    0x58    orr r3, r3, #2
    0xe001410c    0x5c    str r3, [r4, #80] 
    0xe0014110    0x60    beq e001413c <cancelAllSignals+0x8c>
    0xe0014114    0x64    ldr r3, [r4, #84] 
    0xe0014118    0x68    tst r3, #1
    0xe001411c    0x6c    bne e00140ec <cancelAllSignals+0x3c>
    0xe0014120    0x70    mov r0, r4
    0xe0014124    0x74    bl e00107d8 <tcbSchedEnqueue.part.164>
    0xe0014128    0x78    ldr r4, [r4, #144] 
    0xe001412c    0x7c    cmp r4, #0
    0xe0014130    0x80    bne e00140f8 <cancelAllSignals+0x48>
    0xe0014134    0x84    pop {r4, r5, r6, lr}  ; stack access
    0xe0014138    0x88    b e0013098 <rescheduleRequired>
    0xe001413c    0x8c    mov r0, r4
    0xe0014140    0x90    bl e0013114 <setThreadState.part.166>
    0xe0014144    0x94    b e0014114 <cancelAllSignals+0x64>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
38 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelAllSignals` has 66 nodes.

Section Arch_decodeIRQControlInvocation (265 of 299)
====================================================

Deriving specifications
-----------------------

Section `Arch_decodeIRQControlInvocation` consists of 115 instructions.
 STMIA;14,8...+


Stack analysis
---------------

12 stack accesses found. Annotated code for `Arch_decodeIRQControlInvocation`:

    0xe0013ba0      0x0    sub sp, sp, #8
    0xe0013ba4      0x4    cmp r0, #45 
    0xe0013ba8      0x8    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0013bac      0xc    sub sp, sp, #24
    0xe0013bb0     0x10    str r3, [sp, #52]     ; stack access
    0xe0013bb4     0x14    bne e0013bf0 <Arch_decodeIRQControlInvocation+0x50>
    0xe0013bb8     0x18    cmp r3, #0
    0xe0013bbc     0x1c    cmpne r1, #3
    0xe0013bc0     0x20    movls r1, #1
    0xe0013bc4     0x24    movhi r1, #0
    0xe0013bc8     0x28    bhi e0013c14 <Arch_decodeIRQControlInvocation+0x74>
    0xe0013bcc     0x2c    movw r3, #36896 
    0xe0013bd0     0x30    movt r3, #57346 
    0xe0013bd4     0x34    mov r0, #3
    0xe0013bd8     0x38    mov r2, #7
    0xe0013bdc     0x3c    str r2, [r3, #24]
    0xe0013be0     0x40    add sp, sp, #24
    0xe0013be4     0x44    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0013be8     0x48    add sp, sp, #8
    0xe0013bec     0x4c    bx lr
    0xe0013bf0     0x50    movw r3, #36896 
    0xe0013bf4     0x54    movt r3, #57346 
    0xe0013bf8     0x58    mov r2, #3
    0xe0013bfc     0x5c    mov r0, r2
    0xe0013c00     0x60    str r2, [r3, #24]
    0xe0013c04     0x64    add sp, sp, #24
    0xe0013c08     0x68    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0013c0c     0x6c    add sp, sp, #8
    0xe0013c10     0x70    bx lr
    0xe0013c14     0x74    movw r5, #13900 
    0xe0013c18     0x78    movt r5, #57347 
    0xe0013c1c     0x7c    ldr ip, [r5]
    0xe0013c20     0x80    ldr r6, [ip, #8]
    0xe0013c24     0x84    cmp r6, #159 
    0xe0013c28     0x88    bhi e0013c64 <Arch_decodeIRQControlInvocation+0xc4>
    0xe0013c2c     0x8c    movw r1, #36936 
    0xe0013c30     0x90    movt r1, #57346 
    0xe0013c34     0x94    ldr r1, [r1, r6, lsl #2]
    0xe0013c38     0x98    cmp r1, #0
    0xe0013c3c     0x9c    beq e0013c88 <Arch_decodeIRQControlInvocation+0xe8>
    0xe0013c40     0xa0    movw r3, #36896 
    0xe0013c44     0xa4    movt r3, #57346 
    0xe0013c48     0xa8    mov r2, #9
    0xe0013c4c     0xac    mov r0, #3
    0xe0013c50     0xb0    str r2, [r3, #24]
    0xe0013c54     0xb4    add sp, sp, #24
    0xe0013c58     0xb8    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0013c5c     0xbc    add sp, sp, #8
    0xe0013c60     0xc0    bx lr
    0xe0013c64     0xc4    movw r3, #36896 
    0xe0013c68     0xc8    movt r3, #57346 
    0xe0013c6c     0xcc    mov ip, #4
    0xe0013c70     0xd0    mov r2, #159 
    0xe0013c74     0xd4    str r1, [r3, #8]
    0xe0013c78     0xd8    mov r0, #3
    0xe0013c7c     0xdc    str ip, [r3, #24]
    0xe0013c80     0xe0    str r2, [r3, #12]
    0xe0013c84     0xe4    b e0013be0 <Arch_decodeIRQControlInvocation+0x40>
    0xe0013c88     0xe8    mov r4, r2
    0xe0013c8c     0xec    ldr r2, [r3, #4]
    0xe0013c90     0xf0    ldr r3, [r3]
    0xe0013c94     0xf4    add r0, sp, #8
    0xe0013c98     0xf8    ldr r8, [ip, #16]
    0xe0013c9c     0xfc    ldr lr, [ip, #20]
    0xe0013ca0    0x100    str r3, [sp, #16]     ; stack access
    0xe0013ca4    0x104    add r3, sp, #24
    0xe0013ca8    0x108    str r2, [sp, #20]     ; stack access
    0xe0013cac    0x10c    ldr r7, [ip, #12]
    0xe0013cb0    0x110    ldmdb r3, {r2, r3}    ; stack access
    0xe0013cb4    0x114    stm sp, {r8, lr}      ; stack access
    0xe0013cb8    0x118    bl e0012e24 <lookupSlotForCNodeOp>
    0xe0013cbc    0x11c    ldr r0, [sp, #8]      ; stack access
    0xe0013cc0    0x120    cmp r0, #0
    0xe0013cc4    0x124    bne e0013be0 <Arch_decodeIRQControlInvocation+0x40>
    0xe0013cc8    0x128    ldr r8, [sp, #12]     ; stack access
    0xe0013ccc    0x12c    ldr r3, [r8]
    0xe0013cd0    0x130    and r2, r3, #14
    0xe0013cd4    0x134    cmp r2, #14
    0xe0013cd8    0x138    andne r3, r3, #15
    0xe0013cdc    0x13c    uxtbeq r3, r3
    0xe0013ce0    0x140    cmp r3, #0
    0xe0013ce4    0x144    beq e0013d00 <Arch_decodeIRQControlInvocation+0x160>
    0xe0013ce8    0x148    movw r3, #36896 
    0xe0013cec    0x14c    movt r3, #57346 
    0xe0013cf0    0x150    mov r2, #8
    0xe0013cf4    0x154    mov r0, #3
    0xe0013cf8    0x158    str r2, [r3, #24]
    0xe0013cfc    0x15c    b e0013be0 <Arch_decodeIRQControlInvocation+0x40>
    0xe0013d00    0x160    ldr r2, [r5]
    0xe0013d04    0x164    ldr r3, [r2, #80] 
    0xe0013d08    0x168    mov r0, r2
    0xe0013d0c    0x16c    bic r3, r3, #15
    0xe0013d10    0x170    orr r3, r3, #2
    0xe0013d14    0x174    str r3, [r2, #80] 
    0xe0013d18    0x178    bl e0013114 <setThreadState.part.166>
    0xe0013d1c    0x17c    and r3, r6, #15
    0xe0013d20    0x180    mov r1, #1
    0xe0013d24    0x184    lsr r2, r6, #4
    0xe0013d28    0x188    lsl r3, r3, r1
    0xe0013d2c    0x18c    cmp r7, #0
    0xe0013d30    0x190    add r3, r3, r1
    0xe0013d34    0x194    mov r0, r6
    0xe0013d38    0x198    lsl r1, r1, r3
    0xe0013d3c    0x19c    lsl r3, r2, #2
    0xe0013d40    0x1a0    sub r3, r3, #1044480 
    0xe0013d44    0x1a4    ldr r2, [r3, #3072] 
    0xe0013d48    0x1a8    orrne r1, r1, r2
    0xe0013d4c    0x1ac    biceq r1, r2, r1
    0xe0013d50    0x1b0    mov r2, r4
    0xe0013d54    0x1b4    str r1, [r3, #3072] 
    0xe0013d58    0x1b8    mov r1, r8
    0xe0013d5c    0x1bc    add sp, sp, #24
    0xe0013d60    0x1c0    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0013d64    0x1c4    add sp, sp, #8
    0xe0013d68    0x1c8    b e0013b3c <invokeIRQControl>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
115 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_decodeIRQControlInvocation` has 180 nodes.

Section cancelAllIPC (266 of 299)
=================================

Deriving specifications
-----------------------

Section `cancelAllIPC` consists of 37 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `cancelAllIPC`:

    0xe0013944     0x0    ldr r3, [r0]
    0xe0013948     0x4    tst r3, #3
    0xe001394c     0x8    bxeq lr
    0xe0013950     0xc    ldr r2, [r0, #4]
    0xe0013954    0x10    and r3, r3, #12
    0xe0013958    0x14    push {r4, r5, r6, lr}  ; stack access
    0xe001395c    0x18    bics r4, r2, #15
    0xe0013960    0x1c    str r3, [r0]
    0xe0013964    0x20    and r2, r2, #15
    0xe0013968    0x24    str r2, [r0, #4]
    0xe001396c    0x28    beq e00139c4 <cancelAllIPC+0x80>
    0xe0013970    0x2c    movw r5, #13900 
    0xe0013974    0x30    movt r5, #57347 
    0xe0013978    0x34    b e0013988 <cancelAllIPC+0x44>
    0xe001397c    0x38    ldr r4, [r4, #144] 
    0xe0013980    0x3c    cmp r4, #0
    0xe0013984    0x40    beq e00139c4 <cancelAllIPC+0x80>
    0xe0013988    0x44    ldr r2, [r5]
    0xe001398c    0x48    ldr r3, [r4, #80] 
    0xe0013990    0x4c    cmp r2, r4
    0xe0013994    0x50    bic r3, r3, #15
    0xe0013998    0x54    orr r3, r3, #2
    0xe001399c    0x58    str r3, [r4, #80] 
    0xe00139a0    0x5c    beq e00139cc <cancelAllIPC+0x88>
    0xe00139a4    0x60    ldr r3, [r4, #84] 
    0xe00139a8    0x64    tst r3, #1
    0xe00139ac    0x68    bne e001397c <cancelAllIPC+0x38>
    0xe00139b0    0x6c    mov r0, r4
    0xe00139b4    0x70    bl e00107d8 <tcbSchedEnqueue.part.164>
    0xe00139b8    0x74    ldr r4, [r4, #144] 
    0xe00139bc    0x78    cmp r4, #0
    0xe00139c0    0x7c    bne e0013988 <cancelAllIPC+0x44>
    0xe00139c4    0x80    pop {r4, r5, r6, lr}  ; stack access
    0xe00139c8    0x84    b e0013098 <rescheduleRequired>
    0xe00139cc    0x88    mov r0, r4
    0xe00139d0    0x8c    bl e0013114 <setThreadState.part.166>
    0xe00139d4    0x90    b e00139a4 <cancelAllIPC+0x60>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
37 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelAllIPC` has 65 nodes.

Section arm_swi_syscall (267 of 299)
====================================

Deriving specifications
-----------------------

Section `arm_swi_syscall` consists of 11 instructions.
Skipping f8cd0513 srsia sp, #19
Skipping e94d7fff stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
Skipping ee1ddf90 mrc 15, 0, sp, cr13, cr0, {4}


Stack analysis
---------------

1 stack accesses found. Annotated code for `arm_swi_syscall`:

    0xe001005c     0x0    srsia sp, #19
    0xe0010060     0x4    sub lr, lr, #4
    0xe0010064     0x8    str lr, [sp, #8]      ; stack access
    0xe0010068     0xc    stmdb sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, sp, lr}^
    0xe001006c    0x10    mrc 15, 0, sp, cr13, cr0, {4}
    0xe0010070    0x14    cmn r7, #1
    0xe0010074    0x18    beq e00101a0 <c_handle_fastpath_call>
    0xe0010078    0x1c    cmn r7, #2
    0xe001007c    0x20    beq e0010460 <c_handle_fastpath_reply_recv>
    0xe0010080    0x24    mov r2, r7
    0xe0010084    0x28    b e001072c <c_handle_syscall>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
11 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_swi_syscall` has 24 nodes.

Section create_initial_thread (268 of 299)
==========================================

Deriving specifications
-----------------------

Section `create_initial_thread` consists of 871 instructions.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Skipping e7f000f0 udf #0
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.
Switch found.


Stack analysis
---------------

34 stack accesses found. Annotated code for `create_initial_thread`:

    0xe0002fcc      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0002fd0      0x4    movw r7, #46848 
    0xe0002fd4      0x8    movt r7, #57345 
    0xe0002fd8      0xc    sub sp, sp, #44 
    0xe0002fdc     0x10    add sl, sp, #16
    0xe0002fe0     0x14    add r9, sp, #8
    0xe0002fe4     0x18    ldr fp, [r7, #168] 
    0xe0002fe8     0x1c    stm sl, {r0, r1}      ; stack access
    0xe0002fec     0x20    mov r1, #336 
    0xe0002ff0     0x24    add r4, fp, #256 
    0xe0002ff4     0x28    ldr r5, [sp, #16]     ; stack access
    0xe0002ff8     0x2c    str r1, [r4, #64] 
    0xe0002ffc     0x30    mov r0, #5
    0xe0003000     0x34    and r8, r5, #14
    0xe0003004     0x38    ldr r1, [sp, #20]     ; stack access
    0xe0003008     0x3c    cmp r8, #14
    0xe000300c     0x40    str r4, [sp]          ; stack access
    0xe0003010     0x44    str r0, [r4, #124] 
    0xe0003014     0x48    str r1, [sp, #4]      ; stack access
    0xe0003018     0x4c    stm r9, {r2, r3}      ; stack access
    0xe000301c     0x50    beq e0003330 <create_initial_thread+0x364>
    0xe0003020     0x54    and r3, r5, #15
    0xe0003024     0x58    sub r2, r3, #2
    0xe0003028     0x5c    cmp r2, #12
    0xe000302c     0x60    ldrls pc, [pc, r2, lsl #2]
    0xe0003030     0x64    b e0003988 <create_initial_thread+0x9bc>
    0xe0003034     0x68    .word 0xe0003068
    0xe0003038     0x6c    .word 0xe0003988
    0xe000303c     0x70    .word 0xe0003884
    0xe0003040     0x74    .word 0xe0003988
    0xe0003044     0x78    .word 0xe0003068
    0xe0003048     0x7c    .word 0xe0003988
    0xe000304c     0x80    .word 0xe000387c
    0xe0003050     0x84    .word 0xe0003988
    0xe0003054     0x88    .word 0xe00038a4
    0xe0003058     0x8c    .word 0xe0003988
    0xe000305c     0x90    .word 0xe0003894
    0xe0003060     0x94    .word 0xe0003988
    0xe0003064     0x98    .word 0xe000387c
    0xe0003068     0x9c    bic r1, r5, #15
    0xe000306c     0xa0    add r1, r1, #160 
    0xe0003070     0xa4    add r3, sp, #92 
    0xe0003074     0xa8    add r0, sp, #28
    0xe0003078     0xac    ldm r3, {r2, r3}      ; stack access
    0xe000307c     0xb0    bl e0014bf4 <deriveCap>
    0xe0003080     0xb4    ldr r3, [sp, #28]     ; stack access
    0xe0003084     0xb8    cmp r3, #0
    0xe0003088     0xbc    bne e0003b78 <create_initial_thread+0xbac>
    0xe000308c     0xc0    cmp r8, #14
    0xe0003090     0xc4    beq e0003550 <create_initial_thread+0x584>
    0xe0003094     0xc8    and r6, r5, #15
    0xe0003098     0xcc    sub r3, r6, #2
    0xe000309c     0xd0    mov r2, r6
    0xe00030a0     0xd4    cmp r3, #12
    0xe00030a4     0xd8    ldrls pc, [pc, r3, lsl #2]
    0xe00030a8     0xdc    b e0003a88 <create_initial_thread+0xabc>
    0xe00030ac     0xe0    .word 0xe00030e0
    0xe00030b0     0xe4    .word 0xe0003a88
    0xe00030b4     0xe8    .word 0xe00038c8
    0xe00030b8     0xec    .word 0xe0003a88
    0xe00030bc     0xf0    .word 0xe00030e0
    0xe00030c0     0xf4    .word 0xe0003a88
    0xe00030c4     0xf8    .word 0xe0003974
    0xe00030c8     0xfc    .word 0xe0003a88
    0xe00030cc    0x100    .word 0xe0003950
    0xe00030d0    0x104    .word 0xe0003a88
    0xe00030d4    0x108    .word 0xe00038b8
    0xe00030d8    0x10c    .word 0xe0003a88
    0xe00030dc    0x110    .word 0xe0003974
    0xe00030e0    0x114    bic r2, r5, #15
    0xe00030e4    0x118    add r2, r2, #32
    0xe00030e8    0x11c    ldr r3, [r7, #168] 
    0xe00030ec    0x120    ldm sl, {r0, r1}      ; stack access
    0xe00030f0    0x124    bl e0013308 <cteInsert>
    0xe00030f4    0x128    cmp r8, #14
    0xe00030f8    0x12c    uxtbeq r6, r5
    0xe00030fc    0x130    beq e0003448 <create_initial_thread+0x47c>
    0xe0003100    0x134    and r6, r5, #15
    0xe0003104    0x138    sub r3, r6, #2
    0xe0003108    0x13c    mov r2, r6
    0xe000310c    0x140    cmp r3, #12
    0xe0003110    0x144    ldrls pc, [pc, r3, lsl #2]
    0xe0003114    0x148    b e0003a54 <create_initial_thread+0xa88>
    0xe0003118    0x14c    .word 0xe000314c
    0xe000311c    0x150    .word 0xe0003a54
    0xe0003120    0x154    .word 0xe0003940
    0xe0003124    0x158    .word 0xe0003a54
    0xe0003128    0x15c    .word 0xe000314c
    0xe000312c    0x160    .word 0xe0003a54
    0xe0003130    0x164    .word 0xe000395c
    0xe0003134    0x168    .word 0xe0003a54
    0xe0003138    0x16c    .word 0xe0003924
    0xe000313c    0x170    .word 0xe0003a54
    0xe0003140    0x174    .word 0xe0003930
    0xe0003144    0x178    .word 0xe0003a54
    0xe0003148    0x17c    .word 0xe000395c
    0xe000314c    0x180    bic r2, r5, #15
    0xe0003150    0x184    add r2, r2, #48 
    0xe0003154    0x188    ldr r3, [r7, #168] 
    0xe0003158    0x18c    ldm r9, {r0, r1}      ; stack access
    0xe000315c    0x190    add r3, r3, #16
    0xe0003160    0x194    bl e0013308 <cteInsert>
    0xe0003164    0x198    cmp r8, #14
    0xe0003168    0x19c    uxtbeq r6, r5
    0xe000316c    0x1a0    beq e0003778 <create_initial_thread+0x7ac>
    0xe0003170    0x1a4    and r6, r5, #15
    0xe0003174    0x1a8    sub r3, r6, #2
    0xe0003178    0x1ac    cmp r3, #12
    0xe000317c    0x1b0    ldrls pc, [pc, r3, lsl #2]
    0xe0003180    0x1b4    b e0003a20 <create_initial_thread+0xa54>
    0xe0003184    0x1b8    .word 0xe00031b8
    0xe0003188    0x1bc    .word 0xe0003a20
    0xe000318c    0x1c0    .word 0xe0003914
    0xe0003190    0x1c4    .word 0xe0003a20
    0xe0003194    0x1c8    .word 0xe00031b8
    0xe0003198    0x1cc    .word 0xe0003a20
    0xe000319c    0x1d0    .word 0xe00038b0
    0xe00031a0    0x1d4    .word 0xe0003a20
    0xe00031a4    0x1d8    .word 0xe00038e8
    0xe00031a8    0x1dc    .word 0xe0003a20
    0xe00031ac    0x1e0    .word 0xe00038d8
    0xe00031b0    0x1e4    .word 0xe0003a20
    0xe00031b4    0x1e8    .word 0xe00038b0
    0xe00031b8    0x1ec    bic r2, r5, #15
    0xe00031bc    0x1f0    add r2, r2, #160 
    0xe00031c0    0x1f4    ldr r3, [r7, #168] 
    0xe00031c4    0x1f8    add r1, sp, #40 
    0xe00031c8    0x1fc    movw r7, #13904 
    0xe00031cc    0x200    movt r7, #57347 
    0xe00031d0    0x204    ldmdb r1, {r0, r1}    ; stack access
    0xe00031d4    0x208    add r3, r3, #64 
    0xe00031d8    0x20c    bl e0013308 <cteInsert>
    0xe00031dc    0x210    ldr r3, [sp, #88]     ; stack access
    0xe00031e0    0x214    bic r0, r4, #508 
    0xe00031e4    0x218    ldr r2, [r7]
    0xe00031e8    0x21c    bic r0, r0, #3
    0xe00031ec    0x220    ldr ip, [sp, #84]     ; stack access
    0xe00031f0    0x224    str r3, [r4, #132] 
    0xe00031f4    0x228    movw r6, #46024 
    0xe00031f8    0x22c    ldr r3, [r0, #32]
    0xe00031fc    0x230    movt r6, #57345 
    0xe0003200    0x234    lsl r2, r2, #3
    0xe0003204    0x238    str ip, [fp, #256] 
    0xe0003208    0x23c    add r1, r6, r2
    0xe000320c    0x240    and ip, r3, #14
    0xe0003210    0x244    cmp ip, #14
    0xe0003214    0x248    ldr ip, [sp, #80]     ; stack access
    0xe0003218    0x24c    ldr r1, [r1, #112] 
    0xe000321c    0x250    andne r3, r3, #15
    0xe0003220    0x254    uxtbeq r3, r3
    0xe0003224    0x258    add lr, r0, #32
    0xe0003228    0x25c    cmp r3, #0
    0xe000322c    0x260    str ip, [r4, #60] 
    0xe0003230    0x264    str r1, [r4, #112] 
    0xe0003234    0x268    mov ip, #255 
    0xe0003238    0x26c    str ip, [r4, #120] 
    0xe000323c    0x270    str ip, [r4, #116] 
    0xe0003240    0x274    bne e0003260 <create_initial_thread+0x294>
    0xe0003244    0x278    bic ip, r4, #63 
    0xe0003248    0x27c    mov r9, #3
    0xe000324c    0x280    orr ip, ip, #56 
    0xe0003250    0x284    str ip, [r0, #32]
    0xe0003254    0x288    str r3, [lr, #4]
    0xe0003258    0x28c    str r3, [lr, #8]
    0xe000325c    0x290    str r9, [lr, #12]
    0xe0003260    0x294    movw r0, #13900 
    0xe0003264    0x298    movt r0, #57347 
    0xe0003268    0x29c    ldr r3, [r4, #80] 
    0xe000326c    0x2a0    ldr r0, [r0]
    0xe0003270    0x2a4    bic r3, r3, #15
    0xe0003274    0x2a8    cmp r4, r0
    0xe0003278    0x2ac    orr r3, r3, #1
    0xe000327c    0x2b0    str r3, [r4, #80] 
    0xe0003280    0x2b4    beq e0003b8c <create_initial_thread+0xbc0>
    0xe0003284    0x2b8    add r6, r6, r2
    0xe0003288    0x2bc    movw r3, #12288 
    0xe000328c    0x2c0    movw r2, #5324 
    0xe0003290    0x2c4    movt r3, #57347 
    0xe0003294    0x2c8    ldr r0, [r6, #116] 
    0xe0003298    0x2cc    movt r2, #57347 
    0xe000329c    0x2d0    cmp r8, #14
    0xe00032a0    0x2d4    bic r4, r4, #15
    0xe00032a4    0x2d8    orr r4, r4, #12
    0xe00032a8    0x2dc    str r1, [r3]
    0xe00032ac    0x2e0    str r0, [r2]
    0xe00032b0    0x2e4    beq e000365c <create_initial_thread+0x690>
    0xe00032b4    0x2e8    and r3, r5, #15
    0xe00032b8    0x2ec    sub r2, r3, #2
    0xe00032bc    0x2f0    cmp r2, #12
    0xe00032c0    0x2f4    ldrls pc, [pc, r2, lsl #2]
    0xe00032c4    0x2f8    b e00039ec <create_initial_thread+0xa20>
    0xe00032c8    0x2fc    .word 0xe00032fc
    0xe00032cc    0x300    .word 0xe00039ec
    0xe00032d0    0x304    .word 0xe0003908
    0xe00032d4    0x308    .word 0xe00039ec
    0xe00032d8    0x30c    .word 0xe00032fc
    0xe00032dc    0x310    .word 0xe00039ec
    0xe00032e0    0x314    .word 0xe0003324
    0xe00032e4    0x318    .word 0xe00039ec
    0xe00032e8    0x31c    .word 0xe00038f4
    0xe00032ec    0x320    .word 0xe00039ec
    0xe00032f0    0x324    .word 0xe00038fc
    0xe00032f4    0x328    .word 0xe00039ec
    0xe00032f8    0x32c    .word 0xe0003324
    0xe00032fc    0x330    bic r5, r5, #15
    0xe0003300    0x334    mov r3, #0
    0xe0003304    0x338    mov r2, #3
    0xe0003308    0x33c    ldr r0, [sp]          ; stack access
    0xe000330c    0x340    str r4, [r5, #16]
    0xe0003310    0x344    str r3, [r5, #20]
    0xe0003314    0x348    str r3, [r5, #24]
    0xe0003318    0x34c    str r2, [r5, #28]
    0xe000331c    0x350    add sp, sp, #44 
    0xe0003320    0x354    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0003324    0x358    mov r3, #0
    0xe0003328    0x35c    str r3, [r3, #16]
    0xe000332c    0x360    udf #0
    0xe0003330    0x364    uxtb r3, r5
    0xe0003334    0x368    sub r2, r3, #2
    0xe0003338    0x36c    cmp r2, #60 
    0xe000333c    0x370    ldrls pc, [pc, r2, lsl #2]
    0xe0003340    0x374    b e0003988 <create_initial_thread+0x9bc>
    0xe0003344    0x378    .word 0xe0003068
    0xe0003348    0x37c    .word 0xe0003988
    0xe000334c    0x380    .word 0xe0003884
    0xe0003350    0x384    .word 0xe0003988
    0xe0003354    0x388    .word 0xe0003068
    0xe0003358    0x38c    .word 0xe0003988
    0xe000335c    0x390    .word 0xe000387c
    0xe0003360    0x394    .word 0xe0003988
    0xe0003364    0x398    .word 0xe00038a4
    0xe0003368    0x39c    .word 0xe0003988
    0xe000336c    0x3a0    .word 0xe0003894
    0xe0003370    0x3a4    .word 0xe0003988
    0xe0003374    0x3a8    .word 0xe000387c
    0xe0003378    0x3ac    .word 0xe0003988
    0xe000337c    0x3b0    .word 0xe0003988
    0xe0003380    0x3b4    .word 0xe0003988
    0xe0003384    0x3b8    .word 0xe0003988
    0xe0003388    0x3bc    .word 0xe0003988
    0xe000338c    0x3c0    .word 0xe0003988
    0xe0003390    0x3c4    .word 0xe0003988
    0xe0003394    0x3c8    .word 0xe0003988
    0xe0003398    0x3cc    .word 0xe0003988
    0xe000339c    0x3d0    .word 0xe0003988
    0xe00033a0    0x3d4    .word 0xe0003988
    0xe00033a4    0x3d8    .word 0xe0003988
    0xe00033a8    0x3dc    .word 0xe0003988
    0xe00033ac    0x3e0    .word 0xe0003988
    0xe00033b0    0x3e4    .word 0xe0003988
    0xe00033b4    0x3e8    .word 0xe000387c
    0xe00033b8    0x3ec    .word 0xe0003988
    0xe00033bc    0x3f0    .word 0xe0003988
    0xe00033c0    0x3f4    .word 0xe0003988
    0xe00033c4    0x3f8    .word 0xe0003988
    0xe00033c8    0x3fc    .word 0xe0003988
    0xe00033cc    0x400    .word 0xe0003988
    0xe00033d0    0x404    .word 0xe0003988
    0xe00033d4    0x408    .word 0xe0003988
    0xe00033d8    0x40c    .word 0xe0003988
    0xe00033dc    0x410    .word 0xe0003988
    0xe00033e0    0x414    .word 0xe0003988
    0xe00033e4    0x418    .word 0xe0003988
    0xe00033e8    0x41c    .word 0xe0003988
    0xe00033ec    0x420    .word 0xe0003988
    0xe00033f0    0x424    .word 0xe0003988
    0xe00033f4    0x428    .word 0xe00039bc
    0xe00033f8    0x42c    .word 0xe0003988
    0xe00033fc    0x430    .word 0xe0003988
    0xe0003400    0x434    .word 0xe0003988
    0xe0003404    0x438    .word 0xe0003988
    0xe0003408    0x43c    .word 0xe0003988
    0xe000340c    0x440    .word 0xe0003988
    0xe0003410    0x444    .word 0xe0003988
    0xe0003414    0x448    .word 0xe0003988
    0xe0003418    0x44c    .word 0xe0003988
    0xe000341c    0x450    .word 0xe0003988
    0xe0003420    0x454    .word 0xe0003988
    0xe0003424    0x458    .word 0xe0003988
    0xe0003428    0x45c    .word 0xe0003988
    0xe000342c    0x460    .word 0xe0003988
    0xe0003430    0x464    .word 0xe0003988
    0xe0003434    0x468    .word 0xe000387c
    0xe0003438    0x46c    ldr r3, [r7, #168] 
    0xe000343c    0x470    mov r2, #32
    0xe0003440    0x474    ldm sl, {r0, r1}      ; stack access
    0xe0003444    0x478    bl e0013308 <cteInsert>
    0xe0003448    0x47c    sub r3, r6, #2
    0xe000344c    0x480    mov r2, r6
    0xe0003450    0x484    cmp r3, #60 
    0xe0003454    0x488    ldrls pc, [pc, r3, lsl #2]
    0xe0003458    0x48c    b e0003a54 <create_initial_thread+0xa88>
    0xe000345c    0x490    .word 0xe000314c
    0xe0003460    0x494    .word 0xe0003a54
    0xe0003464    0x498    .word 0xe0003940
    0xe0003468    0x49c    .word 0xe0003a54
    0xe000346c    0x4a0    .word 0xe000314c
    0xe0003470    0x4a4    .word 0xe0003a54
    0xe0003474    0x4a8    .word 0xe0003764
    0xe0003478    0x4ac    .word 0xe0003a54
    0xe000347c    0x4b0    .word 0xe0003924
    0xe0003480    0x4b4    .word 0xe0003a54
    0xe0003484    0x4b8    .word 0xe0003930
    0xe0003488    0x4bc    .word 0xe0003a54
    0xe000348c    0x4c0    .word 0xe0003764
    0xe0003490    0x4c4    .word 0xe0003a54
    0xe0003494    0x4c8    .word 0xe0003a54
    0xe0003498    0x4cc    .word 0xe0003a54
    0xe000349c    0x4d0    .word 0xe0003a54
    0xe00034a0    0x4d4    .word 0xe0003a54
    0xe00034a4    0x4d8    .word 0xe0003a54
    0xe00034a8    0x4dc    .word 0xe0003a54
    0xe00034ac    0x4e0    .word 0xe0003a54
    0xe00034b0    0x4e4    .word 0xe0003a54
    0xe00034b4    0x4e8    .word 0xe0003a54
    0xe00034b8    0x4ec    .word 0xe0003a54
    0xe00034bc    0x4f0    .word 0xe0003a54
    0xe00034c0    0x4f4    .word 0xe0003a54
    0xe00034c4    0x4f8    .word 0xe0003a54
    0xe00034c8    0x4fc    .word 0xe0003a54
    0xe00034cc    0x500    .word 0xe0003764
    0xe00034d0    0x504    .word 0xe0003a54
    0xe00034d4    0x508    .word 0xe0003a54
    0xe00034d8    0x50c    .word 0xe0003a54
    0xe00034dc    0x510    .word 0xe0003a54
    0xe00034e0    0x514    .word 0xe0003a54
    0xe00034e4    0x518    .word 0xe0003a54
    0xe00034e8    0x51c    .word 0xe0003a54
    0xe00034ec    0x520    .word 0xe0003a54
    0xe00034f0    0x524    .word 0xe0003a54
    0xe00034f4    0x528    .word 0xe0003a54
    0xe00034f8    0x52c    .word 0xe0003a54
    0xe00034fc    0x530    .word 0xe0003a54
    0xe0003500    0x534    .word 0xe0003a54
    0xe0003504    0x538    .word 0xe0003a54
    0xe0003508    0x53c    .word 0xe0003a54
    0xe000350c    0x540    .word 0xe0003abc
    0xe0003510    0x544    .word 0xe0003a54
    0xe0003514    0x548    .word 0xe0003a54
    0xe0003518    0x54c    .word 0xe0003a54
    0xe000351c    0x550    .word 0xe0003a54
    0xe0003520    0x554    .word 0xe0003a54
    0xe0003524    0x558    .word 0xe0003a54
    0xe0003528    0x55c    .word 0xe0003a54
    0xe000352c    0x560    .word 0xe0003a54
    0xe0003530    0x564    .word 0xe0003a54
    0xe0003534    0x568    .word 0xe0003a54
    0xe0003538    0x56c    .word 0xe0003a54
    0xe000353c    0x570    .word 0xe0003a54
    0xe0003540    0x574    .word 0xe0003a54
    0xe0003544    0x578    .word 0xe0003a54
    0xe0003548    0x57c    .word 0xe0003a54
    0xe000354c    0x580    .word 0xe0003764
    0xe0003550    0x584    uxtb r6, r5
    0xe0003554    0x588    sub r3, r6, #2
    0xe0003558    0x58c    mov r2, r6
    0xe000355c    0x590    cmp r3, #60 
    0xe0003560    0x594    ldrls pc, [pc, r3, lsl #2]
    0xe0003564    0x598    b e0003a88 <create_initial_thread+0xabc>
    0xe0003568    0x59c    .word 0xe00030e0
    0xe000356c    0x5a0    .word 0xe0003a88
    0xe0003570    0x5a4    .word 0xe00038c8
    0xe0003574    0x5a8    .word 0xe0003a88
    0xe0003578    0x5ac    .word 0xe00030e0
    0xe000357c    0x5b0    .word 0xe0003a88
    0xe0003580    0x5b4    .word 0xe0003438
    0xe0003584    0x5b8    .word 0xe0003a88
    0xe0003588    0x5bc    .word 0xe0003950
    0xe000358c    0x5c0    .word 0xe0003a88
    0xe0003590    0x5c4    .word 0xe00038b8
    0xe0003594    0x5c8    .word 0xe0003a88
    0xe0003598    0x5cc    .word 0xe0003438
    0xe000359c    0x5d0    .word 0xe0003a88
    0xe00035a0    0x5d4    .word 0xe0003a88
    0xe00035a4    0x5d8    .word 0xe0003a88
    0xe00035a8    0x5dc    .word 0xe0003a88
    0xe00035ac    0x5e0    .word 0xe0003a88
    0xe00035b0    0x5e4    .word 0xe0003a88
    0xe00035b4    0x5e8    .word 0xe0003a88
    0xe00035b8    0x5ec    .word 0xe0003a88
    0xe00035bc    0x5f0    .word 0xe0003a88
    0xe00035c0    0x5f4    .word 0xe0003a88
    0xe00035c4    0x5f8    .word 0xe0003a88
    0xe00035c8    0x5fc    .word 0xe0003a88
    0xe00035cc    0x600    .word 0xe0003a88
    0xe00035d0    0x604    .word 0xe0003a88
    0xe00035d4    0x608    .word 0xe0003a88
    0xe00035d8    0x60c    .word 0xe0003438
    0xe00035dc    0x610    .word 0xe0003a88
    0xe00035e0    0x614    .word 0xe0003a88
    0xe00035e4    0x618    .word 0xe0003a88
    0xe00035e8    0x61c    .word 0xe0003a88
    0xe00035ec    0x620    .word 0xe0003a88
    0xe00035f0    0x624    .word 0xe0003a88
    0xe00035f4    0x628    .word 0xe0003a88
    0xe00035f8    0x62c    .word 0xe0003a88
    0xe00035fc    0x630    .word 0xe0003a88
    0xe0003600    0x634    .word 0xe0003a88
    0xe0003604    0x638    .word 0xe0003a88
    0xe0003608    0x63c    .word 0xe0003a88
    0xe000360c    0x640    .word 0xe0003a88
    0xe0003610    0x644    .word 0xe0003a88
    0xe0003614    0x648    .word 0xe0003a88
    0xe0003618    0x64c    .word 0xe0003aec
    0xe000361c    0x650    .word 0xe0003a88
    0xe0003620    0x654    .word 0xe0003a88
    0xe0003624    0x658    .word 0xe0003a88
    0xe0003628    0x65c    .word 0xe0003a88
    0xe000362c    0x660    .word 0xe0003a88
    0xe0003630    0x664    .word 0xe0003a88
    0xe0003634    0x668    .word 0xe0003a88
    0xe0003638    0x66c    .word 0xe0003a88
    0xe000363c    0x670    .word 0xe0003a88
    0xe0003640    0x674    .word 0xe0003a88
    0xe0003644    0x678    .word 0xe0003a88
    0xe0003648    0x67c    .word 0xe0003a88
    0xe000364c    0x680    .word 0xe0003a88
    0xe0003650    0x684    .word 0xe0003a88
    0xe0003654    0x688    .word 0xe0003a88
    0xe0003658    0x68c    .word 0xe0003438
    0xe000365c    0x690    uxtb r3, r5
    0xe0003660    0x694    sub r2, r3, #2
    0xe0003664    0x698    cmp r2, #60 
    0xe0003668    0x69c    ldrls pc, [pc, r2, lsl #2]
    0xe000366c    0x6a0    b e00039ec <create_initial_thread+0xa20>
    0xe0003670    0x6a4    .word 0xe00032fc
    0xe0003674    0x6a8    .word 0xe00039ec
    0xe0003678    0x6ac    .word 0xe0003908
    0xe000367c    0x6b0    .word 0xe00039ec
    0xe0003680    0x6b4    .word 0xe00032fc
    0xe0003684    0x6b8    .word 0xe00039ec
    0xe0003688    0x6bc    .word 0xe0003324
    0xe000368c    0x6c0    .word 0xe00039ec
    0xe0003690    0x6c4    .word 0xe00038f4
    0xe0003694    0x6c8    .word 0xe00039ec
    0xe0003698    0x6cc    .word 0xe00038fc
    0xe000369c    0x6d0    .word 0xe00039ec
    0xe00036a0    0x6d4    .word 0xe0003324
    0xe00036a4    0x6d8    .word 0xe00039ec
    0xe00036a8    0x6dc    .word 0xe00039ec
    0xe00036ac    0x6e0    .word 0xe00039ec
    0xe00036b0    0x6e4    .word 0xe00039ec
    0xe00036b4    0x6e8    .word 0xe00039ec
    0xe00036b8    0x6ec    .word 0xe00039ec
    0xe00036bc    0x6f0    .word 0xe00039ec
    0xe00036c0    0x6f4    .word 0xe00039ec
    0xe00036c4    0x6f8    .word 0xe00039ec
    0xe00036c8    0x6fc    .word 0xe00039ec
    0xe00036cc    0x700    .word 0xe00039ec
    0xe00036d0    0x704    .word 0xe00039ec
    0xe00036d4    0x708    .word 0xe00039ec
    0xe00036d8    0x70c    .word 0xe00039ec
    0xe00036dc    0x710    .word 0xe00039ec
    0xe00036e0    0x714    .word 0xe0003324
    0xe00036e4    0x718    .word 0xe00039ec
    0xe00036e8    0x71c    .word 0xe00039ec
    0xe00036ec    0x720    .word 0xe00039ec
    0xe00036f0    0x724    .word 0xe00039ec
    0xe00036f4    0x728    .word 0xe00039ec
    0xe00036f8    0x72c    .word 0xe00039ec
    0xe00036fc    0x730    .word 0xe00039ec
    0xe0003700    0x734    .word 0xe00039ec
    0xe0003704    0x738    .word 0xe00039ec
    0xe0003708    0x73c    .word 0xe00039ec
    0xe000370c    0x740    .word 0xe00039ec
    0xe0003710    0x744    .word 0xe00039ec
    0xe0003714    0x748    .word 0xe00039ec
    0xe0003718    0x74c    .word 0xe00039ec
    0xe000371c    0x750    .word 0xe00039ec
    0xe0003720    0x754    .word 0xe0003b4c
    0xe0003724    0x758    .word 0xe00039ec
    0xe0003728    0x75c    .word 0xe00039ec
    0xe000372c    0x760    .word 0xe00039ec
    0xe0003730    0x764    .word 0xe00039ec
    0xe0003734    0x768    .word 0xe00039ec
    0xe0003738    0x76c    .word 0xe00039ec
    0xe000373c    0x770    .word 0xe00039ec
    0xe0003740    0x774    .word 0xe00039ec
    0xe0003744    0x778    .word 0xe00039ec
    0xe0003748    0x77c    .word 0xe00039ec
    0xe000374c    0x780    .word 0xe00039ec
    0xe0003750    0x784    .word 0xe00039ec
    0xe0003754    0x788    .word 0xe00039ec
    0xe0003758    0x78c    .word 0xe00039ec
    0xe000375c    0x790    .word 0xe00039ec
    0xe0003760    0x794    .word 0xe0003324
    0xe0003764    0x798    ldr r3, [r7, #168] 
    0xe0003768    0x79c    mov r2, #48 
    0xe000376c    0x7a0    ldm r9, {r0, r1}      ; stack access
    0xe0003770    0x7a4    add r3, r3, #16
    0xe0003774    0x7a8    bl e0013308 <cteInsert>
    0xe0003778    0x7ac    sub r3, r6, #2
    0xe000377c    0x7b0    cmp r3, #60 
    0xe0003780    0x7b4    ldrls pc, [pc, r3, lsl #2]
    0xe0003784    0x7b8    b e0003a20 <create_initial_thread+0xa54>
    0xe0003788    0x7bc    .word 0xe00031b8
    0xe000378c    0x7c0    .word 0xe0003a20
    0xe0003790    0x7c4    .word 0xe0003914
    0xe0003794    0x7c8    .word 0xe0003a20
    0xe0003798    0x7cc    .word 0xe00031b8
    0xe000379c    0x7d0    .word 0xe0003a20
    0xe00037a0    0x7d4    .word 0xe00038b0
    0xe00037a4    0x7d8    .word 0xe0003a20
    0xe00037a8    0x7dc    .word 0xe00038e8
    0xe00037ac    0x7e0    .word 0xe0003a20
    0xe00037b0    0x7e4    .word 0xe00038d8
    0xe00037b4    0x7e8    .word 0xe0003a20
    0xe00037b8    0x7ec    .word 0xe00038b0
    0xe00037bc    0x7f0    .word 0xe0003a20
    0xe00037c0    0x7f4    .word 0xe0003a20
    0xe00037c4    0x7f8    .word 0xe0003a20
    0xe00037c8    0x7fc    .word 0xe0003a20
    0xe00037cc    0x800    .word 0xe0003a20
    0xe00037d0    0x804    .word 0xe0003a20
    0xe00037d4    0x808    .word 0xe0003a20
    0xe00037d8    0x80c    .word 0xe0003a20
    0xe00037dc    0x810    .word 0xe0003a20
    0xe00037e0    0x814    .word 0xe0003a20
    0xe00037e4    0x818    .word 0xe0003a20
    0xe00037e8    0x81c    .word 0xe0003a20
    0xe00037ec    0x820    .word 0xe0003a20
    0xe00037f0    0x824    .word 0xe0003a20
    0xe00037f4    0x828    .word 0xe0003a20
    0xe00037f8    0x82c    .word 0xe00038b0
    0xe00037fc    0x830    .word 0xe0003a20
    0xe0003800    0x834    .word 0xe0003a20
    0xe0003804    0x838    .word 0xe0003a20
    0xe0003808    0x83c    .word 0xe0003a20
    0xe000380c    0x840    .word 0xe0003a20
    0xe0003810    0x844    .word 0xe0003a20
    0xe0003814    0x848    .word 0xe0003a20
    0xe0003818    0x84c    .word 0xe0003a20
    0xe000381c    0x850    .word 0xe0003a20
    0xe0003820    0x854    .word 0xe0003a20
    0xe0003824    0x858    .word 0xe0003a20
    0xe0003828    0x85c    .word 0xe0003a20
    0xe000382c    0x860    .word 0xe0003a20
    0xe0003830    0x864    .word 0xe0003a20
    0xe0003834    0x868    .word 0xe0003a20
    0xe0003838    0x86c    .word 0xe0003b1c
    0xe000383c    0x870    .word 0xe0003a20
    0xe0003840    0x874    .word 0xe0003a20
    0xe0003844    0x878    .word 0xe0003a20
    0xe0003848    0x87c    .word 0xe0003a20
    0xe000384c    0x880    .word 0xe0003a20
    0xe0003850    0x884    .word 0xe0003a20
    0xe0003854    0x888    .word 0xe0003a20
    0xe0003858    0x88c    .word 0xe0003a20
    0xe000385c    0x890    .word 0xe0003a20
    0xe0003860    0x894    .word 0xe0003a20
    0xe0003864    0x898    .word 0xe0003a20
    0xe0003868    0x89c    .word 0xe0003a20
    0xe000386c    0x8a0    .word 0xe0003a20
    0xe0003870    0x8a4    .word 0xe0003a20
    0xe0003874    0x8a8    .word 0xe0003a20
    0xe0003878    0x8ac    .word 0xe00038b0
    0xe000387c    0x8b0    mov r1, #160 
    0xe0003880    0x8b4    b e0003070 <create_initial_thread+0xa4>
    0xe0003884    0x8b8    ldr r3, [sp, #4]      ; stack access
    0xe0003888    0x8bc    bic r1, r3, #15
    0xe000388c    0x8c0    add r1, r1, #160 
    0xe0003890    0x8c4    b e0003070 <create_initial_thread+0xa4>
    0xe0003894    0x8c8    bic r1, r5, #508 
    0xe0003898    0x8cc    bic r1, r1, #3
    0xe000389c    0x8d0    add r1, r1, #160 
    0xe00038a0    0x8d4    b e0003070 <create_initial_thread+0xa4>
    0xe00038a4    0x8d8    bic r1, r5, #31
    0xe00038a8    0x8dc    add r1, r1, #160 
    0xe00038ac    0x8e0    b e0003070 <create_initial_thread+0xa4>
    0xe00038b0    0x8e4    mov r2, #160 
    0xe00038b4    0x8e8    b e00031c0 <create_initial_thread+0x1f4>
    0xe00038b8    0x8ec    bic r2, r5, #508 
    0xe00038bc    0x8f0    bic r2, r2, #3
    0xe00038c0    0x8f4    add r2, r2, #32
    0xe00038c4    0x8f8    b e00030e8 <create_initial_thread+0x11c>
    0xe00038c8    0x8fc    ldr r3, [sp, #4]      ; stack access
    0xe00038cc    0x900    bic r2, r3, #15
    0xe00038d0    0x904    add r2, r2, #32
    0xe00038d4    0x908    b e00030e8 <create_initial_thread+0x11c>
    0xe00038d8    0x90c    bic r2, r5, #508 
    0xe00038dc    0x910    bic r2, r2, #3
    0xe00038e0    0x914    add r2, r2, #160 
    0xe00038e4    0x918    b e00031c0 <create_initial_thread+0x1f4>
    0xe00038e8    0x91c    bic r2, r5, #31
    0xe00038ec    0x920    add r2, r2, #160 
    0xe00038f0    0x924    b e00031c0 <create_initial_thread+0x1f4>
    0xe00038f4    0x928    bic r5, r5, #31
    0xe00038f8    0x92c    b e0003300 <create_initial_thread+0x334>
    0xe00038fc    0x930    bic r5, r5, #508 
    0xe0003900    0x934    bic r5, r5, #3
    0xe0003904    0x938    b e0003300 <create_initial_thread+0x334>
    0xe0003908    0x93c    ldr r3, [sp, #4]      ; stack access
    0xe000390c    0x940    bic r5, r3, #15
    0xe0003910    0x944    b e0003300 <create_initial_thread+0x334>
    0xe0003914    0x948    ldr r3, [sp, #4]      ; stack access
    0xe0003918    0x94c    bic r2, r3, #15
    0xe000391c    0x950    add r2, r2, #160 
    0xe0003920    0x954    b e00031c0 <create_initial_thread+0x1f4>
    0xe0003924    0x958    bic r2, r5, #31
    0xe0003928    0x95c    add r2, r2, #48 
    0xe000392c    0x960    b e0003154 <create_initial_thread+0x188>
    0xe0003930    0x964    bic r2, r5, #508 
    0xe0003934    0x968    bic r2, r2, #3
    0xe0003938    0x96c    add r2, r2, #48 
    0xe000393c    0x970    b e0003154 <create_initial_thread+0x188>
    0xe0003940    0x974    ldr r3, [sp, #4]      ; stack access
    0xe0003944    0x978    bic r2, r3, #15
    0xe0003948    0x97c    add r2, r2, #48 
    0xe000394c    0x980    b e0003154 <create_initial_thread+0x188>
    0xe0003950    0x984    bic r2, r5, #31
    0xe0003954    0x988    add r2, r2, #32
    0xe0003958    0x98c    b e00030e8 <create_initial_thread+0x11c>
    0xe000395c    0x990    ldr r3, [r7, #168] 
    0xe0003960    0x994    mov r2, #48 
    0xe0003964    0x998    ldm r9, {r0, r1}      ; stack access
    0xe0003968    0x99c    add r3, r3, #16
    0xe000396c    0x9a0    bl e0013308 <cteInsert>
    0xe0003970    0x9a4    b e0003174 <create_initial_thread+0x1a8>
    0xe0003974    0x9a8    ldr r3, [r7, #168] 
    0xe0003978    0x9ac    mov r2, #32
    0xe000397c    0x9b0    ldm sl, {r0, r1}      ; stack access
    0xe0003980    0x9b4    bl e0013308 <cteInsert>
    0xe0003984    0x9b8    b e0003104 <create_initial_thread+0x138>
    0xe0003988    0x9bc    sub r2, r3, #1
    0xe000398c    0x9c0    cmp r2, #8
    0xe0003990    0x9c4    ldrls pc, [pc, r2, lsl #2]
    0xe0003994    0x9c8    b e000387c <create_initial_thread+0x8b0>
    0xe0003998    0x9cc    .word 0xe0003ba8
    0xe000399c    0x9d0    .word 0xe000387c
    0xe00039a0    0x9d4    .word 0xe0003ba8
    0xe00039a4    0x9d8    .word 0xe000387c
    0xe00039a8    0x9dc    .word 0xe0003068
    0xe00039ac    0x9e0    .word 0xe000387c
    0xe00039b0    0x9e4    .word 0xe0003bdc
    0xe00039b4    0x9e8    .word 0xe000387c
    0xe00039b8    0x9ec    .word 0xe0003bcc
    0xe00039bc    0x9f0    lsr r1, r5, #8
    0xe00039c0    0x9f4    and r3, r1, #63 
    0xe00039c4    0x9f8    cmp r3, #32
    0xe00039c8    0x9fc    andne r3, r1, #31
    0xe00039cc    0xa00    addne r3, r3, #1
    0xe00039d0    0xa04    mvnne r1, #0
    0xe00039d4    0xa08    lslne r1, r1, r3
    0xe00039d8    0xa0c    ldr r3, [sp, #4]      ; stack access
    0xe00039dc    0xa10    mvneq r1, #31
    0xe00039e0    0xa14    and r1, r1, r3
    0xe00039e4    0xa18    add r1, r1, #160 
    0xe00039e8    0xa1c    b e0003070 <create_initial_thread+0xa4>
    0xe00039ec    0xa20    sub r2, r3, #1
    0xe00039f0    0xa24    cmp r2, #8
    0xe00039f4    0xa28    ldrls pc, [pc, r2, lsl #2]
    0xe00039f8    0xa2c    b e0003324 <create_initial_thread+0x358>
    0xe00039fc    0xa30    .word 0xe0003c48
    0xe0003a00    0xa34    .word 0xe0003324
    0xe0003a04    0xa38    .word 0xe0003c48
    0xe0003a08    0xa3c    .word 0xe0003324
    0xe0003a0c    0xa40    .word 0xe00032fc
    0xe0003a10    0xa44    .word 0xe0003324
    0xe0003a14    0xa48    .word 0xe0003c3c
    0xe0003a18    0xa4c    .word 0xe0003324
    0xe0003a1c    0xa50    .word 0xe0003c30
    0xe0003a20    0xa54    sub r3, r6, #1
    0xe0003a24    0xa58    cmp r3, #8
    0xe0003a28    0xa5c    ldrls pc, [pc, r3, lsl #2]
    0xe0003a2c    0xa60    b e00038b0 <create_initial_thread+0x8e4>
    0xe0003a30    0xa64    .word 0xe0003c0c
    0xe0003a34    0xa68    .word 0xe00038b0
    0xe0003a38    0xa6c    .word 0xe0003c0c
    0xe0003a3c    0xa70    .word 0xe00038b0
    0xe0003a40    0xa74    .word 0xe00031b8
    0xe0003a44    0xa78    .word 0xe00038b0
    0xe0003a48    0xa7c    .word 0xe0003cd0
    0xe0003a4c    0xa80    .word 0xe00038b0
    0xe0003a50    0xa84    .word 0xe0003cc0
    0xe0003a54    0xa88    sub r3, r2, #1
    0xe0003a58    0xa8c    cmp r3, #8
    0xe0003a5c    0xa90    ldrls pc, [pc, r3, lsl #2]
    0xe0003a60    0xa94    b e0003cf8 <create_initial_thread+0xd2c>
    0xe0003a64    0xa98    .word 0xe0003c8c
    0xe0003a68    0xa9c    .word 0xe0003cf8
    0xe0003a6c    0xaa0    .word 0xe0003c8c
    0xe0003a70    0xaa4    .word 0xe0003cf8
    0xe0003a74    0xaa8    .word 0xe000314c
    0xe0003a78    0xaac    .word 0xe0003cf8
    0xe0003a7c    0xab0    .word 0xe0003ce0
    0xe0003a80    0xab4    .word 0xe0003cf8
    0xe0003a84    0xab8    .word 0xe0003cb0
    0xe0003a88    0xabc    sub r3, r2, #1
    0xe0003a8c    0xac0    cmp r3, #8
    0xe0003a90    0xac4    ldrls pc, [pc, r3, lsl #2]
    0xe0003a94    0xac8    b e0003cf0 <create_initial_thread+0xd24>
    0xe0003a98    0xacc    .word 0xe0003c68
    0xe0003a9c    0xad0    .word 0xe0003cf0
    0xe0003aa0    0xad4    .word 0xe0003c68
    0xe0003aa4    0xad8    .word 0xe0003cf0
    0xe0003aa8    0xadc    .word 0xe00030e0
    0xe0003aac    0xae0    .word 0xe0003cf0
    0xe0003ab0    0xae4    .word 0xe0003bfc
    0xe0003ab4    0xae8    .word 0xe0003cf0
    0xe0003ab8    0xaec    .word 0xe0003bec
    0xe0003abc    0xaf0    lsr r2, r5, #8
    0xe0003ac0    0xaf4    and r3, r2, #63 
    0xe0003ac4    0xaf8    cmp r3, #32
    0xe0003ac8    0xafc    andne r3, r2, #31
    0xe0003acc    0xb00    addne r3, r3, #1
    0xe0003ad0    0xb04    mvnne r2, #0
    0xe0003ad4    0xb08    lslne r2, r2, r3
    0xe0003ad8    0xb0c    ldr r3, [sp, #4]      ; stack access
    0xe0003adc    0xb10    mvneq r2, #31
    0xe0003ae0    0xb14    and r2, r2, r3
    0xe0003ae4    0xb18    add r2, r2, #48 
    0xe0003ae8    0xb1c    b e0003154 <create_initial_thread+0x188>
    0xe0003aec    0xb20    lsr r2, r5, #8
    0xe0003af0    0xb24    and r3, r2, #63 
    0xe0003af4    0xb28    cmp r3, #32
    0xe0003af8    0xb2c    andne r3, r2, #31
    0xe0003afc    0xb30    addne r3, r3, #1
    0xe0003b00    0xb34    mvnne r2, #0
    0xe0003b04    0xb38    lslne r2, r2, r3
    0xe0003b08    0xb3c    ldr r3, [sp, #4]      ; stack access
    0xe0003b0c    0xb40    mvneq r2, #31
    0xe0003b10    0xb44    and r2, r2, r3
    0xe0003b14    0xb48    add r2, r2, #32
    0xe0003b18    0xb4c    b e00030e8 <create_initial_thread+0x11c>
    0xe0003b1c    0xb50    lsr r2, r5, #8
    0xe0003b20    0xb54    and r3, r2, #63 
    0xe0003b24    0xb58    cmp r3, #32
    0xe0003b28    0xb5c    andne r3, r2, #31
    0xe0003b2c    0xb60    addne r3, r3, #1
    0xe0003b30    0xb64    mvnne r2, #0
    0xe0003b34    0xb68    lslne r2, r2, r3
    0xe0003b38    0xb6c    ldr r3, [sp, #4]      ; stack access
    0xe0003b3c    0xb70    mvneq r2, #31
    0xe0003b40    0xb74    and r2, r2, r3
    0xe0003b44    0xb78    add r2, r2, #160 
    0xe0003b48    0xb7c    b e00031c0 <create_initial_thread+0x1f4>
    0xe0003b4c    0xb80    lsr r5, r5, #8
    0xe0003b50    0xb84    and r3, r5, #63 
    0xe0003b54    0xb88    cmp r3, #32
    0xe0003b58    0xb8c    andne r3, r5, #31
    0xe0003b5c    0xb90    addne r3, r3, #1
    0xe0003b60    0xb94    mvnne r5, #0
    0xe0003b64    0xb98    lslne r5, r5, r3
    0xe0003b68    0xb9c    ldr r3, [sp, #4]      ; stack access
    0xe0003b6c    0xba0    mvneq r5, #31
    0xe0003b70    0xba4    and r5, r5, r3
    0xe0003b74    0xba8    b e0003300 <create_initial_thread+0x334>
    0xe0003b78    0xbac    mov r3, #0
    0xe0003b7c    0xbb0    str r3, [sp]          ; stack access
    0xe0003b80    0xbb4    ldr r0, [sp]          ; stack access
    0xe0003b84    0xbb8    add sp, sp, #44 
    0xe0003b88    0xbbc    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0003b8c    0xbc0    mov r0, r4
    0xe0003b90    0xbc4    bl e0013114 <setThreadState.part.166>
    0xe0003b94    0xbc8    ldr r2, [r7]
    0xe0003b98    0xbcc    lsl r2, r2, #3
    0xe0003b9c    0xbd0    add r3, r6, r2
    0xe0003ba0    0xbd4    ldr r1, [r3, #112] 
    0xe0003ba4    0xbd8    b e0003284 <create_initial_thread+0x2b8>
    0xe0003ba8    0xbdc    cmp r3, #1
    0xe0003bac    0xbe0    beq e0003d00 <create_initial_thread+0xd34>
    0xe0003bb0    0xbe4    cmp r3, #3
    0xe0003bb4    0xbe8    bne e000387c <create_initial_thread+0x8b0>
    0xe0003bb8    0xbec    mov r3, #49152 
    0xe0003bbc    0xbf0    movt r3, #65535 
    0xe0003bc0    0xbf4    and r3, r3, r5, lsl #10
    0xe0003bc4    0xbf8    add r1, r3, #160 
    0xe0003bc8    0xbfc    b e0003070 <create_initial_thread+0xa4>
    0xe0003bcc    0xc00    bic r1, r5, #16320 
    0xe0003bd0    0xc04    bic r1, r1, #63 
    0xe0003bd4    0xc08    add r1, r1, #160 
    0xe0003bd8    0xc0c    b e0003070 <create_initial_thread+0xa4>
    0xe0003bdc    0xc10    bic r1, r5, #1020 
    0xe0003be0    0xc14    bic r1, r1, #3
    0xe0003be4    0xc18    add r1, r1, #160 
    0xe0003be8    0xc1c    b e0003070 <create_initial_thread+0xa4>
    0xe0003bec    0xc20    bic r2, r5, #16320 
    0xe0003bf0    0xc24    bic r2, r2, #63 
    0xe0003bf4    0xc28    add r2, r2, #32
    0xe0003bf8    0xc2c    b e00030e8 <create_initial_thread+0x11c>
    0xe0003bfc    0xc30    bic r2, r5, #1020 
    0xe0003c00    0xc34    bic r2, r2, #3
    0xe0003c04    0xc38    add r2, r2, #32
    0xe0003c08    0xc3c    b e00030e8 <create_initial_thread+0x11c>
    0xe0003c0c    0xc40    cmp r6, #1
    0xe0003c10    0xc44    beq e0003d14 <create_initial_thread+0xd48>
    0xe0003c14    0xc48    cmp r6, #3
    0xe0003c18    0xc4c    bne e00038b0 <create_initial_thread+0x8e4>
    0xe0003c1c    0xc50    mov r3, #49152 
    0xe0003c20    0xc54    movt r3, #65535 
    0xe0003c24    0xc58    and r3, r3, r5, lsl #10
    0xe0003c28    0xc5c    add r2, r3, #160 
    0xe0003c2c    0xc60    b e00031c0 <create_initial_thread+0x1f4>
    0xe0003c30    0xc64    bic r5, r5, #16320 
    0xe0003c34    0xc68    bic r5, r5, #63 
    0xe0003c38    0xc6c    b e0003300 <create_initial_thread+0x334>
    0xe0003c3c    0xc70    bic r5, r5, #1020 
    0xe0003c40    0xc74    bic r5, r5, #3
    0xe0003c44    0xc78    b e0003300 <create_initial_thread+0x334>
    0xe0003c48    0xc7c    cmp r3, #1
    0xe0003c4c    0xc80    beq e0003d30 <create_initial_thread+0xd64>
    0xe0003c50    0xc84    cmp r3, #3
    0xe0003c54    0xc88    bne e0003d28 <create_initial_thread+0xd5c>
    0xe0003c58    0xc8c    mov r3, #49152 
    0xe0003c5c    0xc90    movt r3, #65535 
    0xe0003c60    0xc94    and r5, r3, r5, lsl #10
    0xe0003c64    0xc98    b e0003300 <create_initial_thread+0x334>
    0xe0003c68    0xc9c    cmp r2, #1
    0xe0003c6c    0xca0    beq e0003d54 <create_initial_thread+0xd88>
    0xe0003c70    0xca4    cmp r2, #3
    0xe0003c74    0xca8    bne e0003cf0 <create_initial_thread+0xd24>
    0xe0003c78    0xcac    mov r3, #49152 
    0xe0003c7c    0xcb0    movt r3, #65535 
    0xe0003c80    0xcb4    and r3, r3, r5, lsl #10
    0xe0003c84    0xcb8    add r2, r3, #32
    0xe0003c88    0xcbc    b e00030e8 <create_initial_thread+0x11c>
    0xe0003c8c    0xcc0    cmp r2, #1
    0xe0003c90    0xcc4    beq e0003d40 <create_initial_thread+0xd74>
    0xe0003c94    0xcc8    cmp r2, #3
    0xe0003c98    0xccc    bne e0003cf8 <create_initial_thread+0xd2c>
    0xe0003c9c    0xcd0    mov r3, #49152 
    0xe0003ca0    0xcd4    movt r3, #65535 
    0xe0003ca4    0xcd8    and r3, r3, r5, lsl #10
    0xe0003ca8    0xcdc    add r2, r3, #48 
    0xe0003cac    0xce0    b e0003154 <create_initial_thread+0x188>
    0xe0003cb0    0xce4    bic r2, r5, #16320 
    0xe0003cb4    0xce8    bic r2, r2, #63 
    0xe0003cb8    0xcec    add r2, r2, #48 
    0xe0003cbc    0xcf0    b e0003154 <create_initial_thread+0x188>
    0xe0003cc0    0xcf4    bic r2, r5, #16320 
    0xe0003cc4    0xcf8    bic r2, r2, #63 
    0xe0003cc8    0xcfc    add r2, r2, #160 
    0xe0003ccc    0xd00    b e00031c0 <create_initial_thread+0x1f4>
    0xe0003cd0    0xd04    bic r2, r5, #1020 
    0xe0003cd4    0xd08    bic r2, r2, #3
    0xe0003cd8    0xd0c    add r2, r2, #160 
    0xe0003cdc    0xd10    b e00031c0 <create_initial_thread+0x1f4>
    0xe0003ce0    0xd14    bic r2, r5, #1020 
    0xe0003ce4    0xd18    bic r2, r2, #3
    0xe0003ce8    0xd1c    add r2, r2, #48 
    0xe0003cec    0xd20    b e0003154 <create_initial_thread+0x188>
    0xe0003cf0    0xd24    mov r2, #32
    0xe0003cf4    0xd28    b e00030e8 <create_initial_thread+0x11c>
    0xe0003cf8    0xd2c    mov r2, #48 
    0xe0003cfc    0xd30    b e0003154 <create_initial_thread+0x188>
    0xe0003d00    0xd34    mov r3, #61440 
    0xe0003d04    0xd38    movt r3, #65535 
    0xe0003d08    0xd3c    and r3, r3, r5, lsl #8
    0xe0003d0c    0xd40    add r1, r3, #160 
    0xe0003d10    0xd44    b e0003070 <create_initial_thread+0xa4>
    0xe0003d14    0xd48    mov r3, #61440 
    0xe0003d18    0xd4c    movt r3, #65535 
    0xe0003d1c    0xd50    and r3, r3, r5, lsl #8
    0xe0003d20    0xd54    add r2, r3, #160 
    0xe0003d24    0xd58    b e00031c0 <create_initial_thread+0x1f4>
    0xe0003d28    0xd5c    mov r5, #0
    0xe0003d2c    0xd60    b e0003300 <create_initial_thread+0x334>
    0xe0003d30    0xd64    mov r3, #61440 
    0xe0003d34    0xd68    movt r3, #65535 
    0xe0003d38    0xd6c    and r5, r3, r5, lsl #8
    0xe0003d3c    0xd70    b e0003300 <create_initial_thread+0x334>
    0xe0003d40    0xd74    mov r3, #61440 
    0xe0003d44    0xd78    movt r3, #65535 
    0xe0003d48    0xd7c    and r3, r3, r5, lsl #8
    0xe0003d4c    0xd80    add r2, r3, #48 
    0xe0003d50    0xd84    b e0003154 <create_initial_thread+0x188>
    0xe0003d54    0xd88    mov r3, #61440 
    0xe0003d58    0xd8c    movt r3, #65535 
    0xe0003d5c    0xd90    and r3, r3, r5, lsl #8
    0xe0003d60    0xd94    add r2, r3, #32
    0xe0003d64    0xd98    b e00030e8 <create_initial_thread+0x11c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
456 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `create_initial_thread` has 1890 nodes.

Section map_kernel_devices (269 of 299)
=======================================

Deriving specifications
-----------------------

Section `map_kernel_devices` consists of 34 instructions.
 LDMIA;8,3,1....++


Stack analysis
---------------

5 stack accesses found. Annotated code for `map_kernel_devices`:

    0xe0000d40     0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0000d44     0x4    mov r1, #4096 
    0xe0000d48     0x8    ldr r4, [pc, #116] 
    0xe0000d4c     0xc    sub sp, sp, #8
    0xe0000d50    0x10    mov r5, r1
    0xe0000d54    0x14    movt r1, #65520 
    0xe0000d58    0x18    add r6, r4, #32
    0xe0000d5c    0x1c    movt r5, #160 
    0xe0000d60    0x20    mov r7, sp
    0xe0000d64    0x24    mov r8, #0
    0xe0000d68    0x28    mov r3, #1
    0xe0000d6c    0x2c    lsl r3, r3, #2
    0xe0000d70    0x30    mov r2, #1
    0xe0000d74    0x34    and r3, r3, #4
    0xe0000d78    0x38    mov r0, r5
    0xe0000d7c    0x3c    bl e0000374 <map_kernel_frame>
    0xe0000d80    0x40    cmp r8, #0
    0xe0000d84    0x44    beq e0000dac <map_kernel_devices+0x6c>
    0xe0000d88    0x48    cmp r6, r4
    0xe0000d8c    0x4c    beq e0000da4 <map_kernel_devices+0x64>
    0xe0000d90    0x50    add r1, r4, #20
    0xe0000d94    0x54    ldr r5, [r4, #16]
    0xe0000d98    0x58    add r4, r4, #16
    0xe0000d9c    0x5c    ldm r1, {r1, r3, r8}
    0xe0000da0    0x60    b e0000d6c <map_kernel_devices+0x2c>
    0xe0000da4    0x64    add sp, sp, #8
    0xe0000da8    0x68    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0000dac    0x6c    str r5, [sp]          ; stack access
    0xe0000db0    0x70    add r5, r5, #4096 
    0xe0000db4    0x74    str r5, [sp, #4]      ; stack access
    0xe0000db8    0x78    ldm r7, {r0, r1}      ; stack access
    0xe0000dbc    0x7c    bl e0000bd8 <reserve_region>
    0xe0000dc0    0x80    b e0000d88 <map_kernel_devices+0x48>
    0xe0000dc4    0x84    .word 0xe0004450

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
33 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `map_kernel_devices` has 46 nodes.

Section _start (270 of 299)
===========================

Deriving specifications
-----------------------

Section `_start` consists of 24 instructions.
 LDMIA (wb);8,7.+
 MSR (cpsr, reg, control).+
Skipping ee114f10 mrc 15, 0, r4, cr1, cr0, {0}
 BIC (reg)..........+++++
Skipping ee014f10 mcr 15, 0, r4, cr1, cr0, {0}
 STMDB (wb);8,7,3,2,1,0..+
 LDMIA (wb);8,7,3,2,1,0.+
Skipping f1020017 cps #23
Skipping f1020013 cps #19
 STMDB (wb);8,7..+


Stack analysis
---------------

1 stack accesses found. Annotated code for `_start`:

    0xe0000000     0x0    pop {r7, r8}          ; stack access
    0xe0000004     0x4    ldr r5, [pc, #64] 
    0xe0000008     0x8    msr CPSR_fc, r5
    0xe000000c     0xc    mrc 15, 0, r4, cr1, cr0, {0}
    0xe0000010    0x10    ldr r5, [pc, #56] 
    0xe0000014    0x14    ldr r6, [pc, #56] 
    0xe0000018    0x18    orr r4, r4, r5
    0xe000001c    0x1c    bic r4, r4, r6
    0xe0000020    0x20    mcr 15, 0, r4, cr1, cr0, {0}
    0xe0000024    0x24    ldr sp, [pc, #44] 
    0xe0000028    0x28    push {r0, r1, r2, r3, r7, r8}
    0xe000002c    0x2c    bl e0000a94 <arm_errata>
    0xe0000030    0x30    pop {r0, r1, r2, r3, r7, r8}
    0xe0000034    0x34    cps #23
    0xe0000038    0x38    ldr sp, [pc, #28] 
    0xe000003c    0x3c    cps #19
    0xe0000040    0x40    push {r7, r8}
    0xe0000044    0x44    bl e0003d68 <init_kernel>
    0xe0000048    0x48    b e0010a10 <restore_user_context>
    0xe000004c    0x4c    .word 0x000001d3
    0xe0000050    0x50    .word 0x00c03805
    0xe0000054    0x54    .word 0x33004382
    0xe0000058    0x58    .word 0xe0029010
    0xe000005c    0x5c    .word 0xe001c7b8

Proving inst theorems
---------------------

Graph spec failed in _start for pos 0xe0000008.
18 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `_start` has 29 nodes.

Section decodeSetIPCBuffer (271 of 299)
=======================================

Deriving specifications
-----------------------

Section `decodeSetIPCBuffer` consists of 76 instructions.


Stack analysis
---------------

26 stack accesses found. Annotated code for `decodeSetIPCBuffer`:

    0xe0019650      0x0    push {r4, r5, r6, r7, r8, r9, lr}  ; stack access
    0xe0019654      0x4    sub sp, sp, #84 
    0xe0019658      0x8    add ip, sp, #48 
    0xe001965c      0xc    ldr r4, [sp, #112]    ; stack access
    0xe0019660     0x10    stm ip, {r0, r1}      ; stack access
    0xe0019664     0x14    cmp r2, #0
    0xe0019668     0x18    cmpne r4, #0
    0xe001966c     0x1c    beq e0019764 <decodeSetIPCBuffer+0x114>
    0xe0019670     0x20    movw r7, #13900 
    0xe0019674     0x24    movt r7, #57347 
    0xe0019678     0x28    mov r6, r3
    0xe001967c     0x2c    ldm r4, {r0, r1}
    0xe0019680     0x30    ldr r3, [r7]
    0xe0019684     0x34    add r5, sp, #60 
    0xe0019688     0x38    add r8, sp, #68 
    0xe001968c     0x3c    stm r5, {r0, r1}      ; stack access
    0xe0019690     0x40    ldr r9, [r3, #8]
    0xe0019694     0x44    cmp r9, #0
    0xe0019698     0x48    bne e0019720 <decodeSetIPCBuffer+0xd0>
    0xe001969c     0x4c    mov r4, r9
    0xe00196a0     0x50    ldr r2, [r3, #80] 
    0xe00196a4     0x54    mov r0, r3
    0xe00196a8     0x58    bic r2, r2, #15
    0xe00196ac     0x5c    orr r2, r2, #2
    0xe00196b0     0x60    str r2, [r3, #80] 
    0xe00196b4     0x64    bl e0013114 <setThreadState.part.166>
    0xe00196b8     0x68    ldm r5, {r0, r1}      ; stack access
    0xe00196bc     0x6c    add r3, sp, #32
    0xe00196c0     0x70    mov ip, #0
    0xe00196c4     0x74    str r4, [sp, #40]     ; stack access
    0xe00196c8     0x78    mov r2, #2
    0xe00196cc     0x7c    str r2, [sp, #44]     ; stack access
    0xe00196d0     0x80    add lr, sp, #16
    0xe00196d4     0x84    stm r3, {r0, r1}      ; stack access
    0xe00196d8     0x88    mov r2, ip
    0xe00196dc     0x8c    str ip, [sp, #68]     ; stack access
    0xe00196e0     0x90    mov r3, ip
    0xe00196e4     0x94    str ip, [sp, #72]     ; stack access
    0xe00196e8     0x98    ldm r8, {r0, r1}      ; stack access
    0xe00196ec     0x9c    str r9, [sp, #28]     ; stack access
    0xe00196f0     0xa0    str ip, [sp, #24]     ; stack access
    0xe00196f4     0xa4    stm lr, {r0, r1}      ; stack access
    0xe00196f8     0xa8    ldm r8, {r0, r1}      ; stack access
    0xe00196fc     0xac    ldr lr, [sp, #48]     ; stack access
    0xe0019700     0xb0    str ip, [sp, #12]     ; stack access
    0xe0019704     0xb4    stmib sp, {r0, r1}    ; stack access
    0xe0019708     0xb8    mov r1, r6
    0xe001970c     0xbc    str ip, [sp]          ; stack access
    0xe0019710     0xc0    bic r0, lr, #15
    0xe0019714     0xc4    bl e0018d60 <invokeTCB_ThreadControl>
    0xe0019718     0xc8    add sp, sp, #84 
    0xe001971c     0xcc    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access
    0xe0019720     0xd0    mov r0, r8
    0xe0019724     0xd4    ldm r5, {r2, r3}      ; stack access
    0xe0019728     0xd8    mov r1, r4
    0xe001972c     0xdc    bl e0014bf4 <deriveCap>
    0xe0019730     0xe0    ldr r0, [sp, #68]     ; stack access
    0xe0019734     0xe4    cmp r0, #0
    0xe0019738     0xe8    bne e0019718 <decodeSetIPCBuffer+0xc8>
    0xe001973c     0xec    add r3, sp, #80 
    0xe0019740     0xf0    ldmdb r3, {r0, r1}    ; stack access
    0xe0019744     0xf4    stm r5, {r0, r1}      ; stack access
    0xe0019748     0xf8    mov r0, r9
    0xe001974c     0xfc    ldm r5, {r1, r2}      ; stack access
    0xe0019750    0x100    bl e0010ffc <checkValidIPCBuffer>
    0xe0019754    0x104    cmp r0, #0
    0xe0019758    0x108    ldreq r3, [r7]
    0xe001975c    0x10c    beq e00196a0 <decodeSetIPCBuffer+0x50>
    0xe0019760    0x110    b e0019718 <decodeSetIPCBuffer+0xc8>
    0xe0019764    0x114    movw r3, #36896 
    0xe0019768    0x118    movt r3, #57346 
    0xe001976c    0x11c    mov r2, #7
    0xe0019770    0x120    mov r0, #3
    0xe0019774    0x124    str r2, [r3, #24]
    0xe0019778    0x128    add sp, sp, #84 
    0xe001977c    0x12c    pop {r4, r5, r6, r7, r8, r9, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
76 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetIPCBuffer` has 125 nodes.

Section handleVMFaultEvent (272 of 299)
=======================================

Deriving specifications
-----------------------

Section `handleVMFaultEvent` consists of 14 instructions.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleVMFaultEvent`:

    0xe00185bc     0x0    push {r4, lr}         ; stack access
    0xe00185c0     0x4    movw r4, #13900 
    0xe00185c4     0x8    movt r4, #57347 
    0xe00185c8     0xc    mov r1, r0
    0xe00185cc    0x10    ldr r0, [r4]
    0xe00185d0    0x14    bl e001144c <handleVMFault>
    0xe00185d4    0x18    cmp r0, #0
    0xe00185d8    0x1c    beq e00185e4 <handleVMFaultEvent+0x28>
    0xe00185dc    0x20    ldr r0, [r4]
    0xe00185e0    0x24    bl e0018508 <handleFault>
    0xe00185e4    0x28    bl e00165a8 <schedule>
    0xe00185e8    0x2c    bl e001319c <activateThread>
    0xe00185ec    0x30    mov r0, #0
    0xe00185f0    0x34    pop {r4, pc}          ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
14 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleVMFaultEvent` has 24 nodes.

Section doNormalTransfer (273 of 299)
=====================================

Deriving specifications
-----------------------

Section `doNormalTransfer` consists of 166 instructions.
 BICHI (imm)....+++
 ORRHI (reg)...........++++++
 LDMIA;2,1,0....++
 STMIA;2,1,0....+


Stack analysis
---------------

27 stack accesses found. Annotated code for `doNormalTransfer`:

    0xe0017d50      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0017d54      0x4    sub sp, sp, #60 
    0xe0017d58      0x8    ldr r4, [r0, #4]
    0xe0017d5c      0xc    mov r9, r0
    0xe0017d60     0x10    ldr ip, [sp, #96]     ; stack access
    0xe0017d64     0x14    mov r7, r1
    0xe0017d68     0x18    and r5, r4, #127 
    0xe0017d6c     0x1c    mov fp, r2
    0xe0017d70     0x20    cmp r5, #120 
    0xe0017d74     0x24    mov sl, r3
    0xe0017d78     0x28    bichi r4, r4, #127 
    0xe0017d7c     0x2c    ldr r6, [sp, #100]    ; stack access
    0xe0017d80     0x30    movhi r5, #120 
    0xe0017d84     0x34    orrhi r4, r4, r5
    0xe0017d88     0x38    cmp ip, #0
    0xe0017d8c     0x3c    ldr r8, [sp, #104]    ; stack access
    0xe0017d90     0x40    bne e0017f58 <doNormalTransfer+0x208>
    0xe0017d94     0x44    movw r2, #36924 
    0xe0017d98     0x48    movt r2, #57346 
    0xe0017d9c     0x4c    add r3, sp, #20
    0xe0017da0     0x50    cmp r5, #0
    0xe0017da4     0x54    ldm r2, {r0, r1, r2}
    0xe0017da8     0x58    stm r3, {r0, r1, r2}  ; stack access
    0xe0017dac     0x5c    beq e0017f88 <doNormalTransfer+0x238>
    0xe0017db0     0x60    ldr lr, [pc, #556] 
    0xe0017db4     0x64    mov r1, #2
    0xe0017db8     0x68    mov r2, #0
    0xe0017dbc     0x6c    add r2, r2, #1
    0xe0017dc0     0x70    ldr r0, [r9, r1, lsl #2]
    0xe0017dc4     0x74    cmp r2, #3
    0xe0017dc8     0x78    cmpls r2, r5
    0xe0017dcc     0x7c    str r0, [r6, r1, lsl #2]
    0xe0017dd0     0x80    ldrcc r1, [lr, r2, lsl #2]
    0xe0017dd4     0x84    bcc e0017dbc <doNormalTransfer+0x6c>
    0xe0017dd8     0x88    clz lr, r8
    0xe0017ddc     0x8c    cmp r8, #0
    0xe0017de0     0x90    cmpne r7, #0
    0xe0017de4     0x94    bic r4, r4, #3968 
    0xe0017de8     0x98    lsr lr, lr, #5
    0xe0017dec     0x9c    beq e0017e50 <doNormalTransfer+0x100>
    0xe0017df0     0xa0    cmp r2, r5
    0xe0017df4     0xa4    movcs r5, r2
    0xe0017df8     0xa8    bcs e0017e1c <doNormalTransfer+0xcc>
    0xe0017dfc     0xac    lsl r2, r2, #2
    0xe0017e00     0xb0    add r0, r7, r5, lsl #2
    0xe0017e04     0xb4    add r7, r7, r2
    0xe0017e08     0xb8    add r2, r8, r2
    0xe0017e0c     0xbc    ldr r1, [r7, #4]!
    0xe0017e10     0xc0    cmp r0, r7
    0xe0017e14     0xc4    str r1, [r2, #4]!
    0xe0017e18     0xc8    bne e0017e0c <doNormalTransfer+0xbc>
    0xe0017e1c     0xcc    str ip, [sp, #20]     ; stack access
    0xe0017e20     0xd0    add r7, sp, #32
    0xe0017e24     0xd4    ldm r3, {r0, r1, r2}  ; stack access
    0xe0017e28     0xd8    cmp r0, #0
    0xe0017e2c     0xdc    stm r7, {r0, r1, r2}  ; stack access
    0xe0017e30     0xe0    mov r9, r0
    0xe0017e34     0xe4    bne e0017e78 <doNormalTransfer+0x128>
    0xe0017e38     0xe8    bic r4, r4, #127 
    0xe0017e3c     0xec    str sl, [r6]
    0xe0017e40     0xf0    orr r5, r4, r5
    0xe0017e44     0xf4    str r5, [r6, #4]
    0xe0017e48     0xf8    add sp, sp, #60 
    0xe0017e4c     0xfc    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0017e50    0x100    mov r5, r2
    0xe0017e54    0x104    str ip, [sp, #20]     ; stack access
    0xe0017e58    0x108    add r7, sp, #32
    0xe0017e5c    0x10c    ldm r3, {r0, r1, r2}  ; stack access
    0xe0017e60    0x110    cmp r0, #0
    0xe0017e64    0x114    stm r7, {r0, r1, r2}  ; stack access
    0xe0017e68    0x118    moveq lr, #1
    0xe0017e6c    0x11c    cmp lr, #0
    0xe0017e70    0x120    mov r9, r0
    0xe0017e74    0x124    bne e0017e38 <doNormalTransfer+0xe8>
    0xe0017e78    0x128    mov r0, r6
    0xe0017e7c    0x12c    mov r1, r8
    0xe0017e80    0x130    bl e0013878 <getReceiveSlots>
    0xe0017e84    0x134    mov r3, #0
    0xe0017e88    0x138    str r5, [sp, #4]      ; stack access
    0xe0017e8c    0x13c    mov r5, r3
    0xe0017e90    0x140    str r6, [sp, #100]    ; stack access
    0xe0017e94    0x144    mov r6, r0
    0xe0017e98    0x148    ldm r9, {r0, r1}
    0xe0017e9c    0x14c    and r2, r0, #14
    0xe0017ea0    0x150    cmp r2, #14
    0xe0017ea4    0x154    add r2, sp, #12
    0xe0017ea8    0x158    mov r3, r0
    0xe0017eac    0x15c    stm r2, {r0, r1}      ; stack access
    0xe0017eb0    0x160    mov r2, r1
    0xe0017eb4    0x164    andne r1, r0, #15
    0xe0017eb8    0x168    uxtbeq r1, r0
    0xe0017ebc    0x16c    cmp r1, #4
    0xe0017ec0    0x170    beq e0017fa4 <doNormalTransfer+0x254>
    0xe0017ec4    0x174    cmp r6, #0
    0xe0017ec8    0x178    beq e0017f40 <doNormalTransfer+0x1f0>
    0xe0017ecc    0x17c    str r3, [sp, #12]     ; stack access
    0xe0017ed0    0x180    add r3, sp, #12
    0xe0017ed4    0x184    str r2, [sp, #16]     ; stack access
    0xe0017ed8    0x188    mov r1, r9
    0xe0017edc    0x18c    ldm r3, {r2, r3}      ; stack access
    0xe0017ee0    0x190    add r0, sp, #44 
    0xe0017ee4    0x194    bl e0014bf4 <deriveCap>
    0xe0017ee8    0x198    ldr r3, [sp, #44]     ; stack access
    0xe0017eec    0x19c    cmp r3, #0
    0xe0017ef0    0x1a0    bne e0017f40 <doNormalTransfer+0x1f0>
    0xe0017ef4    0x1a4    ldr r3, [sp, #48]     ; stack access
    0xe0017ef8    0x1a8    and r2, r3, #14
    0xe0017efc    0x1ac    cmp r2, #14
    0xe0017f00    0x1b0    andne r3, r3, #15
    0xe0017f04    0x1b4    uxtbeq r3, r3
    0xe0017f08    0x1b8    cmp r3, #0
    0xe0017f0c    0x1bc    beq e0017f40 <doNormalTransfer+0x1f0>
    0xe0017f10    0x1c0    add r1, sp, #48 
    0xe0017f14    0x1c4    mov r3, r6
    0xe0017f18    0x1c8    mov r2, r9
    0xe0017f1c    0x1cc    mov r6, #0
    0xe0017f20    0x1d0    ldm r1, {r0, r1}      ; stack access
    0xe0017f24    0x1d4    bl e0013308 <cteInsert>
    0xe0017f28    0x1d8    add r5, r5, #1
    0xe0017f2c    0x1dc    cmp r5, #3
    0xe0017f30    0x1e0    beq e0017fd4 <doNormalTransfer+0x284>
    0xe0017f34    0x1e4    ldr r9, [r7, r5, lsl #2]  ; stack access
    0xe0017f38    0x1e8    cmp r9, #0
    0xe0017f3c    0x1ec    bne e0017e98 <doNormalTransfer+0x148>
    0xe0017f40    0x1f0    mov r3, r5
    0xe0017f44    0x1f4    ldr r6, [sp, #100]    ; stack access
    0xe0017f48    0x1f8    ldr r5, [sp, #4]      ; stack access
    0xe0017f4c    0x1fc    lsl r3, r3, #7
    0xe0017f50    0x200    orr r4, r4, r3
    0xe0017f54    0x204    b e0017e38 <doNormalTransfer+0xe8>
    0xe0017f58    0x208    mov r2, r4
    0xe0017f5c    0x20c    bl e0017c8c <lookupExtraCaps>
    0xe0017f60    0x210    movw r2, #36924 
    0xe0017f64    0x214    movt r2, #57346 
    0xe0017f68    0x218    add r3, sp, #20
    0xe0017f6c    0x21c    cmp r0, #0
    0xe0017f70    0x220    ldm r2, {r0, r1, r2}
    0xe0017f74    0x224    movne ip, #0
    0xe0017f78    0x228    moveq ip, r0
    0xe0017f7c    0x22c    cmp r5, #0
    0xe0017f80    0x230    stm r3, {r0, r1, r2}  ; stack access
    0xe0017f84    0x234    bne e0017db0 <doNormalTransfer+0x60>
    0xe0017f88    0x238    clz lr, r8
    0xe0017f8c    0x23c    cmp r8, #0
    0xe0017f90    0x240    cmpne r7, #0
    0xe0017f94    0x244    bic r4, r4, #3968 
    0xe0017f98    0x248    lsr lr, lr, #5
    0xe0017f9c    0x24c    beq e0017e54 <doNormalTransfer+0x104>
    0xe0017fa0    0x250    b e0017e1c <doNormalTransfer+0xcc>
    0xe0017fa4    0x254    bic r1, r2, #15
    0xe0017fa8    0x258    cmp fp, r1
    0xe0017fac    0x25c    bne e0017ec4 <doNormalTransfer+0x174>
    0xe0017fb0    0x260    ubfx r2, r4, #9, #3
    0xe0017fb4    0x264    mov r0, #1
    0xe0017fb8    0x268    add r1, r8, r5, lsl #2
    0xe0017fbc    0x26c    orr r2, r2, r0, lsl r5
    0xe0017fc0    0x270    bic r4, r4, #3584 
    0xe0017fc4    0x274    lsr r3, r3, #4
    0xe0017fc8    0x278    orr r4, r4, r2, lsl #9
    0xe0017fcc    0x27c    str r3, [r1, #488] 
    0xe0017fd0    0x280    b e0017f28 <doNormalTransfer+0x1d8>
    0xe0017fd4    0x284    ldr r5, [sp, #4]      ; stack access
    0xe0017fd8    0x288    mov r3, #384 
    0xe0017fdc    0x28c    ldr r6, [sp, #100]    ; stack access
    0xe0017fe0    0x290    b e0017f50 <doNormalTransfer+0x200>
    0xe0017fe4    0x294    .word 0xe001b428

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
165 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doNormalTransfer` has 272 nodes.

Section restart (274 of 299)
============================

Deriving specifications
-----------------------

Section `restart` consists of 49 instructions.
 BXHI..++


Stack analysis
---------------

2 stack accesses found. Annotated code for `restart`:

    0xe0017514     0x0    ldr r3, [r0, #80] 
    0xe0017518     0x4    and r3, r3, #15
    0xe001751c     0x8    cmp r3, #6
    0xe0017520     0xc    bxhi lr
    0xe0017524    0x10    mov r1, #1
    0xe0017528    0x14    lsl r3, r1, r3
    0xe001752c    0x18    tst r3, #121 
    0xe0017530    0x1c    bxeq lr
    0xe0017534    0x20    push {r4, lr}         ; stack access
    0xe0017538    0x24    mov r4, r0
    0xe001753c    0x28    bl e0017438 <cancelIPC>
    0xe0017540    0x2c    bic r2, r4, #508 
    0xe0017544    0x30    bic r2, r2, #3
    0xe0017548    0x34    add r0, r2, #32
    0xe001754c    0x38    ldr r3, [r2, #32]
    0xe0017550    0x3c    and r1, r3, #14
    0xe0017554    0x40    cmp r1, #14
    0xe0017558    0x44    andne r3, r3, #15
    0xe001755c    0x48    uxtbeq r3, r3
    0xe0017560    0x4c    cmp r3, #0
    0xe0017564    0x50    bne e0017584 <restart+0x70>
    0xe0017568    0x54    bic r1, r4, #63 
    0xe001756c    0x58    mov ip, #3
    0xe0017570    0x5c    orr r1, r1, #56 
    0xe0017574    0x60    str r1, [r2, #32]
    0xe0017578    0x64    str r3, [r0, #4]
    0xe001757c    0x68    str r3, [r0, #8]
    0xe0017580    0x6c    str ip, [r0, #12]
    0xe0017584    0x70    movw r2, #13900 
    0xe0017588    0x74    movt r2, #57347 
    0xe001758c    0x78    ldr r3, [r4, #80] 
    0xe0017590    0x7c    ldr r2, [r2]
    0xe0017594    0x80    bic r3, r3, #15
    0xe0017598    0x84    cmp r4, r2
    0xe001759c    0x88    orr r3, r3, #2
    0xe00175a0    0x8c    str r3, [r4, #80] 
    0xe00175a4    0x90    beq e00175cc <restart+0xb8>
    0xe00175a8    0x94    ldr r3, [r4, #84] 
    0xe00175ac    0x98    tst r3, #1
    0xe00175b0    0x9c    beq e00175c0 <restart+0xac>
    0xe00175b4    0xa0    mov r0, r4
    0xe00175b8    0xa4    pop {r4, lr}          ; stack access
    0xe00175bc    0xa8    b e00131ec <possibleSwitchTo>
    0xe00175c0    0xac    mov r0, r4
    0xe00175c4    0xb0    bl e00107d8 <tcbSchedEnqueue.part.164>
    0xe00175c8    0xb4    b e00175b4 <restart+0xa0>
    0xe00175cc    0xb8    mov r0, r4
    0xe00175d0    0xbc    bl e0013114 <setThreadState.part.166>
    0xe00175d4    0xc0    b e00175a8 <restart+0x94>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
49 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `restart` has 81 nodes.

Section decodeIRQControlInvocation (275 of 299)
===============================================

Deriving specifications
-----------------------

Section `decodeIRQControlInvocation` consists of 106 instructions.
 LDMIA;7,2...+


Stack analysis
---------------

17 stack accesses found. Annotated code for `decodeIRQControlInvocation`:

    0xe0013d6c      0x0    sub sp, sp, #8
    0xe0013d70      0x4    cmp r0, #25
    0xe0013d74      0x8    mov ip, r1
    0xe0013d78      0xc    push {r4, r5, r6, r7, lr}  ; stack access
    0xe0013d7c     0x10    sub sp, sp, #36 
    0xe0013d80     0x14    str r3, [sp, #60]     ; stack access
    0xe0013d84     0x18    ldr r1, [sp, #72]     ; stack access
    0xe0013d88     0x1c    bne e0013dc4 <decodeIRQControlInvocation+0x58>
    0xe0013d8c     0x20    cmp r3, #0
    0xe0013d90     0x24    cmpne ip, #2
    0xe0013d94     0x28    movls ip, #1
    0xe0013d98     0x2c    movhi ip, #0
    0xe0013d9c     0x30    bhi e0013df4 <decodeIRQControlInvocation+0x88>
    0xe0013da0     0x34    movw r3, #36896 
    0xe0013da4     0x38    movt r3, #57346 
    0xe0013da8     0x3c    mov r0, #3
    0xe0013dac     0x40    mov r2, #7
    0xe0013db0     0x44    str r2, [r3, #24]
    0xe0013db4     0x48    add sp, sp, #36 
    0xe0013db8     0x4c    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0013dbc     0x50    add sp, sp, #8
    0xe0013dc0     0x54    bx lr
    0xe0013dc4     0x58    mov lr, r0
    0xe0013dc8     0x5c    add r0, sp, #64 
    0xe0013dcc     0x60    str r1, [sp, #8]      ; stack access
    0xe0013dd0     0x64    ldm r0, {r0, r1}      ; stack access
    0xe0013dd4     0x68    stm sp, {r0, r1}      ; stack access
    0xe0013dd8     0x6c    mov r1, ip
    0xe0013ddc     0x70    mov r0, lr
    0xe0013de0     0x74    bl e0013ba0 <Arch_decodeIRQControlInvocation>
    0xe0013de4     0x78    add sp, sp, #36 
    0xe0013de8     0x7c    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0013dec     0x80    add sp, sp, #8
    0xe0013df0     0x84    bx lr
    0xe0013df4     0x88    movw r5, #13900 
    0xe0013df8     0x8c    movt r5, #57347 
    0xe0013dfc     0x90    ldr lr, [r5]
    0xe0013e00     0x94    ldr r6, [lr, #8]
    0xe0013e04     0x98    cmp r6, #159 
    0xe0013e08     0x9c    bhi e0013e48 <decodeIRQControlInvocation+0xdc>
    0xe0013e0c     0xa0    mov r4, r2
    0xe0013e10     0xa4    movw r2, #36936 
    0xe0013e14     0xa8    movt r2, #57346 
    0xe0013e18     0xac    ldr r1, [r2, r6, lsl #2]
    0xe0013e1c     0xb0    cmp r1, #0
    0xe0013e20     0xb4    beq e0013e6c <decodeIRQControlInvocation+0x100>
    0xe0013e24     0xb8    movw r3, #36896 
    0xe0013e28     0xbc    movt r3, #57346 
    0xe0013e2c     0xc0    mov r2, #9
    0xe0013e30     0xc4    mov r0, #3
    0xe0013e34     0xc8    str r2, [r3, #24]
    0xe0013e38     0xcc    add sp, sp, #36 
    0xe0013e3c     0xd0    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0013e40     0xd4    add sp, sp, #8
    0xe0013e44     0xd8    bx lr
    0xe0013e48     0xdc    movw r3, #36896 
    0xe0013e4c     0xe0    movt r3, #57346 
    0xe0013e50     0xe4    mov r1, #4
    0xe0013e54     0xe8    mov r2, #159 
    0xe0013e58     0xec    str ip, [r3, #8]
    0xe0013e5c     0xf0    mov r0, #3
    0xe0013e60     0xf4    str r1, [r3, #24]
    0xe0013e64     0xf8    str r2, [r3, #12]
    0xe0013e68     0xfc    b e0013db4 <decodeIRQControlInvocation+0x48>
    0xe0013e6c    0x100    ldm r3, {r2, r7}
    0xe0013e70    0x104    add r0, sp, #16
    0xe0013e74    0x108    ldr r3, [lr, #16]
    0xe0013e78    0x10c    ldr ip, [lr, #12]
    0xe0013e7c    0x110    str r7, [sp, #28]     ; stack access
    0xe0013e80    0x114    str r3, [sp, #4]      ; stack access
    0xe0013e84    0x118    add r3, sp, #32
    0xe0013e88    0x11c    str r2, [sp, #24]     ; stack access
    0xe0013e8c    0x120    ldmdb r3, {r2, r3}    ; stack access
    0xe0013e90    0x124    str ip, [sp]          ; stack access
    0xe0013e94    0x128    bl e0012e24 <lookupSlotForCNodeOp>
    0xe0013e98    0x12c    ldr r0, [sp, #16]     ; stack access
    0xe0013e9c    0x130    cmp r0, #0
    0xe0013ea0    0x134    bne e0013db4 <decodeIRQControlInvocation+0x48>
    0xe0013ea4    0x138    ldr r7, [sp, #20]     ; stack access
    0xe0013ea8    0x13c    ldr r3, [r7]
    0xe0013eac    0x140    and r2, r3, #14
    0xe0013eb0    0x144    cmp r2, #14
    0xe0013eb4    0x148    andne r3, r3, #15
    0xe0013eb8    0x14c    uxtbeq r3, r3
    0xe0013ebc    0x150    cmp r3, #0
    0xe0013ec0    0x154    beq e0013edc <decodeIRQControlInvocation+0x170>
    0xe0013ec4    0x158    movw r3, #36896 
    0xe0013ec8    0x15c    movt r3, #57346 
    0xe0013ecc    0x160    mov r2, #8
    0xe0013ed0    0x164    mov r0, #3
    0xe0013ed4    0x168    str r2, [r3, #24]
    0xe0013ed8    0x16c    b e0013db4 <decodeIRQControlInvocation+0x48>
    0xe0013edc    0x170    ldr r2, [r5]
    0xe0013ee0    0x174    ldr r3, [r2, #80] 
    0xe0013ee4    0x178    mov r0, r2
    0xe0013ee8    0x17c    bic r3, r3, #15
    0xe0013eec    0x180    orr r3, r3, #2
    0xe0013ef0    0x184    str r3, [r2, #80] 
    0xe0013ef4    0x188    bl e0013114 <setThreadState.part.166>
    0xe0013ef8    0x18c    mov r2, r4
    0xe0013efc    0x190    mov r1, r7
    0xe0013f00    0x194    mov r0, r6
    0xe0013f04    0x198    add sp, sp, #36 
    0xe0013f08    0x19c    pop {r4, r5, r6, r7, lr}  ; stack access
    0xe0013f0c    0x1a0    add sp, sp, #8
    0xe0013f10    0x1a4    b e0013b3c <invokeIRQControl>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
106 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeIRQControlInvocation` has 168 nodes.

Section cancelBadgedSends (276 of 299)
======================================

Deriving specifications
-----------------------

Section `cancelBadgedSends` consists of 76 instructions.
 LDMIACC (wb);15,10,9,8,7,6,5,4..++
 LDMIAEQ (wb);15,10,9,8,7,6,5,4..++


Stack analysis
---------------

4 stack accesses found. Annotated code for `cancelBadgedSends`:

    0xe00139d8      0x0    ldr r3, [r0]
    0xe00139dc      0x4    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe00139e0      0x8    and r2, r3, #3
    0xe00139e4      0xc    cmp r2, #1
    0xe00139e8     0x10    beq e00139fc <cancelBadgedSends+0x24>
    0xe00139ec     0x14    popcc {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe00139f0     0x18    cmp r2, #2
    0xe00139f4     0x1c    popeq {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe00139f8     0x20    bl e0010a3c <halt>
    0xe00139fc     0x24    ldr r2, [r0, #4]
    0xe0013a00     0x28    mov r7, r1
    0xe0013a04     0x2c    mov r6, r0
    0xe0013a08     0x30    and r1, r3, #12
    0xe0013a0c     0x34    bics r4, r2, #15
    0xe0013a10     0x38    str r1, [r0]
    0xe0013a14     0x3c    and r2, r2, #15
    0xe0013a18     0x40    bic sl, r3, #15
    0xe0013a1c     0x44    str r2, [r0, #4]
    0xe0013a20     0x48    beq e0013af0 <cancelBadgedSends+0x118>
    0xe0013a24     0x4c    movw r9, #13900 
    0xe0013a28     0x50    mov r8, r4
    0xe0013a2c     0x54    movt r9, #57347 
    0xe0013a30     0x58    b e0013a40 <cancelBadgedSends+0x68>
    0xe0013a34     0x5c    cmp r5, #0
    0xe0013a38     0x60    mov r4, r5
    0xe0013a3c     0x64    beq e0013aa8 <cancelBadgedSends+0xd0>
    0xe0013a40     0x68    ldr r3, [r4, #88] 
    0xe0013a44     0x6c    ldr r5, [r4, #144] 
    0xe0013a48     0x70    cmp r7, r3, lsr #4
    0xe0013a4c     0x74    bne e0013a34 <cancelBadgedSends+0x5c>
    0xe0013a50     0x78    ldr r2, [r9]
    0xe0013a54     0x7c    ldr r3, [r4, #80] 
    0xe0013a58     0x80    cmp r2, r4
    0xe0013a5c     0x84    bic r3, r3, #15
    0xe0013a60     0x88    orr r3, r3, #2
    0xe0013a64     0x8c    str r3, [r4, #80] 
    0xe0013a68     0x90    beq e0013afc <cancelBadgedSends+0x124>
    0xe0013a6c     0x94    ldr r3, [r4, #84] 
    0xe0013a70     0x98    tst r3, #1
    0xe0013a74     0x9c    beq e0013ae4 <cancelBadgedSends+0x10c>
    0xe0013a78     0xa0    ldr r2, [r4, #148] 
    0xe0013a7c     0xa4    ldr r3, [r4, #144] 
    0xe0013a80     0xa8    cmp r2, #0
    0xe0013a84     0xac    strne r3, [r2, #144] 
    0xe0013a88     0xb0    moveq r8, r3
    0xe0013a8c     0xb4    ldrne r3, [r4, #144] 
    0xe0013a90     0xb8    mov r4, r5
    0xe0013a94     0xbc    cmp r3, #0
    0xe0013a98     0xc0    strne r2, [r3, #148] 
    0xe0013a9c     0xc4    moveq sl, r2
    0xe0013aa0     0xc8    cmp r5, #0
    0xe0013aa4     0xcc    bne e0013a40 <cancelBadgedSends+0x68>
    0xe0013aa8     0xd0    ldr r3, [r6]
    0xe0013aac     0xd4    bic sl, sl, #15
    0xe0013ab0     0xd8    ldr r2, [r6, #4]
    0xe0013ab4     0xdc    cmp r8, #0
    0xe0013ab8     0xe0    and r3, r3, #15
    0xe0013abc     0xe4    bic r8, r8, #15
    0xe0013ac0     0xe8    orr r3, r3, sl
    0xe0013ac4     0xec    and r2, r2, #15
    0xe0013ac8     0xf0    bicne r3, r3, #3
    0xe0013acc     0xf4    orr r8, r2, r8
    0xe0013ad0     0xf8    orrne r3, r3, #1
    0xe0013ad4     0xfc    str r8, [r6, #4]
    0xe0013ad8    0x100    str r3, [r6]
    0xe0013adc    0x104    pop {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0013ae0    0x108    b e0013098 <rescheduleRequired>
    0xe0013ae4    0x10c    mov r0, r4
    0xe0013ae8    0x110    bl e00107d8 <tcbSchedEnqueue.part.164>
    0xe0013aec    0x114    b e0013a78 <cancelBadgedSends+0xa0>
    0xe0013af0    0x118    bic r3, r3, #3
    0xe0013af4    0x11c    str r3, [r0]
    0xe0013af8    0x120    b e0013adc <cancelBadgedSends+0x104>
    0xe0013afc    0x124    mov r0, r4
    0xe0013b00    0x128    bl e0013114 <setThreadState.part.166>
    0xe0013b04    0x12c    b e0013a6c <cancelBadgedSends+0x94>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
76 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cancelBadgedSends` has 136 nodes.

Section Arch_finaliseCap (277 of 299)
=====================================

Deriving specifications
-----------------------

Section `Arch_finaliseCap` consists of 79 instructions.
Switch found.
 ADDS (reg)..........+++++


Stack analysis
---------------

Section `Arch_finaliseCap` expects pointer to stack in r0.
9 stack accesses found. Annotated code for `Arch_finaliseCap`:

    0xe00122d4      0x0    push {r4, lr}         ; stack access
    0xe00122d8      0x4    sub sp, sp, #8
    0xe00122dc      0x8    add ip, sp, #8
    0xe00122e0      0xc    mov r4, r0
    0xe00122e4     0x10    stmdb ip, {r1, r2}    ; stack access
    0xe00122e8     0x14    ldr ip, [sp]          ; stack access
    0xe00122ec     0x18    ldr r0, [sp, #4]      ; stack access
    0xe00122f0     0x1c    and r2, ip, #14
    0xe00122f4     0x20    cmp r2, #14
    0xe00122f8     0x24    andne r2, ip, #15
    0xe00122fc     0x28    uxtbeq r2, ip
    0xe0012300     0x2c    sub r2, r2, #1
    0xe0012304     0x30    cmp r2, #8
    0xe0012308     0x34    ldrls pc, [pc, r2, lsl #2]
    0xe001230c     0x38    b e0012348 <Arch_finaliseCap+0x74>
    0xe0012310     0x3c    .word 0xe001238c
    0xe0012314     0x40    .word 0xe0012348
    0xe0012318     0x44    .word 0xe00123b8
    0xe001231c     0x48    .word 0xe0012348
    0xe0012320     0x4c    .word 0xe0012334
    0xe0012324     0x50    .word 0xe0012348
    0xe0012328     0x54    .word 0xe00123e8
    0xe001232c     0x58    .word 0xe0012348
    0xe0012330     0x5c    .word 0xe0012368
    0xe0012334     0x60    cmp r3, #0
    0xe0012338     0x64    beq e0012348 <Arch_finaliseCap+0x74>
    0xe001233c     0x68    bic r1, ip, #15
    0xe0012340     0x6c    ubfx r0, r0, #0, #17
    0xe0012344     0x70    bl e00121c0 <deleteASIDPool>
    0xe0012348     0x74    mov r3, #0
    0xe001234c     0x78    mov r0, r4
    0xe0012350     0x7c    str r3, [r4]          ; stack access
    0xe0012354     0x80    str r3, [r4, #4]      ; stack access
    0xe0012358     0x84    str r3, [r4, #8]      ; stack access
    0xe001235c     0x88    str r3, [r4, #12]     ; stack access
    0xe0012360     0x8c    add sp, sp, #8
    0xe0012364     0x90    pop {r4, pc}          ; stack access
    0xe0012368     0x94    cmp r3, #0
    0xe001236c     0x98    beq e0012348 <Arch_finaliseCap+0x74>
    0xe0012370     0x9c    tst ip, #16
    0xe0012374     0xa0    beq e0012348 <Arch_finaliseCap+0x74>
    0xe0012378     0xa4    bic r1, ip, #16320 
    0xe001237c     0xa8    ubfx r0, r0, #0, #17
    0xe0012380     0xac    bic r1, r1, #63 
    0xe0012384     0xb0    bl e001225c <deleteASID>
    0xe0012388     0xb4    b e0012348 <Arch_finaliseCap+0x74>
    0xe001238c     0xb8    lsr r1, ip, #14
    0xe0012390     0xbc    and r1, r1, #130048 
    0xe0012394     0xc0    adds r1, r1, r0, lsr #22
    0xe0012398     0xc4    beq e0012348 <Arch_finaliseCap+0x74>
    0xe001239c     0xc8    mov r3, #61440 
    0xe00123a0     0xcc    movt r3, #65535 
    0xe00123a4     0xd0    lsl r2, r0, #12
    0xe00123a8     0xd4    and r3, r3, ip, lsl #8
    0xe00123ac     0xd8    mov r0, #0
    0xe00123b0     0xdc    bl e0011530 <unmapPage>
    0xe00123b4     0xe0    b e0012348 <Arch_finaliseCap+0x74>
    0xe00123b8     0xe4    lsr r1, ip, #12
    0xe00123bc     0xe8    ubfx r3, r0, #20, #10
    0xe00123c0     0xec    and r1, r1, #130048 
    0xe00123c4     0xf0    orrs r1, r1, r3
    0xe00123c8     0xf4    beq e0012348 <Arch_finaliseCap+0x74>
    0xe00123cc     0xf8    mov r3, #49152 
    0xe00123d0     0xfc    movt r3, #65535 
    0xe00123d4    0x100    lsl r2, r0, #14
    0xe00123d8    0x104    and r3, r3, ip, lsl #10
    0xe00123dc    0x108    lsr r0, r0, #30
    0xe00123e0    0x10c    bl e0011530 <unmapPage>
    0xe00123e4    0x110    b e0012348 <Arch_finaliseCap+0x74>
    0xe00123e8    0x114    cmp r3, #0
    0xe00123ec    0x118    beq e0012348 <Arch_finaliseCap+0x74>
    0xe00123f0    0x11c    tst r0, #536870912 
    0xe00123f4    0x120    beq e0012348 <Arch_finaliseCap+0x74>
    0xe00123f8    0x124    bic r2, ip, #1020 
    0xe00123fc    0x128    lsl r1, r0, #20
    0xe0012400    0x12c    bic r2, r2, #3
    0xe0012404    0x130    ubfx r0, r0, #12, #17
    0xe0012408    0x134    bl e00117a4 <unmapPageTable>
    0xe001240c    0x138    b e0012348 <Arch_finaliseCap+0x74>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
70 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `Arch_finaliseCap` has 130 nodes.

Section unmapPage (278 of 299)
==============================

Deriving specifications
-----------------------

Section `unmapPage` consists of 132 instructions.
 LDMIA;5,3...+
Switch found.
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy
Skipping ee070f3b mcr 15, 0, r0, cr7, cr11, {1}
Skipping f57ff05f dmb sy
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy
Skipping ee072f3b mcr 15, 0, r2, cr7, cr11, {1}
Skipping f57ff05f dmb sy


Stack analysis
---------------

8 stack accesses found. Annotated code for `unmapPage`:

    0xe0011530      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0011534      0x4    sub sp, sp, #16
    0xe0011538      0x8    mov r4, r0
    0xe001153c      0xc    add r8, r3, #805306368 
    0xe0011540     0x10    mov r0, sp
    0xe0011544     0x14    mov r6, r2
    0xe0011548     0x18    mov r7, r1
    0xe001154c     0x1c    bl e0010cf8 <findPDForASID>
    0xe0011550     0x20    ldm sp, {r3, r5}      ; stack access
    0xe0011554     0x24    cmp r3, #0
    0xe0011558     0x28    bne e0011734 <unmapPage+0x204>
    0xe001155c     0x2c    cmp r4, #3
    0xe0011560     0x30    ldrls pc, [pc, r4, lsl #2]
    0xe0011564     0x34    b e001173c <unmapPage+0x20c>
    0xe0011568     0x38    .word 0xe00116e8
    0xe001156c     0x3c    .word 0xe0011654
    0xe0011570     0x40    .word 0xe00115f8
    0xe0011574     0x44    .word 0xe0011578
    0xe0011578     0x48    lsr r2, r6, #20
    0xe001157c     0x4c    ldr r3, [r5, r2, lsl #2]
    0xe0011580     0x50    add r2, r5, r2, lsl #2
    0xe0011584     0x54    and r1, r3, #3
    0xe0011588     0x58    cmp r1, #2
    0xe001158c     0x5c    bne e0011734 <unmapPage+0x204>
    0xe0011590     0x60    tst r3, #262144 
    0xe0011594     0x64    beq e0011734 <unmapPage+0x204>
    0xe0011598     0x68    lsr r3, r3, #20
    0xe001159c     0x6c    lsl r3, r3, #20
    0xe00115a0     0x70    cmp r8, r3
    0xe00115a4     0x74    bne e0011734 <unmapPage+0x204>
    0xe00115a8     0x78    sub r3, r2, #4
    0xe00115ac     0x7c    add r0, r2, #60 
    0xe00115b0     0x80    mov r1, #0
    0xe00115b4     0x84    str r1, [r3, #4]!
    0xe00115b8     0x88    cmp r0, r3
    0xe00115bc     0x8c    bne e00115b4 <unmapPage+0x84>
    0xe00115c0     0x90    add r1, r2, #63 
    0xe00115c4     0x94    lsr r3, r2, #5
    0xe00115c8     0x98    lsr r2, r1, #5
    0xe00115cc     0x9c    add r2, r2, #1
    0xe00115d0     0xa0    cmp r2, r3
    0xe00115d4     0xa4    bls e0011638 <unmapPage+0x108>
    0xe00115d8     0xa8    lsl r3, r3, #5
    0xe00115dc     0xac    lsl r2, r2, #5
    0xe00115e0     0xb0    mcr 15, 0, r3, cr7, cr11, {1}
    0xe00115e4     0xb4    dmb sy
    0xe00115e8     0xb8    add r3, r3, #32
    0xe00115ec     0xbc    cmp r2, r3
    0xe00115f0     0xc0    bne e00115e0 <unmapPage+0xb0>
    0xe00115f4     0xc4    b e0011638 <unmapPage+0x108>
    0xe00115f8     0xc8    lsr r2, r6, #20
    0xe00115fc     0xcc    ldr r3, [r5, r2, lsl #2]
    0xe0011600     0xd0    add r0, r5, r2, lsl #2
    0xe0011604     0xd4    and r1, r3, #3
    0xe0011608     0xd8    cmp r1, #2
    0xe001160c     0xdc    bne e0011734 <unmapPage+0x204>
    0xe0011610     0xe0    ubfx r1, r3, #18, #1
    0xe0011614     0xe4    cmp r1, #0
    0xe0011618     0xe8    bne e0011734 <unmapPage+0x204>
    0xe001161c     0xec    lsr r3, r3, #20
    0xe0011620     0xf0    lsl r3, r3, #20
    0xe0011624     0xf4    cmp r8, r3
    0xe0011628     0xf8    bne e0011734 <unmapPage+0x204>
    0xe001162c     0xfc    str r1, [r5, r2, lsl #2]
    0xe0011630    0x100    mcr 15, 0, r0, cr7, cr11, {1}
    0xe0011634    0x104    dmb sy
    0xe0011638    0x108    mov r3, r6
    0xe001163c    0x10c    mov r2, r7
    0xe0011640    0x110    mov r1, r5
    0xe0011644    0x114    mov r0, r4
    0xe0011648    0x118    add sp, sp, #16
    0xe001164c    0x11c    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0011650    0x120    b e00114b8 <flushPage>
    0xe0011654    0x124    mov r2, r6
    0xe0011658    0x128    mov r1, r5
    0xe001165c    0x12c    add r0, sp, #8
    0xe0011660    0x130    bl e001108c <lookupPTSlot>
    0xe0011664    0x134    ldr r3, [sp, #8]      ; stack access
    0xe0011668    0x138    ldr r2, [sp, #12]     ; stack access
    0xe001166c    0x13c    cmp r3, #0
    0xe0011670    0x140    bne e0011734 <unmapPage+0x204>
    0xe0011674    0x144    ldr r3, [r2]
    0xe0011678    0x148    ubfx r1, r3, #1, #1
    0xe001167c    0x14c    cmp r1, #0
    0xe0011680    0x150    bne e0011734 <unmapPage+0x204>
    0xe0011684    0x154    tst r3, #1
    0xe0011688    0x158    beq e0011734 <unmapPage+0x204>
    0xe001168c    0x15c    lsr r3, r3, #16
    0xe0011690    0x160    lsl r3, r3, #16
    0xe0011694    0x164    cmp r8, r3
    0xe0011698    0x168    bne e0011734 <unmapPage+0x204>
    0xe001169c    0x16c    sub r3, r2, #4
    0xe00116a0    0x170    add r0, r2, #60 
    0xe00116a4    0x174    str r1, [r3, #4]!
    0xe00116a8    0x178    cmp r0, r3
    0xe00116ac    0x17c    bne e00116a4 <unmapPage+0x174>
    0xe00116b0    0x180    add r1, r2, #63 
    0xe00116b4    0x184    lsr r3, r2, #5
    0xe00116b8    0x188    lsr r2, r1, #5
    0xe00116bc    0x18c    add r2, r2, #1
    0xe00116c0    0x190    cmp r2, r3
    0xe00116c4    0x194    bls e0011638 <unmapPage+0x108>
    0xe00116c8    0x198    lsl r3, r3, #5
    0xe00116cc    0x19c    lsl r2, r2, #5
    0xe00116d0    0x1a0    mcr 15, 0, r3, cr7, cr11, {1}
    0xe00116d4    0x1a4    dmb sy
    0xe00116d8    0x1a8    add r3, r3, #32
    0xe00116dc    0x1ac    cmp r2, r3
    0xe00116e0    0x1b0    bne e00116d0 <unmapPage+0x1a0>
    0xe00116e4    0x1b4    b e0011638 <unmapPage+0x108>
    0xe00116e8    0x1b8    mov r2, r6
    0xe00116ec    0x1bc    mov r1, r5
    0xe00116f0    0x1c0    add r0, sp, #8
    0xe00116f4    0x1c4    bl e001108c <lookupPTSlot>
    0xe00116f8    0x1c8    ldr r1, [sp, #8]      ; stack access
    0xe00116fc    0x1cc    ldr r2, [sp, #12]     ; stack access
    0xe0011700    0x1d0    cmp r1, #0
    0xe0011704    0x1d4    bne e0011734 <unmapPage+0x204>
    0xe0011708    0x1d8    ldr r3, [r2]
    0xe001170c    0x1dc    tst r3, #2
    0xe0011710    0x1e0    beq e0011734 <unmapPage+0x204>
    0xe0011714    0x1e4    bic r3, r3, #4080 
    0xe0011718    0x1e8    bic r3, r3, #15
    0xe001171c    0x1ec    cmp r8, r3
    0xe0011720    0x1f0    bne e0011734 <unmapPage+0x204>
    0xe0011724    0x1f4    str r1, [r2]
    0xe0011728    0x1f8    mcr 15, 0, r2, cr7, cr11, {1}
    0xe001172c    0x1fc    dmb sy
    0xe0011730    0x200    b e0011638 <unmapPage+0x108>
    0xe0011734    0x204    add sp, sp, #16
    0xe0011738    0x208    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe001173c    0x20c    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
128 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `unmapPage` has 210 nodes.

Section init_freemem (279 of 299)
=================================

Deriving specifications
-----------------------

Section `init_freemem` consists of 263 instructions.
 ADDLS (imm)....+++
 CMPCC (reg)......+++
 LDMIB;4,3...+
 ADDCC (reg)...........++++++
 LDMIALS;1,0....+++
 STMIALS;1,0....++
 LDMIB;2,1...++
 STRLS (+imm,pre)....+++


Stack analysis
---------------

28 stack accesses found. Annotated code for `init_freemem`:

    0xe0002b08      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0002b0c      0x4    movw r8, #46848 
    0xe0002b10      0x8    subs r4, r0, #0
    0xe0002b14      0xc    movt r8, #57345 
    0xe0002b18     0x10    mov r5, #0
    0xe0002b1c     0x14    sub sp, sp, #44 
    0xe0002b20     0x18    mov sl, r2
    0xe0002b24     0x1c    mov r9, r3
    0xe0002b28     0x20    str r5, [r8, #92] 
    0xe0002b2c     0x24    str r5, [r8, #96] 
    0xe0002b30     0x28    str r5, [r8, #100] 
    0xe0002b34     0x2c    str r5, [r8, #104] 
    0xe0002b38     0x30    str r5, [r8, #108] 
    0xe0002b3c     0x34    str r5, [r8, #112] 
    0xe0002b40     0x38    str r5, [r8, #116] 
    0xe0002b44     0x3c    str r5, [r8, #120] 
    0xe0002b48     0x40    beq e0002e90 <init_freemem+0x388>
    0xe0002b4c     0x44    movw r7, #17544 
    0xe0002b50     0x48    movt r7, #57344 
    0xe0002b54     0x4c    mov lr, r5
    0xe0002b58     0x50    mov ip, r5
    0xe0002b5c     0x54    movt lr, #12272 
    0xe0002b60     0x58    movt ip, #65520 
    0xe0002b64     0x5c    mov r0, r7
    0xe0002b68     0x60    mov r2, r1
    0xe0002b6c     0x64    ldr r3, [r2, #4]
    0xe0002b70     0x68    add r0, r0, #8
    0xe0002b74     0x6c    ldr r6, [r1, r5, lsl #3]
    0xe0002b78     0x70    add r2, r2, #8
    0xe0002b7c     0x74    cmp r3, lr
    0xe0002b80     0x78    addls r3, r3, #-805306368 
    0xe0002b84     0x7c    add r6, r6, #-805306368 
    0xe0002b88     0x80    movhi r3, ip
    0xe0002b8c     0x84    str r6, [r7, r5, lsl #3]
    0xe0002b90     0x88    str r3, [r0, #-4]
    0xe0002b94     0x8c    ldr r3, [r7, r5, lsl #3]
    0xe0002b98     0x90    add r6, r3, #805306368 
    0xe0002b9c     0x94    cmp r6, lr
    0xe0002ba0     0x98    movhi r3, ip
    0xe0002ba4     0x9c    str r3, [r7, r5, lsl #3]
    0xe0002ba8     0xa0    add r5, r5, #1
    0xe0002bac     0xa4    cmp r4, r5
    0xe0002bb0     0xa8    bne e0002b6c <init_freemem+0x64>
    0xe0002bb4     0xac    mov r4, #0
    0xe0002bb8     0xb0    mov r6, r4
    0xe0002bbc     0xb4    cmp r6, r5
    0xe0002bc0     0xb8    cmpcc r4, sl
    0xe0002bc4     0xbc    bcs e0002c50 <init_freemem+0x148>
    0xe0002bc8     0xc0    lsl r3, r4, #3
    0xe0002bcc     0xc4    ldr ip, [r9, r4, lsl #3]
    0xe0002bd0     0xc8    add fp, r9, r3
    0xe0002bd4     0xcc    ldr r1, [fp, #4]
    0xe0002bd8     0xd0    cmp ip, r1
    0xe0002bdc     0xd4    addeq r4, r4, #1
    0xe0002be0     0xd8    beq e0002bbc <init_freemem+0xb4>
    0xe0002be4     0xdc    add r2, r7, r6, lsl #3
    0xe0002be8     0xe0    ldr r0, [r7, r6, lsl #3]
    0xe0002bec     0xe4    ldr lr, [r2, #4]
    0xe0002bf0     0xe8    cmp r0, lr
    0xe0002bf4     0xec    bcs e0002dec <init_freemem+0x2e4>
    0xe0002bf8     0xf0    cmp r1, r0
    0xe0002bfc     0xf4    bls e0002e44 <init_freemem+0x33c>
    0xe0002c00     0xf8    cmp ip, lr
    0xe0002c04     0xfc    bcs e0002e68 <init_freemem+0x360>
    0xe0002c08    0x100    cmp ip, r0
    0xe0002c0c    0x104    bhi e0002db4 <init_freemem+0x2ac>
    0xe0002c10    0x108    cmp r1, lr
    0xe0002c14    0x10c    add r4, r4, #1
    0xe0002c18    0x110    movcs r1, lr
    0xe0002c1c    0x114    str r1, [r7, r6, lsl #3]
    0xe0002c20    0x118    ldr r3, [r9, r3]
    0xe0002c24    0x11c    ldr r2, [fp, #4]
    0xe0002c28    0x120    add r3, r3, #805306368 
    0xe0002c2c    0x124    str r3, [sp, #16]     ; stack access
    0xe0002c30    0x128    add r3, sp, #16
    0xe0002c34    0x12c    add r2, r2, #805306368 
    0xe0002c38    0x130    str r2, [sp, #20]     ; stack access
    0xe0002c3c    0x134    ldm r3, {r0, r1}      ; stack access
    0xe0002c40    0x138    bl e0000bd8 <reserve_region>
    0xe0002c44    0x13c    cmp r6, r5
    0xe0002c48    0x140    cmpcc r4, sl
    0xe0002c4c    0x144    bcc e0002bc8 <init_freemem+0xc0>
    0xe0002c50    0x148    cmp r4, sl
    0xe0002c54    0x14c    bcs e0002ecc <init_freemem+0x3c4>
    0xe0002c58    0x150    add r5, r9, r4, lsl #3
    0xe0002c5c    0x154    add r6, sp, #32
    0xe0002c60    0x158    b e0002c74 <init_freemem+0x16c>
    0xe0002c64    0x15c    add r4, r4, #1
    0xe0002c68    0x160    add r5, r5, #8
    0xe0002c6c    0x164    cmp sl, r4
    0xe0002c70    0x168    bls e0002ca8 <init_freemem+0x1a0>
    0xe0002c74    0x16c    ldr r2, [r9, r4, lsl #3]
    0xe0002c78    0x170    ldr r3, [r5, #4]
    0xe0002c7c    0x174    cmp r2, r3
    0xe0002c80    0x178    bcs e0002c64 <init_freemem+0x15c>
    0xe0002c84    0x17c    add r2, r2, #805306368 
    0xe0002c88    0x180    add r3, r3, #805306368 
    0xe0002c8c    0x184    add r4, r4, #1
    0xe0002c90    0x188    strd r2, [sp, #32]    ; stack access
    0xe0002c94    0x18c    ldm r6, {r0, r1}      ; stack access
    0xe0002c98    0x190    add r5, r5, #8
    0xe0002c9c    0x194    bl e0000bd8 <reserve_region>
    0xe0002ca0    0x198    cmp sl, r4
    0xe0002ca4    0x19c    bhi e0002c74 <init_freemem+0x16c>
    0xe0002ca8    0x1a0    ldrd r2, [r8, #116] 
    0xe0002cac    0x1a4    cmp r2, r3
    0xe0002cb0    0x1a8    bne e0002f20 <init_freemem+0x418>
    0xe0002cb4    0x1ac    ldr r2, [r8, #112] 
    0xe0002cb8    0x1b0    ldr r3, [r8, #108] 
    0xe0002cbc    0x1b4    cmp r2, r3
    0xe0002cc0    0x1b8    bne e0002e78 <init_freemem+0x370>
    0xe0002cc4    0x1bc    ldr r2, [r8, #104] 
    0xe0002cc8    0x1c0    ldr r3, [r8, #100] 
    0xe0002ccc    0x1c4    cmp r2, r3
    0xe0002cd0    0x1c8    bne e0002e84 <init_freemem+0x37c>
    0xe0002cd4    0x1cc    ldr r2, [r8, #96] 
    0xe0002cd8    0x1d0    ldr r3, [r8, #92] 
    0xe0002cdc    0x1d4    cmp r2, r3
    0xe0002ce0    0x1d8    movne r2, #1
    0xe0002ce4    0x1dc    moveq r2, #0
    0xe0002ce8    0x1e0    mvneq r6, #0
    0xe0002cec    0x1e4    movne r6, #0
    0xe0002cf0    0x1e8    ldr r3, [sp, #88]     ; stack access
    0xe0002cf4    0x1ec    ldr r5, [sp, #80]     ; stack access
    0xe0002cf8    0x1f0    cmp r3, #0
    0xe0002cfc    0x1f4    ldr r3, [sp, #84]     ; stack access
    0xe0002d00    0x1f8    ldr ip, [sp, #88]     ; stack access
    0xe0002d04    0x1fc    sub r3, r3, #1
    0xe0002d08    0x200    lsr lr, r5, #20
    0xe0002d0c    0x204    ldrne r1, [sp, #88]   ; stack access
    0xe0002d10    0x208    movne r0, #1
    0xe0002d14    0x20c    lsr r3, r3, #20
    0xe0002d18    0x210    lsl lr, lr, #20
    0xe0002d1c    0x214    lslne r0, r0, r1
    0xe0002d20    0x218    add r1, r6, #11
    0xe0002d24    0x21c    lsl r3, r3, #20
    0xe0002d28    0x220    ldreq r0, [sp, #88]   ; stack access
    0xe0002d2c    0x224    add r5, r3, #1048576 
    0xe0002d30    0x228    add r1, r8, r1, lsl #3
    0xe0002d34    0x22c    sub r5, r5, lr
    0xe0002d38    0x230    cmp ip, #16
    0xe0002d3c    0x234    ldmib r1, {r3, r4}
    0xe0002d40    0x238    lsr r5, r5, #10
    0xe0002d44    0x23c    movcc ip, #16
    0xe0002d48    0x240    add r5, r5, #94208 
    0xe0002d4c    0x244    add r5, r5, #512 
    0xe0002d50    0x248    add r5, r5, r0
    0xe0002d54    0x24c    sub r4, r4, r5
    0xe0002d58    0x250    lsr r4, r4, ip
    0xe0002d5c    0x254    lsl r4, r4, ip
    0xe0002d60    0x258    cmp r4, r3
    0xe0002d64    0x25c    addcc r3, r8, r6, lsl #3
    0xe0002d68    0x260    bcs e0002df4 <init_freemem+0x2ec>
    0xe0002d6c    0x264    cmp r6, #3
    0xe0002d70    0x268    sub r7, r6, #1
    0xe0002d74    0x26c    addls r1, r3, #92 
    0xe0002d78    0x270    addls r2, r8, r2, lsl #3
    0xe0002d7c    0x274    addls r2, r2, #92 
    0xe0002d80    0x278    sub r3, r3, #8
    0xe0002d84    0x27c    ldmls r1, {r0, r1}
    0xe0002d88    0x280    stmls r2, {r0, r1}
    0xe0002d8c    0x284    mov r2, r6
    0xe0002d90    0x288    ldr r4, [r3, #96] 
    0xe0002d94    0x28c    sub r4, r4, r5
    0xe0002d98    0x290    ldr r1, [r3, #92] 
    0xe0002d9c    0x294    lsr r4, r4, ip
    0xe0002da0    0x298    lsl r4, r4, ip
    0xe0002da4    0x29c    cmp r1, r4
    0xe0002da8    0x2a0    bls e0002dfc <init_freemem+0x2f4>
    0xe0002dac    0x2a4    mov r6, r7
    0xe0002db0    0x2a8    b e0002d6c <init_freemem+0x264>
    0xe0002db4    0x2ac    ldm r2, {r0, r1}
    0xe0002db8    0x2b0    str r3, [sp, #4]      ; stack access
    0xe0002dbc    0x2b4    add r3, sp, #32
    0xe0002dc0    0x2b8    str r2, [sp]          ; stack access
    0xe0002dc4    0x2bc    stm r3, {r0, r1}      ; stack access
    0xe0002dc8    0x2c0    str ip, [sp, #36]     ; stack access
    0xe0002dcc    0x2c4    ldm r3, {r0, r1}      ; stack access
    0xe0002dd0    0x2c8    bl e0000f2c <insert_region>
    0xe0002dd4    0x2cc    ldr r2, [sp]          ; stack access
    0xe0002dd8    0x2d0    ldr r3, [sp, #4]      ; stack access
    0xe0002ddc    0x2d4    ldr r1, [r2, #4]
    0xe0002de0    0x2d8    ldr r2, [fp, #4]
    0xe0002de4    0x2dc    cmp r1, r2
    0xe0002de8    0x2e0    bhi e0002e9c <init_freemem+0x394>
    0xe0002dec    0x2e4    add r6, r6, #1
    0xe0002df0    0x2e8    b e0002bbc <init_freemem+0xb4>
    0xe0002df4    0x2ec    mov r7, r6
    0xe0002df8    0x2f0    mov r6, r2
    0xe0002dfc    0x2f4    add r2, sp, #76 
    0xe0002e00    0x2f8    ldr r3, [sp, #88]     ; stack access
    0xe0002e04    0x2fc    mov r0, r4
    0xe0002e08    0x300    ldmib r2, {r1, r2}    ; stack access
    0xe0002e0c    0x304    bl e0000fe8 <create_rootserver_objects>
    0xe0002e10    0x308    cmp r7, #3
    0xe0002e14    0x30c    add r7, r7, #11
    0xe0002e18    0x310    addls r6, r6, #11
    0xe0002e1c    0x314    addls r5, r5, r4
    0xe0002e20    0x318    addls r3, r8, r7, lsl #3
    0xe0002e24    0x31c    addls r6, r8, r6, lsl #3
    0xe0002e28    0x320    add r7, r8, r7, lsl #3
    0xe0002e2c    0x324    strls r5, [r6, #4]
    0xe0002e30    0x328    ldrls r3, [r3, #8]
    0xe0002e34    0x32c    strls r3, [r6, #8]
    0xe0002e38    0x330    str r4, [r7, #8]
    0xe0002e3c    0x334    add sp, sp, #44 
    0xe0002e40    0x338    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0002e44    0x33c    add r3, sp, #8
    0xe0002e48    0x340    add ip, ip, #805306368 
    0xe0002e4c    0x344    add r1, r1, #805306368 
    0xe0002e50    0x348    str ip, [sp, #8]      ; stack access
    0xe0002e54    0x34c    str r1, [sp, #12]     ; stack access
    0xe0002e58    0x350    add r4, r4, #1
    0xe0002e5c    0x354    ldm r3, {r0, r1}      ; stack access
    0xe0002e60    0x358    bl e0000bd8 <reserve_region>
    0xe0002e64    0x35c    b e0002bbc <init_freemem+0xb4>
    0xe0002e68    0x360    ldm r2, {r0, r1}
    0xe0002e6c    0x364    add r6, r6, #1
    0xe0002e70    0x368    bl e0000f2c <insert_region>
    0xe0002e74    0x36c    b e0002bbc <init_freemem+0xb4>
    0xe0002e78    0x370    mov r2, #3
    0xe0002e7c    0x374    mov r6, #2
    0xe0002e80    0x378    b e0002cf0 <init_freemem+0x1e8>
    0xe0002e84    0x37c    mov r2, #2
    0xe0002e88    0x380    mov r6, #1
    0xe0002e8c    0x384    b e0002cf0 <init_freemem+0x1e8>
    0xe0002e90    0x388    cmp r2, #0
    0xe0002e94    0x38c    bne e0002c58 <init_freemem+0x150>
    0xe0002e98    0x390    b e0002cb4 <init_freemem+0x1ac>
    0xe0002e9c    0x394    str r2, [r7, r6, lsl #3]
    0xe0002ea0    0x398    add r4, r4, #1
    0xe0002ea4    0x39c    ldr r3, [r9, r3]
    0xe0002ea8    0x3a0    ldr r2, [fp, #4]
    0xe0002eac    0x3a4    add r3, r3, #805306368 
    0xe0002eb0    0x3a8    str r3, [sp, #24]     ; stack access
    0xe0002eb4    0x3ac    add r3, sp, #24
    0xe0002eb8    0x3b0    add r2, r2, #805306368 
    0xe0002ebc    0x3b4    str r2, [sp, #28]     ; stack access
    0xe0002ec0    0x3b8    ldm r3, {r0, r1}      ; stack access
    0xe0002ec4    0x3bc    bl e0000bd8 <reserve_region>
    0xe0002ec8    0x3c0    b e0002bbc <init_freemem+0xb4>
    0xe0002ecc    0x3c4    cmp r6, r5
    0xe0002ed0    0x3c8    bcs e0002ca8 <init_freemem+0x1a0>
    0xe0002ed4    0x3cc    lsl r3, r6, #3
    0xe0002ed8    0x3d0    add r4, r7, r3
    0xe0002edc    0x3d4    ldr r1, [r7, r3]
    0xe0002ee0    0x3d8    ldr r2, [r4, #4]
    0xe0002ee4    0x3dc    cmp r1, r2
    0xe0002ee8    0x3e0    bcc e0002f10 <init_freemem+0x408>
    0xe0002eec    0x3e4    add r6, r6, #1
    0xe0002ef0    0x3e8    add r4, r4, #8
    0xe0002ef4    0x3ec    cmp r6, r5
    0xe0002ef8    0x3f0    bcs e0002ca8 <init_freemem+0x1a0>
    0xe0002efc    0x3f4    lsl r3, r6, #3
    0xe0002f00    0x3f8    ldr r2, [r4, #4]
    0xe0002f04    0x3fc    ldr r1, [r7, r3]
    0xe0002f08    0x400    cmp r1, r2
    0xe0002f0c    0x404    bcs e0002eec <init_freemem+0x3e4>
    0xe0002f10    0x408    add r3, r7, r3
    0xe0002f14    0x40c    ldm r3, {r0, r1}
    0xe0002f18    0x410    bl e0000f2c <insert_region>
    0xe0002f1c    0x414    b e0002eec <init_freemem+0x3e4>
    0xe0002f20    0x418    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
263 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_freemem` has 457 nodes.

Section decodeUntypedInvocation (280 of 299)
============================================

Deriving specifications
-----------------------

Section `decodeUntypedInvocation` consists of 253 instructions.
 CMPLS (imm)...++
 RSB (reg-shift)...............+++++++++++++++


Stack analysis
---------------

32 stack accesses found. Annotated code for `decodeUntypedInvocation`:

    0xe001a624      0x0    sub sp, sp, #8
    0xe001a628      0x4    cmp r0, #1
    0xe001a62c      0x8    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001a630      0xc    sub sp, sp, #52 
    0xe001a634     0x10    str r3, [sp, #92]     ; stack access
    0xe001a638     0x14    ldr fp, [sp, #116]    ; stack access
    0xe001a63c     0x18    bne e001a7d0 <decodeUntypedInvocation+0x1ac>
    0xe001a640     0x1c    cmp r1, #5
    0xe001a644     0x20    ldr sl, [sp, #100]    ; stack access
    0xe001a648     0x24    movhi r1, #0
    0xe001a64c     0x28    movls r1, #1
    0xe001a650     0x2c    cmp sl, #0
    0xe001a654     0x30    movne r9, r1
    0xe001a658     0x34    moveq r9, #1
    0xe001a65c     0x38    cmp r9, #0
    0xe001a660     0x3c    bne e001a7a8 <decodeUntypedInvocation+0x184>
    0xe001a664     0x40    movw r5, #13900 
    0xe001a668     0x44    movt r5, #57347 
    0xe001a66c     0x48    mov r4, r2
    0xe001a670     0x4c    ldr r2, [r5]
    0xe001a674     0x50    ldr r6, [r2, #8]
    0xe001a678     0x54    cmp r6, #10
    0xe001a67c     0x58    bhi e001a7e8 <decodeUntypedInvocation+0x1c4>
    0xe001a680     0x5c    ldr r7, [r2, #12]
    0xe001a684     0x60    mov r0, r6
    0xe001a688     0x64    mov r1, r7
    0xe001a68c     0x68    bl e0014258 <getObjectSize>
    0xe001a690     0x6c    cmp r0, #29
    0xe001a694     0x70    cmpls r7, #31
    0xe001a698     0x74    mov r8, r0
    0xe001a69c     0x78    bhi e001a81c <decodeUntypedInvocation+0x1f8>
    0xe001a6a0     0x7c    cmp r6, #4
    0xe001a6a4     0x80    cmpeq r7, #0
    0xe001a6a8     0x84    beq e001a800 <decodeUntypedInvocation+0x1dc>
    0xe001a6ac     0x88    cmp r7, #3
    0xe001a6b0     0x8c    movhi r1, #0
    0xe001a6b4     0x90    movls r1, #1
    0xe001a6b8     0x94    cmp r6, #0
    0xe001a6bc     0x98    movne r1, #0
    0xe001a6c0     0x9c    cmp r1, #0
    0xe001a6c4     0xa0    bne e001a800 <decodeUntypedInvocation+0x1dc>
    0xe001a6c8     0xa4    ldr r3, [sp, #96]     ; stack access
    0xe001a6cc     0xa8    ldr r9, [r2, #20]
    0xe001a6d0     0xac    ldr r0, [sl, #4]
    0xe001a6d4     0xb0    str r3, [sp, #12]     ; stack access
    0xe001a6d8     0xb4    cmp r9, #0
    0xe001a6dc     0xb8    ldr r3, [fp, #20]
    0xe001a6e0     0xbc    ldr ip, [sl]
    0xe001a6e4     0xc0    ldr fp, [fp, #24]
    0xe001a6e8     0xc4    str r3, [sp, #8]      ; stack access
    0xe001a6ec     0xc8    bne e001a840 <decodeUntypedInvocation+0x21c>
    0xe001a6f0     0xcc    and r3, ip, #14
    0xe001a6f4     0xd0    cmp r3, #14
    0xe001a6f8     0xd4    andne r3, ip, #15
    0xe001a6fc     0xd8    uxtbeq r3, ip
    0xe001a700     0xdc    cmp r3, #10
    0xe001a704     0xe0    bne e001a87c <decodeUntypedInvocation+0x258>
    0xe001a708     0xe4    ubfx r0, r0, #18, #5
    0xe001a70c     0xe8    mov r2, #1
    0xe001a710     0xec    lsl r0, r2, r0
    0xe001a714     0xf0    ldr r1, [sp, #8]      ; stack access
    0xe001a718     0xf4    sub r3, r0, #1
    0xe001a71c     0xf8    cmp r3, r1
    0xe001a720     0xfc    bcc e001a8b8 <decodeUntypedInvocation+0x294>
    0xe001a724    0x100    sub r3, fp, #1
    0xe001a728    0x104    cmp r3, #255 
    0xe001a72c    0x108    bhi e001a8dc <decodeUntypedInvocation+0x2b8>
    0xe001a730    0x10c    ldr r3, [sp, #8]      ; stack access
    0xe001a734    0x110    sub r0, r0, r3
    0xe001a738    0x114    cmp r0, fp
    0xe001a73c    0x118    bcc e001a9dc <decodeUntypedInvocation+0x3b8>
    0xe001a740    0x11c    ldr r1, [sp, #8]      ; stack access
    0xe001a744    0x120    bic r9, ip, #31
    0xe001a748    0x124    str fp, [sp, #44]     ; stack access
    0xe001a74c    0x128    add lr, fp, r1
    0xe001a750    0x12c    cmp r1, lr
    0xe001a754    0x130    str r1, [sp, #40]     ; stack access
    0xe001a758    0x134    bcs e001a900 <decodeUntypedInvocation+0x2dc>
    0xe001a75c    0x138    add r2, r9, r1, lsl #4
    0xe001a760    0x13c    b e001a76c <decodeUntypedInvocation+0x148>
    0xe001a764    0x140    cmp r1, lr
    0xe001a768    0x144    bcs e001a900 <decodeUntypedInvocation+0x2dc>
    0xe001a76c    0x148    ldr r3, [r2]
    0xe001a770    0x14c    add r1, r1, #1
    0xe001a774    0x150    add r2, r2, #16
    0xe001a778    0x154    and ip, r3, #14
    0xe001a77c    0x158    and r0, r3, #15
    0xe001a780    0x15c    cmp ip, #14
    0xe001a784    0x160    uxtbeq r0, r3
    0xe001a788    0x164    cmp r0, #0
    0xe001a78c    0x168    beq e001a764 <decodeUntypedInvocation+0x140>
    0xe001a790    0x16c    movw r2, #36896 
    0xe001a794    0x170    movt r2, #57346 
    0xe001a798    0x174    mov r1, #8
    0xe001a79c    0x178    mov r3, #3
    0xe001a7a0    0x17c    str r1, [r2, #24]
    0xe001a7a4    0x180    b e001a7bc <decodeUntypedInvocation+0x198>
    0xe001a7a8    0x184    movw r2, #36896 
    0xe001a7ac    0x188    movt r2, #57346 
    0xe001a7b0    0x18c    mov r3, #3
    0xe001a7b4    0x190    mov r1, #7
    0xe001a7b8    0x194    str r1, [r2, #24]
    0xe001a7bc    0x198    mov r0, r3
    0xe001a7c0    0x19c    add sp, sp, #52 
    0xe001a7c4    0x1a0    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001a7c8    0x1a4    add sp, sp, #8
    0xe001a7cc    0x1a8    bx lr
    0xe001a7d0    0x1ac    movw r2, #36896 
    0xe001a7d4    0x1b0    movt r2, #57346 
    0xe001a7d8    0x1b4    mov r1, #3
    0xe001a7dc    0x1b8    mov r3, r1
    0xe001a7e0    0x1bc    str r1, [r2, #24]
    0xe001a7e4    0x1c0    b e001a7bc <decodeUntypedInvocation+0x198>
    0xe001a7e8    0x1c4    movw r2, #36896 
    0xe001a7ec    0x1c8    movt r2, #57346 
    0xe001a7f0    0x1cc    mov r3, #3
    0xe001a7f4    0x1d0    str r0, [r2, #24]
    0xe001a7f8    0x1d4    str r9, [r2]
    0xe001a7fc    0x1d8    b e001a7bc <decodeUntypedInvocation+0x198>
    0xe001a800    0x1dc    movw r2, #36896 
    0xe001a804    0x1e0    movt r2, #57346 
    0xe001a808    0x1e4    mov r1, #1
    0xe001a80c    0x1e8    mov r3, #3
    0xe001a810    0x1ec    str r1, [r2, #24]
    0xe001a814    0x1f0    str r1, [r2]
    0xe001a818    0x1f4    b e001a7bc <decodeUntypedInvocation+0x198>
    0xe001a81c    0x1f8    movw r2, #36896 
    0xe001a820    0x1fc    movt r2, #57346 
    0xe001a824    0x200    mov r0, #4
    0xe001a828    0x204    mov r1, #29
    0xe001a82c    0x208    str r9, [r2, #8]
    0xe001a830    0x20c    mov r3, #3
    0xe001a834    0x210    str r0, [r2, #24]
    0xe001a838    0x214    str r1, [r2, #12]
    0xe001a83c    0x218    b e001a7bc <decodeUntypedInvocation+0x198>
    0xe001a840    0x21c    ldr r2, [r2, #16]
    0xe001a844    0x220    add r3, sp, #28
    0xe001a848    0x224    str r0, [sp, #32]     ; stack access
    0xe001a84c    0x228    add r0, sp, #20
    0xe001a850    0x22c    str ip, [sp, #28]     ; stack access
    0xe001a854    0x230    stm sp, {r2, r9}      ; stack access
    0xe001a858    0x234    ldm r3, {r2, r3}      ; stack access
    0xe001a85c    0x238    bl e0012e24 <lookupSlotForCNodeOp>
    0xe001a860    0x23c    ldr r3, [sp, #20]     ; stack access
    0xe001a864    0x240    cmp r3, #0
    0xe001a868    0x244    bne e001a7bc <decodeUntypedInvocation+0x198>
    0xe001a86c    0x248    ldr r3, [sp, #24]     ; stack access
    0xe001a870    0x24c    ldr ip, [r3]
    0xe001a874    0x250    ldr r0, [r3, #4]
    0xe001a878    0x254    b e001a6f0 <decodeUntypedInvocation+0xcc>
    0xe001a87c    0x258    lsl r3, r9, #2
    0xe001a880    0x25c    movw r1, #36884 
    0xe001a884    0x260    movw r2, #36896 
    0xe001a888    0x264    movt r1, #57346 
    0xe001a88c    0x268    movt r2, #57346 
    0xe001a890    0x26c    uxtb r3, r3
    0xe001a894    0x270    orr r3, r3, #1
    0xe001a898    0x274    mov r0, #0
    0xe001a89c    0x278    str r3, [r1]
    0xe001a8a0    0x27c    mov ip, #6
    0xe001a8a4    0x280    str r0, [r1, #4]
    0xe001a8a8    0x284    mov r3, #3
    0xe001a8ac    0x288    str r0, [r2, #20]
    0xe001a8b0    0x28c    str ip, [r2, #24]
    0xe001a8b4    0x290    b e001a7bc <decodeUntypedInvocation+0x198>
    0xe001a8b8    0x294    movw r2, #36896 
    0xe001a8bc    0x298    movt r2, #57346 
    0xe001a8c0    0x29c    mov r0, #4
    0xe001a8c4    0x2a0    mov r1, #0
    0xe001a8c8    0x2a4    str r3, [r2, #12]
    0xe001a8cc    0x2a8    mov r3, #3
    0xe001a8d0    0x2ac    str r0, [r2, #24]
    0xe001a8d4    0x2b0    str r1, [r2, #8]
    0xe001a8d8    0x2b4    b e001a7bc <decodeUntypedInvocation+0x198>
    0xe001a8dc    0x2b8    movw r1, #36896 
    0xe001a8e0    0x2bc    movt r1, #57346 
    0xe001a8e4    0x2c0    mov ip, #4
    0xe001a8e8    0x2c4    mov r0, #256 
    0xe001a8ec    0x2c8    str r2, [r1, #8]
    0xe001a8f0    0x2cc    mov r3, #3
    0xe001a8f4    0x2d0    str ip, [r1, #24]
    0xe001a8f8    0x2d4    str r0, [r1, #12]
    0xe001a8fc    0x2d8    b e001a7bc <decodeUntypedInvocation+0x198>
    0xe001a900    0x2dc    mov r0, r4
    0xe001a904    0x2e0    bl e0014bbc <ensureNoChildren>
    0xe001a908    0x2e4    subs r3, r0, #0
    0xe001a90c    0x2e8    ldrne r3, [sp, #12]   ; stack access
    0xe001a910    0x2ec    movne r2, #0
    0xe001a914    0x2f0    moveq r2, #1
    0xe001a918    0x2f4    strne r2, [sp, #8]    ; stack access
    0xe001a91c    0x2f8    streq r2, [sp, #8]    ; stack access
    0xe001a920    0x2fc    lsrne r3, r3, #6
    0xe001a924    0x300    ldr r2, [sp, #12]     ; stack access
    0xe001a928    0x304    lslne r3, r3, #4
    0xe001a92c    0x308    and r0, r2, #31
    0xe001a930    0x30c    mov r2, #1
    0xe001a934    0x310    rsb r2, r3, r2, lsl r0
    0xe001a938    0x314    cmp fp, r2, lsr r8
    0xe001a93c    0x318    bhi e001a9fc <decodeUntypedInvocation+0x3d8>
    0xe001a940    0x31c    ldr r2, [sp, #12]     ; stack access
    0xe001a944    0x320    ubfx sl, r2, #5, #1
    0xe001a948    0x324    cmp sl, #0
    0xe001a94c    0x328    beq e001a964 <decodeUntypedInvocation+0x340>
    0xe001a950    0x32c    sub r2, r6, #5
    0xe001a954    0x330    cmp r2, #3
    0xe001a958    0x334    bls e001a964 <decodeUntypedInvocation+0x340>
    0xe001a95c    0x338    cmp r6, #0
    0xe001a960    0x33c    bne e001a800 <decodeUntypedInvocation+0x1dc>
    0xe001a964    0x340    ldr r0, [r5]
    0xe001a968    0x344    mov r2, #1
    0xe001a96c    0x348    ldr r5, [sp, #92]     ; stack access
    0xe001a970    0x34c    lsl r8, r2, r8
    0xe001a974    0x350    rsb r2, r8, #0
    0xe001a978    0x354    ldr ip, [r0, #80] 
    0xe001a97c    0x358    bic r5, r5, #15
    0xe001a980    0x35c    sub r5, r5, #1
    0xe001a984    0x360    add r5, r5, r8
    0xe001a988    0x364    bic ip, ip, #15
    0xe001a98c    0x368    orr ip, ip, #2
    0xe001a990    0x36c    add r5, r5, r3
    0xe001a994    0x370    str ip, [r0, #80] 
    0xe001a998    0x374    and r5, r5, r2
    0xe001a99c    0x378    bl e0013114 <setThreadState.part.166>
    0xe001a9a0    0x37c    add r3, sp, #48 
    0xe001a9a4    0x380    add ip, sp, #100 
    0xe001a9a8    0x384    str r9, [r3, #-12]!   ; stack access
    0xe001a9ac    0x388    ldm r3, {r0, r1, r2}  ; stack access
    0xe001a9b0    0x38c    mov r3, r6
    0xe001a9b4    0x390    str sl, [sp, #112]    ; stack access
    0xe001a9b8    0x394    str r7, [sp, #96]     ; stack access
    0xe001a9bc    0x398    stm ip, {r0, r1, r2}  ; stack access
    0xe001a9c0    0x39c    mov r2, r5
    0xe001a9c4    0x3a0    ldr r1, [sp, #8]      ; stack access
    0xe001a9c8    0x3a4    mov r0, r4
    0xe001a9cc    0x3a8    add sp, sp, #52 
    0xe001a9d0    0x3ac    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001a9d4    0x3b0    add sp, sp, #8
    0xe001a9d8    0x3b4    b e001a454 <invokeUntyped_Retype>
    0xe001a9dc    0x3b8    movw r1, #36896 
    0xe001a9e0    0x3bc    movt r1, #57346 
    0xe001a9e4    0x3c0    mov ip, #4
    0xe001a9e8    0x3c4    mov r3, #3
    0xe001a9ec    0x3c8    str r2, [r1, #8]
    0xe001a9f0    0x3cc    str r0, [r1, #12]
    0xe001a9f4    0x3d0    str ip, [r1, #24]
    0xe001a9f8    0x3d4    b e001a7bc <decodeUntypedInvocation+0x198>
    0xe001a9fc    0x3d8    movw r1, #36896 
    0xe001aa00    0x3dc    movt r1, #57346 
    0xe001aa04    0x3e0    mov r0, #10
    0xe001aa08    0x3e4    mov r3, #3
    0xe001aa0c    0x3e8    str r2, [r1, #16]
    0xe001aa10    0x3ec    str r0, [r1, #24]
    0xe001aa14    0x3f0    b e001a7bc <decodeUntypedInvocation+0x198>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
253 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeUntypedInvocation` has 407 nodes.

Section decodeSetSpace (281 of 299)
===================================

Deriving specifications
-----------------------

Section `decodeSetSpace` consists of 154 instructions.
 LDR (-imm,pre,wb).+


Stack analysis
---------------

59 stack accesses found. Annotated code for `decodeSetSpace`:

    0xe0019780      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0019784      0x4    sub sp, sp, #116 
    0xe0019788      0x8    add lr, sp, #64 
    0xe001978c      0xc    ldrd r4, [sp, #152]   ; stack access
    0xe0019790     0x10    stm lr, {r0, r1}      ; stack access
    0xe0019794     0x14    clz ip, r5
    0xe0019798     0x18    cmp r4, #0
    0xe001979c     0x1c    lsr ip, ip, #5
    0xe00197a0     0x20    moveq ip, #1
    0xe00197a4     0x24    cmp r2, #2
    0xe00197a8     0x28    orrls ip, ip, #1
    0xe00197ac     0x2c    cmp ip, #0
    0xe00197b0     0x30    beq e00197d0 <decodeSetSpace+0x50>
    0xe00197b4     0x34    movw r3, #36896 
    0xe00197b8     0x38    movt r3, #57346 
    0xe00197bc     0x3c    mov r0, #3
    0xe00197c0     0x40    mov r2, #7
    0xe00197c4     0x44    str r2, [r3, #24]
    0xe00197c8     0x48    add sp, sp, #116 
    0xe00197cc     0x4c    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe00197d0     0x50    movw r8, #13900 
    0xe00197d4     0x54    movt r8, #57347 
    0xe00197d8     0x58    str r3, [sp, #60]     ; stack access
    0xe00197dc     0x5c    add r6, sp, #76 
    0xe00197e0     0x60    ldr r2, [r8]
    0xe00197e4     0x64    add r7, sp, #84 
    0xe00197e8     0x68    ldm r4, {r0, r1}
    0xe00197ec     0x6c    ldr sl, [sp, #64]     ; stack access
    0xe00197f0     0x70    ldr r3, [r2, #8]
    0xe00197f4     0x74    stm r6, {r0, r1}      ; stack access
    0xe00197f8     0x78    mov r9, r0
    0xe00197fc     0x7c    bic fp, sl, #508 
    0xe0019800     0x80    ldm r5, {r0, r1}
    0xe0019804     0x84    str r3, [sp, #56]     ; stack access
    0xe0019808     0x88    bic fp, fp, #3
    0xe001980c     0x8c    ldr r3, [r2, #12]
    0xe0019810     0x90    stm r7, {r0, r1}      ; stack access
    0xe0019814     0x94    mov r0, fp
    0xe0019818     0x98    str r3, [sp, #48]     ; stack access
    0xe001981c     0x9c    ldr r3, [r2, #16]
    0xe0019820     0xa0    str r3, [sp, #52]     ; stack access
    0xe0019824     0xa4    bl e0014da0 <slotCapLongRunningDelete>
    0xe0019828     0xa8    cmp r0, #0
    0xe001982c     0xac    bne e00199cc <decodeSetSpace+0x24c>
    0xe0019830     0xb0    add r0, fp, #16
    0xe0019834     0xb4    bl e0014da0 <slotCapLongRunningDelete>
    0xe0019838     0xb8    subs r1, r0, #0
    0xe001983c     0xbc    bne e00199cc <decodeSetSpace+0x24c>
    0xe0019840     0xc0    ldr r2, [sp, #48]     ; stack access
    0xe0019844     0xc4    ldr r3, [r7]          ; stack access
    0xe0019848     0xc8    cmp r2, #0
    0xe001984c     0xcc    str r3, [sp, #48]     ; stack access
    0xe0019850     0xd0    beq e0019870 <decodeSetSpace+0xf0>
    0xe0019854     0xd4    ldr ip, [sp, #80]     ; stack access
    0xe0019858     0xd8    mov r3, r9
    0xe001985c     0xdc    mov r0, r6
    0xe0019860     0xe0    str r9, [sp, #76]     ; stack access
    0xe0019864     0xe4    str ip, [sp]          ; stack access
    0xe0019868     0xe8    bl e0015e7c <updateCapData>
    0xe001986c     0xec    ldr r9, [sp, #76]     ; stack access
    0xe0019870     0xf0    str r9, [sp, #76]     ; stack access
    0xe0019874     0xf4    add r0, sp, #100 
    0xe0019878     0xf8    mov r1, r4
    0xe001987c     0xfc    ldm r6, {r2, r3}      ; stack access
    0xe0019880    0x100    bl e0014bf4 <deriveCap>
    0xe0019884    0x104    ldr r0, [sp, #100]    ; stack access
    0xe0019888    0x108    cmp r0, #0
    0xe001988c    0x10c    bne e00197c8 <decodeSetSpace+0x48>
    0xe0019890    0x110    add r9, sp, #112 
    0xe0019894    0x114    ldr fp, [r9, #-8]!    ; stack access
    0xe0019898    0x118    and r3, fp, #14
    0xe001989c    0x11c    cmp r3, #14
    0xe00198a0    0x120    ldm r9, {r0, r1}      ; stack access
    0xe00198a4    0x124    andne r3, fp, #15
    0xe00198a8    0x128    uxtbeq r3, fp
    0xe00198ac    0x12c    cmp r3, #10
    0xe00198b0    0x130    stm r6, {r0, r1}      ; stack access
    0xe00198b4    0x134    bne e00199cc <decodeSetSpace+0x24c>
    0xe00198b8    0x138    ldr r2, [sp, #52]     ; stack access
    0xe00198bc    0x13c    cmp r2, #0
    0xe00198c0    0x140    beq e00198ec <decodeSetSpace+0x16c>
    0xe00198c4    0x144    ldr r0, [sp, #48]     ; stack access
    0xe00198c8    0x148    mov r1, #0
    0xe00198cc    0x14c    ldr ip, [sp, #88]     ; stack access
    0xe00198d0    0x150    mov r3, r0
    0xe00198d4    0x154    str r0, [sp, #84]     ; stack access
    0xe00198d8    0x158    str ip, [sp]          ; stack access
    0xe00198dc    0x15c    mov r0, r7
    0xe00198e0    0x160    bl e0015e7c <updateCapData>
    0xe00198e4    0x164    ldr r3, [sp, #84]     ; stack access
    0xe00198e8    0x168    str r3, [sp, #48]     ; stack access
    0xe00198ec    0x16c    ldr r3, [sp, #48]     ; stack access
    0xe00198f0    0x170    add r0, sp, #100 
    0xe00198f4    0x174    mov r1, r5
    0xe00198f8    0x178    str r3, [sp, #84]     ; stack access
    0xe00198fc    0x17c    ldm r7, {r2, r3}      ; stack access
    0xe0019900    0x180    bl e0014bf4 <deriveCap>
    0xe0019904    0x184    ldr r0, [sp, #100]    ; stack access
    0xe0019908    0x188    cmp r0, #0
    0xe001990c    0x18c    bne e00197c8 <decodeSetSpace+0x48>
    0xe0019910    0x190    ldr r3, [sp, #104]    ; stack access
    0xe0019914    0x194    ldm r9, {r0, r1}      ; stack access
    0xe0019918    0x198    and r2, r3, #14
    0xe001991c    0x19c    cmp r2, #14
    0xe0019920    0x1a0    andne r2, r3, #15
    0xe0019924    0x1a4    uxtbeq r2, r3
    0xe0019928    0x1a8    cmp r2, #9
    0xe001992c    0x1ac    stm r7, {r0, r1}      ; stack access
    0xe0019930    0x1b0    bne e00199cc <decodeSetSpace+0x24c>
    0xe0019934    0x1b4    tst r3, #16
    0xe0019938    0x1b8    str r3, [sp, #48]     ; stack access
    0xe001993c    0x1bc    beq e00199cc <decodeSetSpace+0x24c>
    0xe0019940    0x1c0    ldr r1, [r8]
    0xe0019944    0x1c4    ldr r2, [r1, #80] 
    0xe0019948    0x1c8    mov r0, r1
    0xe001994c    0x1cc    bic r2, r2, #15
    0xe0019950    0x1d0    orr r2, r2, #2
    0xe0019954    0x1d4    str r2, [r1, #80] 
    0xe0019958    0x1d8    bl e0013114 <setThreadState.part.166>
    0xe001995c    0x1dc    add r2, sp, #92 
    0xe0019960    0x1e0    mov ip, #0
    0xe0019964    0x1e4    ldr r3, [sp, #48]     ; stack access
    0xe0019968    0x1e8    str ip, [sp, #92]     ; stack access
    0xe001996c    0x1ec    add lr, sp, #32
    0xe0019970    0x1f0    str ip, [sp, #96]     ; stack access
    0xe0019974    0x1f4    ldm r2, {r0, r1}      ; stack access
    0xe0019978    0x1f8    str r3, [sp, #84]     ; stack access
    0xe001997c    0x1fc    mov r3, #4
    0xe0019980    0x200    str ip, [sp, #40]     ; stack access
    0xe0019984    0x204    str r3, [sp, #44]     ; stack access
    0xe0019988    0x208    mov r3, ip
    0xe001998c    0x20c    ldr r2, [sp, #56]     ; stack access
    0xe0019990    0x210    stm lr, {r0, r1}      ; stack access
    0xe0019994    0x214    add lr, sp, #16
    0xe0019998    0x218    ldm r7, {r0, r1}      ; stack access
    0xe001999c    0x21c    str fp, [sp, #76]     ; stack access
    0xe00199a0    0x220    str ip, [sp, #28]     ; stack access
    0xe00199a4    0x224    str r5, [sp, #24]     ; stack access
    0xe00199a8    0x228    stm lr, {r0, r1}      ; stack access
    0xe00199ac    0x22c    ldm r6, {r0, r1}      ; stack access
    0xe00199b0    0x230    str ip, [sp]          ; stack access
    0xe00199b4    0x234    str r4, [sp, #12]     ; stack access
    0xe00199b8    0x238    stmib sp, {r0, r1}    ; stack access
    0xe00199bc    0x23c    bic r0, sl, #15
    0xe00199c0    0x240    ldr r1, [sp, #60]     ; stack access
    0xe00199c4    0x244    bl e0018d60 <invokeTCB_ThreadControl>
    0xe00199c8    0x248    b e00197c8 <decodeSetSpace+0x48>
    0xe00199cc    0x24c    movw r3, #36896 
    0xe00199d0    0x250    movt r3, #57346 
    0xe00199d4    0x254    mov r2, #3
    0xe00199d8    0x258    mov r0, r2
    0xe00199dc    0x25c    str r2, [r3, #24]
    0xe00199e0    0x260    add sp, sp, #116 
    0xe00199e4    0x264    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
154 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeSetSpace` has 264 nodes.

Section invokeTCB_ThreadControl (282 of 299)
============================================

Deriving specifications
-----------------------

Section `invokeTCB_ThreadControl` consists of 112 instructions.
 STMIA;12,0...+


Stack analysis
---------------

22 stack accesses found. Annotated code for `invokeTCB_ThreadControl`:

    0xe0018d60      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0018d64      0x4    sub sp, sp, #8
    0xe0018d68      0x8    mov r5, r0
    0xe0018d6c      0xc    bic r0, r0, #15
    0xe0018d70     0x10    ldr r4, [sp, #76]     ; stack access
    0xe0018d74     0x14    mov r7, r1
    0xe0018d78     0x18    orr r0, r0, #12
    0xe0018d7c     0x1c    mov ip, #0
    0xe0018d80     0x20    tst r4, #4
    0xe0018d84     0x24    and r1, r4, #8
    0xe0018d88     0x28    stm sp, {r0, ip}      ; stack access
    0xe0018d8c     0x2c    beq e0018e4c <invokeTCB_ThreadControl+0xec>
    0xe0018d90     0x30    bic r6, r5, #508 
    0xe0018d94     0x34    cmp r1, ip
    0xe0018d98     0x38    bic r6, r6, #3
    0xe0018d9c     0x3c    strne r3, [r5, #116] 
    0xe0018da0     0x40    str r2, [r5, #128] 
    0xe0018da4     0x44    mov r1, #1
    0xe0018da8     0x48    mov r0, r6
    0xe0018dac     0x4c    bl e0016a68 <cteDelete>
    0xe0018db0     0x50    cmp r0, #0
    0xe0018db4     0x54    bne e0018f04 <invokeTCB_ThreadControl+0x1a4>
    0xe0018db8     0x58    ldr r3, [sp, #44]     ; stack access
    0xe0018dbc     0x5c    add r8, sp, #36 
    0xe0018dc0     0x60    ldm r8, {r0, r1}      ; stack access
    0xe0018dc4     0x64    ldm r3, {r2, r3}
    0xe0018dc8     0x68    bl e0014c9c <sameObjectAs>
    0xe0018dcc     0x6c    cmp r0, #0
    0xe0018dd0     0x70    beq e0018dec <invokeTCB_ThreadControl+0x8c>
    0xe0018dd4     0x74    add r1, sp, #8
    0xe0018dd8     0x78    ldm r7, {r2, r3}
    0xe0018ddc     0x7c    ldmdb r1, {r0, r1}    ; stack access
    0xe0018de0     0x80    bl e0014c9c <sameObjectAs>
    0xe0018de4     0x84    cmp r0, #0
    0xe0018de8     0x88    bne e0018f0c <invokeTCB_ThreadControl+0x1ac>
    0xe0018dec     0x8c    add r6, r6, #16
    0xe0018df0     0x90    mov r1, #1
    0xe0018df4     0x94    mov r0, r6
    0xe0018df8     0x98    bl e0016a68 <cteDelete>
    0xe0018dfc     0x9c    cmp r0, #0
    0xe0018e00     0xa0    bne e0018f04 <invokeTCB_ThreadControl+0x1a4>
    0xe0018e04     0xa4    ldr r3, [sp, #56]     ; stack access
    0xe0018e08     0xa8    add r8, sp, #48 
    0xe0018e0c     0xac    ldm r8, {r0, r1}      ; stack access
    0xe0018e10     0xb0    ldm r3, {r2, r3}
    0xe0018e14     0xb4    bl e0014c9c <sameObjectAs>
    0xe0018e18     0xb8    cmp r0, #0
    0xe0018e1c     0xbc    beq e0018e54 <invokeTCB_ThreadControl+0xf4>
    0xe0018e20     0xc0    add r1, sp, #8
    0xe0018e24     0xc4    ldm r7, {r2, r3}
    0xe0018e28     0xc8    ldmdb r1, {r0, r1}    ; stack access
    0xe0018e2c     0xcc    bl e0014c9c <sameObjectAs>
    0xe0018e30     0xd0    cmp r0, #0
    0xe0018e34     0xd4    beq e0018e54 <invokeTCB_ThreadControl+0xf4>
    0xe0018e38     0xd8    mov r3, r6
    0xe0018e3c     0xdc    ldr r2, [sp, #56]     ; stack access
    0xe0018e40     0xe0    ldm r8, {r0, r1}      ; stack access
    0xe0018e44     0xe4    bl e0013308 <cteInsert>
    0xe0018e48     0xe8    b e0018e54 <invokeTCB_ThreadControl+0xf4>
    0xe0018e4c     0xec    cmp r1, #0
    0xe0018e50     0xf0    strne r3, [r5, #116] 
    0xe0018e54     0xf4    tst r4, #2
    0xe0018e58     0xf8    beq e0018eec <invokeTCB_ThreadControl+0x18c>
    0xe0018e5c     0xfc    bic r0, r5, #508 
    0xe0018e60    0x100    mov r1, #1
    0xe0018e64    0x104    bic r0, r0, #3
    0xe0018e68    0x108    add r6, r0, #64 
    0xe0018e6c    0x10c    mov r0, r6
    0xe0018e70    0x110    bl e0016a68 <cteDelete>
    0xe0018e74    0x114    cmp r0, #0
    0xe0018e78    0x118    bne e0018f04 <invokeTCB_ThreadControl+0x1a4>
    0xe0018e7c    0x11c    ldr r3, [sp, #72]     ; stack access
    0xe0018e80    0x120    cmp r3, #0
    0xe0018e84    0x124    ldr r3, [sp, #60]     ; stack access
    0xe0018e88    0x128    str r3, [r5, #132] 
    0xe0018e8c    0x12c    beq e0018ed4 <invokeTCB_ThreadControl+0x174>
    0xe0018e90    0x130    ldr r3, [sp, #72]     ; stack access
    0xe0018e94    0x134    add r8, sp, #64 
    0xe0018e98    0x138    ldm r8, {r0, r1}      ; stack access
    0xe0018e9c    0x13c    ldm r3, {r2, r3}
    0xe0018ea0    0x140    bl e0014c9c <sameObjectAs>
    0xe0018ea4    0x144    cmp r0, #0
    0xe0018ea8    0x148    beq e0018ed4 <invokeTCB_ThreadControl+0x174>
    0xe0018eac    0x14c    add r1, sp, #8
    0xe0018eb0    0x150    ldm r7, {r2, r3}
    0xe0018eb4    0x154    ldmdb r1, {r0, r1}    ; stack access
    0xe0018eb8    0x158    bl e0014c9c <sameObjectAs>
    0xe0018ebc    0x15c    cmp r0, #0
    0xe0018ec0    0x160    beq e0018ed4 <invokeTCB_ThreadControl+0x174>
    0xe0018ec4    0x164    mov r3, r6
    0xe0018ec8    0x168    ldr r2, [sp, #72]     ; stack access
    0xe0018ecc    0x16c    ldm r8, {r0, r1}      ; stack access
    0xe0018ed0    0x170    bl e0013308 <cteInsert>
    0xe0018ed4    0x174    movw r3, #13900 
    0xe0018ed8    0x178    movt r3, #57347 
    0xe0018edc    0x17c    ldr r3, [r3]
    0xe0018ee0    0x180    cmp r3, r5
    0xe0018ee4    0x184    bne e0018eec <invokeTCB_ThreadControl+0x18c>
    0xe0018ee8    0x188    bl e0013098 <rescheduleRequired>
    0xe0018eec    0x18c    ands r0, r4, #1
    0xe0018ef0    0x190    beq e0018f04 <invokeTCB_ThreadControl+0x1a4>
    0xe0018ef4    0x194    mov r0, r5
    0xe0018ef8    0x198    ldr r1, [sp, #32]     ; stack access
    0xe0018efc    0x19c    bl e001676c <setPriority>
    0xe0018f00    0x1a0    mov r0, #0
    0xe0018f04    0x1a4    add sp, sp, #8
    0xe0018f08    0x1a8    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0018f0c    0x1ac    mov r3, r6
    0xe0018f10    0x1b0    ldr r2, [sp, #44]     ; stack access
    0xe0018f14    0x1b4    ldm r8, {r0, r1}      ; stack access
    0xe0018f18    0x1b8    bl e0013308 <cteInsert>
    0xe0018f1c    0x1bc    b e0018dec <invokeTCB_ThreadControl+0x8c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
112 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `invokeTCB_ThreadControl` has 192 nodes.

Section handleRecv (283 of 299)
===============================

Deriving specifications
-----------------------

Section `handleRecv` consists of 88 instructions.
 LDMIA;8,5...+
 LDMDB;2,1...++
 STMIA;6,1...+
 STMIA;6,2...+
 STMIA;6,3...+


Stack analysis
---------------

13 stack accesses found. Annotated code for `handleRecv`:

    0xe001889c      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe00188a0      0x4    movw r4, #13900 
    0xe00188a4      0x8    movt r4, #57347 
    0xe00188a8      0xc    sub sp, sp, #16
    0xe00188ac     0x10    mov r7, r0
    0xe00188b0     0x14    add r0, sp, #4
    0xe00188b4     0x18    ldr r1, [r4]
    0xe00188b8     0x1c    ldr r6, [r1]
    0xe00188bc     0x20    mov r2, r6
    0xe00188c0     0x24    bl e0012d38 <lookupSlot>
    0xe00188c4     0x28    ldr r3, [sp, #4]      ; stack access
    0xe00188c8     0x2c    cmp r3, #0
    0xe00188cc     0x30    bne e00189b4 <handleRecv+0x118>
    0xe00188d0     0x34    ldr r3, [sp, #8]      ; stack access
    0xe00188d4     0x38    ldm r3, {r5, r8}
    0xe00188d8     0x3c    and r3, r5, #14
    0xe00188dc     0x40    cmp r3, #14
    0xe00188e0     0x44    andne r3, r5, #15
    0xe00188e4     0x48    uxtbeq r3, r5
    0xe00188e8     0x4c    cmp r3, #4
    0xe00188ec     0x50    ldr r0, [r4]
    0xe00188f0     0x54    beq e0018974 <handleRecv+0xd8>
    0xe00188f4     0x58    cmp r3, #6
    0xe00188f8     0x5c    bne e0018940 <handleRecv+0xa4>
    0xe00188fc     0x60    bic r3, r5, #15
    0xe0018900     0x64    tst r8, #2
    0xe0018904     0x68    ldr r3, [r3, #12]
    0xe0018908     0x6c    bic r3, r3, #15
    0xe001890c     0x70    beq e0018940 <handleRecv+0xa4>
    0xe0018910     0x74    cmp r3, #0
    0xe0018914     0x78    bne e0018938 <handleRecv+0x9c>
    0xe0018918     0x7c    add r2, sp, #16
    0xe001891c     0x80    str r5, [sp, #8]      ; stack access
    0xe0018920     0x84    str r8, [sp, #12]     ; stack access
    0xe0018924     0x88    mov r3, r7
    0xe0018928     0x8c    ldmdb r2, {r1, r2}    ; stack access
    0xe001892c     0x90    add sp, sp, #16
    0xe0018930     0x94    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0018934     0x98    b e0013fcc <receiveSignal>
    0xe0018938     0x9c    cmp r0, r3
    0xe001893c     0xa0    beq e0018918 <handleRecv+0x7c>
    0xe0018940     0xa4    movw r2, #36884 
    0xe0018944     0xa8    movw r3, #32768 
    0xe0018948     0xac    movt r2, #57346 
    0xe001894c     0xb0    movt r3, #57346 
    0xe0018950     0xb4    mov r1, #1
    0xe0018954     0xb8    mov ip, #0
    0xe0018958     0xbc    str r1, [r2]
    0xe001895c     0xc0    mov r1, #-2147483647 
    0xe0018960     0xc4    str ip, [r2, #4]
    0xe0018964     0xc8    stm r3, {r1, r6}
    0xe0018968     0xcc    add sp, sp, #16
    0xe001896c     0xd0    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0018970     0xd4    b e0018508 <handleFault>
    0xe0018974     0xd8    ubfx r3, r8, #1, #1
    0xe0018978     0xdc    cmp r3, #0
    0xe001897c     0xe0    beq e00189d4 <handleRecv+0x138>
    0xe0018980     0xe4    bic r0, r0, #508 
    0xe0018984     0xe8    bic r0, r0, #3
    0xe0018988     0xec    add r0, r0, #48 
    0xe001898c     0xf0    bl e00173d0 <cteDeleteOne>
    0xe0018990     0xf4    add r2, sp, #16
    0xe0018994     0xf8    str r5, [sp, #8]      ; stack access
    0xe0018998     0xfc    mov r3, r7
    0xe001899c    0x100    str r8, [sp, #12]     ; stack access
    0xe00189a0    0x104    ldr r0, [r4]
    0xe00189a4    0x108    ldmdb r2, {r1, r2}    ; stack access
    0xe00189a8    0x10c    add sp, sp, #16
    0xe00189ac    0x110    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe00189b0    0x114    b e001865c <receiveIPC>
    0xe00189b4    0x118    movw r3, #32768 
    0xe00189b8    0x11c    movt r3, #57346 
    0xe00189bc    0x120    mov r2, #-2147483647 
    0xe00189c0    0x124    ldr r0, [r4]
    0xe00189c4    0x128    stm r3, {r2, r6}
    0xe00189c8    0x12c    add sp, sp, #16
    0xe00189cc    0x130    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe00189d0    0x134    b e0018508 <handleFault>
    0xe00189d4    0x138    movw r1, #36884 
    0xe00189d8    0x13c    movw r2, #32768 
    0xe00189dc    0x140    movt r1, #57346 
    0xe00189e0    0x144    movt r2, #57346 
    0xe00189e4    0x148    mov ip, #1
    0xe00189e8    0x14c    str r3, [r1, #4]
    0xe00189ec    0x150    mov r3, #-2147483647 
    0xe00189f0    0x154    str ip, [r1]
    0xe00189f4    0x158    stm r2, {r3, r6}
    0xe00189f8    0x15c    b e0018968 <handleRecv+0xcc>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
88 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleRecv` has 139 nodes.

Section receiveIPC (284 of 299)
===============================

Deriving specifications
-----------------------

Section `receiveIPC` consists of 144 instructions.


Stack analysis
---------------

12 stack accesses found. Annotated code for `receiveIPC`:

    0xe001865c      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0018660      0x4    sub sp, sp, #24
    0xe0018664      0x8    add ip, sp, #24
    0xe0018668      0xc    stmdb ip, {r1, r2}    ; stack access
    0xe001866c     0x10    ldr r2, [r0, #92] 
    0xe0018670     0x14    ldr r5, [sp, #20]     ; stack access
    0xe0018674     0x18    cmp r2, #0
    0xe0018678     0x1c    bic r1, r5, #15
    0xe001867c     0x20    beq e0018690 <receiveIPC+0x34>
    0xe0018680     0x24    ldr ip, [r2]
    0xe0018684     0x28    and lr, ip, #3
    0xe0018688     0x2c    cmp lr, #2
    0xe001868c     0x30    beq e00186b8 <receiveIPC+0x5c>
    0xe0018690     0x34    ldr r2, [r1]
    0xe0018694     0x38    mov r4, r0
    0xe0018698     0x3c    and r0, r2, #3
    0xe001869c     0x40    cmp r0, #1
    0xe00186a0     0x44    beq e0018760 <receiveIPC+0x104>
    0xe00186a4     0x48    bcc e00186d0 <receiveIPC+0x74>
    0xe00186a8     0x4c    cmp r0, #2
    0xe00186ac     0x50    beq e00186d0 <receiveIPC+0x74>
    0xe00186b0     0x54    add sp, sp, #24
    0xe00186b4     0x58    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe00186b8     0x5c    ldr r3, [r2, #8]
    0xe00186bc     0x60    bic ip, ip, #3
    0xe00186c0     0x64    str r3, [r0]
    0xe00186c4     0x68    str ip, [r2]
    0xe00186c8     0x6c    add sp, sp, #24
    0xe00186cc     0x70    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe00186d0     0x74    cmp r3, #0
    0xe00186d4     0x78    streq r3, [r4]
    0xe00186d8     0x7c    beq e00186b0 <receiveIPC+0x54>
    0xe00186dc     0x80    movw r2, #13900 
    0xe00186e0     0x84    movt r2, #57347 
    0xe00186e4     0x88    ldr r3, [r4, #88] 
    0xe00186e8     0x8c    lsl r5, r5, #1
    0xe00186ec     0x90    ldr r0, [r2]
    0xe00186f0     0x94    and r5, r5, #8
    0xe00186f4     0x98    bic r3, r3, #8
    0xe00186f8     0x9c    orr r2, r1, #3
    0xe00186fc     0xa0    cmp r4, r0
    0xe0018700     0xa4    orr r5, r5, r3
    0xe0018704     0xa8    str r2, [r4, #80] 
    0xe0018708     0xac    str r5, [r4, #88] 
    0xe001870c     0xb0    beq e0018850 <receiveIPC+0x1f4>
    0xe0018710     0xb4    ldr r2, [r1, #4]
    0xe0018714     0xb8    bic lr, r4, #15
    0xe0018718     0xbc    ldr r3, [r1]
    0xe001871c     0xc0    bics r0, r2, #15
    0xe0018720     0xc4    and r2, r2, #15
    0xe0018724     0xc8    bic ip, r3, #15
    0xe0018728     0xcc    and r3, r3, #12
    0xe001872c     0xd0    moveq r0, r4
    0xe0018730     0xd4    orr r3, r3, #2
    0xe0018734     0xd8    bic r0, r0, #15
    0xe0018738     0xdc    strne r4, [ip, #144] 
    0xe001873c     0xe0    orr r2, r2, r0
    0xe0018740     0xe4    str ip, [r4, #148] 
    0xe0018744     0xe8    orr r3, r3, lr
    0xe0018748     0xec    mov r0, #0
    0xe001874c     0xf0    str r0, [r4, #144] 
    0xe0018750     0xf4    str r3, [r1]
    0xe0018754     0xf8    str r2, [r1, #4]
    0xe0018758     0xfc    add sp, sp, #24
    0xe001875c    0x100    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe0018760    0x104    ldr r0, [r1, #4]
    0xe0018764    0x108    bic r6, r0, #15
    0xe0018768    0x10c    and r0, r0, #15
    0xe001876c    0x110    ldr r3, [r6, #148] 
    0xe0018770    0x114    ldr ip, [r6, #144] 
    0xe0018774    0x118    cmp r3, #0
    0xe0018778    0x11c    strne ip, [r3, #144] 
    0xe001877c    0x120    moveq lr, ip
    0xe0018780    0x124    ldrne lr, [r6, #144] 
    0xe0018784    0x128    movne ip, r6
    0xe0018788    0x12c    cmp lr, #0
    0xe001878c    0x130    strne r3, [lr, #148] 
    0xe0018790    0x134    bicne r3, r2, #15
    0xe0018794    0x138    bic r3, r3, #15
    0xe0018798    0x13c    and r2, r2, #15
    0xe001879c    0x140    cmp ip, #0
    0xe00187a0    0x144    orr r2, r2, r3
    0xe00187a4    0x148    bic ip, ip, #15
    0xe00187a8    0x14c    biceq r2, r2, #3
    0xe00187ac    0x150    orr r0, r0, ip
    0xe00187b0    0x154    str r2, [r1]
    0xe00187b4    0x158    str r0, [r1, #4]
    0xe00187b8    0x15c    mov r0, r6
    0xe00187bc    0x160    ldr r8, [r6, #88] 
    0xe00187c0    0x164    str r4, [sp]          ; stack access
    0xe00187c4    0x168    lsr r7, r8, #3
    0xe00187c8    0x16c    lsr r2, r8, #4
    0xe00187cc    0x170    and r3, r7, #1
    0xe00187d0    0x174    bl e0017fe8 <doIPCTransfer>
    0xe00187d4    0x178    ldr r3, [r6, #88] 
    0xe00187d8    0x17c    tst r3, #2
    0xe00187dc    0x180    beq e001881c <receiveIPC+0x1c0>
    0xe00187e0    0x184    orr r7, r7, r8, lsr #2
    0xe00187e4    0x188    tst r7, #1
    0xe00187e8    0x18c    bne e0018878 <receiveIPC+0x21c>
    0xe00187ec    0x190    movw r2, #13900 
    0xe00187f0    0x194    movt r2, #57347 
    0xe00187f4    0x198    ldr r3, [r6, #80] 
    0xe00187f8    0x19c    ldr r2, [r2]
    0xe00187fc    0x1a0    bic r3, r3, #15
    0xe0018800    0x1a4    str r3, [r6, #80] 
    0xe0018804    0x1a8    cmp r6, r2
    0xe0018808    0x1ac    bne e00186b0 <receiveIPC+0x54>
    0xe001880c    0x1b0    mov r0, r6
    0xe0018810    0x1b4    add sp, sp, #24
    0xe0018814    0x1b8    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe0018818    0x1bc    b e0013114 <setThreadState.part.166>
    0xe001881c    0x1c0    movw r2, #13900 
    0xe0018820    0x1c4    movt r2, #57347 
    0xe0018824    0x1c8    ldr r3, [r6, #80] 
    0xe0018828    0x1cc    ldr r2, [r2]
    0xe001882c    0x1d0    bic r3, r3, #15
    0xe0018830    0x1d4    cmp r6, r2
    0xe0018834    0x1d8    orr r3, r3, #1
    0xe0018838    0x1dc    str r3, [r6, #80] 
    0xe001883c    0x1e0    beq e0018890 <receiveIPC+0x234>
    0xe0018840    0x1e4    mov r0, r6
    0xe0018844    0x1e8    add sp, sp, #24
    0xe0018848    0x1ec    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe001884c    0x1f0    b e00131ec <possibleSwitchTo>
    0xe0018850    0x1f4    movw r3, #36892 
    0xe0018854    0x1f8    movt r3, #57346 
    0xe0018858    0x1fc    ldr r3, [r3]
    0xe001885c    0x200    cmp r3, #0
    0xe0018860    0x204    bne e0018710 <receiveIPC+0xb4>
    0xe0018864    0x208    mov r0, r4
    0xe0018868    0x20c    str r1, [sp, #12]     ; stack access
    0xe001886c    0x210    bl e00130d0 <scheduleTCB.part.165>
    0xe0018870    0x214    ldr r1, [sp, #12]     ; stack access
    0xe0018874    0x218    b e0018710 <receiveIPC+0xb4>
    0xe0018878    0x21c    ubfx r2, r5, #2, #1
    0xe001887c    0x220    mov r1, r4
    0xe0018880    0x224    mov r0, r6
    0xe0018884    0x228    add sp, sp, #24
    0xe0018888    0x22c    pop {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe001888c    0x230    b e0017bf0 <setupCallerCap>
    0xe0018890    0x234    mov r0, r6
    0xe0018894    0x238    bl e0013114 <setThreadState.part.166>
    0xe0018898    0x23c    b e0018840 <receiveIPC+0x1e4>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
144 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `receiveIPC` has 241 nodes.

Section sendIPC (285 of 299)
============================

Deriving specifications
-----------------------

Section `sendIPC` consists of 128 instructions.


Stack analysis
---------------

9 stack accesses found. Annotated code for `sendIPC`:

    0xe00181f0      0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe00181f4      0x4    sub sp, sp, #8
    0xe00181f8      0x8    mov r7, r3
    0xe00181fc      0xc    mov r8, r1
    0xe0018200     0x10    ldr r4, [sp, #48]     ; stack access
    0xe0018204     0x14    ldr r9, [sp, #40]     ; stack access
    0xe0018208     0x18    ldr r6, [sp, #44]     ; stack access
    0xe001820c     0x1c    ldr r3, [r4]
    0xe0018210     0x20    and r1, r3, #3
    0xe0018214     0x24    cmp r1, #1
    0xe0018218     0x28    bls e00182f0 <sendIPC+0x100>
    0xe001821c     0x2c    cmp r1, #2
    0xe0018220     0x30    bne e00182e8 <sendIPC+0xf8>
    0xe0018224     0x34    ldr r0, [r4, #4]
    0xe0018228     0x38    movw sl, #13900 
    0xe001822c     0x3c    movt sl, #57347 
    0xe0018230     0x40    bic r5, r0, #15
    0xe0018234     0x44    and r0, r0, #15
    0xe0018238     0x48    ldr r1, [r5, #148] 
    0xe001823c     0x4c    ldr ip, [r5, #144] 
    0xe0018240     0x50    cmp r1, #0
    0xe0018244     0x54    strne ip, [r1, #144] 
    0xe0018248     0x58    moveq lr, ip
    0xe001824c     0x5c    ldrne lr, [r5, #144] 
    0xe0018250     0x60    movne ip, r5
    0xe0018254     0x64    cmp lr, #0
    0xe0018258     0x68    strne r1, [lr, #148] 
    0xe001825c     0x6c    bicne r1, r3, #15
    0xe0018260     0x70    bic r1, r1, #15
    0xe0018264     0x74    and r3, r3, #15
    0xe0018268     0x78    cmp ip, #0
    0xe001826c     0x7c    orr r3, r3, r1
    0xe0018270     0x80    bic ip, ip, #15
    0xe0018274     0x84    biceq r3, r3, #3
    0xe0018278     0x88    orr ip, r0, ip
    0xe001827c     0x8c    str r3, [r4]
    0xe0018280     0x90    str ip, [r4, #4]
    0xe0018284     0x94    mov r1, r4
    0xe0018288     0x98    mov r3, r7
    0xe001828c     0x9c    str r5, [sp]          ; stack access
    0xe0018290     0xa0    mov r0, r6
    0xe0018294     0xa4    bl e0017fe8 <doIPCTransfer>
    0xe0018298     0xa8    ldr r2, [sl]
    0xe001829c     0xac    ldr r3, [r5, #80] 
    0xe00182a0     0xb0    cmp r5, r2
    0xe00182a4     0xb4    ldr r4, [r5, #88] 
    0xe00182a8     0xb8    bic r3, r3, #15
    0xe00182ac     0xbc    orr r3, r3, #1
    0xe00182b0     0xc0    str r3, [r5, #80] 
    0xe00182b4     0xc4    beq e001839c <sendIPC+0x1ac>
    0xe00182b8     0xc8    mov r0, r5
    0xe00182bc     0xcc    bl e00131ec <possibleSwitchTo>
    0xe00182c0     0xd0    cmp r8, #0
    0xe00182c4     0xd4    beq e00182e8 <sendIPC+0xf8>
    0xe00182c8     0xd8    orrs r3, r7, r9
    0xe00182cc     0xdc    bne e00183c8 <sendIPC+0x1d8>
    0xe00182d0     0xe0    ldr r2, [sl]
    0xe00182d4     0xe4    ldr r3, [r6, #80] 
    0xe00182d8     0xe8    cmp r6, r2
    0xe00182dc     0xec    bic r3, r3, #15
    0xe00182e0     0xf0    str r3, [r6, #80] 
    0xe00182e4     0xf4    beq e00183e0 <sendIPC+0x1f0>
    0xe00182e8     0xf8    add sp, sp, #8
    0xe00182ec     0xfc    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe00182f0    0x100    cmp r0, #0
    0xe00182f4    0x104    beq e00182e8 <sendIPC+0xf8>
    0xe00182f8    0x108    ldr r3, [r6, #88] 
    0xe00182fc    0x10c    lsl r1, r7, #3
    0xe0018300    0x110    movw r0, #13900 
    0xe0018304    0x114    movt r0, #57347 
    0xe0018308    0x118    and r7, r3, #15
    0xe001830c    0x11c    lsl r9, r9, #2
    0xe0018310    0x120    orr r7, r7, r2, lsl #4
    0xe0018314    0x124    and r3, r1, #8
    0xe0018318    0x128    bic r7, r7, #12
    0xe001831c    0x12c    ldr r1, [r0]
    0xe0018320    0x130    orr r7, r7, r3
    0xe0018324    0x134    and r9, r9, #4
    0xe0018328    0x138    lsl r2, r8, #1
    0xe001832c    0x13c    cmp r6, r1
    0xe0018330    0x140    orr r8, r7, r9
    0xe0018334    0x144    and r2, r2, #2
    0xe0018338    0x148    bic r8, r8, #2
    0xe001833c    0x14c    bic r3, r4, #15
    0xe0018340    0x150    orr r8, r8, r2
    0xe0018344    0x154    orr r3, r3, #4
    0xe0018348    0x158    str r8, [r6, #88] 
    0xe001834c    0x15c    str r3, [r6, #80] 
    0xe0018350    0x160    beq e00183a8 <sendIPC+0x1b8>
    0xe0018354    0x164    ldm r4, {r0, r3}
    0xe0018358    0x168    bic r2, r6, #15
    0xe001835c    0x16c    orr r2, r2, #1
    0xe0018360    0x170    bics r1, r3, #15
    0xe0018364    0x174    bic ip, r0, #15
    0xe0018368    0x178    and r3, r3, #15
    0xe001836c    0x17c    and r0, r0, #12
    0xe0018370    0x180    moveq r1, r6
    0xe0018374    0x184    bic r1, r1, #15
    0xe0018378    0x188    strne r6, [ip, #144] 
    0xe001837c    0x18c    orr r3, r3, r1
    0xe0018380    0x190    str ip, [r6, #148] 
    0xe0018384    0x194    mov r1, #0
    0xe0018388    0x198    orr r2, r2, r0
    0xe001838c    0x19c    str r1, [r6, #144] 
    0xe0018390    0x1a0    strd r2, [r4]
    0xe0018394    0x1a4    add sp, sp, #8
    0xe0018398    0x1a8    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe001839c    0x1ac    mov r0, r5
    0xe00183a0    0x1b0    bl e0013114 <setThreadState.part.166>
    0xe00183a4    0x1b4    b e00182b8 <sendIPC+0xc8>
    0xe00183a8    0x1b8    movw r3, #36892 
    0xe00183ac    0x1bc    movt r3, #57346 
    0xe00183b0    0x1c0    ldr r3, [r3]
    0xe00183b4    0x1c4    cmp r3, #0
    0xe00183b8    0x1c8    bne e0018354 <sendIPC+0x164>
    0xe00183bc    0x1cc    mov r0, r6
    0xe00183c0    0x1d0    bl e00130d0 <scheduleTCB.part.165>
    0xe00183c4    0x1d4    b e0018354 <sendIPC+0x164>
    0xe00183c8    0x1d8    ubfx r2, r4, #3, #1
    0xe00183cc    0x1dc    mov r1, r5
    0xe00183d0    0x1e0    mov r0, r6
    0xe00183d4    0x1e4    add sp, sp, #8
    0xe00183d8    0x1e8    pop {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe00183dc    0x1ec    b e0017bf0 <setupCallerCap>
    0xe00183e0    0x1f0    mov r0, r6
    0xe00183e4    0x1f4    add sp, sp, #8
    0xe00183e8    0x1f8    pop {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe00183ec    0x1fc    b e0013114 <setThreadState.part.166>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
128 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `sendIPC` has 205 nodes.

Section doReplyTransfer (286 of 299)
====================================

Deriving specifications
-----------------------

Section `doReplyTransfer` consists of 60 instructions.


Stack analysis
---------------

6 stack accesses found. Annotated code for `doReplyTransfer`:

    0xe0018080     0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0018084     0x4    mov r5, r2
    0xe0018088     0x8    ldr r2, [r1, #96] 
    0xe001808c     0xc    sub sp, sp, #8
    0xe0018090    0x10    mov r4, r1
    0xe0018094    0x14    ands r2, r2, #15
    0xe0018098    0x18    bne e00180e4 <doReplyTransfer+0x64>
    0xe001809c    0x1c    str r1, [sp]          ; stack access
    0xe00180a0    0x20    mov r1, r2
    0xe00180a4    0x24    bl e0017fe8 <doIPCTransfer>
    0xe00180a8    0x28    mov r0, r5
    0xe00180ac    0x2c    bl e00173d0 <cteDeleteOne>
    0xe00180b0    0x30    movw r2, #13900 
    0xe00180b4    0x34    movt r2, #57347 
    0xe00180b8    0x38    ldr r3, [r4, #80] 
    0xe00180bc    0x3c    ldr r2, [r2]
    0xe00180c0    0x40    bic r3, r3, #15
    0xe00180c4    0x44    orr r3, r3, #1
    0xe00180c8    0x48    str r3, [r4, #80] 
    0xe00180cc    0x4c    cmp r4, r2
    0xe00180d0    0x50    beq e0018134 <doReplyTransfer+0xb4>
    0xe00180d4    0x54    mov r0, r4
    0xe00180d8    0x58    add sp, sp, #8
    0xe00180dc    0x5c    pop {r4, r5, r6, lr}  ; stack access
    0xe00180e0    0x60    b e00131ec <possibleSwitchTo>
    0xe00180e4    0x64    mov r6, r0
    0xe00180e8    0x68    mov r0, r5
    0xe00180ec    0x6c    bl e00173d0 <cteDeleteOne>
    0xe00180f0    0x70    mov r1, r6
    0xe00180f4    0x74    mov r0, r4
    0xe00180f8    0x78    bl e0010e58 <handleFaultReply>
    0xe00180fc    0x7c    mov r3, #0
    0xe0018100    0x80    movw r2, #13900 
    0xe0018104    0x84    str r3, [r4, #96] 
    0xe0018108    0x88    str r3, [r4, #100] 
    0xe001810c    0x8c    movt r2, #57347 
    0xe0018110    0x90    ldr r2, [r2]
    0xe0018114    0x94    cmp r0, r3
    0xe0018118    0x98    ldr r3, [r4, #80] 
    0xe001811c    0x9c    bic r3, r3, #15
    0xe0018120    0xa0    beq e001814c <doReplyTransfer+0xcc>
    0xe0018124    0xa4    cmp r4, r2
    0xe0018128    0xa8    orr r3, r3, #2
    0xe001812c    0xac    str r3, [r4, #80] 
    0xe0018130    0xb0    bne e00180d4 <doReplyTransfer+0x54>
    0xe0018134    0xb4    mov r0, r4
    0xe0018138    0xb8    bl e0013114 <setThreadState.part.166>
    0xe001813c    0xbc    mov r0, r4
    0xe0018140    0xc0    add sp, sp, #8
    0xe0018144    0xc4    pop {r4, r5, r6, lr}  ; stack access
    0xe0018148    0xc8    b e00131ec <possibleSwitchTo>
    0xe001814c    0xcc    cmp r4, r2
    0xe0018150    0xd0    str r3, [r4, #80] 
    0xe0018154    0xd4    beq e0018160 <doReplyTransfer+0xe0>
    0xe0018158    0xd8    add sp, sp, #8
    0xe001815c    0xdc    pop {r4, r5, r6, pc}  ; stack access
    0xe0018160    0xe0    mov r0, r4
    0xe0018164    0xe4    add sp, sp, #8
    0xe0018168    0xe8    pop {r4, r5, r6, lr}  ; stack access
    0xe001816c    0xec    b e0013114 <setThreadState.part.166>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
60 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `doReplyTransfer` has 94 nodes.

Section schedule (287 of 299)
=============================

Deriving specifications
-----------------------

Section `schedule` consists of 91 instructions.
Skipping e1830f91 strex r0, r1, [r3]


Stack analysis
---------------

3 stack accesses found. Annotated code for `schedule`:

    0xe00165a8      0x0    push {r4, r5, r6, r7, lr}  ; stack access
    0xe00165ac      0x4    movw r4, #36892 
    0xe00165b0      0x8    movt r4, #57346 
    0xe00165b4      0xc    sub sp, sp, #12
    0xe00165b8     0x10    ldr r5, [r4]
    0xe00165bc     0x14    cmp r5, #0
    0xe00165c0     0x18    beq e0016698 <schedule+0xf0>
    0xe00165c4     0x1c    movw r6, #13900 
    0xe00165c8     0x20    movt r6, #57347 
    0xe00165cc     0x24    ldr r0, [r6]
    0xe00165d0     0x28    ldr r3, [r0, #80] 
    0xe00165d4     0x2c    and r3, r3, #15
    0xe00165d8     0x30    sub r3, r3, #1
    0xe00165dc     0x34    cmp r3, #1
    0xe00165e0     0x38    movhi r0, #0
    0xe00165e4     0x3c    bls e00166a8 <schedule+0x100>
    0xe00165e8     0x40    cmp r5, #1
    0xe00165ec     0x44    beq e00166dc <schedule+0x134>
    0xe00165f0     0x48    movw r3, #36880 
    0xe00165f4     0x4c    movt r3, #57346 
    0xe00165f8     0x50    ldr r2, [r6]
    0xe00165fc     0x54    ldr r3, [r3]
    0xe0016600     0x58    ldr ip, [r5, #120] 
    0xe0016604     0x5c    cmp r2, r3
    0xe0016608     0x60    beq e0016618 <schedule+0x70>
    0xe001660c     0x64    ldr r3, [r2, #120] 
    0xe0016610     0x68    cmp r3, ip
    0xe0016614     0x6c    bls e0016668 <schedule+0xc0>
    0xe0016618     0x70    movw r1, #12288 
    0xe001661c     0x74    movt r1, #57347 
    0xe0016620     0x78    movw r3, #12808 
    0xe0016624     0x7c    movt r3, #57347 
    0xe0016628     0x80    ldr r1, [r1]
    0xe001662c     0x84    ldr r3, [r3, r1, lsl #2]
    0xe0016630     0x88    cmp r3, #0
    0xe0016634     0x8c    beq e0016668 <schedule+0xc0>
    0xe0016638     0x90    clz r3, r3
    0xe001663c     0x94    movw lr, #12292 
    0xe0016640     0x98    rsb r3, r3, #31
    0xe0016644     0x9c    movt lr, #57347 
    0xe0016648     0xa0    rsb r7, r3, #7
    0xe001664c     0xa4    add r1, r7, r1, lsl #3
    0xe0016650     0xa8    ldr r1, [lr, r1, lsl #2]
    0xe0016654     0xac    clz r1, r1
    0xe0016658     0xb0    rsb r1, r1, #31
    0xe001665c     0xb4    orr r3, r1, r3, lsl #5
    0xe0016660     0xb8    cmp r3, ip
    0xe0016664     0xbc    bhi e00166c8 <schedule+0x120>
    0xe0016668     0xc0    cmp r0, #0
    0xe001666c     0xc4    beq e001667c <schedule+0xd4>
    0xe0016670     0xc8    ldr r3, [r2, #120] 
    0xe0016674     0xcc    cmp r3, ip
    0xe0016678     0xd0    beq e00166f0 <schedule+0x148>
    0xe001667c     0xd4    mov r0, r5
    0xe0016680     0xd8    bl e0011294 <setVMRoot>
    0xe0016684     0xdc    add r3, sp, #4
    0xe0016688     0xe0    strex r0, r1, [r3]
    0xe001668c     0xe4    mov r0, r5
    0xe0016690     0xe8    bl e0016384 <tcbSchedDequeue>
    0xe0016694     0xec    str r5, [r6]
    0xe0016698     0xf0    mov r3, #0
    0xe001669c     0xf4    str r3, [r4]
    0xe00166a0     0xf8    add sp, sp, #12
    0xe00166a4     0xfc    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe00166a8    0x100    ldr r3, [r0, #84] 
    0xe00166ac    0x104    tst r3, #1
    0xe00166b0    0x108    movne r0, #1
    0xe00166b4    0x10c    bne e00165e8 <schedule+0x40>
    0xe00166b8    0x110    bl e00107d8 <tcbSchedEnqueue.part.164>
    0xe00166bc    0x114    ldr r5, [r4]
    0xe00166c0    0x118    mov r0, #1
    0xe00166c4    0x11c    b e00165e8 <schedule+0x40>
    0xe00166c8    0x120    ldr r3, [r5, #84] 
    0xe00166cc    0x124    tst r3, #1
    0xe00166d0    0x128    beq e0016708 <schedule+0x160>
    0xe00166d4    0x12c    mov r3, #1
    0xe00166d8    0x130    str r3, [r4]
    0xe00166dc    0x134    bl e001653c <scheduleChooseNewThread>
    0xe00166e0    0x138    mov r3, #0
    0xe00166e4    0x13c    str r3, [r4]
    0xe00166e8    0x140    add sp, sp, #12
    0xe00166ec    0x144    pop {r4, r5, r6, r7, pc}  ; stack access
    0xe00166f0    0x148    ldr r3, [r5, #84] 
    0xe00166f4    0x14c    tst r3, #1
    0xe00166f8    0x150    bne e00166d4 <schedule+0x12c>
    0xe00166fc    0x154    mov r0, r5
    0xe0016700    0x158    bl e0010870 <tcbSchedAppend.part.171>
    0xe0016704    0x15c    b e00166d4 <schedule+0x12c>
    0xe0016708    0x160    mov r0, r5
    0xe001670c    0x164    bl e00107d8 <tcbSchedEnqueue.part.164>
    0xe0016710    0x168    b e00166d4 <schedule+0x12c>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
91 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `schedule` has 148 nodes.

Section decodeTCBConfigure (288 of 299)
=======================================

Deriving specifications
-----------------------

Section `decodeTCBConfigure` consists of 187 instructions.


Stack analysis
---------------

72 stack accesses found. Annotated code for `decodeTCBConfigure`:

    0xe0018f20      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0018f24      0x4    sub sp, sp, #132 
    0xe0018f28      0x8    add lr, sp, #80 
    0xe0018f2c      0xc    ldr r6, [sp, #172]    ; stack access
    0xe0018f30     0x10    ldr r5, [sp, #168]    ; stack access
    0xe0018f34     0x14    clz ip, r6
    0xe0018f38     0x18    ldr r4, [sp, #176]    ; stack access
    0xe0018f3c     0x1c    cmp r5, #0
    0xe0018f40     0x20    stm lr, {r0, r1}      ; stack access
    0xe0018f44     0x24    lsr ip, ip, #5
    0xe0018f48     0x28    moveq ip, #1
    0xe0018f4c     0x2c    cmp r4, #0
    0xe0018f50     0x30    moveq ip, #1
    0xe0018f54     0x34    cmp r2, #3
    0xe0018f58     0x38    orrls ip, ip, #1
    0xe0018f5c     0x3c    cmp ip, #0
    0xe0018f60     0x40    beq e0018f80 <decodeTCBConfigure+0x60>
    0xe0018f64     0x44    movw r3, #36896 
    0xe0018f68     0x48    movt r3, #57346 
    0xe0018f6c     0x4c    mov r0, #3
    0xe0018f70     0x50    mov r2, #7
    0xe0018f74     0x54    str r2, [r3, #24]
    0xe0018f78     0x58    add sp, sp, #132 
    0xe0018f7c     0x5c    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0018f80     0x60    movw r8, #13900 
    0xe0018f84     0x64    movt r8, #57347 
    0xe0018f88     0x68    str r3, [sp, #76]     ; stack access
    0xe0018f8c     0x6c    add r7, sp, #100 
    0xe0018f90     0x70    ldr r3, [r8]
    0xe0018f94     0x74    add fp, sp, #92 
    0xe0018f98     0x78    ldm r5, {r0, r1}
    0xe0018f9c     0x7c    ldr r2, [r3, #8]
    0xe0018fa0     0x80    mov sl, r0
    0xe0018fa4     0x84    stm r7, {r0, r1}      ; stack access
    0xe0018fa8     0x88    ldm r6, {r0, r1}
    0xe0018fac     0x8c    str r2, [sp, #72]     ; stack access
    0xe0018fb0     0x90    add r2, sp, #108 
    0xe0018fb4     0x94    ldr r9, [r3, #20]
    0xe0018fb8     0x98    stm r2, {r0, r1}      ; stack access
    0xe0018fbc     0x9c    ldr r2, [r3, #12]
    0xe0018fc0     0xa0    cmp r9, #0
    0xe0018fc4     0xa4    ldr r3, [r3, #16]
    0xe0018fc8     0xa8    str r0, [sp, #64]     ; stack access
    0xe0018fcc     0xac    ldm r4, {r0, r1}
    0xe0018fd0     0xb0    moveq r4, r9
    0xe0018fd4     0xb4    str r3, [sp, #68]     ; stack access
    0xe0018fd8     0xb8    ldr r3, [sp, #80]     ; stack access
    0xe0018fdc     0xbc    str r2, [sp, #56]     ; stack access
    0xe0018fe0     0xc0    stm fp, {r0, r1}      ; stack access
    0xe0018fe4     0xc4    str r3, [sp, #52]     ; stack access
    0xe0018fe8     0xc8    bne e00191cc <decodeTCBConfigure+0x2ac>
    0xe0018fec     0xcc    ldr r3, [sp, #52]     ; stack access
    0xe0018ff0     0xd0    bic r3, r3, #508 
    0xe0018ff4     0xd4    bic r3, r3, #3
    0xe0018ff8     0xd8    str r3, [sp, #60]     ; stack access
    0xe0018ffc     0xdc    mov r0, r3
    0xe0019000     0xe0    bl e0014da0 <slotCapLongRunningDelete>
    0xe0019004     0xe4    cmp r0, #0
    0xe0019008     0xe8    bne e00191b0 <decodeTCBConfigure+0x290>
    0xe001900c     0xec    ldr r3, [sp, #60]     ; stack access
    0xe0019010     0xf0    add r0, r3, #16
    0xe0019014     0xf4    bl e0014da0 <slotCapLongRunningDelete>
    0xe0019018     0xf8    subs r1, r0, #0
    0xe001901c     0xfc    bne e00191b0 <decodeTCBConfigure+0x290>
    0xe0019020    0x100    ldr r2, [sp, #56]     ; stack access
    0xe0019024    0x104    cmp r2, #0
    0xe0019028    0x108    beq e0019048 <decodeTCBConfigure+0x128>
    0xe001902c    0x10c    ldr ip, [sp, #104]    ; stack access
    0xe0019030    0x110    mov r3, sl
    0xe0019034    0x114    mov r0, r7
    0xe0019038    0x118    str sl, [sp, #100]    ; stack access
    0xe001903c    0x11c    str ip, [sp]          ; stack access
    0xe0019040    0x120    bl e0015e7c <updateCapData>
    0xe0019044    0x124    ldr sl, [sp, #100]    ; stack access
    0xe0019048    0x128    str sl, [sp, #100]    ; stack access
    0xe001904c    0x12c    add r0, sp, #116 
    0xe0019050    0x130    mov r1, r5
    0xe0019054    0x134    ldm r7, {r2, r3}      ; stack access
    0xe0019058    0x138    bl e0014bf4 <deriveCap>
    0xe001905c    0x13c    ldr r0, [sp, #116]    ; stack access
    0xe0019060    0x140    cmp r0, #0
    0xe0019064    0x144    bne e0018f78 <decodeTCBConfigure+0x58>
    0xe0019068    0x148    add sl, sp, #128 
    0xe001906c    0x14c    ldr r2, [sl, #-8]!    ; stack access
    0xe0019070    0x150    and r3, r2, #14
    0xe0019074    0x154    cmp r3, #14
    0xe0019078    0x158    str r2, [sp, #56]     ; stack access
    0xe001907c    0x15c    ldm sl, {r0, r1}      ; stack access
    0xe0019080    0x160    andne r3, r2, #15
    0xe0019084    0x164    ldrbeq r3, [sp, #56]   ; stack access
    0xe0019088    0x168    cmp r3, #10
    0xe001908c    0x16c    stm r7, {r0, r1}      ; stack access
    0xe0019090    0x170    bne e00191b0 <decodeTCBConfigure+0x290>
    0xe0019094    0x174    ldr r2, [sp, #68]     ; stack access
    0xe0019098    0x178    cmp r2, #0
    0xe001909c    0x17c    beq e00190c8 <decodeTCBConfigure+0x1a8>
    0xe00190a0    0x180    ldr r0, [sp, #64]     ; stack access
    0xe00190a4    0x184    mov r1, #0
    0xe00190a8    0x188    ldr ip, [sp, #112]    ; stack access
    0xe00190ac    0x18c    mov r3, r0
    0xe00190b0    0x190    str r0, [sp, #108]    ; stack access
    0xe00190b4    0x194    str ip, [sp]          ; stack access
    0xe00190b8    0x198    add r0, sp, #108 
    0xe00190bc    0x19c    bl e0015e7c <updateCapData>
    0xe00190c0    0x1a0    ldr r3, [sp, #108]    ; stack access
    0xe00190c4    0x1a4    str r3, [sp, #64]     ; stack access
    0xe00190c8    0x1a8    ldr r3, [sp, #64]     ; stack access
    0xe00190cc    0x1ac    add r0, sp, #116 
    0xe00190d0    0x1b0    mov r1, r6
    0xe00190d4    0x1b4    str r3, [sp, #108]    ; stack access
    0xe00190d8    0x1b8    add r3, sp, #108 
    0xe00190dc    0x1bc    ldm r3, {r2, r3}      ; stack access
    0xe00190e0    0x1c0    bl e0014bf4 <deriveCap>
    0xe00190e4    0x1c4    ldr r0, [sp, #116]    ; stack access
    0xe00190e8    0x1c8    cmp r0, #0
    0xe00190ec    0x1cc    bne e0018f78 <decodeTCBConfigure+0x58>
    0xe00190f0    0x1d0    ldr r3, [sp, #120]    ; stack access
    0xe00190f4    0x1d4    ldm sl, {r0, r1}      ; stack access
    0xe00190f8    0x1d8    and r2, r3, #14
    0xe00190fc    0x1dc    cmp r2, #14
    0xe0019100    0x1e0    add r2, sp, #108 
    0xe0019104    0x1e4    stm r2, {r0, r1}      ; stack access
    0xe0019108    0x1e8    andne r2, r3, #15
    0xe001910c    0x1ec    uxtbeq r2, r3
    0xe0019110    0x1f0    cmp r2, #9
    0xe0019114    0x1f4    bne e00191b0 <decodeTCBConfigure+0x290>
    0xe0019118    0x1f8    tst r3, #16
    0xe001911c    0x1fc    str r3, [sp, #60]     ; stack access
    0xe0019120    0x200    beq e00191b0 <decodeTCBConfigure+0x290>
    0xe0019124    0x204    ldr r1, [r8]
    0xe0019128    0x208    ldr r2, [r1, #80] 
    0xe001912c    0x20c    mov r0, r1
    0xe0019130    0x210    bic r2, r2, #15
    0xe0019134    0x214    orr r2, r2, #2
    0xe0019138    0x218    str r2, [r1, #80] 
    0xe001913c    0x21c    bl e0013114 <setThreadState.part.166>
    0xe0019140    0x220    ldr r3, [sp, #60]     ; stack access
    0xe0019144    0x224    ldm fp, {r0, r1}      ; stack access
    0xe0019148    0x228    add r2, sp, #32
    0xe001914c    0x22c    str r4, [sp, #40]     ; stack access
    0xe0019150    0x230    add lr, sp, #16
    0xe0019154    0x234    str r3, [sp, #108]    ; stack access
    0xe0019158    0x238    mov r3, #6
    0xe001915c    0x23c    str r3, [sp, #44]     ; stack access
    0xe0019160    0x240    add r3, sp, #108 
    0xe0019164    0x244    stm r2, {r0, r1}      ; stack access
    0xe0019168    0x248    mov ip, #0
    0xe001916c    0x24c    ldm r3, {r0, r1}      ; stack access
    0xe0019170    0x250    ldr r3, [sp, #56]     ; stack access
    0xe0019174    0x254    str r9, [sp, #28]     ; stack access
    0xe0019178    0x258    str r6, [sp, #24]     ; stack access
    0xe001917c    0x25c    str r3, [sp, #100]    ; stack access
    0xe0019180    0x260    mov r3, ip
    0xe0019184    0x264    ldr r2, [sp, #72]     ; stack access
    0xe0019188    0x268    stm lr, {r0, r1}      ; stack access
    0xe001918c    0x26c    ldm r7, {r0, r1}      ; stack access
    0xe0019190    0x270    str r5, [sp, #12]     ; stack access
    0xe0019194    0x274    str ip, [sp]          ; stack access
    0xe0019198    0x278    stmib sp, {r0, r1}    ; stack access
    0xe001919c    0x27c    ldr r0, [sp, #52]     ; stack access
    0xe00191a0    0x280    ldr r1, [sp, #76]     ; stack access
    0xe00191a4    0x284    bic r0, r0, #15
    0xe00191a8    0x288    bl e0018d60 <invokeTCB_ThreadControl>
    0xe00191ac    0x28c    b e0018f78 <decodeTCBConfigure+0x58>
    0xe00191b0    0x290    movw r3, #36896 
    0xe00191b4    0x294    movt r3, #57346 
    0xe00191b8    0x298    mov r2, #3
    0xe00191bc    0x29c    mov r0, r2
    0xe00191c0    0x2a0    str r2, [r3, #24]
    0xe00191c4    0x2a4    add sp, sp, #132 
    0xe00191c8    0x2a8    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe00191cc    0x2ac    add r0, sp, #116 
    0xe00191d0    0x2b0    ldm fp, {r2, r3}      ; stack access
    0xe00191d4    0x2b4    mov r1, r4
    0xe00191d8    0x2b8    bl e0014bf4 <deriveCap>
    0xe00191dc    0x2bc    ldr r0, [sp, #116]    ; stack access
    0xe00191e0    0x2c0    cmp r0, #0
    0xe00191e4    0x2c4    bne e0018f78 <decodeTCBConfigure+0x58>
    0xe00191e8    0x2c8    add r3, sp, #128 
    0xe00191ec    0x2cc    ldmdb r3, {r0, r1}    ; stack access
    0xe00191f0    0x2d0    stm fp, {r0, r1}      ; stack access
    0xe00191f4    0x2d4    mov r0, r9
    0xe00191f8    0x2d8    ldm fp, {r1, r2}      ; stack access
    0xe00191fc    0x2dc    bl e0010ffc <checkValidIPCBuffer>
    0xe0019200    0x2e0    cmp r0, #0
    0xe0019204    0x2e4    beq e0018fec <decodeTCBConfigure+0xcc>
    0xe0019208    0x2e8    b e0018f78 <decodeTCBConfigure+0x58>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
187 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeTCBConfigure` has 324 nodes.

Section finaliseCap (289 of 299)
================================

Deriving specifications
-----------------------

Section `finaliseCap` consists of 150 instructions.
Switch found.
 STMIA;5,3...+
 EOR (reg-shift)...............+++++++++++++++
 EOR (reg)..........+++++


Stack analysis
---------------

Section `finaliseCap` expects pointer to stack in r0.
26 stack accesses found. Annotated code for `finaliseCap`:

    0xe0016810      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0016814      0x4    sub sp, sp, #8
    0xe0016818      0x8    mov r5, r1
    0xe001681c      0xc    mov r4, r0
    0xe0016820     0x10    mov ip, sp
    0xe0016824     0x14    stm ip, {r1, r2}      ; stack access
    0xe0016828     0x18    and r2, r1, #14
    0xe001682c     0x1c    cmp r2, #14
    0xe0016830     0x20    andne r2, r1, #15
    0xe0016834     0x24    uxtbeq r2, r1
    0xe0016838     0x28    ands r1, r2, #1
    0xe001683c     0x2c    bne e0016950 <finaliseCap+0x140>
    0xe0016840     0x30    cmp r2, #6
    0xe0016844     0x34    ldr r6, [sp, #4]      ; stack access
    0xe0016848     0x38    beq e0016964 <finaliseCap+0x154>
    0xe001684c     0x3c    bhi e0016890 <finaliseCap+0x80>
    0xe0016850     0x40    cmp r2, #0
    0xe0016854     0x44    beq e0016870 <finaliseCap+0x60>
    0xe0016858     0x48    cmp r2, #4
    0xe001685c     0x4c    bne e00168a0 <finaliseCap+0x90>
    0xe0016860     0x50    cmp r3, #0
    0xe0016864     0x54    beq e0016870 <finaliseCap+0x60>
    0xe0016868     0x58    bic r0, r6, #15
    0xe001686c     0x5c    bl e0013944 <cancelAllIPC>
    0xe0016870     0x60    mov r3, #0
    0xe0016874     0x64    str r3, [r4]          ; stack access
    0xe0016878     0x68    str r3, [r4, #4]      ; stack access
    0xe001687c     0x6c    str r3, [r4, #8]      ; stack access
    0xe0016880     0x70    str r3, [r4, #12]     ; stack access
    0xe0016884     0x74    mov r0, r4
    0xe0016888     0x78    add sp, sp, #8
    0xe001688c     0x7c    pop {r4, r5, r6, pc}  ; stack access
    0xe0016890     0x80    cmp r2, #8
    0xe0016894     0x84    beq e0016870 <finaliseCap+0x60>
    0xe0016898     0x88    cmp r2, #62 
    0xe001689c     0x8c    beq e0016870 <finaliseCap+0x60>
    0xe00168a0     0x90    ldr r1, [sp, #24]     ; stack access
    0xe00168a4     0x94    cmp r1, #0
    0xe00168a8     0x98    bne e0016a64 <finaliseCap+0x254>
    0xe00168ac     0x9c    sub r2, r2, #10
    0xe00168b0     0xa0    cmp r2, #36 
    0xe00168b4     0xa4    ldrls pc, [pc, r2, lsl #2]
    0xe00168b8     0xa8    b e0016870 <finaliseCap+0x60>
    0xe00168bc     0xac    .word 0xe0016a1c
    0xe00168c0     0xb0    .word 0xe0016870
    0xe00168c4     0xb4    .word 0xe00169cc
    0xe00168c8     0xb8    .word 0xe0016870
    0xe00168cc     0xbc    .word 0xe0016870
    0xe00168d0     0xc0    .word 0xe0016870
    0xe00168d4     0xc4    .word 0xe0016870
    0xe00168d8     0xc8    .word 0xe0016870
    0xe00168dc     0xcc    .word 0xe0016870
    0xe00168e0     0xd0    .word 0xe0016870
    0xe00168e4     0xd4    .word 0xe0016870
    0xe00168e8     0xd8    .word 0xe0016870
    0xe00168ec     0xdc    .word 0xe0016870
    0xe00168f0     0xe0    .word 0xe0016870
    0xe00168f4     0xe4    .word 0xe0016870
    0xe00168f8     0xe8    .word 0xe0016870
    0xe00168fc     0xec    .word 0xe0016870
    0xe0016900     0xf0    .word 0xe0016870
    0xe0016904     0xf4    .word 0xe0016870
    0xe0016908     0xf8    .word 0xe0016870
    0xe001690c     0xfc    .word 0xe00169a4
    0xe0016910    0x100    .word 0xe0016870
    0xe0016914    0x104    .word 0xe0016870
    0xe0016918    0x108    .word 0xe0016870
    0xe001691c    0x10c    .word 0xe0016870
    0xe0016920    0x110    .word 0xe0016870
    0xe0016924    0x114    .word 0xe0016870
    0xe0016928    0x118    .word 0xe0016870
    0xe001692c    0x11c    .word 0xe0016870
    0xe0016930    0x120    .word 0xe0016870
    0xe0016934    0x124    .word 0xe0016870
    0xe0016938    0x128    .word 0xe0016870
    0xe001693c    0x12c    .word 0xe0016870
    0xe0016940    0x130    .word 0xe0016870
    0xe0016944    0x134    .word 0xe0016870
    0xe0016948    0x138    .word 0xe0016870
    0xe001694c    0x13c    .word 0xe001698c
    0xe0016950    0x140    ldm ip, {r1, r2}      ; stack access
    0xe0016954    0x144    bl e00122d4 <Arch_finaliseCap>
    0xe0016958    0x148    mov r0, r4
    0xe001695c    0x14c    add sp, sp, #8
    0xe0016960    0x150    pop {r4, r5, r6, pc}  ; stack access
    0xe0016964    0x154    cmp r3, #0
    0xe0016968    0x158    beq e0016870 <finaliseCap+0x60>
    0xe001696c    0x15c    bic r0, r5, #15
    0xe0016970    0x160    ldr r3, [r0, #12]
    0xe0016974    0x164    bics r2, r3, #15
    0xe0016978    0x168    andne r3, r3, #15
    0xe001697c    0x16c    strne r3, [r0, #12]
    0xe0016980    0x170    strne r1, [r2, #92] 
    0xe0016984    0x174    bl e00140b0 <cancelAllSignals>
    0xe0016988    0x178    b e0016870 <finaliseCap+0x60>
    0xe001698c    0x17c    mov r3, #0
    0xe0016990    0x180    str r5, [r4]          ; stack access
    0xe0016994    0x184    str r6, [r4, #4]      ; stack access
    0xe0016998    0x188    str r3, [r4, #8]      ; stack access
    0xe001699c    0x18c    str r3, [r4, #12]     ; stack access
    0xe00169a0    0x190    b e0016884 <finaliseCap+0x74>
    0xe00169a4    0x194    cmp r3, #0
    0xe00169a8    0x198    beq e0016870 <finaliseCap+0x60>
    0xe00169ac    0x19c    uxtb r0, r6
    0xe00169b0    0x1a0    bl e0017960 <invokeIRQHandler_ClearIRQHandler>
    0xe00169b4    0x1a4    mov r3, #0
    0xe00169b8    0x1a8    str r5, [r4, #8]      ; stack access
    0xe00169bc    0x1ac    str r6, [r4, #12]     ; stack access
    0xe00169c0    0x1b0    str r3, [r4]          ; stack access
    0xe00169c4    0x1b4    str r3, [r4, #4]      ; stack access
    0xe00169c8    0x1b8    b e0016884 <finaliseCap+0x74>
    0xe00169cc    0x1bc    cmp r3, #0
    0xe00169d0    0x1c0    beq e0016870 <finaliseCap+0x60>
    0xe00169d4    0x1c4    bic r0, r5, #15
    0xe00169d8    0x1c8    bic r5, r5, #508 
    0xe00169dc    0x1cc    bic r5, r5, #3
    0xe00169e0    0x1d0    ldr r3, [r0, #92] 
    0xe00169e4    0x1d4    eor r5, r5, #5
    0xe00169e8    0x1d8    cmp r3, #0
    0xe00169ec    0x1dc    ldrne r2, [r3, #12]
    0xe00169f0    0x1e0    movne r1, #0
    0xe00169f4    0x1e4    andne r2, r2, #15
    0xe00169f8    0x1e8    strne r2, [r3, #12]
    0xe00169fc    0x1ec    strne r1, [r0, #92] 
    0xe0016a00    0x1f0    bl e00167b4 <suspend>
    0xe0016a04    0x1f4    movw r3, #8238 
    0xe0016a08    0x1f8    stm r4, {r3, r5}      ; stack access
    0xe0016a0c    0x1fc    mov r3, #0
    0xe0016a10    0x200    str r3, [r4, #8]      ; stack access
    0xe0016a14    0x204    str r3, [r4, #12]     ; stack access
    0xe0016a18    0x208    b e0016884 <finaliseCap+0x74>
    0xe0016a1c    0x20c    cmp r3, #0
    0xe0016a20    0x210    beq e0016870 <finaliseCap+0x60>
    0xe0016a24    0x214    ubfx r6, r6, #18, #5
    0xe0016a28    0x218    bic r5, r5, #31
    0xe0016a2c    0x21c    mov r3, #1
    0xe0016a30    0x220    mvn r1, #0
    0xe0016a34    0x224    add r2, r6, r3
    0xe0016a38    0x228    eor r3, r5, r3, lsl r6
    0xe0016a3c    0x22c    bic r3, r3, r1, lsl r2
    0xe0016a40    0x230    lsl r6, r6, #8
    0xe0016a44    0x234    eor r5, r5, r3
    0xe0016a48    0x238    orr r6, r6, #46 
    0xe0016a4c    0x23c    mov r3, #0
    0xe0016a50    0x240    str r6, [r4]          ; stack access
    0xe0016a54    0x244    str r5, [r4, #4]      ; stack access
    0xe0016a58    0x248    str r3, [r4, #8]      ; stack access
    0xe0016a5c    0x24c    str r3, [r4, #12]     ; stack access
    0xe0016a60    0x250    b e0016884 <finaliseCap+0x74>
    0xe0016a64    0x254    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
113 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `finaliseCap` has 310 nodes.

Section performPDFlush (290 of 299)
===================================

Deriving specifications
-----------------------

Section `performPDFlush` consists of 81 instructions.
Switch found.
Skipping ee072f3b mcr 15, 0, r2, cr7, cr11, {1}
Skipping f57ff05f dmb sy
Skipping f57ff04f dsb sy
Skipping ee072f35 mcr 15, 0, r2, cr7, cr5, {1}
Skipping f57ff06f isb sy
Skipping ee073ff5 mcr 15, 0, r3, cr7, cr5, {7}
Skipping f57ff06f isb sy


Stack analysis
---------------

7 stack accesses found. Annotated code for `performPDFlush`:

    0xe00127e0      0x0    push {r4, r5, r6, r7, r8, lr}  ; stack access
    0xe00127e4      0x4    ldr r5, [sp, #24]     ; stack access
    0xe00127e8      0x8    cmp r3, r5
    0xe00127ec      0xc    bcc e00127f8 <performPDFlush+0x18>
    0xe00127f0     0x10    mov r0, #0
    0xe00127f4     0x14    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe00127f8     0x18    mov ip, r1
    0xe00127fc     0x1c    mov r7, r0
    0xe0012800     0x20    mov r1, r2
    0xe0012804     0x24    mov r0, ip
    0xe0012808     0x28    mov r4, r3
    0xe001280c     0x2c    bl e001137c <setVMRootForFlush>
    0xe0012810     0x30    mov r6, r0
    0xe0012814     0x34    sub r0, r7, #30
    0xe0012818     0x38    cmp r0, #11
    0xe001281c     0x3c    ldrls pc, [pc, r0, lsl #2]
    0xe0012820     0x40    b e0012920 <performPDFlush+0x140>
    0xe0012824     0x44    .word 0xe00128f8
    0xe0012828     0x48    .word 0xe001290c
    0xe001282c     0x4c    .word 0xe00128c8
    0xe0012830     0x50    .word 0xe0012854
    0xe0012834     0x54    .word 0xe0012920
    0xe0012838     0x58    .word 0xe0012920
    0xe001283c     0x5c    .word 0xe0012920
    0xe0012840     0x60    .word 0xe0012920
    0xe0012844     0x64    .word 0xe00128f8
    0xe0012848     0x68    .word 0xe001290c
    0xe001284c     0x6c    .word 0xe00128c8
    0xe0012850     0x70    .word 0xe0012854
    0xe0012854     0x74    lsr r5, r5, #5
    0xe0012858     0x78    lsr r3, r4, #5
    0xe001285c     0x7c    add r5, r5, #1
    0xe0012860     0x80    cmp r3, r5
    0xe0012864     0x84    bcs e0012884 <performPDFlush+0xa4>
    0xe0012868     0x88    lsl r2, r3, #5
    0xe001286c     0x8c    lsl r1, r5, #5
    0xe0012870     0x90    mcr 15, 0, r2, cr7, cr11, {1}
    0xe0012874     0x94    dmb sy
    0xe0012878     0x98    add r2, r2, #32
    0xe001287c     0x9c    cmp r2, r1
    0xe0012880     0xa0    bne e0012870 <performPDFlush+0x90>
    0xe0012884     0xa4    dsb sy
    0xe0012888     0xa8    cmp r3, r5
    0xe001288c     0xac    bcs e00128c0 <performPDFlush+0xe0>
    0xe0012890     0xb0    lsl r3, r3, #5
    0xe0012894     0xb4    lsl r5, r5, #5
    0xe0012898     0xb8    mov r2, r3
    0xe001289c     0xbc    mcr 15, 0, r2, cr7, cr5, {1}
    0xe00128a0     0xc0    isb sy
    0xe00128a4     0xc4    add r2, r2, #32
    0xe00128a8     0xc8    cmp r5, r2
    0xe00128ac     0xcc    bne e001289c <performPDFlush+0xbc>
    0xe00128b0     0xd0    mcr 15, 0, r3, cr7, cr5, {7}
    0xe00128b4     0xd4    add r3, r3, #32
    0xe00128b8     0xd8    cmp r2, r3
    0xe00128bc     0xdc    bne e00128b0 <performPDFlush+0xd0>
    0xe00128c0     0xe0    isb sy
    0xe00128c4     0xe4    b e00128d8 <performPDFlush+0xf8>
    0xe00128c8     0xe8    mov r1, r5
    0xe00128cc     0xec    mov r0, r4
    0xe00128d0     0xf0    ldr r2, [sp, #28]     ; stack access
    0xe00128d4     0xf4    bl e0012588 <cleanInvalidateCacheRange_RAM>
    0xe00128d8     0xf8    cmp r6, #0
    0xe00128dc     0xfc    beq e00127f0 <performPDFlush+0x10>
    0xe00128e0    0x100    movw r3, #13900 
    0xe00128e4    0x104    movt r3, #57347 
    0xe00128e8    0x108    ldr r0, [r3]
    0xe00128ec    0x10c    bl e0011294 <setVMRoot>
    0xe00128f0    0x110    mov r0, #0
    0xe00128f4    0x114    pop {r4, r5, r6, r7, r8, pc}  ; stack access
    0xe00128f8    0x118    mov r1, r5
    0xe00128fc    0x11c    mov r0, r4
    0xe0012900    0x120    ldr r2, [sp, #28]     ; stack access
    0xe0012904    0x124    bl e001264c <cleanCacheRange_RAM>
    0xe0012908    0x128    b e00128d8 <performPDFlush+0xf8>
    0xe001290c    0x12c    mov r1, r5
    0xe0012910    0x130    mov r0, r4
    0xe0012914    0x134    ldr r2, [sp, #28]     ; stack access
    0xe0012918    0x138    bl e0012710 <invalidateCacheRange_RAM>
    0xe001291c    0x13c    b e00128d8 <performPDFlush+0xf8>
    0xe0012920    0x140    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
69 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `performPDFlush` has 141 nodes.

Section handleInvocation (291 of 299)
=====================================

Deriving specifications
-----------------------

Section `handleInvocation` consists of 102 instructions.
 ORRHI (imm)....+++
 STMIA;8,2...+


Stack analysis
---------------

12 stack accesses found. Annotated code for `handleInvocation`:

    0xe001adb0      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001adb4      0x4    movw r7, #13900 
    0xe001adb8      0x8    movt r7, #57347 
    0xe001adbc      0xc    sub sp, sp, #60 
    0xe001adc0     0x10    mov sl, r0
    0xe001adc4     0x14    mov r9, r1
    0xe001adc8     0x18    ldr r5, [r7]
    0xe001adcc     0x1c    add r0, sp, #40 
    0xe001add0     0x20    ldr r6, [r5, #4]
    0xe001add4     0x24    mov r1, r5
    0xe001add8     0x28    ldr r8, [r5]
    0xe001addc     0x2c    and r3, r6, #127 
    0xe001ade0     0x30    cmp r3, #120 
    0xe001ade4     0x34    bichi r6, r6, #127 
    0xe001ade8     0x38    mov r2, r8
    0xe001adec     0x3c    orrhi r6, r6, #120 
    0xe001adf0     0x40    bl e0012dcc <lookupCapAndSlot>
    0xe001adf4     0x44    ldr r4, [sp, #40]     ; stack access
    0xe001adf8     0x48    cmp r4, #0
    0xe001adfc     0x4c    bne e001aebc <handleInvocation+0x10c>
    0xe001ae00     0x50    mov r1, r5
    0xe001ae04     0x54    mov r0, r4
    0xe001ae08     0x58    bl e0010d50 <lookupIPCBuffer>
    0xe001ae0c     0x5c    mov r2, r6
    0xe001ae10     0x60    mov r1, r0
    0xe001ae14     0x64    mov fp, r0
    0xe001ae18     0x68    mov r0, r5
    0xe001ae1c     0x6c    bl e0017c8c <lookupExtraCaps>
    0xe001ae20     0x70    subs r3, r0, #0
    0xe001ae24     0x74    str r3, [sp, #36]     ; stack access
    0xe001ae28     0x78    bne e001aee4 <handleInvocation+0x134>
    0xe001ae2c     0x7c    movw r2, #36924 
    0xe001ae30     0x80    movt r2, #57346 
    0xe001ae34     0x84    add ip, sp, #8
    0xe001ae38     0x88    add lr, sp, #44 
    0xe001ae3c     0x8c    ldm r2, {r0, r1, r2}
    0xe001ae40     0x90    strd sl, [sp, #24]    ; stack access
    0xe001ae44     0x94    str r9, [sp, #20]     ; stack access
    0xe001ae48     0x98    stm ip, {r0, r1, r2}  ; stack access
    0xe001ae4c     0x9c    and ip, r6, #127 
    0xe001ae50     0xa0    cmp ip, #4
    0xe001ae54     0xa4    ldm lr, {r0, r1}      ; stack access
    0xe001ae58     0xa8    ldr r3, [sp, #52]     ; stack access
    0xe001ae5c     0xac    movls r2, #0
    0xe001ae60     0xb0    movhi r2, #1
    0xe001ae64     0xb4    cmp fp, #0
    0xe001ae68     0xb8    stm sp, {r0, r1}      ; stack access
    0xe001ae6c     0xbc    lsr r0, r6, #12
    0xe001ae70     0xc0    movne r2, #0
    0xe001ae74     0xc4    cmp r2, #0
    0xe001ae78     0xc8    mov r2, r8
    0xe001ae7c     0xcc    moveq r1, ip
    0xe001ae80     0xd0    movne r1, #4
    0xe001ae84     0xd4    bl e001aa18 <decodeInvocation>
    0xe001ae88     0xd8    cmp r0, #4
    0xe001ae8c     0xdc    mov r4, r0
    0xe001ae90     0xe0    beq e001aeb0 <handleInvocation+0x100>
    0xe001ae94     0xe4    cmp r0, #3
    0xe001ae98     0xe8    beq e001aef8 <handleInvocation+0x148>
    0xe001ae9c     0xec    ldr r3, [r5, #80] 
    0xe001aea0     0xf0    and r2, r3, #15
    0xe001aea4     0xf4    cmp r2, #2
    0xe001aea8     0xf8    beq e001af10 <handleInvocation+0x160>
    0xe001aeac     0xfc    mov r4, #0
    0xe001aeb0    0x100    mov r0, r4
    0xe001aeb4    0x104    add sp, sp, #60 
    0xe001aeb8    0x108    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe001aebc    0x10c    movw r3, #32768 
    0xe001aec0    0x110    cmp r9, #0
    0xe001aec4    0x114    movt r3, #57346 
    0xe001aec8    0x118    mov r2, #1
    0xe001aecc    0x11c    stm r3, {r2, r8}
    0xe001aed0    0x120    beq e001aeac <handleInvocation+0xfc>
    0xe001aed4    0x124    mov r0, r5
    0xe001aed8    0x128    mov r4, #0
    0xe001aedc    0x12c    bl e0018508 <handleFault>
    0xe001aee0    0x130    b e001aeb0 <handleInvocation+0x100>
    0xe001aee4    0x134    cmp r9, #0
    0xe001aee8    0x138    beq e001aeac <handleInvocation+0xfc>
    0xe001aeec    0x13c    mov r0, r5
    0xe001aef0    0x140    bl e0018508 <handleFault>
    0xe001aef4    0x144    b e001aeb0 <handleInvocation+0x100>
    0xe001aef8    0x148    cmp sl, #0
    0xe001aefc    0x14c    beq e001aeac <handleInvocation+0xfc>
    0xe001af00    0x150    mov r0, r5
    0xe001af04    0x154    ldr r4, [sp, #36]     ; stack access
    0xe001af08    0x158    bl e001a410 <replyFromKernel_error>
    0xe001af0c    0x15c    b e001aeb0 <handleInvocation+0x100>
    0xe001af10    0x160    cmp sl, #0
    0xe001af14    0x164    bic r3, r3, #15
    0xe001af18    0x168    orr r3, r3, #1
    0xe001af1c    0x16c    str r3, [r5, #80] 
    0xe001af20    0x170    ldrne r2, [sp, #36]   ; stack access
    0xe001af24    0x174    strne r2, [r5]
    0xe001af28    0x178    strne r2, [r5, #4]
    0xe001af2c    0x17c    ldr r2, [r7]
    0xe001af30    0x180    cmp r5, r2
    0xe001af34    0x184    bne e001aeac <handleInvocation+0xfc>
    0xe001af38    0x188    mov r0, r5
    0xe001af3c    0x18c    mov r4, #0
    0xe001af40    0x190    bl e0013114 <setThreadState.part.166>
    0xe001af44    0x194    b e001aeb0 <handleInvocation+0x100>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
102 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleInvocation` has 170 nodes.

Section cteDelete (292 of 299)
==============================

Deriving specifications
-----------------------

Section `cteDelete` consists of 148 instructions.
 MVNNE (reg-shift)......++++++
 ANDS (reg)..........+++++
 CMPEQ (reg)......+++
 ANDNE (reg-shift)................++++++++++++++++
 ADDEQ (reg)...........++++++


Stack analysis
---------------

13 stack accesses found. Annotated code for `cteDelete`:

    0xe0016a68      0x0    push {r4, r5, r6, r7, r8, r9, sl, lr}  ; stack access
    0xe0016a6c      0x4    movw r5, #12804 
    0xe0016a70      0x8    sub sp, sp, #40 
    0xe0016a74      0xc    movt r5, #57347 
    0xe0016a78     0x10    mov r4, r0
    0xe0016a7c     0x14    mov r7, r1
    0xe0016a80     0x18    mov r6, #0
    0xe0016a84     0x1c    ldr r3, [r4]
    0xe0016a88     0x20    and r2, r3, #14
    0xe0016a8c     0x24    cmp r2, #14
    0xe0016a90     0x28    andne r3, r3, #15
    0xe0016a94     0x2c    uxtbeq r3, r3
    0xe0016a98     0x30    cmp r3, #0
    0xe0016a9c     0x34    beq e0016c74 <cteDelete+0x20c>
    0xe0016aa0     0x38    mov r0, r4
    0xe0016aa4     0x3c    bl e0014d44 <isFinalCapability>
    0xe0016aa8     0x40    str r6, [sp]          ; stack access
    0xe0016aac     0x44    ldm r4, {r1, r2}
    0xe0016ab0     0x48    mov r3, r0
    0xe0016ab4     0x4c    add r0, sp, #24
    0xe0016ab8     0x50    bl e0016810 <finaliseCap>
    0xe0016abc     0x54    ldr r3, [sp, #24]     ; stack access
    0xe0016ac0     0x58    and ip, r3, #14
    0xe0016ac4     0x5c    cmp ip, #14
    0xe0016ac8     0x60    andne r2, r3, #15
    0xe0016acc     0x64    uxtbeq r2, r3
    0xe0016ad0     0x68    cmp r2, #0
    0xe0016ad4     0x6c    bne e0016b04 <cteDelete+0x9c>
    0xe0016ad8     0x70    ldr r3, [sp, #32]     ; stack access
    0xe0016adc     0x74    mov r0, r4
    0xe0016ae0     0x78    ldr r2, [sp, #36]     ; stack access
    0xe0016ae4     0x7c    str r3, [sp, #16]     ; stack access
    0xe0016ae8     0x80    add r3, sp, #16
    0xe0016aec     0x84    str r2, [sp, #20]     ; stack access
    0xe0016af0     0x88    ldm r3, {r1, r2}      ; stack access
    0xe0016af4     0x8c    bl e0010928 <emptySlot>
    0xe0016af8     0x90    mov r0, #0
    0xe0016afc     0x94    add sp, sp, #40 
    0xe0016b00     0x98    pop {r4, r5, r6, r7, r8, r9, sl, pc}  ; stack access
    0xe0016b04     0x9c    cmp r2, #46 
    0xe0016b08     0xa0    bne e0016cb4 <cteDelete+0x24c>
    0xe0016b0c     0xa4    lsr r2, r3, #8
    0xe0016b10     0xa8    ldr lr, [sp, #28]     ; stack access
    0xe0016b14     0xac    and r8, r2, #63 
    0xe0016b18     0xb0    cmp r8, #32
    0xe0016b1c     0xb4    andne r1, r2, #31
    0xe0016b20     0xb8    mvnne r0, #0
    0xe0016b24     0xbc    addne r1, r1, #1
    0xe0016b28     0xc0    movne r9, r0
    0xe0016b2c     0xc4    mvneq r9, #31
    0xe0016b30     0xc8    lslne r9, r9, r1
    0xe0016b34     0xcc    moveq r1, #31
    0xe0016b38     0xd0    mvnne r1, r0, lsl r1
    0xe0016b3c     0xd4    ands r1, lr, r1
    0xe0016b40     0xd8    beq e0016ad8 <cteDelete+0x70>
    0xe0016b44     0xdc    and r9, r9, lr
    0xe0016b48     0xe0    cmp r1, #1
    0xe0016b4c     0xe4    cmpeq r4, r9
    0xe0016b50     0xe8    beq e0016ad8 <cteDelete+0x70>
    0xe0016b54     0xec    cmp r7, #0
    0xe0016b58     0xf0    stm r4, {r3, lr}
    0xe0016b5c     0xf4    bne e0016bb4 <cteDelete+0x14c>
    0xe0016b60     0xf8    cmp ip, #14
    0xe0016b64     0xfc    beq e0016c5c <cteDelete+0x1f4>
    0xe0016b68    0x100    cmp r8, #32
    0xe0016b6c    0x104    andne r2, r2, #31
    0xe0016b70    0x108    mvnne r0, #0
    0xe0016b74    0x10c    addne r2, r2, #1
    0xe0016b78    0x110    andne r0, lr, r0, lsl r2
    0xe0016b7c    0x114    beq e0016c90 <cteDelete+0x228>
    0xe0016b80    0x118    cmp r4, r0
    0xe0016b84    0x11c    beq e0016b90 <cteDelete+0x128>
    0xe0016b88    0x120    mov r1, r4
    0xe0016b8c    0x124    bl e0013750 <capSwapForDelete.part.162>
    0xe0016b90    0x128    ldr r3, [r5]
    0xe0016b94    0x12c    add r3, r3, #1
    0xe0016b98    0x130    str r3, [r5]
    0xe0016b9c    0x134    cmp r3, #99 
    0xe0016ba0    0x138    bls e0016a84 <cteDelete+0x1c>
    0xe0016ba4    0x13c    bl e00107a8 <preemptionPoint.part.161>
    0xe0016ba8    0x140    cmp r0, #0
    0xe0016bac    0x144    beq e0016a80 <cteDelete+0x18>
    0xe0016bb0    0x148    b e0016afc <cteDelete+0x94>
    0xe0016bb4    0x14c    cmp r8, #32
    0xe0016bb8    0x150    biceq r9, lr, #31
    0xe0016bbc    0x154    andeq sl, lr, #31
    0xe0016bc0    0x158    bne e0016c98 <cteDelete+0x230>
    0xe0016bc4    0x15c    sub r0, sl, #-268435455 
    0xe0016bc8    0x160    mov r1, #0
    0xe0016bcc    0x164    add r0, r9, r0, lsl #4
    0xe0016bd0    0x168    bl e0016a68 <cteDelete>
    0xe0016bd4    0x16c    cmp r0, #0
    0xe0016bd8    0x170    bne e0016afc <cteDelete+0x94>
    0xe0016bdc    0x174    ldr r3, [r4]
    0xe0016be0    0x178    and r2, r3, #14
    0xe0016be4    0x17c    cmp r2, #14
    0xe0016be8    0x180    andne r2, r3, #15
    0xe0016bec    0x184    uxtbeq r2, r3
    0xe0016bf0    0x188    cmp r2, #0
    0xe0016bf4    0x18c    beq e0016b90 <cteDelete+0x128>
    0xe0016bf8    0x190    cmp r2, #46 
    0xe0016bfc    0x194    bne e0016cb4 <cteDelete+0x24c>
    0xe0016c00    0x198    lsr r3, r3, #8
    0xe0016c04    0x19c    ldr r1, [r4, #4]
    0xe0016c08    0x1a0    and r0, r3, #63 
    0xe0016c0c    0x1a4    cmp r0, #32
    0xe0016c10    0x1a8    andne r3, r3, #31
    0xe0016c14    0x1ac    mvnne r2, #0
    0xe0016c18    0x1b0    addne r3, r3, #1
    0xe0016c1c    0x1b4    lslne r2, r2, r3
    0xe0016c20    0x1b8    mvneq r2, #31
    0xe0016c24    0x1bc    and r2, r2, r1
    0xe0016c28    0x1c0    moveq r3, #5
    0xe0016c2c    0x1c4    cmp r9, r2
    0xe0016c30    0x1c8    bne e0016b90 <cteDelete+0x128>
    0xe0016c34    0x1cc    mvn r2, #0
    0xe0016c38    0x1d0    mvn r3, r2, lsl r3
    0xe0016c3c    0x1d4    and r1, r1, r3
    0xe0016c40    0x1d8    cmp r1, sl
    0xe0016c44    0x1dc    cmpeq r8, r0
    0xe0016c48    0x1e0    addeq lr, sl, r2
    0xe0016c4c    0x1e4    andeq r3, r3, lr
    0xe0016c50    0x1e8    orreq r9, r3, r9
    0xe0016c54    0x1ec    streq r9, [r4, #4]
    0xe0016c58    0x1f0    b e0016b90 <cteDelete+0x128>
    0xe0016c5c    0x1f4    uxtb r3, r3
    0xe0016c60    0x1f8    cmp r3, #46 
    0xe0016c64    0x1fc    bne e0016b68 <cteDelete+0x100>
    0xe0016c68    0x200    cmp r4, r9
    0xe0016c6c    0x204    bne e0016b68 <cteDelete+0x100>
    0xe0016c70    0x208    b e0016af8 <cteDelete+0x90>
    0xe0016c74    0x20c    str r3, [sp, #16]     ; stack access
    0xe0016c78    0x210    mov r0, r4
    0xe0016c7c    0x214    str r3, [sp, #20]     ; stack access
    0xe0016c80    0x218    add r3, sp, #16
    0xe0016c84    0x21c    ldm r3, {r1, r2}      ; stack access
    0xe0016c88    0x220    bl e0010928 <emptySlot>
    0xe0016c8c    0x224    b e0016af8 <cteDelete+0x90>
    0xe0016c90    0x228    bic r0, lr, #31
    0xe0016c94    0x22c    b e0016b80 <cteDelete+0x118>
    0xe0016c98    0x230    mvn r9, #0
    0xe0016c9c    0x234    and r3, r2, #31
    0xe0016ca0    0x238    add r3, r3, #1
    0xe0016ca4    0x23c    mov sl, r9
    0xe0016ca8    0x240    bic sl, lr, sl, lsl r3
    0xe0016cac    0x244    and r9, lr, r9, lsl r3
    0xe0016cb0    0x248    b e0016bc4 <cteDelete+0x15c>
    0xe0016cb4    0x24c    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
148 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `cteDelete` has 277 nodes.

Section arm_vector_table (293 of 299)
=====================================

Deriving specifications
-----------------------

Section `arm_vector_table` consists of 15 instructions.
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre).+Skipping e59ff018 ldr pc, [pc, #24] ; e0010020 <ki_boot_end+0x20>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff018 ldr pc, [pc, #24] ; e0010024 <ki_boot_end+0x24>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff018 ldr pc, [pc, #24] ; e0010028 <ki_boot_end+0x28>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff018 ldr pc, [pc, #24] ; e001002c <ki_boot_end+0x2c>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff018 ldr pc, [pc, #24] ; e0010030 <ki_boot_end+0x30>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff004 ldr pc, [pc, #4] ; e0010020 <ki_boot_end+0x20>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff014 ldr pc, [pc, #20] ; e0010034 <ki_boot_end+0x34>
 LDR (+imm,pre) LDR (+lit) LDR (pc,+imm,pre)Skipping e59ff014 ldr pc, [pc, #20] ; e0010038 <ki_boot_end+0x38>


Stack analysis
---------------

No stack accesses found. Code for `arm_vector_table`:

    0xe0010000     0x0    ldr pc, [pc, #24] 
    0xe0010004     0x4    ldr pc, [pc, #24] 
    0xe0010008     0x8    ldr pc, [pc, #24] 
    0xe001000c     0xc    ldr pc, [pc, #24] 
    0xe0010010    0x10    ldr pc, [pc, #24] 
    0xe0010014    0x14    ldr pc, [pc, #4] 
    0xe0010018    0x18    ldr pc, [pc, #20] 
    0xe001001c    0x1c    ldr pc, [pc, #20] 
    0xe0010020    0x20    .word 0xe0010110
    0xe0010024    0x24    .word 0xe001003c
    0xe0010028    0x28    .word 0xe001005c
    0xe001002c    0x2c    .word 0xe0010088
    0xe0010030    0x30    .word 0xe00100b8
    0xe0010034    0x34    .word 0xe00100ec
    0xe0010038    0x38    .word 0xe0010114

Proving inst theorems
---------------------

8 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `arm_vector_table` has 16 nodes.

Section handleSyscall (294 of 299)
==================================

Deriving specifications
-----------------------

Section `handleSyscall` consists of 72 instructions.
Switch found.


Stack analysis
---------------

2 stack accesses found. Annotated code for `handleSyscall`:

    0xe001af48      0x0    add r0, r0, #8
    0xe001af4c      0x4    push {r4, lr}         ; stack access
    0xe001af50      0x8    cmp r0, #7
    0xe001af54      0xc    ldrls pc, [pc, r0, lsl #2]
    0xe001af58     0x10    b e001b064 <handleSyscall+0x11c>
    0xe001af5c     0x14    .word 0xe001b02c
    0xe001af60     0x18    .word 0xe001b038
    0xe001af64     0x1c    .word 0xe001af98
    0xe001af68     0x20    .word 0xe001af80
    0xe001af6c     0x24    .word 0xe001afa0
    0xe001af70     0x28    .word 0xe001affc
    0xe001af74     0x2c    .word 0xe001af7c
    0xe001af78     0x30    .word 0xe001b014
    0xe001af7c     0x34    bl e0018170 <handleReply>
    0xe001af80     0x38    mov r0, #1
    0xe001af84     0x3c    bl e001889c <handleRecv>
    0xe001af88     0x40    bl e00165a8 <schedule>
    0xe001af8c     0x44    bl e001319c <activateThread>
    0xe001af90     0x48    mov r0, #0
    0xe001af94     0x4c    pop {r4, pc}          ; stack access
    0xe001af98     0x50    bl e0018170 <handleReply>
    0xe001af9c     0x54    b e001af88 <handleSyscall+0x40>
    0xe001afa0     0x58    mov r1, #0
    0xe001afa4     0x5c    mov r0, r1
    0xe001afa8     0x60    bl e001adb0 <handleInvocation>
    0xe001afac     0x64    cmp r0, #0
    0xe001afb0     0x68    beq e001af88 <handleSyscall+0x40>
    0xe001afb4     0x6c    movw r3, #46264 
    0xe001afb8     0x70    movt r3, #57345 
    0xe001afbc     0x74    ldr r0, [r3]
    0xe001afc0     0x78    ubfx r0, r0, #0, #10
    0xe001afc4     0x7c    cmp r0, #1020 
    0xe001afc8     0x80    bcc e001afe8 <handleSyscall+0xa0>
    0xe001afcc     0x84    movw r2, #8703 
    0xe001afd0     0x88    movt r2, #65520 
    0xe001afd4     0x8c    ldr r2, [r2, #-243] 
    0xe001afd8     0x90    ubfx r0, r2, #0, #10
    0xe001afdc     0x94    cmp r0, #1020 
    0xe001afe0     0x98    str r2, [r3]
    0xe001afe4     0x9c    bcs e001af88 <handleSyscall+0x40>
    0xe001afe8     0xa0    ldr r3, [r3, #4]
    0xe001afec     0xa4    cmp r3, r0
    0xe001aff0     0xa8    beq e001af88 <handleSyscall+0x40>
    0xe001aff4     0xac    bl e001771c <handleInterrupt>
    0xe001aff8     0xb0    b e001af88 <handleSyscall+0x40>
    0xe001affc     0xb4    mov r1, #1
    0xe001b000     0xb8    mov r0, #0
    0xe001b004     0xbc    bl e001adb0 <handleInvocation>
    0xe001b008     0xc0    cmp r0, #0
    0xe001b00c     0xc4    beq e001af88 <handleSyscall+0x40>
    0xe001b010     0xc8    b e001afb4 <handleSyscall+0x6c>
    0xe001b014     0xcc    mov r1, #1
    0xe001b018     0xd0    mov r0, r1
    0xe001b01c     0xd4    bl e001adb0 <handleInvocation>
    0xe001b020     0xd8    cmp r0, #0
    0xe001b024     0xdc    beq e001af88 <handleSyscall+0x40>
    0xe001b028     0xe0    b e001afb4 <handleSyscall+0x6c>
    0xe001b02c     0xe4    mov r0, #0
    0xe001b030     0xe8    bl e001889c <handleRecv>
    0xe001b034     0xec    b e001af88 <handleSyscall+0x40>
    0xe001b038     0xf0    movw r4, #13900 
    0xe001b03c     0xf4    movt r4, #57347 
    0xe001b040     0xf8    ldr r0, [r4]
    0xe001b044     0xfc    bl e0016384 <tcbSchedDequeue>
    0xe001b048    0x100    ldr r0, [r4]
    0xe001b04c    0x104    ldr r3, [r0, #84] 
    0xe001b050    0x108    tst r3, #1
    0xe001b054    0x10c    bne e001b05c <handleSyscall+0x114>
    0xe001b058    0x110    bl e0010870 <tcbSchedAppend.part.171>
    0xe001b05c    0x114    bl e0013098 <rescheduleRequired>
    0xe001b060    0x118    b e001af88 <handleSyscall+0x40>
    0xe001b064    0x11c    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
64 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `handleSyscall` has 127 nodes.

Section decodeInvocation (295 of 299)
=====================================

Deriving specifications
-----------------------

Section `decodeInvocation` consists of 230 instructions.
Switch found.
 STMIB;2,1,0....+
 LDMIB;3,2...++


Stack analysis
---------------

48 stack accesses found. Annotated code for `decodeInvocation`:

    0xe001aa18      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001aa1c      0x4    sub sp, sp, #52 
    0xe001aa20      0x8    mov fp, r2
    0xe001aa24      0xc    mov lr, r0
    0xe001aa28     0x10    ldr r4, [sp, #88]     ; stack access
    0xe001aa2c     0x14    mov r5, r1
    0xe001aa30     0x18    ldr sl, [sp, #108]    ; stack access
    0xe001aa34     0x1c    and r2, r4, #14
    0xe001aa38     0x20    ldr r9, [sp, #112]    ; stack access
    0xe001aa3c     0x24    cmp r2, #14
    0xe001aa40     0x28    ldr r8, [sp, #116]    ; stack access
    0xe001aa44     0x2c    andne ip, r4, #15
    0xe001aa48     0x30    uxtbeq ip, r4
    0xe001aa4c     0x34    tst ip, #1
    0xe001aa50     0x38    ldr r7, [sp, #92]     ; stack access
    0xe001aa54     0x3c    bne e001ab64 <decodeInvocation+0x14c>
    0xe001aa58     0x40    mov r6, r3
    0xe001aa5c     0x44    cmp ip, #62 
    0xe001aa60     0x48    ldrls pc, [pc, ip, lsl #2]
    0xe001aa64     0x4c    b e001adac <decodeInvocation+0x394>
    0xe001aa68     0x50    .word 0xe001aba8
    0xe001aa6c     0x54    .word 0xe001adac
    0xe001aa70     0x58    .word 0xe001abcc
    0xe001aa74     0x5c    .word 0xe001adac
    0xe001aa78     0x60    .word 0xe001ac00
    0xe001aa7c     0x64    .word 0xe001adac
    0xe001aa80     0x68    .word 0xe001ac60
    0xe001aa84     0x6c    .word 0xe001adac
    0xe001aa88     0x70    .word 0xe001aca0
    0xe001aa8c     0x74    .word 0xe001adac
    0xe001aa90     0x78    .word 0xe001acec
    0xe001aa94     0x7c    .word 0xe001adac
    0xe001aa98     0x80    .word 0xe001ad14
    0xe001aa9c     0x84    .word 0xe001adac
    0xe001aaa0     0x88    .word 0xe001ad44
    0xe001aaa4     0x8c    .word 0xe001adac
    0xe001aaa8     0x90    .word 0xe001adac
    0xe001aaac     0x94    .word 0xe001adac
    0xe001aab0     0x98    .word 0xe001adac
    0xe001aab4     0x9c    .word 0xe001adac
    0xe001aab8     0xa0    .word 0xe001adac
    0xe001aabc     0xa4    .word 0xe001adac
    0xe001aac0     0xa8    .word 0xe001adac
    0xe001aac4     0xac    .word 0xe001adac
    0xe001aac8     0xb0    .word 0xe001adac
    0xe001aacc     0xb4    .word 0xe001adac
    0xe001aad0     0xb8    .word 0xe001adac
    0xe001aad4     0xbc    .word 0xe001adac
    0xe001aad8     0xc0    .word 0xe001adac
    0xe001aadc     0xc4    .word 0xe001adac
    0xe001aae0     0xc8    .word 0xe001ad6c
    0xe001aae4     0xcc    .word 0xe001adac
    0xe001aae8     0xd0    .word 0xe001adac
    0xe001aaec     0xd4    .word 0xe001adac
    0xe001aaf0     0xd8    .word 0xe001adac
    0xe001aaf4     0xdc    .word 0xe001adac
    0xe001aaf8     0xe0    .word 0xe001adac
    0xe001aafc     0xe4    .word 0xe001adac
    0xe001ab00     0xe8    .word 0xe001adac
    0xe001ab04     0xec    .word 0xe001adac
    0xe001ab08     0xf0    .word 0xe001adac
    0xe001ab0c     0xf4    .word 0xe001adac
    0xe001ab10     0xf8    .word 0xe001adac
    0xe001ab14     0xfc    .word 0xe001adac
    0xe001ab18    0x100    .word 0xe001adac
    0xe001ab1c    0x104    .word 0xe001adac
    0xe001ab20    0x108    .word 0xe001aba8
    0xe001ab24    0x10c    .word 0xe001adac
    0xe001ab28    0x110    .word 0xe001adac
    0xe001ab2c    0x114    .word 0xe001adac
    0xe001ab30    0x118    .word 0xe001adac
    0xe001ab34    0x11c    .word 0xe001adac
    0xe001ab38    0x120    .word 0xe001adac
    0xe001ab3c    0x124    .word 0xe001adac
    0xe001ab40    0x128    .word 0xe001adac
    0xe001ab44    0x12c    .word 0xe001adac
    0xe001ab48    0x130    .word 0xe001adac
    0xe001ab4c    0x134    .word 0xe001adac
    0xe001ab50    0x138    .word 0xe001adac
    0xe001ab54    0x13c    .word 0xe001adac
    0xe001ab58    0x140    .word 0xe001adac
    0xe001ab5c    0x144    .word 0xe001adac
    0xe001ab60    0x148    .word 0xe001ad8c
    0xe001ab64    0x14c    add ip, sp, #96 
    0xe001ab68    0x150    add r6, sp, #36 
    0xe001ab6c    0x154    add r9, sp, #28
    0xe001ab70    0x158    str r4, [sp, #28]     ; stack access
    0xe001ab74    0x15c    ldm ip, {r0, r1, r2}  ; stack access
    0xe001ab78    0x160    add ip, sp, #84 
    0xe001ab7c    0x164    str r8, [sp, #108]    ; stack access
    0xe001ab80    0x168    str r7, [sp, #32]     ; stack access
    0xe001ab84    0x16c    stm r6, {r0, r1, r2}  ; stack access
    0xe001ab88    0x170    mov r2, fp
    0xe001ab8c    0x174    ldm r9, {r0, r1}      ; stack access
    0xe001ab90    0x178    stmib ip, {r0, r1}    ; stack access
    0xe001ab94    0x17c    mov r1, r5
    0xe001ab98    0x180    mov r0, lr
    0xe001ab9c    0x184    add sp, sp, #52 
    0xe001aba0    0x188    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001aba4    0x18c    b e0014df4 <decodeARMMMUInvocation>
    0xe001aba8    0x190    movw r3, #36896 
    0xe001abac    0x194    movt r3, #57346 
    0xe001abb0    0x198    mov r0, #3
    0xe001abb4    0x19c    mov r1, #2
    0xe001abb8    0x1a0    mov r2, #0
    0xe001abbc    0x1a4    str r1, [r3, #24]
    0xe001abc0    0x1a8    str r2, [r3, #4]
    0xe001abc4    0x1ac    add sp, sp, #52 
    0xe001abc8    0x1b0    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe001abcc    0x1b4    add r3, sp, #96 
    0xe001abd0    0x1b8    str r8, [sp, #20]     ; stack access
    0xe001abd4    0x1bc    ldr ip, [sp, #92]     ; stack access
    0xe001abd8    0x1c0    ldm r3, {r0, r1, r2}  ; stack access
    0xe001abdc    0x1c4    str r9, [sp, #16]     ; stack access
    0xe001abe0    0x1c8    str ip, [sp]          ; stack access
    0xe001abe4    0x1cc    ldr r3, [sp, #88]     ; stack access
    0xe001abe8    0x1d0    stmib sp, {r0, r1, r2}  ; stack access
    0xe001abec    0x1d4    mov r2, r6
    0xe001abf0    0x1d8    mov r1, r5
    0xe001abf4    0x1dc    mov r0, lr
    0xe001abf8    0x1e0    bl e001a624 <decodeUntypedInvocation>
    0xe001abfc    0x1e4    b e001abc4 <decodeInvocation+0x1ac>
    0xe001ac00    0x1e8    tst r7, #1
    0xe001ac04    0x1ec    beq e001aba8 <decodeInvocation+0x190>
    0xe001ac08    0x1f0    movw r5, #13900 
    0xe001ac0c    0x1f4    movt r5, #57347 
    0xe001ac10    0x1f8    ldr r2, [r5]
    0xe001ac14    0x1fc    ldr r3, [r2, #80] 
    0xe001ac18    0x200    mov r0, r2
    0xe001ac1c    0x204    bic r3, r3, #15
    0xe001ac20    0x208    orr r3, r3, #2
    0xe001ac24    0x20c    str r3, [r2, #80] 
    0xe001ac28    0x210    bl e0013114 <setThreadState.part.166>
    0xe001ac2c    0x214    ldr ip, [r5]
    0xe001ac30    0x218    mov r0, sl
    0xe001ac34    0x21c    bic r3, r7, #15
    0xe001ac38    0x220    lsr r2, r4, #4
    0xe001ac3c    0x224    str r3, [sp, #8]      ; stack access
    0xe001ac40    0x228    str ip, [sp, #4]      ; stack access
    0xe001ac44    0x22c    mov r1, r9
    0xe001ac48    0x230    ubfx ip, r7, #3, #1
    0xe001ac4c    0x234    ubfx r3, r7, #2, #1
    0xe001ac50    0x238    str ip, [sp]          ; stack access
    0xe001ac54    0x23c    bl e00181f0 <sendIPC>
    0xe001ac58    0x240    mov r0, #0
    0xe001ac5c    0x244    b e001abc4 <decodeInvocation+0x1ac>
    0xe001ac60    0x248    tst r7, #1
    0xe001ac64    0x24c    beq e001aba8 <decodeInvocation+0x190>
    0xe001ac68    0x250    movw r3, #13900 
    0xe001ac6c    0x254    movt r3, #57347 
    0xe001ac70    0x258    ldr r2, [r3]
    0xe001ac74    0x25c    ldr r3, [r2, #80] 
    0xe001ac78    0x260    mov r0, r2
    0xe001ac7c    0x264    bic r3, r3, #15
    0xe001ac80    0x268    orr r3, r3, #2
    0xe001ac84    0x26c    str r3, [r2, #80] 
    0xe001ac88    0x270    bl e0013114 <setThreadState.part.166>
    0xe001ac8c    0x274    bic r0, r4, #15
    0xe001ac90    0x278    lsr r1, r7, #4
    0xe001ac94    0x27c    bl e00175d8 <sendSignal>
    0xe001ac98    0x280    mov r0, #0
    0xe001ac9c    0x284    b e001abc4 <decodeInvocation+0x1ac>
    0xe001aca0    0x288    ubfx r5, r4, #4, #1
    0xe001aca4    0x28c    cmp r5, #0
    0xe001aca8    0x290    bne e001aba8 <decodeInvocation+0x190>
    0xe001acac    0x294    movw r7, #13900 
    0xe001acb0    0x298    movt r7, #57347 
    0xe001acb4    0x29c    ldr r2, [r7]
    0xe001acb8    0x2a0    ldr r3, [r2, #80] 
    0xe001acbc    0x2a4    mov r0, r2
    0xe001acc0    0x2a8    bic r3, r3, #15
    0xe001acc4    0x2ac    orr r3, r3, #2
    0xe001acc8    0x2b0    str r3, [r2, #80] 
    0xe001accc    0x2b4    bl e0013114 <setThreadState.part.166>
    0xe001acd0    0x2b8    ldr r0, [r7]
    0xe001acd4    0x2bc    mov r2, r6
    0xe001acd8    0x2c0    ubfx r3, r4, #5, #1
    0xe001acdc    0x2c4    bic r1, r4, #63 
    0xe001ace0    0x2c8    bl e0018080 <doReplyTransfer>
    0xe001ace4    0x2cc    mov r0, r5
    0xe001ace8    0x2d0    b e001abc4 <decodeInvocation+0x1ac>
    0xe001acec    0x2d4    add r3, sp, #96 
    0xe001acf0    0x2d8    str r8, [sp, #12]     ; stack access
    0xe001acf4    0x2dc    ldm r3, {r0, r1, r2}  ; stack access
    0xe001acf8    0x2e0    add r3, sp, #84 
    0xe001acfc    0x2e4    stm sp, {r0, r1, r2}  ; stack access
    0xe001ad00    0x2e8    mov r1, r5
    0xe001ad04    0x2ec    mov r0, lr
    0xe001ad08    0x2f0    ldmib r3, {r2, r3}    ; stack access
    0xe001ad0c    0x2f4    bl e0016d4c <decodeCNodeInvocation>
    0xe001ad10    0x2f8    b e001abc4 <decodeInvocation+0x1ac>
    0xe001ad14    0x2fc    add r3, sp, #96 
    0xe001ad18    0x300    str r8, [sp, #20]     ; stack access
    0xe001ad1c    0x304    str r9, [sp, #16]     ; stack access
    0xe001ad20    0x308    ldm r3, {r0, r1, r2}  ; stack access
    0xe001ad24    0x30c    add r3, sp, #84 
    0xe001ad28    0x310    str r6, [sp]          ; stack access
    0xe001ad2c    0x314    stmib sp, {r0, r1, r2}  ; stack access
    0xe001ad30    0x318    mov r1, r5
    0xe001ad34    0x31c    mov r0, lr
    0xe001ad38    0x320    ldmib r3, {r2, r3}    ; stack access
    0xe001ad3c    0x324    bl e0019fdc <decodeTCBInvocation>
    0xe001ad40    0x328    b e001abc4 <decodeInvocation+0x1ac>
    0xe001ad44    0x32c    add r1, sp, #100 
    0xe001ad48    0x330    str r8, [sp, #8]      ; stack access
    0xe001ad4c    0x334    mov r2, r3
    0xe001ad50    0x338    ldr r3, [sp, #96]     ; stack access
    0xe001ad54    0x33c    ldm r1, {r0, r1}      ; stack access
    0xe001ad58    0x340    stm sp, {r0, r1}      ; stack access
    0xe001ad5c    0x344    mov r1, r5
    0xe001ad60    0x348    mov r0, lr
    0xe001ad64    0x34c    bl e0013d6c <decodeIRQControlInvocation>
    0xe001ad68    0x350    b e001abc4 <decodeInvocation+0x1ac>
    0xe001ad6c    0x354    ldr ip, [sp, #104]    ; stack access
    0xe001ad70    0x358    add r3, sp, #96 
    0xe001ad74    0x35c    uxtb r1, r7
    0xe001ad78    0x360    ldm r3, {r2, r3}      ; stack access
    0xe001ad7c    0x364    str ip, [sp, #88]     ; stack access
    0xe001ad80    0x368    add sp, sp, #52 
    0xe001ad84    0x36c    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001ad88    0x370    b e0017974 <decodeIRQHandlerInvocation>
    0xe001ad8c    0x374    ldr ip, [sp, #104]    ; stack access
    0xe001ad90    0x378    add r3, sp, #96 
    0xe001ad94    0x37c    str r8, [sp, #92]     ; stack access
    0xe001ad98    0x380    ldm r3, {r2, r3}      ; stack access
    0xe001ad9c    0x384    str ip, [sp, #88]     ; stack access
    0xe001ada0    0x388    add sp, sp, #52 
    0xe001ada4    0x38c    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe001ada8    0x390    b e0018a90 <decodeDomainInvocation>
    0xe001adac    0x394    bl e0010a3c <halt>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
167 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeInvocation` has 444 nodes.

Section decodeCNodeInvocation (296 of 299)
==========================================

Deriving specifications
-----------------------

Section `decodeCNodeInvocation` consists of 417 instructions.
 STMIA;12,4...+


Stack analysis
---------------

70 stack accesses found. Annotated code for `decodeCNodeInvocation`:

    0xe0016d4c      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0016d50      0x4    sub ip, r0, #16
    0xe0016d54      0x8    sub sp, sp, #132 
    0xe0016d58      0xc    cmp ip, #8
    0xe0016d5c     0x10    add ip, sp, #16
    0xe0016d60     0x14    ldr r6, [sp, #180]    ; stack access
    0xe0016d64     0x18    stm ip, {r2, r3}      ; stack access
    0xe0016d68     0x1c    bhi e0016f70 <decodeCNodeInvocation+0x224>
    0xe0016d6c     0x20    cmp r1, #1
    0xe0016d70     0x24    bls e0016f50 <decodeCNodeInvocation+0x204>
    0xe0016d74     0x28    movw r5, #13900 
    0xe0016d78     0x2c    movt r5, #57347 
    0xe0016d7c     0x30    add ip, sp, #52 
    0xe0016d80     0x34    mov sl, r1
    0xe0016d84     0x38    ldr lr, [r5]
    0xe0016d88     0x3c    mov r8, r0
    0xe0016d8c     0x40    stm ip, {r2, r3}      ; stack access
    0xe0016d90     0x44    mov r1, #0
    0xe0016d94     0x48    ldm ip, {r2, r3}      ; stack access
    0xe0016d98     0x4c    add r0, sp, #28
    0xe0016d9c     0x50    ldr r4, [lr, #8]
    0xe0016da0     0x54    ldr ip, [lr, #12]
    0xe0016da4     0x58    ldr r9, [sp, #168]    ; stack access
    0xe0016da8     0x5c    ldr fp, [sp, #172]    ; stack access
    0xe0016dac     0x60    stm sp, {r4, ip}      ; stack access
    0xe0016db0     0x64    bl e0012e24 <lookupSlotForCNodeOp>
    0xe0016db4     0x68    ldr r4, [sp, #28]     ; stack access
    0xe0016db8     0x6c    cmp r4, #0
    0xe0016dbc     0x70    bne e0016f64 <decodeCNodeInvocation+0x218>
    0xe0016dc0     0x74    sub r3, r8, #19
    0xe0016dc4     0x78    ldr r7, [sp, #32]     ; stack access
    0xe0016dc8     0x7c    cmp r3, #3
    0xe0016dcc     0x80    bls e0016f44 <decodeCNodeInvocation+0x1f8>
    0xe0016dd0     0x84    cmp r8, #16
    0xe0016dd4     0x88    beq e001705c <decodeCNodeInvocation+0x310>
    0xe0016dd8     0x8c    cmp r8, #17
    0xe0016ddc     0x90    beq e0017088 <decodeCNodeInvocation+0x33c>
    0xe0016de0     0x94    cmp r8, #24
    0xe0016de4     0x98    beq e0017014 <decodeCNodeInvocation+0x2c8>
    0xe0016de8     0x9c    cmp r8, #18
    0xe0016dec     0xa0    beq e0016fc4 <decodeCNodeInvocation+0x278>
    0xe0016df0     0xa4    cmp r8, #23
    0xe0016df4     0xa8    bne e0016f64 <decodeCNodeInvocation+0x218>
    0xe0016df8     0xac    clz r3, r9
    0xe0016dfc     0xb0    cmp fp, #0
    0xe0016e00     0xb4    lsr r3, r3, #5
    0xe0016e04     0xb8    moveq r3, #1
    0xe0016e08     0xbc    cmp sl, #7
    0xe0016e0c     0xc0    movhi sl, r3
    0xe0016e10     0xc4    orrls sl, r3, #1
    0xe0016e14     0xc8    cmp sl, #0
    0xe0016e18     0xcc    bne e0016f50 <decodeCNodeInvocation+0x204>
    0xe0016e1c     0xd0    ldr r2, [r5]
    0xe0016e20     0xd4    add r3, sp, #92 
    0xe0016e24     0xd8    ldr lr, [fp, #4]
    0xe0016e28     0xdc    mov r1, #1
    0xe0016e2c     0xe0    ldr r4, [fp]
    0xe0016e30     0xe4    add r0, sp, #100 
    0xe0016e34     0xe8    ldr ip, [r6, #28]
    0xe0016e38     0xec    ldr r8, [r6, #32]
    0xe0016e3c     0xf0    ldr sl, [r2, #16]
    0xe0016e40     0xf4    ldr r2, [r2, #20]
    0xe0016e44     0xf8    str lr, [sp, #96]     ; stack access
    0xe0016e48     0xfc    ldr lr, [r9, #4]
    0xe0016e4c    0x100    ldr fp, [r9]
    0xe0016e50    0x104    str r4, [sp, #92]     ; stack access
    0xe0016e54    0x108    str r2, [sp, #8]      ; stack access
    0xe0016e58    0x10c    ldm r3, {r2, r3}      ; stack access
    0xe0016e5c    0x110    str ip, [sp]          ; stack access
    0xe0016e60    0x114    str r8, [sp, #4]      ; stack access
    0xe0016e64    0x118    str lr, [sp, #12]     ; stack access
    0xe0016e68    0x11c    ldr r9, [r6, #20]
    0xe0016e6c    0x120    ldr r6, [r6, #24]
    0xe0016e70    0x124    bl e0012e24 <lookupSlotForCNodeOp>
    0xe0016e74    0x128    ldr r4, [sp, #100]    ; stack access
    0xe0016e78    0x12c    cmp r4, #0
    0xe0016e7c    0x130    bne e0016f64 <decodeCNodeInvocation+0x218>
    0xe0016e80    0x134    ldr r2, [sp, #12]     ; stack access
    0xe0016e84    0x138    add r3, sp, #108 
    0xe0016e88    0x13c    str fp, [sp, #108]    ; stack access
    0xe0016e8c    0x140    mov r1, #1
    0xe0016e90    0x144    str r9, [sp, #4]      ; stack access
    0xe0016e94    0x148    add r0, sp, #116 
    0xe0016e98    0x14c    str r2, [sp, #112]    ; stack access
    0xe0016e9c    0x150    ldr r2, [sp, #8]      ; stack access
    0xe0016ea0    0x154    ldr fp, [sp, #104]    ; stack access
    0xe0016ea4    0x158    str r2, [sp]          ; stack access
    0xe0016ea8    0x15c    ldm r3, {r2, r3}      ; stack access
    0xe0016eac    0x160    bl e0012e24 <lookupSlotForCNodeOp>
    0xe0016eb0    0x164    ldr r4, [sp, #116]    ; stack access
    0xe0016eb4    0x168    cmp r4, #0
    0xe0016eb8    0x16c    bne e0016f64 <decodeCNodeInvocation+0x218>
    0xe0016ebc    0x170    ldr r4, [sp, #120]    ; stack access
    0xe0016ec0    0x174    cmp r4, r7
    0xe0016ec4    0x178    cmpne fp, r4
    0xe0016ec8    0x17c    beq e0016f70 <decodeCNodeInvocation+0x224>
    0xe0016ecc    0x180    cmp fp, r7
    0xe0016ed0    0x184    beq e0016ef0 <decodeCNodeInvocation+0x1a4>
    0xe0016ed4    0x188    ldr r3, [r7]
    0xe0016ed8    0x18c    and r2, r3, #14
    0xe0016edc    0x190    cmp r2, #14
    0xe0016ee0    0x194    andne r3, r3, #15
    0xe0016ee4    0x198    uxtbeq r3, r3
    0xe0016ee8    0x19c    cmp r3, #0
    0xe0016eec    0x1a0    bne e0016fac <decodeCNodeInvocation+0x260>
    0xe0016ef0    0x1a4    ldr r2, [fp]
    0xe0016ef4    0x1a8    and r3, r2, #14
    0xe0016ef8    0x1ac    cmp r3, #14
    0xe0016efc    0x1b0    andne r2, r2, #15
    0xe0016f00    0x1b4    uxtbeq r2, r2
    0xe0016f04    0x1b8    cmp r2, #0
    0xe0016f08    0x1bc    bne e00172c8 <decodeCNodeInvocation+0x57c>
    0xe0016f0c    0x1c0    lsl r3, r8, #2
    0xe0016f10    0x1c4    movw r0, #36884 
    0xe0016f14    0x1c8    movw r1, #36896 
    0xe0016f18    0x1cc    movt r0, #57346 
    0xe0016f1c    0x1d0    movt r1, #57346 
    0xe0016f20    0x1d4    uxtb r3, r3
    0xe0016f24    0x1d8    orr r3, r3, #1
    0xe0016f28    0x1dc    str r2, [r0, #4]
    0xe0016f2c    0x1e0    str r3, [r0]
    0xe0016f30    0x1e4    mov r2, #1
    0xe0016f34    0x1e8    mov r3, #6
    0xe0016f38    0x1ec    mov r4, #3
    0xe0016f3c    0x1f0    strd r2, [r1, #20]
    0xe0016f40    0x1f4    b e0016f64 <decodeCNodeInvocation+0x218>
    0xe0016f44    0x1f8    cmp r9, #0
    0xe0016f48    0x1fc    cmpne sl, #3
    0xe0016f4c    0x200    bhi e0016f90 <decodeCNodeInvocation+0x244>
    0xe0016f50    0x204    movw r3, #36896 
    0xe0016f54    0x208    movt r3, #57346 
    0xe0016f58    0x20c    mov r4, #3
    0xe0016f5c    0x210    mov r2, #7
    0xe0016f60    0x214    str r2, [r3, #24]
    0xe0016f64    0x218    mov r0, r4
    0xe0016f68    0x21c    add sp, sp, #132 
    0xe0016f6c    0x220    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0016f70    0x224    mov r2, #3
    0xe0016f74    0x228    movw r3, #36896 
    0xe0016f78    0x22c    movt r3, #57346 
    0xe0016f7c    0x230    mov r4, r2
    0xe0016f80    0x234    mov r0, r4
    0xe0016f84    0x238    str r2, [r3, #24]
    0xe0016f88    0x23c    add sp, sp, #132 
    0xe0016f8c    0x240    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0016f90    0x244    ldr r3, [r7]
    0xe0016f94    0x248    and r2, r3, #14
    0xe0016f98    0x24c    cmp r2, #14
    0xe0016f9c    0x250    andne r3, r3, #15
    0xe0016fa0    0x254    uxtbeq r3, r3
    0xe0016fa4    0x258    cmp r3, #0
    0xe0016fa8    0x25c    beq e00170b8 <decodeCNodeInvocation+0x36c>
    0xe0016fac    0x260    movw r3, #36896 
    0xe0016fb0    0x264    movt r3, #57346 
    0xe0016fb4    0x268    mov r2, #8
    0xe0016fb8    0x26c    mov r4, #3
    0xe0016fbc    0x270    str r2, [r3, #24]
    0xe0016fc0    0x274    b e0016f64 <decodeCNodeInvocation+0x218>
    0xe0016fc4    0x278    ldr r6, [r7]
    0xe0016fc8    0x27c    add r3, sp, #36 
    0xe0016fcc    0x280    ldr r7, [r7, #4]
    0xe0016fd0    0x284    strd r6, [sp, #36]    ; stack access
    0xe0016fd4    0x288    ldm r3, {r0, r1}      ; stack access
    0xe0016fd8    0x28c    bl e00142a4 <hasCancelSendRights>
    0xe0016fdc    0x290    cmp r0, #0
    0xe0016fe0    0x294    beq e0016f70 <decodeCNodeInvocation+0x224>
    0xe0016fe4    0x298    ldr r2, [r5]
    0xe0016fe8    0x29c    ldr r3, [r2, #80] 
    0xe0016fec    0x2a0    mov r0, r2
    0xe0016ff0    0x2a4    bic r3, r3, #15
    0xe0016ff4    0x2a8    orr r3, r3, #2
    0xe0016ff8    0x2ac    str r3, [r2, #80] 
    0xe0016ffc    0x2b0    bl e0013114 <setThreadState.part.166>
    0xe0017000    0x2b4    lsrs r1, r6, #4
    0xe0017004    0x2b8    beq e0016f64 <decodeCNodeInvocation+0x218>
    0xe0017008    0x2bc    bic r0, r7, #15
    0xe001700c    0x2c0    bl e00139d8 <cancelBadgedSends>
    0xe0017010    0x2c4    b e0016f64 <decodeCNodeInvocation+0x218>
    0xe0017014    0x2c8    ldr r3, [r7]
    0xe0017018    0x2cc    and r2, r3, #14
    0xe001701c    0x2d0    cmp r2, #14
    0xe0017020    0x2d4    andne r3, r3, #15
    0xe0017024    0x2d8    uxtbeq r3, r3
    0xe0017028    0x2dc    cmp r3, #0
    0xe001702c    0x2e0    bne e0016fac <decodeCNodeInvocation+0x260>
    0xe0017030    0x2e4    ldr r2, [r5]
    0xe0017034    0x2e8    ldr r3, [r2, #80] 
    0xe0017038    0x2ec    mov r0, r2
    0xe001703c    0x2f0    bic r3, r3, #15
    0xe0017040    0x2f4    orr r3, r3, #2
    0xe0017044    0x2f8    str r3, [r2, #80] 
    0xe0017048    0x2fc    bl e0013114 <setThreadState.part.166>
    0xe001704c    0x300    mov r0, r7
    0xe0017050    0x304    add sp, sp, #132 
    0xe0017054    0x308    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0017058    0x30c    b e0013590 <invokeCNodeSaveCaller>
    0xe001705c    0x310    ldr r2, [r5]
    0xe0017060    0x314    ldr r3, [r2, #80] 
    0xe0017064    0x318    mov r0, r2
    0xe0017068    0x31c    bic r3, r3, #15
    0xe001706c    0x320    orr r3, r3, #2
    0xe0017070    0x324    str r3, [r2, #80] 
    0xe0017074    0x328    bl e0013114 <setThreadState.part.166>
    0xe0017078    0x32c    mov r0, r7
    0xe001707c    0x330    add sp, sp, #132 
    0xe0017080    0x334    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0017084    0x338    b e0016cc0 <cteRevoke>
    0xe0017088    0x33c    ldr r2, [r5]
    0xe001708c    0x340    ldr r3, [r2, #80] 
    0xe0017090    0x344    mov r0, r2
    0xe0017094    0x348    bic r3, r3, #15
    0xe0017098    0x34c    orr r3, r3, #2
    0xe001709c    0x350    str r3, [r2, #80] 
    0xe00170a0    0x354    bl e0013114 <setThreadState.part.166>
    0xe00170a4    0x358    mov r0, r7
    0xe00170a8    0x35c    mov r1, #1
    0xe00170ac    0x360    add sp, sp, #132 
    0xe00170b0    0x364    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00170b4    0x368    b e0016a68 <cteDelete>
    0xe00170b8    0x36c    ldr r2, [r5]
    0xe00170bc    0x370    add r3, sp, #60 
    0xe00170c0    0x374    ldr r0, [r9]
    0xe00170c4    0x378    mov r1, #1
    0xe00170c8    0x37c    ldr ip, [r9, #4]
    0xe00170cc    0x380    ldr lr, [r2, #16]
    0xe00170d0    0x384    ldr r9, [r2, #20]
    0xe00170d4    0x388    str r0, [sp, #60]     ; stack access
    0xe00170d8    0x38c    add r0, sp, #68 
    0xe00170dc    0x390    str lr, [sp]          ; stack access
    0xe00170e0    0x394    str r9, [sp, #4]      ; stack access
    0xe00170e4    0x398    str ip, [sp, #64]     ; stack access
    0xe00170e8    0x39c    ldm r3, {r2, r3}      ; stack access
    0xe00170ec    0x3a0    bl e0012e24 <lookupSlotForCNodeOp>
    0xe00170f0    0x3a4    ldr r4, [sp, #68]     ; stack access
    0xe00170f4    0x3a8    cmp r4, #0
    0xe00170f8    0x3ac    bne e0016f64 <decodeCNodeInvocation+0x218>
    0xe00170fc    0x3b0    ldr fp, [sp, #72]     ; stack access
    0xe0017100    0x3b4    ldr r3, [fp]
    0xe0017104    0x3b8    and r2, r3, #14
    0xe0017108    0x3bc    cmp r2, #14
    0xe001710c    0x3c0    andne r1, r3, #15
    0xe0017110    0x3c4    uxtbeq r1, r3
    0xe0017114    0x3c8    cmp r1, #0
    0xe0017118    0x3cc    bne e0017154 <decodeCNodeInvocation+0x408>
    0xe001711c    0x3d0    lsl r3, r9, #2
    0xe0017120    0x3d4    movw r0, #36884 
    0xe0017124    0x3d8    movw r2, #36896 
    0xe0017128    0x3dc    movt r0, #57346 
    0xe001712c    0x3e0    movt r2, #57346 
    0xe0017130    0x3e4    uxtb r3, r3
    0xe0017134    0x3e8    mov r4, #1
    0xe0017138    0x3ec    orr r3, r3, #1
    0xe001713c    0x3f0    mov r5, #6
    0xe0017140    0x3f4    str r1, [r0, #4]
    0xe0017144    0x3f8    strd r4, [r2, #20]
    0xe0017148    0x3fc    mov r4, #3
    0xe001714c    0x400    str r3, [r0]
    0xe0017150    0x404    b e0016f64 <decodeCNodeInvocation+0x218>
    0xe0017154    0x408    cmp r8, #21
    0xe0017158    0x40c    beq e0017220 <decodeCNodeInvocation+0x4d4>
    0xe001715c    0x410    cmp r8, #22
    0xe0017160    0x414    beq e0017274 <decodeCNodeInvocation+0x528>
    0xe0017164    0x418    cmp r8, #20
    0xe0017168    0x41c    beq e0017234 <decodeCNodeInvocation+0x4e8>
    0xe001716c    0x420    cmp sl, #4
    0xe0017170    0x424    beq e0016f50 <decodeCNodeInvocation+0x204>
    0xe0017174    0x428    add r8, sp, #108 
    0xe0017178    0x42c    ldr r1, [r6, #20]
    0xe001717c    0x430    ldm fp, {r2, r3}
    0xe0017180    0x434    mov r0, r8
    0xe0017184    0x438    bl e0015f5c <maskCapRights>
    0xe0017188    0x43c    ldm r8, {r2, r3}      ; stack access
    0xe001718c    0x440    mov r1, fp
    0xe0017190    0x444    add r0, sp, #116 
    0xe0017194    0x448    bl e0014bf4 <deriveCap>
    0xe0017198    0x44c    ldr r6, [sp, #116]    ; stack access
    0xe001719c    0x450    cmp r6, #0
    0xe00171a0    0x454    movne r4, r6
    0xe00171a4    0x458    bne e0016f64 <decodeCNodeInvocation+0x218>
    0xe00171a8    0x45c    add r3, sp, #128 
    0xe00171ac    0x460    add r8, sp, #100 
    0xe00171b0    0x464    ldmdb r3, {r0, r1}    ; stack access
    0xe00171b4    0x468    ldr r3, [sp, #120]    ; stack access
    0xe00171b8    0x46c    and r2, r3, #14
    0xe00171bc    0x470    stm r8, {r0, r1}      ; stack access
    0xe00171c0    0x474    cmp r2, #14
    0xe00171c4    0x478    andne r2, r3, #15
    0xe00171c8    0x47c    uxtbeq r2, r3
    0xe00171cc    0x480    cmp r2, #0
    0xe00171d0    0x484    beq e0016f70 <decodeCNodeInvocation+0x224>
    0xe00171d4    0x488    ldr r1, [r5]
    0xe00171d8    0x48c    str r3, [sp, #8]      ; stack access
    0xe00171dc    0x490    ldr r2, [r1, #80] 
    0xe00171e0    0x494    mov r0, r1
    0xe00171e4    0x498    bic r2, r2, #15
    0xe00171e8    0x49c    orr r2, r2, #2
    0xe00171ec    0x4a0    str r2, [r1, #80] 
    0xe00171f0    0x4a4    bl e0013114 <setThreadState.part.166>
    0xe00171f4    0x4a8    ldr r3, [sp, #8]      ; stack access
    0xe00171f8    0x4ac    cmp r6, #0
    0xe00171fc    0x4b0    str r3, [sp, #100]    ; stack access
    0xe0017200    0x4b4    beq e00172ac <decodeCNodeInvocation+0x560>
    0xe0017204    0x4b8    ldm r8, {r0, r1}      ; stack access
    0xe0017208    0x4bc    add ip, sp, #76 
    0xe001720c    0x4c0    mov r3, r7
    0xe0017210    0x4c4    mov r2, fp
    0xe0017214    0x4c8    stm ip, {r0, r1}      ; stack access
    0xe0017218    0x4cc    bl e00134f8 <cteMove>
    0xe001721c    0x4d0    b e0016f64 <decodeCNodeInvocation+0x218>
    0xe0017220    0x4d4    ldm fp, {r0, r1}
    0xe0017224    0x4d8    add r8, sp, #100 
    0xe0017228    0x4dc    mov r6, #1
    0xe001722c    0x4e0    stm r8, {r0, r1}      ; stack access
    0xe0017230    0x4e4    b e00171c0 <decodeCNodeInvocation+0x474>
    0xe0017234    0x4e8    cmp sl, #5
    0xe0017238    0x4ec    bls e0016f50 <decodeCNodeInvocation+0x204>
    0xe001723c    0x4f0    ldm fp, {r2, r3}
    0xe0017240    0x4f4    add r0, sp, #108 
    0xe0017244    0x4f8    ldr r1, [r6, #20]
    0xe0017248    0x4fc    add r8, sp, #44 
    0xe001724c    0x500    ldr r6, [r6, #24]
    0xe0017250    0x504    bl e0015f5c <maskCapRights>
    0xe0017254    0x508    ldr ip, [sp, #112]    ; stack access
    0xe0017258    0x50c    mov r0, r8
    0xe001725c    0x510    ldr r3, [sp, #108]    ; stack access
    0xe0017260    0x514    mov r1, #0
    0xe0017264    0x518    mov r2, r6
    0xe0017268    0x51c    str ip, [sp]          ; stack access
    0xe001726c    0x520    bl e0015e7c <updateCapData>
    0xe0017270    0x524    b e0017188 <decodeCNodeInvocation+0x43c>
    0xe0017274    0x528    cmp sl, #4
    0xe0017278    0x52c    beq e0016f50 <decodeCNodeInvocation+0x204>
    0xe001727c    0x530    ldr r3, [fp, #4]
    0xe0017280    0x534    add r8, sp, #100 
    0xe0017284    0x538    ldr r2, [r6, #20]
    0xe0017288    0x53c    mov r1, #1
    0xe001728c    0x540    mov r0, r8
    0xe0017290    0x544    mov r6, r1
    0xe0017294    0x548    str r3, [sp]          ; stack access
    0xe0017298    0x54c    ldr r3, [fp]
    0xe001729c    0x550    bl e0015e7c <updateCapData>
    0xe00172a0    0x554    ldr r3, [sp, #100]    ; stack access
    0xe00172a4    0x558    and r2, r3, #14
    0xe00172a8    0x55c    b e00171c0 <decodeCNodeInvocation+0x474>
    0xe00172ac    0x560    ldm r8, {r0, r1}      ; stack access
    0xe00172b0    0x564    add ip, sp, #84 
    0xe00172b4    0x568    mov r3, r7
    0xe00172b8    0x56c    mov r2, fp
    0xe00172bc    0x570    stm ip, {r0, r1}      ; stack access
    0xe00172c0    0x574    bl e0013308 <cteInsert>
    0xe00172c4    0x578    b e0016f64 <decodeCNodeInvocation+0x218>
    0xe00172c8    0x57c    ldr r2, [r4]
    0xe00172cc    0x580    and r3, r2, #14
    0xe00172d0    0x584    cmp r3, #14
    0xe00172d4    0x588    andne r2, r2, #15
    0xe00172d8    0x58c    uxtbeq r2, r2
    0xe00172dc    0x590    cmp r2, #0
    0xe00172e0    0x594    bne e001731c <decodeCNodeInvocation+0x5d0>
    0xe00172e4    0x598    lsl r3, r9, #2
    0xe00172e8    0x59c    movw r0, #36884 
    0xe00172ec    0x5a0    movw r1, #36896 
    0xe00172f0    0x5a4    movt r0, #57346 
    0xe00172f4    0x5a8    movt r1, #57346 
    0xe00172f8    0x5ac    uxtb r3, r3
    0xe00172fc    0x5b0    orr r3, r3, #1
    0xe0017300    0x5b4    str r2, [r0, #4]
    0xe0017304    0x5b8    str r3, [r0]
    0xe0017308    0x5bc    mov r4, #3
    0xe001730c    0x5c0    mov r3, #6
    0xe0017310    0x5c4    str r2, [r1, #20]
    0xe0017314    0x5c8    str r3, [r1, #24]
    0xe0017318    0x5cc    b e0016f64 <decodeCNodeInvocation+0x218>
    0xe001731c    0x5d0    ldr r3, [fp, #4]
    0xe0017320    0x5d4    add r8, sp, #76 
    0xe0017324    0x5d8    mov r2, r6
    0xe0017328    0x5dc    mov r1, #1
    0xe001732c    0x5e0    mov r0, r8
    0xe0017330    0x5e4    add r6, sp, #84 
    0xe0017334    0x5e8    str r3, [sp]          ; stack access
    0xe0017338    0x5ec    ldr r3, [fp]
    0xe001733c    0x5f0    bl e0015e7c <updateCapData>
    0xe0017340    0x5f4    ldr r3, [r4, #4]
    0xe0017344    0x5f8    mov r2, sl
    0xe0017348    0x5fc    mov r0, r6
    0xe001734c    0x600    mov r1, #1
    0xe0017350    0x604    str r3, [sp]          ; stack access
    0xe0017354    0x608    ldr r3, [r4]
    0xe0017358    0x60c    bl e0015e7c <updateCapData>
    0xe001735c    0x610    ldr r3, [sp, #76]     ; stack access
    0xe0017360    0x614    and r2, r3, #14
    0xe0017364    0x618    cmp r2, #14
    0xe0017368    0x61c    andne r3, r3, #15
    0xe001736c    0x620    uxtbeq r3, r3
    0xe0017370    0x624    cmp r3, #0
    0xe0017374    0x628    beq e0016f70 <decodeCNodeInvocation+0x224>
    0xe0017378    0x62c    ldr r3, [sp, #84]     ; stack access
    0xe001737c    0x630    and r2, r3, #14
    0xe0017380    0x634    cmp r2, #14
    0xe0017384    0x638    andne r3, r3, #15
    0xe0017388    0x63c    uxtbeq r3, r3
    0xe001738c    0x640    cmp r3, #0
    0xe0017390    0x644    beq e0016f70 <decodeCNodeInvocation+0x224>
    0xe0017394    0x648    ldr r2, [r5]
    0xe0017398    0x64c    ldr r3, [r2, #80] 
    0xe001739c    0x650    mov r0, r2
    0xe00173a0    0x654    bic r3, r3, #15
    0xe00173a4    0x658    orr r3, r3, #2
    0xe00173a8    0x65c    str r3, [r2, #80] 
    0xe00173ac    0x660    bl e0013114 <setThreadState.part.166>
    0xe00173b0    0x664    str r7, [sp, #176]    ; stack access
    0xe00173b4    0x668    str r4, [sp, #172]    ; stack access
    0xe00173b8    0x66c    str fp, [sp, #168]    ; stack access
    0xe00173bc    0x670    ldm r6, {r2, r3}      ; stack access
    0xe00173c0    0x674    ldm r8, {r0, r1}      ; stack access
    0xe00173c4    0x678    add sp, sp, #132 
    0xe00173c8    0x67c    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00173cc    0x680    b e00136d0 <invokeCNodeRotate>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
417 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeCNodeInvocation` has 701 nodes.

Section decodeARMMMUInvocation (297 of 299)
===========================================

Deriving specifications
-----------------------

Section `decodeARMMMUInvocation` consists of 1047 instructions.
Switch found.
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy
Switch found.
 STMIB;3,1...+
 MOVTEQ..++
 ANDNE (reg)...........++++++
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy
 TST (reg).....++
 LDMIA;3,2,1,0.....++
 STMIA;3,2,1,0.....+
 ADDNE (reg)...........++++++
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy
Skipping f57ff04f dsb sy
Skipping ee083f57 mcr 15, 0, r3, cr8, cr7, {2}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy
Skipping ee073f3b mcr 15, 0, r3, cr7, cr11, {1}
Skipping f57ff05f dmb sy


Stack analysis
---------------

86 stack accesses found. Annotated code for `decodeARMMMUInvocation`:

    0xe0014df4       0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0014df8       0x4    sub sp, sp, #76 
    0xe0014dfc       0x8    mov sl, r3
    0xe0014e00       0xc    mov fp, r0
    0xe0014e04      0x10    ldr r8, [sp, #112]    ; stack access
    0xe0014e08      0x14    ldr r7, [sp, #116]    ; stack access
    0xe0014e0c      0x18    and r3, r8, #14
    0xe0014e10      0x1c    ldr r6, [sp, #120]    ; stack access
    0xe0014e14      0x20    cmp r3, #14
    0xe0014e18      0x24    andne r9, r8, #15
    0xe0014e1c      0x28    uxtbeq r9, r8
    0xe0014e20      0x2c    sub r3, r9, #1
    0xe0014e24      0x30    cmp r3, #10
    0xe0014e28      0x34    ldrls pc, [pc, r3, lsl #2]
    0xe0014e2c      0x38    b e0015658 <decodeARMMMUInvocation+0x864>
    0xe0014e30      0x3c    .word 0xe001521c
    0xe0014e34      0x40    .word 0xe0015658
    0xe0014e38      0x44    .word 0xe001521c
    0xe0014e3c      0x48    .word 0xe0015658
    0xe0014e40      0x4c    .word 0xe0015134
    0xe0014e44      0x50    .word 0xe0015658
    0xe0014e48      0x54    .word 0xe001500c
    0xe0014e4c      0x58    .word 0xe0015658
    0xe0014e50      0x5c    .word 0xe0014f0c
    0xe0014e54      0x60    .word 0xe0015658
    0xe0014e58      0x64    .word 0xe0014e5c
    0xe0014e5c      0x68    cmp r0, #43 
    0xe0014e60      0x6c    bne e0015298 <decodeARMMMUInvocation+0x4a4>
    0xe0014e64      0x70    ldr ip, [sp, #124]    ; stack access
    0xe0014e68      0x74    cmp r6, #0
    0xe0014e6c      0x78    clz r4, ip
    0xe0014e70      0x7c    lsr r4, r4, #5
    0xe0014e74      0x80    moveq r4, #1
    0xe0014e78      0x84    cmp r1, #1
    0xe0014e7c      0x88    orrls r4, r4, #1
    0xe0014e80      0x8c    cmp r4, #0
    0xe0014e84      0x90    bne e00152d4 <decodeARMMMUInvocation+0x4e0>
    0xe0014e88      0x94    movw r7, #37576 
    0xe0014e8c      0x98    movt r7, #57346 
    0xe0014e90      0x9c    ldr r8, [r6]
    0xe0014e94      0xa0    mov r3, r7
    0xe0014e98      0xa4    b e0014ea8 <decodeARMMMUInvocation+0xb4>
    0xe0014e9c      0xa8    add r4, r4, #1
    0xe0014ea0      0xac    cmp r4, #128 
    0xe0014ea4      0xb0    beq e0015640 <decodeARMMMUInvocation+0x84c>
    0xe0014ea8      0xb4    ldr r2, [r3], #4
    0xe0014eac      0xb8    cmp r2, #0
    0xe0014eb0      0xbc    bne e0014e9c <decodeARMMMUInvocation+0xa8>
    0xe0014eb4      0xc0    and r3, r8, #14
    0xe0014eb8      0xc4    cmp r3, #14
    0xe0014ebc      0xc8    andne r3, r8, #15
    0xe0014ec0      0xcc    uxtbeq r3, r8
    0xe0014ec4      0xd0    cmp r3, #2
    0xe0014ec8      0xd4    bne e0014ee4 <decodeARMMMUInvocation+0xf0>
    0xe0014ecc      0xd8    ldr r3, [r6, #4]
    0xe0014ed0      0xdc    and r1, r3, #31
    0xe0014ed4      0xe0    cmp r1, #12
    0xe0014ed8      0xe4    bne e0014ee4 <decodeARMMMUInvocation+0xf0>
    0xe0014edc      0xe8    tst r3, #32
    0xe0014ee0      0xec    beq e001565c <decodeARMMMUInvocation+0x868>
    0xe0014ee4      0xf0    movw r3, #36896 
    0xe0014ee8      0xf4    movt r3, #57346 
    0xe0014eec      0xf8    mov r5, #3
    0xe0014ef0      0xfc    mov r1, #2
    0xe0014ef4     0x100    mov r2, #1
    0xe0014ef8     0x104    mov r0, r5
    0xe0014efc     0x108    str r1, [r3, #24]
    0xe0014f00     0x10c    str r2, [r3, #4]
    0xe0014f04     0x110    add sp, sp, #76 
    0xe0014f08     0x114    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe0014f0c     0x118    sub r3, r0, #30
    0xe0014f10     0x11c    cmp r3, #3
    0xe0014f14     0x120    bhi e0015298 <decodeARMMMUInvocation+0x4a4>
    0xe0014f18     0x124    cmp r1, #1
    0xe0014f1c     0x128    bls e00152d4 <decodeARMMMUInvocation+0x4e0>
    0xe0014f20     0x12c    movw r3, #13900 
    0xe0014f24     0x130    movt r3, #57347 
    0xe0014f28     0x134    str r3, [sp, #8]      ; stack access
    0xe0014f2c     0x138    ldr r3, [r3]
    0xe0014f30     0x13c    ldr r4, [r3, #8]
    0xe0014f34     0x140    ldr r6, [r3, #12]
    0xe0014f38     0x144    cmp r4, r6
    0xe0014f3c     0x148    bcs e00152b8 <decodeARMMMUInvocation+0x4c4>
    0xe0014f40     0x14c    cmn r4, #536870913 
    0xe0014f44     0x150    cmpls r6, #-536870912 
    0xe0014f48     0x154    movhi r9, #1
    0xe0014f4c     0x158    movls r9, #0
    0xe0014f50     0x15c    bhi e0015298 <decodeARMMMUInvocation+0x4a4>
    0xe0014f54     0x160    tst r8, #16
    0xe0014f58     0x164    beq e0015768 <decodeARMMMUInvocation+0x974>
    0xe0014f5c     0x168    ubfx r7, r7, #0, #17
    0xe0014f60     0x16c    add r0, sp, #56 
    0xe0014f64     0x170    bic r8, r8, #16320 
    0xe0014f68     0x174    mov r1, r7
    0xe0014f6c     0x178    bic r8, r8, #63 
    0xe0014f70     0x17c    bl e0010cf8 <findPDForASID>
    0xe0014f74     0x180    ldr r5, [sp, #56]     ; stack access
    0xe0014f78     0x184    cmp r5, #0
    0xe0014f7c     0x188    bne e0015e08 <decodeARMMMUInvocation+0x1014>
    0xe0014f80     0x18c    ldr r3, [sp, #60]     ; stack access
    0xe0014f84     0x190    cmp r8, r3
    0xe0014f88     0x194    bne e0015768 <decodeARMMMUInvocation+0x974>
    0xe0014f8c     0x198    lsr r3, r4, #20
    0xe0014f90     0x19c    ldr r2, [r8, r3, lsl #2]
    0xe0014f94     0x1a0    and r3, r2, #3
    0xe0014f98     0x1a4    cmp r3, #1
    0xe0014f9c     0x1a8    beq e0015b08 <decodeARMMMUInvocation+0xd14>
    0xe0014fa0     0x1ac    cmp r3, #2
    0xe0014fa4     0x1b0    bne e0015aac <decodeARMMMUInvocation+0xcb8>
    0xe0014fa8     0x1b4    ubfx r1, r2, #18, #1
    0xe0014fac     0x1b8    mov r3, #0
    0xe0014fb0     0x1bc    cmp r1, r3
    0xe0014fb4     0x1c0    movt r3, #65520 
    0xe0014fb8     0x1c4    and r2, r2, r3
    0xe0014fbc     0x1c8    movne r1, #16777216 
    0xe0014fc0     0x1cc    movne r3, #-16777216 
    0xe0014fc4     0x1d0    moveq r1, #1048576 
    0xe0014fc8     0x1d4    movne ip, #24
    0xe0014fcc     0x1d8    moveq ip, #20
    0xe0014fd0     0x1dc    sub r6, r6, #1
    0xe0014fd4     0x1e0    and r0, r4, r3
    0xe0014fd8     0x1e4    and r3, r3, r6
    0xe0014fdc     0x1e8    cmp r0, r3
    0xe0014fe0     0x1ec    beq e0015db8 <decodeARMMMUInvocation+0xfc4>
    0xe0014fe4     0x1f0    movw r2, #36896 
    0xe0014fe8     0x1f4    movt r2, #57346 
    0xe0014fec     0x1f8    sub r3, r1, #1
    0xe0014ff0     0x1fc    mov r5, #3
    0xe0014ff4     0x200    mov r1, #4
    0xe0014ff8     0x204    add r3, r3, r0
    0xe0014ffc     0x208    str r4, [r2, #8]
    0xe0015000     0x20c    str r3, [r2, #12]
    0xe0015004     0x210    str r1, [r2, #24]
    0xe0015008     0x214    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe001500c     0x218    cmp r0, #35 
    0xe0015010     0x21c    beq e0015248 <decodeARMMMUInvocation+0x454>
    0xe0015014     0x220    cmp r0, #34 
    0xe0015018     0x224    bne e0015298 <decodeARMMMUInvocation+0x4a4>
    0xe001501c     0x228    cmp r6, #0
    0xe0015020     0x22c    cmpne r1, #1
    0xe0015024     0x230    bls e00152d4 <decodeARMMMUInvocation+0x4e0>
    0xe0015028     0x234    tst r7, #536870912 
    0xe001502c     0x238    bne e0015768 <decodeARMMMUInvocation+0x974>
    0xe0015030     0x23c    ldr r4, [r6]
    0xe0015034     0x240    and r3, r4, #14
    0xe0015038     0x244    cmp r3, #14
    0xe001503c     0x248    andne r3, r4, #15
    0xe0015040     0x24c    uxtbeq r3, r4
    0xe0015044     0x250    cmp r3, #9
    0xe0015048     0x254    bne e0014ee4 <decodeARMMMUInvocation+0xf0>
    0xe001504c     0x258    tst r4, #16
    0xe0015050     0x25c    beq e0014ee4 <decodeARMMMUInvocation+0xf0>
    0xe0015054     0x260    movw fp, #13900 
    0xe0015058     0x264    movt fp, #57347 
    0xe001505c     0x268    ldr r6, [r6, #4]
    0xe0015060     0x26c    bic r4, r4, #16320 
    0xe0015064     0x270    ldr r3, [fp]
    0xe0015068     0x274    bic r4, r4, #63 
    0xe001506c     0x278    ubfx r6, r6, #0, #17
    0xe0015070     0x27c    ldr r9, [r3, #8]
    0xe0015074     0x280    cmn r9, #536870913 
    0xe0015078     0x284    bhi e001540c <decodeARMMMUInvocation+0x618>
    0xe001507c     0x288    ldr r3, [r3, #12]
    0xe0015080     0x28c    mov r1, r6
    0xe0015084     0x290    add r0, sp, #56 
    0xe0015088     0x294    str r3, [sp, #8]      ; stack access
    0xe001508c     0x298    bl e0010cf8 <findPDForASID>
    0xe0015090     0x29c    ldr r5, [sp, #56]     ; stack access
    0xe0015094     0x2a0    cmp r5, #0
    0xe0015098     0x2a4    bne e0015a5c <decodeARMMMUInvocation+0xc68>
    0xe001509c     0x2a8    ldr r3, [sp, #60]     ; stack access
    0xe00150a0     0x2ac    cmp r4, r3
    0xe00150a4     0x2b0    bne e0015a90 <decodeARMMMUInvocation+0xc9c>
    0xe00150a8     0x2b4    lsr r9, r9, #20
    0xe00150ac     0x2b8    ldr r1, [r4, r9, lsl #2]
    0xe00150b0     0x2bc    add r3, r4, r9, lsl #2
    0xe00150b4     0x2c0    tst r1, #3
    0xe00150b8     0x2c4    bne e0015640 <decodeARMMMUInvocation+0x84c>
    0xe00150bc     0x2c8    ldr r0, [fp]
    0xe00150c0     0x2cc    movw r2, #4095 
    0xe00150c4     0x2d0    movt r2, #49152 
    0xe00150c8     0x2d4    str r3, [sp, #12]     ; stack access
    0xe00150cc     0x2d8    and r2, r2, r7
    0xe00150d0     0x2dc    ldr r3, [sp, #8]      ; stack access
    0xe00150d4     0x2e0    ldr ip, [r0, #80] 
    0xe00150d8     0x2e4    bic r1, r8, #1020 
    0xe00150dc     0x2e8    orr r2, r2, #536870912 
    0xe00150e0     0x2ec    bic r1, r1, #3
    0xe00150e4     0x2f0    orr r2, r2, r6, lsl #12
    0xe00150e8     0x2f4    lsl fp, r3, #8
    0xe00150ec     0x2f8    add r6, r1, #805306368 
    0xe00150f0     0x2fc    bic ip, ip, #15
    0xe00150f4     0x300    bic r2, r2, #4080 
    0xe00150f8     0x304    orr ip, ip, #2
    0xe00150fc     0x308    bic r2, r2, #15
    0xe0015100     0x30c    and fp, fp, #512 
    0xe0015104     0x310    str ip, [r0, #80] 
    0xe0015108     0x314    orr r6, r6, #1
    0xe001510c     0x318    orr r7, r2, r9
    0xe0015110     0x31c    orr r6, r6, fp
    0xe0015114     0x320    bl e0013114 <setThreadState.part.166>
    0xe0015118     0x324    str r7, [sl, #4]
    0xe001511c     0x328    str r8, [sl]
    0xe0015120     0x32c    ldr r3, [sp, #12]     ; stack access
    0xe0015124     0x330    str r6, [r4, r9, lsl #2]
    0xe0015128     0x334    mcr 15, 0, r3, cr7, cr11, {1}
    0xe001512c     0x338    dmb sy
    0xe0015130     0x33c    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015134     0x340    cmp r0, #44 
    0xe0015138     0x344    bne e0015298 <decodeARMMMUInvocation+0x4a4>
    0xe001513c     0x348    cmp r6, #0
    0xe0015140     0x34c    beq e00152d4 <decodeARMMMUInvocation+0x4e0>
    0xe0015144     0x350    ldr r3, [r6]
    0xe0015148     0x354    and r2, r3, #14
    0xe001514c     0x358    cmp r2, #14
    0xe0015150     0x35c    andne r2, r3, #15
    0xe0015154     0x360    uxtbeq r2, r3
    0xe0015158     0x364    cmp r2, #9
    0xe001515c     0x368    bne e0014ee4 <decodeARMMMUInvocation+0xf0>
    0xe0015160     0x36c    tst r3, #16
    0xe0015164     0x370    bne e0014ee4 <decodeARMMMUInvocation+0xf0>
    0xe0015168     0x374    ubfx r7, r7, #0, #17
    0xe001516c     0x378    movw r3, #37576 
    0xe0015170     0x37c    movt r3, #57346 
    0xe0015174     0x380    lsr r2, r7, #10
    0xe0015178     0x384    ldr r4, [r3, r2, lsl #2]
    0xe001517c     0x388    cmp r4, #0
    0xe0015180     0x38c    beq e0015a08 <decodeARMMMUInvocation+0xc14>
    0xe0015184     0x390    bic r8, r8, #15
    0xe0015188     0x394    cmp r4, r8
    0xe001518c     0x398    bne e0015768 <decodeARMMMUInvocation+0x974>
    0xe0015190     0x39c    add r2, r7, #1024 
    0xe0015194     0x3a0    sub r3, r4, r7, lsl #2
    0xe0015198     0x3a4    b e00151a8 <decodeARMMMUInvocation+0x3b4>
    0xe001519c     0x3a8    add r7, r7, #1
    0xe00151a0     0x3ac    cmp r2, r7
    0xe00151a4     0x3b0    beq e0015640 <decodeARMMMUInvocation+0x84c>
    0xe00151a8     0x3b4    cmp r7, #0
    0xe00151ac     0x3b8    beq e001519c <decodeARMMMUInvocation+0x3a8>
    0xe00151b0     0x3bc    ldr r5, [r3, r7, lsl #2]
    0xe00151b4     0x3c0    cmp r5, #0
    0xe00151b8     0x3c4    bne e001519c <decodeARMMMUInvocation+0x3a8>
    0xe00151bc     0x3c8    movw r3, #13900 
    0xe00151c0     0x3cc    movt r3, #57347 
    0xe00151c4     0x3d0    ldr r2, [r3]
    0xe00151c8     0x3d4    ldr r3, [r2, #80] 
    0xe00151cc     0x3d8    mov r0, r2
    0xe00151d0     0x3dc    bic r3, r3, #15
    0xe00151d4     0x3e0    orr r3, r3, #2
    0xe00151d8     0x3e4    str r3, [r2, #80] 
    0xe00151dc     0x3e8    bl e0013114 <setThreadState.part.166>
    0xe00151e0     0x3ec    ldrd r2, [r6]
    0xe00151e4     0x3f0    ubfx r0, r7, #0, #17
    0xe00151e8     0x3f4    ubfx r7, r7, #0, #10
    0xe00151ec     0x3f8    bic r1, r2, #16320 
    0xe00151f0     0x3fc    orr r2, r2, #16
    0xe00151f4     0x400    lsr r3, r3, #17
    0xe00151f8     0x404    bic r1, r1, #63 
    0xe00151fc     0x408    str r2, [r6]
    0xe0015200     0x40c    lsl r3, r3, #17
    0xe0015204     0x410    orr r3, r3, r0
    0xe0015208     0x414    str r3, [r6, #4]
    0xe001520c     0x418    str r1, [r4, r7, lsl #2]
    0xe0015210     0x41c    mov r0, r5
    0xe0015214     0x420    add sp, sp, #76 
    0xe0015218     0x424    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe001521c     0x428    sub r3, r0, #36 
    0xe0015220     0x42c    cmp r3, #6
    0xe0015224     0x430    ldrls pc, [pc, r3, lsl #2]
    0xe0015228     0x434    b e0015298 <decodeARMMMUInvocation+0x4a4>
    0xe001522c     0x438    .word 0xe0015354
    0xe0015230     0x43c    .word 0xe001542c
    0xe0015234     0x440    .word 0xe00154dc
    0xe0015238     0x444    .word 0xe00154dc
    0xe001523c     0x448    .word 0xe00154dc
    0xe0015240     0x44c    .word 0xe00154dc
    0xe0015244     0x450    .word 0xe00152f4
    0xe0015248     0x454    mov r0, sl
    0xe001524c     0x458    bl e0014d44 <isFinalCapability>
    0xe0015250     0x45c    cmp r0, #0
    0xe0015254     0x460    beq e0015a78 <decodeARMMMUInvocation+0xc84>
    0xe0015258     0x464    movw r3, #13900 
    0xe001525c     0x468    movt r3, #57347 
    0xe0015260     0x46c    ldr r2, [r3]
    0xe0015264     0x470    ldr r3, [r2, #80] 
    0xe0015268     0x474    mov r0, r2
    0xe001526c     0x478    bic r3, r3, #15
    0xe0015270     0x47c    orr r3, r3, #2
    0xe0015274     0x480    str r3, [r2, #80] 
    0xe0015278     0x484    bl e0013114 <setThreadState.part.166>
    0xe001527c     0x488    tst r7, #536870912 
    0xe0015280     0x48c    bne e00155c4 <decodeARMMMUInvocation+0x7d0>
    0xe0015284     0x490    ldr r3, [sl, #4]
    0xe0015288     0x494    mov r5, #0
    0xe001528c     0x498    bic r3, r3, #536870912 
    0xe0015290     0x49c    str r3, [sl, #4]
    0xe0015294     0x4a0    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015298     0x4a4    mov r2, #3
    0xe001529c     0x4a8    movw r3, #36896 
    0xe00152a0     0x4ac    movt r3, #57346 
    0xe00152a4     0x4b0    mov r5, r2
    0xe00152a8     0x4b4    mov r0, r5
    0xe00152ac     0x4b8    str r2, [r3, #24]
    0xe00152b0     0x4bc    add sp, sp, #76 
    0xe00152b4     0x4c0    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe00152b8     0x4c4    movw r3, #36896 
    0xe00152bc     0x4c8    movt r3, #57346 
    0xe00152c0     0x4cc    mov r2, #1
    0xe00152c4     0x4d0    mov r5, #3
    0xe00152c8     0x4d4    str r2, [r3, #24]
    0xe00152cc     0x4d8    str r2, [r3]
    0xe00152d0     0x4dc    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe00152d4     0x4e0    movw r3, #36896 
    0xe00152d8     0x4e4    movt r3, #57346 
    0xe00152dc     0x4e8    mov r5, #3
    0xe00152e0     0x4ec    mov r2, #7
    0xe00152e4     0x4f0    mov r0, r5
    0xe00152e8     0x4f4    str r2, [r3, #24]
    0xe00152ec     0x4f8    add sp, sp, #76 
    0xe00152f0     0x4fc    pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}  ; stack access
    0xe00152f4     0x500    movw r3, #13900 
    0xe00152f8     0x504    movt r3, #57347 
    0xe00152fc     0x508    str r3, [sp, #8]      ; stack access
    0xe0015300     0x50c    ldr r2, [r3]
    0xe0015304     0x510    ldr r3, [r2, #80] 
    0xe0015308     0x514    mov r0, r2
    0xe001530c     0x518    bic r3, r3, #15
    0xe0015310     0x51c    orr r3, r3, #2
    0xe0015314     0x520    str r3, [r2, #80] 
    0xe0015318     0x524    bl e0013114 <setThreadState.part.166>
    0xe001531c     0x528    cmp r9, #1
    0xe0015320     0x52c    beq e00159f4 <decodeARMMMUInvocation+0xc00>
    0xe0015324     0x530    cmp r9, #3
    0xe0015328     0x534    bne e00159ec <decodeARMMMUInvocation+0xbf8>
    0xe001532c     0x538    mov r3, #49152 
    0xe0015330     0x53c    movt r3, #65535 
    0xe0015334     0x540    and r3, r3, r8, lsl #10
    0xe0015338     0x544    add r3, r3, #805306368 
    0xe001533c     0x548    ldr r2, [sp, #8]      ; stack access
    0xe0015340     0x54c    mov r1, #1
    0xe0015344     0x550    mov r5, #0
    0xe0015348     0x554    ldr r2, [r2]
    0xe001534c     0x558    stmib r2, {r1, r3}
    0xe0015350     0x55c    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015354     0x560    cmp r6, #0
    0xe0015358     0x564    cmpne r1, #2
    0xe001535c     0x568    movls r4, #1
    0xe0015360     0x56c    movhi r4, #0
    0xe0015364     0x570    bls e00152d4 <decodeARMMMUInvocation+0x4e0>
    0xe0015368     0x574    cmp r9, #3
    0xe001536c     0x578    ldr fp, [r6]
    0xe0015370     0x57c    lsreq r4, r7, #30
    0xe0015374     0x580    ubfxeq r3, r7, #18, #2
    0xe0015378     0x584    beq e0015388 <decodeARMMMUInvocation+0x594>
    0xe001537c     0x588    cmp r9, #1
    0xe0015380     0x58c    ubfxeq r3, r7, #20, #2
    0xe0015384     0x590    movne r3, r4
    0xe0015388     0x594    and r2, fp, #14
    0xe001538c     0x598    cmp r2, #14
    0xe0015390     0x59c    andne r2, fp, #15
    0xe0015394     0x5a0    uxtbeq r2, fp
    0xe0015398     0x5a4    cmp r2, #9
    0xe001539c     0x5a8    bne e0014ee4 <decodeARMMMUInvocation+0xf0>
    0xe00153a0     0x5ac    tst fp, #16
    0xe00153a4     0x5b0    beq e0014ee4 <decodeARMMMUInvocation+0xf0>
    0xe00153a8     0x5b4    ldr r2, [r6, #4]
    0xe00153ac     0x5b8    cmp r9, #1
    0xe00153b0     0x5bc    ubfxne r1, r7, #20, #10
    0xe00153b4     0x5c0    lsreq r1, r8, #14
    0xe00153b8     0x5c4    ubfx r6, r2, #0, #17
    0xe00153bc     0x5c8    andeq r1, r1, #130048 
    0xe00153c0     0x5cc    str r2, [sp, #12]     ; stack access
    0xe00153c4     0x5d0    lsrne r2, r8, #12
    0xe00153c8     0x5d4    andne r2, r2, #130048 
    0xe00153cc     0x5d8    addeq r1, r1, r7, lsr #22
    0xe00153d0     0x5dc    orrne r1, r2, r1
    0xe00153d4     0x5e0    movw r2, #13900 
    0xe00153d8     0x5e4    movt r2, #57347 
    0xe00153dc     0x5e8    cmp r1, #0
    0xe00153e0     0x5ec    str r2, [sp, #8]      ; stack access
    0xe00153e4     0x5f0    ldr ip, [r2]
    0xe00153e8     0x5f4    ldr r2, [ip, #8]
    0xe00153ec     0x5f8    beq e0015788 <decodeARMMMUInvocation+0x994>
    0xe00153f0     0x5fc    cmp r6, r1
    0xe00153f4     0x600    bne e0014ee4 <decodeARMMMUInvocation+0xf0>
    0xe00153f8     0x604    cmp r9, #1
    0xe00153fc     0x608    lsleq r1, r7, #12
    0xe0015400     0x60c    lslne r1, r7, #14
    0xe0015404     0x610    cmp r2, r1
    0xe0015408     0x614    beq e00157bc <decodeARMMMUInvocation+0x9c8>
    0xe001540c     0x618    movw r3, #36896 
    0xe0015410     0x61c    movt r3, #57346 
    0xe0015414     0x620    mov r1, #1
    0xe0015418     0x624    mov r2, #0
    0xe001541c     0x628    str r1, [r3, #24]
    0xe0015420     0x62c    mov r5, #3
    0xe0015424     0x630    str r2, [r3]
    0xe0015428     0x634    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe001542c     0x638    movw r3, #13900 
    0xe0015430     0x63c    movt r3, #57347 
    0xe0015434     0x640    ldr r2, [r3]
    0xe0015438     0x644    ldr r3, [r2, #80] 
    0xe001543c     0x648    mov r0, r2
    0xe0015440     0x64c    bic r3, r3, #15
    0xe0015444     0x650    orr r3, r3, #2
    0xe0015448     0x654    str r3, [r2, #80] 
    0xe001544c     0x658    bl e0013114 <setThreadState.part.166>
    0xe0015450     0x65c    cmp r9, #1
    0xe0015454     0x660    beq e0015a34 <decodeARMMMUInvocation+0xc40>
    0xe0015458     0x664    lsr r3, r8, #12
    0xe001545c     0x668    ubfx r1, r7, #20, #10
    0xe0015460     0x66c    mov r2, r3
    0xe0015464     0x670    and r3, r3, #130048 
    0xe0015468     0x674    orrs r1, r3, r1
    0xe001546c     0x678    beq e0015498 <decodeARMMMUInvocation+0x6a4>
    0xe0015470     0x67c    cmp r9, #3
    0xe0015474     0x680    lsreq r0, r7, #30
    0xe0015478     0x684    lsleq r2, r7, #14
    0xe001547c     0x688    moveq r3, #49152 
    0xe0015480     0x68c    movteq r3, #65535 
    0xe0015484     0x690    movne r3, #0
    0xe0015488     0x694    andeq r3, r3, r8, lsl #10
    0xe001548c     0x698    lslne r2, r7, #14
    0xe0015490     0x69c    movne r0, r3
    0xe0015494     0x6a0    bl e0011530 <unmapPage>
    0xe0015498     0x6a4    ldr r3, [sl]
    0xe001549c     0x6a8    mov r5, #0
    0xe00154a0     0x6ac    ldr r2, [sl, #4]
    0xe00154a4     0x6b0    and r1, r3, #14
    0xe00154a8     0x6b4    cmp r1, #14
    0xe00154ac     0x6b8    andne r1, r3, #15
    0xe00154b0     0x6bc    uxtbeq r1, r3
    0xe00154b4     0x6c0    cmp r1, #1
    0xe00154b8     0x6c4    biceq r3, r3, #2130706432 
    0xe00154bc     0x6c8    andeq r2, r2, #3145728 
    0xe00154c0     0x6cc    movne r1, #0
    0xe00154c4     0x6d0    movtne r1, #49164 
    0xe00154c8     0x6d4    bicne r3, r3, #532676608 
    0xe00154cc     0x6d8    andne r2, r2, r1
    0xe00154d0     0x6dc    str r3, [sl]
    0xe00154d4     0x6e0    str r2, [sl, #4]
    0xe00154d8     0x6e4    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe00154dc     0x6e8    cmp r1, #1
    0xe00154e0     0x6ec    bls e00152d4 <decodeARMMMUInvocation+0x4e0>
    0xe00154e4     0x6f0    cmp r9, #1
    0xe00154e8     0x6f4    lsreq r4, r8, #14
    0xe00154ec     0x6f8    lsrne r3, r8, #12
    0xe00154f0     0x6fc    andeq r4, r4, #130048 
    0xe00154f4     0x700    ubfxne r4, r7, #20, #10
    0xe00154f8     0x704    andne r3, r3, #130048 
    0xe00154fc     0x708    addeq r4, r4, r7, lsr #22
    0xe0015500     0x70c    orrne r4, r3, r4
    0xe0015504     0x710    lsleq r5, r7, #12
    0xe0015508     0x714    lslne r5, r7, #14
    0xe001550c     0x718    cmp r4, #0
    0xe0015510     0x71c    beq e0015298 <decodeARMMMUInvocation+0x4a4>
    0xe0015514     0x720    mov r1, r4
    0xe0015518     0x724    add r0, sp, #56 
    0xe001551c     0x728    bl e0010cf8 <findPDForASID>
    0xe0015520     0x72c    ldr r2, [sp, #56]     ; stack access
    0xe0015524     0x730    cmp r2, #0
    0xe0015528     0x734    bne e0015d98 <decodeARMMMUInvocation+0xfa4>
    0xe001552c     0x738    movw r3, #13900 
    0xe0015530     0x73c    movt r3, #57347 
    0xe0015534     0x740    ldr r3, [r3]
    0xe0015538     0x744    ldr r1, [r3, #8]
    0xe001553c     0x748    ldr r6, [r3, #12]
    0xe0015540     0x74c    cmp r1, r6
    0xe0015544     0x750    bcs e00152b8 <decodeARMMMUInvocation+0x4c4>
    0xe0015548     0x754    cmp r9, #3
    0xe001554c     0x758    beq e0015ad0 <decodeARMMMUInvocation+0xcdc>
    0xe0015550     0x75c    cmp r9, #1
    0xe0015554     0x760    beq e0015cc4 <decodeARMMMUInvocation+0xed0>
    0xe0015558     0x764    cmp r9, #3
    0xe001555c     0x768    movne r8, r2
    0xe0015560     0x76c    movne r0, #4096 
    0xe0015564     0x770    beq e0015af4 <decodeARMMMUInvocation+0xd00>
    0xe0015568     0x774    cmp r6, r0
    0xe001556c     0x778    cmpls r1, r0
    0xe0015570     0x77c    bcs e001540c <decodeARMMMUInvocation+0x618>
    0xe0015574     0x780    ldr r2, [r3, #80] 
    0xe0015578     0x784    add ip, r1, #805306368 
    0xe001557c     0x788    mov r0, r3
    0xe0015580     0x78c    add r7, r1, r5
    0xe0015584     0x790    bic r2, r2, #15
    0xe0015588     0x794    add r8, ip, r8
    0xe001558c     0x798    orr r2, r2, #2
    0xe0015590     0x79c    str r2, [r3, #80] 
    0xe0015594     0x7a0    bl e0013114 <setThreadState.part.166>
    0xe0015598     0x7a4    sub r6, r6, #1
    0xe001559c     0x7a8    add r5, r6, r5
    0xe00155a0     0x7ac    ldr r1, [sp, #60]     ; stack access
    0xe00155a4     0x7b0    str r8, [sp, #116]    ; stack access
    0xe00155a8     0x7b4    mov r3, r7
    0xe00155ac     0x7b8    str r5, [sp, #112]    ; stack access
    0xe00155b0     0x7bc    mov r2, r4
    0xe00155b4     0x7c0    mov r0, fp
    0xe00155b8     0x7c4    add sp, sp, #76 
    0xe00155bc     0x7c8    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe00155c0     0x7cc    b e00127e0 <performPDFlush>
    0xe00155c4     0x7d0    bic r8, r8, #1020 
    0xe00155c8     0x7d4    lsl r1, r7, #20
    0xe00155cc     0x7d8    bic r8, r8, #3
    0xe00155d0     0x7dc    ubfx r0, r7, #12, #17
    0xe00155d4     0x7e0    mov r2, r8
    0xe00155d8     0x7e4    mov r4, r8
    0xe00155dc     0x7e8    bl e00117a4 <unmapPageTable>
    0xe00155e0     0x7ec    add r2, r8, #1024 
    0xe00155e4     0x7f0    mov r3, #0
    0xe00155e8     0x7f4    str r3, [r4], #4
    0xe00155ec     0x7f8    cmp r4, r2
    0xe00155f0     0x7fc    bne e00155e8 <decodeARMMMUInvocation+0x7f4>
    0xe00155f4     0x800    add r3, r8, #1020 
    0xe00155f8     0x804    lsr r8, r8, #5
    0xe00155fc     0x808    add r3, r3, #3
    0xe0015600     0x80c    lsr r2, r3, #5
    0xe0015604     0x810    add r2, r2, #1
    0xe0015608     0x814    cmp r8, r2
    0xe001560c     0x818    bcs e0015284 <decodeARMMMUInvocation+0x490>
    0xe0015610     0x81c    lsl r3, r8, #5
    0xe0015614     0x820    lsl r2, r2, #5
    0xe0015618     0x824    mcr 15, 0, r3, cr7, cr11, {1}
    0xe001561c     0x828    dmb sy
    0xe0015620     0x82c    add r3, r3, #32
    0xe0015624     0x830    cmp r2, r3
    0xe0015628     0x834    bne e0015618 <decodeARMMMUInvocation+0x824>
    0xe001562c     0x838    b e0015284 <decodeARMMMUInvocation+0x490>
    0xe0015630     0x83c    cmp r3, #2
    0xe0015634     0x840    bne e0015640 <decodeARMMMUInvocation+0x84c>
    0xe0015638     0x844    tst r6, #262144 
    0xe001563c     0x848    beq e00158e8 <decodeARMMMUInvocation+0xaf4>
    0xe0015640     0x84c    movw r3, #36896 
    0xe0015644     0x850    movt r3, #57346 
    0xe0015648     0x854    mov r2, #8
    0xe001564c     0x858    mov r5, #3
    0xe0015650     0x85c    str r2, [r3, #24]
    0xe0015654     0x860    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015658     0x864    bl e0010a3c <halt>
    0xe001565c     0x868    movw r3, #13900 
    0xe0015660     0x86c    movt r3, #57347 
    0xe0015664     0x870    str r3, [sp, #8]      ; stack access
    0xe0015668     0x874    mov r0, r6
    0xe001566c     0x878    ldr r3, [r3]
    0xe0015670     0x87c    ldr fp, [ip]
    0xe0015674     0x880    ldr sl, [ip, #4]
    0xe0015678     0x884    ldr r2, [r3, #8]
    0xe001567c     0x888    ldr r9, [r3, #12]
    0xe0015680     0x88c    str r2, [sp, #12]     ; stack access
    0xe0015684     0x890    bl e0014bbc <ensureNoChildren>
    0xe0015688     0x894    subs r5, r0, #0
    0xe001568c     0x898    bne e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015690     0x89c    ldr r2, [sp, #12]     ; stack access
    0xe0015694     0x8a0    add r3, sp, #32
    0xe0015698     0x8a4    str fp, [sp, #32]     ; stack access
    0xe001569c     0x8a8    mov r1, r5
    0xe00156a0     0x8ac    str sl, [sp, #36]     ; stack access
    0xe00156a4     0x8b0    add r0, sp, #40 
    0xe00156a8     0x8b4    str r9, [sp, #4]      ; stack access
    0xe00156ac     0x8b8    bic r8, r8, #15
    0xe00156b0     0x8bc    str r2, [sp]          ; stack access
    0xe00156b4     0x8c0    ldm r3, {r2, r3}      ; stack access
    0xe00156b8     0x8c4    bl e0012e24 <lookupSlotForCNodeOp>
    0xe00156bc     0x8c8    ldr r5, [sp, #40]     ; stack access
    0xe00156c0     0x8cc    cmp r5, #0
    0xe00156c4     0x8d0    bne e0015210 <decodeARMMMUInvocation+0x41c>
    0xe00156c8     0x8d4    ldr sl, [sp, #44]     ; stack access
    0xe00156cc     0x8d8    ldr r1, [sl]
    0xe00156d0     0x8dc    and r3, r1, #14
    0xe00156d4     0x8e0    cmp r3, #14
    0xe00156d8     0x8e4    andne r9, r1, #15
    0xe00156dc     0x8e8    uxtbeq r9, r1
    0xe00156e0     0x8ec    cmp r9, #0
    0xe00156e4     0x8f0    bne e0015640 <decodeARMMMUInvocation+0x84c>
    0xe00156e8     0x8f4    ldr r3, [sp, #8]      ; stack access
    0xe00156ec     0x8f8    ldr r2, [r3]
    0xe00156f0     0x8fc    ldr r3, [r2, #80] 
    0xe00156f4     0x900    mov r0, r2
    0xe00156f8     0x904    bic r3, r3, #15
    0xe00156fc     0x908    orr r3, r3, #2
    0xe0015700     0x90c    str r3, [r2, #80] 
    0xe0015704     0x910    bl e0013114 <setThreadState.part.166>
    0xe0015708     0x914    ldr r3, [r6, #4]
    0xe001570c     0x918    mov ip, #64 
    0xe0015710     0x91c    add r0, r8, #4096 
    0xe0015714     0x920    and r2, r3, #31
    0xe0015718     0x924    and r3, r3, #63 
    0xe001571c     0x928    sub r2, r2, #4
    0xe0015720     0x92c    mov r1, r9
    0xe0015724     0x930    orr r3, r3, ip, lsl r2
    0xe0015728     0x934    mov r2, r8
    0xe001572c     0x938    str r3, [r6, #4]
    0xe0015730     0x93c    str r1, [r2], #4
    0xe0015734     0x940    cmp r0, r2
    0xe0015738     0x944    bne e0015730 <decodeARMMMUInvocation+0x93c>
    0xe001573c     0x948    add r1, sp, #56 
    0xe0015740     0x94c    orr r0, r8, #5
    0xe0015744     0x950    mov r3, sl
    0xe0015748     0x954    str r0, [sp, #56]     ; stack access
    0xe001574c     0x958    mov r2, r6
    0xe0015750     0x95c    lsl r0, r4, #10
    0xe0015754     0x960    str r0, [sp, #60]     ; stack access
    0xe0015758     0x964    ldm r1, {r0, r1}      ; stack access
    0xe001575c     0x968    bl e0013308 <cteInsert>
    0xe0015760     0x96c    str r8, [r7, r4, lsl #2]
    0xe0015764     0x970    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015768     0x974    movw r3, #36896 
    0xe001576c     0x978    movt r3, #57346 
    0xe0015770     0x97c    mov r1, #2
    0xe0015774     0x980    mov r2, #0
    0xe0015778     0x984    str r1, [r3, #24]
    0xe001577c     0x988    mov r5, #3
    0xe0015780     0x98c    str r2, [r3, #4]
    0xe0015784     0x990    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015788     0x994    cmp r4, #2
    0xe001578c     0x998    moveq r0, #1048576 
    0xe0015790     0x99c    beq e00157ac <decodeARMMMUInvocation+0x9b8>
    0xe0015794     0x9a0    cmp r4, #3
    0xe0015798     0x9a4    moveq r0, #16777216 
    0xe001579c     0x9a8    beq e00157ac <decodeARMMMUInvocation+0x9b8>
    0xe00157a0     0x9ac    cmp r4, #1
    0xe00157a4     0x9b0    moveq r0, #65536 
    0xe00157a8     0x9b4    movne r0, #4096 
    0xe00157ac     0x9b8    sub r1, r2, #1
    0xe00157b0     0x9bc    add r1, r1, r0
    0xe00157b4     0x9c0    cmn r1, #536870913 
    0xe00157b8     0x9c4    bhi e001540c <decodeARMMMUInvocation+0x618>
    0xe00157bc     0x9c8    strd r2, [sp, #20]    ; stack access
    0xe00157c0     0x9cc    mov r1, r6
    0xe00157c4     0x9d0    ldr r3, [ip, #12]
    0xe00157c8     0x9d4    add r0, sp, #56 
    0xe00157cc     0x9d8    str r3, [sp, #28]     ; stack access
    0xe00157d0     0x9dc    ldr r3, [ip, #16]
    0xe00157d4     0x9e0    str r3, [sp, #16]     ; stack access
    0xe00157d8     0x9e4    bl e0010cf8 <findPDForASID>
    0xe00157dc     0x9e8    ldr r5, [sp, #56]     ; stack access
    0xe00157e0     0x9ec    ldrd r2, [sp, #20]    ; stack access
    0xe00157e4     0x9f0    cmp r5, #0
    0xe00157e8     0x9f4    bne e0015a5c <decodeARMMMUInvocation+0xc68>
    0xe00157ec     0x9f8    bic fp, fp, #16320 
    0xe00157f0     0x9fc    ldr r1, [sp, #60]     ; stack access
    0xe00157f4     0xa00    bic fp, fp, #63 
    0xe00157f8     0xa04    cmp fp, r1
    0xe00157fc     0xa08    bne e0015a90 <decodeARMMMUInvocation+0xc9c>
    0xe0015800     0xa0c    ldr r1, [sp, #28]     ; stack access
    0xe0015804     0xa10    mov r0, r3
    0xe0015808     0xa14    str r2, [sp, #20]     ; stack access
    0xe001580c     0xa18    bl e0010cb8 <maskVMRights>
    0xe0015810     0xa1c    cmp r4, #2
    0xe0015814     0xa20    ldr r2, [sp, #20]     ; stack access
    0xe0015818     0xa24    beq e0015d5c <decodeARMMMUInvocation+0xf68>
    0xe001581c     0xa28    cmp r4, #3
    0xe0015820     0xa2c    mvneq r3, #-16777216 
    0xe0015824     0xa30    beq e0015838 <decodeARMMMUInvocation+0xa44>
    0xe0015828     0xa34    cmp r4, #1
    0xe001582c     0xa38    movw r1, #4095 
    0xe0015830     0xa3c    movw r3, #65535 
    0xe0015834     0xa40    movne r3, r1
    0xe0015838     0xa44    tst r3, r2
    0xe001583c     0xa48    bne e0015e2c <decodeARMMMUInvocation+0x1038>
    0xe0015840     0xa4c    cmp r9, #1
    0xe0015844     0xa50    beq e0015d20 <decodeARMMMUInvocation+0xf2c>
    0xe0015848     0xa54    cmp r9, #3
    0xe001584c     0xa58    bne e0015d18 <decodeARMMMUInvocation+0xf24>
    0xe0015850     0xa5c    mov r3, #49152 
    0xe0015854     0xa60    movt r3, #65535 
    0xe0015858     0xa64    and r3, r3, r8, lsl #10
    0xe001585c     0xa68    add r9, r3, #805306368 
    0xe0015860     0xa6c    mov r1, #0
    0xe0015864     0xa70    lsr ip, r6, #10
    0xe0015868     0xa74    mov r3, r1
    0xe001586c     0xa78    bic r8, r8, #532676608 
    0xe0015870     0xa7c    movt r1, #16368 
    0xe0015874     0xa80    movt r3, #49164 
    0xe0015878     0xa84    and r1, r1, r6, lsl #20
    0xe001587c     0xa88    and r3, r3, r7
    0xe0015880     0xa8c    orr r8, r8, ip, lsl #22
    0xe0015884     0xa90    orr r3, r3, r1
    0xe0015888     0xa94    orr r3, r3, r2, lsr #14
    0xe001588c     0xa98    str ip, [sp, #24]     ; stack access
    0xe0015890     0xa9c    str r3, [sp, #20]     ; stack access
    0xe0015894     0xaa0    ldr r1, [sp, #16]     ; stack access
    0xe0015898     0xaa4    cmp r4, #1
    0xe001589c     0xaa8    and r3, r1, #1
    0xe00158a0     0xaac    ubfx r1, r1, #2, #1
    0xe00158a4     0xab0    bls e0015b40 <decodeARMMMUInvocation+0xd4c>
    0xe00158a8     0xab4    lsr ip, r2, #20
    0xe00158ac     0xab8    cmp r4, #3
    0xe00158b0     0xabc    ldr r2, [sp, #16]     ; stack access
    0xe00158b4     0xac0    ldr r6, [fp, ip, lsl #2]
    0xe00158b8     0xac4    add r7, fp, ip, lsl #2
    0xe00158bc     0xac8    str r1, [sp]          ; stack access
    0xe00158c0     0xacc    ubfx r2, r2, #1, #1
    0xe00158c4     0xad0    str r0, [sp, #4]      ; stack access
    0xe00158c8     0xad4    mov r1, r9
    0xe00158cc     0xad8    beq e0015cd8 <decodeARMMMUInvocation+0xee4>
    0xe00158d0     0xadc    mov r0, #2
    0xe00158d4     0xae0    bl e0010c4c <makeUserPDE.constprop.186>
    0xe00158d8     0xae4    and r3, r6, #3
    0xe00158dc     0xae8    cmp r3, #0
    0xe00158e0     0xaec    str r0, [sp, #60]     ; stack access
    0xe00158e4     0xaf0    bne e0015630 <decodeARMMMUInvocation+0x83c>
    0xe00158e8     0xaf4    mov r2, #0
    0xe00158ec     0xaf8    mov r3, #1
    0xe00158f0     0xafc    str r7, [sp, #64]     ; stack access
    0xe00158f4     0xb00    str r3, [sp, #68]     ; stack access
    0xe00158f8     0xb04    add r3, sp, #56 
    0xe00158fc     0xb08    str r2, [sp, #56]     ; stack access
    0xe0015900     0xb0c    add ip, sp, #40 
    0xe0015904     0xb10    ldm r3, {r0, r1, r2, r3}  ; stack access
    0xe0015908     0xb14    stm ip, {r0, r1, r2, r3}  ; stack access
    0xe001590c     0xb18    ldr r3, [sp, #8]      ; stack access
    0xe0015910     0xb1c    ldr r2, [r3]
    0xe0015914     0xb20    ldr r3, [r2, #80] 
    0xe0015918     0xb24    mov r0, r2
    0xe001591c     0xb28    bic r3, r3, #15
    0xe0015920     0xb2c    orr r3, r3, #2
    0xe0015924     0xb30    str r3, [r2, #80] 
    0xe0015928     0xb34    bl e0013114 <setThreadState.part.166>
    0xe001592c     0xb38    ldr r3, [sp, #48]     ; stack access
    0xe0015930     0xb3c    ldr r2, [sp, #52]     ; stack access
    0xe0015934     0xb40    ldr r1, [sp, #20]     ; stack access
    0xe0015938     0xb44    ldr r0, [r3]
    0xe001593c     0xb48    cmp r2, #0
    0xe0015940     0xb4c    str r8, [sl]
    0xe0015944     0xb50    addne lr, r3, r2, lsl #2
    0xe0015948     0xb54    str r1, [sl, #4]
    0xe001594c     0xb58    and r0, r0, #3
    0xe0015950     0xb5c    ldr ip, [sp, #44]     ; stack access
    0xe0015954     0xb60    movne r1, r3
    0xe0015958     0xb64    beq e0015968 <decodeARMMMUInvocation+0xb74>
    0xe001595c     0xb68    str ip, [r1], #4
    0xe0015960     0xb6c    cmp lr, r1
    0xe0015964     0xb70    bne e001595c <decodeARMMMUInvocation+0xb68>
    0xe0015968     0xb74    add r2, r3, r2, lsl #2
    0xe001596c     0xb78    lsr r3, r3, #5
    0xe0015970     0xb7c    sub r2, r2, #1
    0xe0015974     0xb80    lsr r2, r2, #5
    0xe0015978     0xb84    add r2, r2, #1
    0xe001597c     0xb88    cmp r3, r2
    0xe0015980     0xb8c    bcs e00159a0 <decodeARMMMUInvocation+0xbac>
    0xe0015984     0xb90    lsl r3, r3, #5
    0xe0015988     0xb94    lsl r2, r2, #5
    0xe001598c     0xb98    mcr 15, 0, r3, cr7, cr11, {1}
    0xe0015990     0xb9c    dmb sy
    0xe0015994     0xba0    add r3, r3, #32
    0xe0015998     0xba4    cmp r2, r3
    0xe001599c     0xba8    bne e001598c <decodeARMMMUInvocation+0xb98>
    0xe00159a0     0xbac    cmp r0, #0
    0xe00159a4     0xbb0    beq e0015210 <decodeARMMMUInvocation+0x41c>
    0xe00159a8     0xbb4    ldr r1, [sp, #24]     ; stack access
    0xe00159ac     0xbb8    movw r3, #37576 
    0xe00159b0     0xbbc    movt r3, #57346 
    0xe00159b4     0xbc0    ldr r2, [sp, #12]     ; stack access
    0xe00159b8     0xbc4    ldr r3, [r3, r1, lsl #2]
    0xe00159bc     0xbc8    ubfx r2, r2, #0, #10
    0xe00159c0     0xbcc    ldr r3, [r3, r2, lsl #2]
    0xe00159c4     0xbd0    add r3, r3, #12288 
    0xe00159c8     0xbd4    ldr r3, [r3, #4032] 
    0xe00159cc     0xbd8    tst r3, #8388608 
    0xe00159d0     0xbdc    beq e0015210 <decodeARMMMUInvocation+0x41c>
    0xe00159d4     0xbe0    dsb sy
    0xe00159d8     0xbe4    lsr r3, r3, #24
    0xe00159dc     0xbe8    mcr 15, 0, r3, cr8, cr7, {2}
    0xe00159e0     0xbec    dsb sy
    0xe00159e4     0xbf0    isb sy
    0xe00159e8     0xbf4    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe00159ec     0xbf8    mov r3, #805306368 
    0xe00159f0     0xbfc    b e001533c <decodeARMMMUInvocation+0x548>
    0xe00159f4     0xc00    mov r3, #61440 
    0xe00159f8     0xc04    movt r3, #65535 
    0xe00159fc     0xc08    and r3, r3, r8, lsl #8
    0xe0015a00     0xc0c    add r3, r3, #805306368 
    0xe0015a04     0xc10    b e001533c <decodeARMMMUInvocation+0x548>
    0xe0015a08     0xc14    movw r2, #36896 
    0xe0015a0c     0xc18    movw r3, #36884 
    0xe0015a10     0xc1c    movt r2, #57346 
    0xe0015a14     0xc20    movt r3, #57346 
    0xe0015a18     0xc24    mov r1, #6
    0xe0015a1c     0xc28    mov r5, #3
    0xe0015a20     0xc2c    str r4, [r2, #20]
    0xe0015a24     0xc30    str r1, [r2, #24]
    0xe0015a28     0xc34    str r4, [r3]
    0xe0015a2c     0xc38    str r4, [r3, #4]
    0xe0015a30     0xc3c    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015a34     0xc40    lsr r3, r8, #14
    0xe0015a38     0xc44    and r3, r3, #130048 
    0xe0015a3c     0xc48    adds r1, r3, r7, lsr #22
    0xe0015a40     0xc4c    beq e0015498 <decodeARMMMUInvocation+0x6a4>
    0xe0015a44     0xc50    mov r3, #61440 
    0xe0015a48     0xc54    movt r3, #65535 
    0xe0015a4c     0xc58    lsl r2, r7, #12
    0xe0015a50     0xc5c    and r3, r3, r8, lsl #8
    0xe0015a54     0xc60    mov r0, #0
    0xe0015a58     0xc64    b e0015494 <decodeARMMMUInvocation+0x6a0>
    0xe0015a5c     0xc68    movw r3, #36896 
    0xe0015a60     0xc6c    movt r3, #57346 
    0xe0015a64     0xc70    mov r4, #0
    0xe0015a68     0xc74    mov r5, #6
    0xe0015a6c     0xc78    strd r4, [r3, #20]
    0xe0015a70     0xc7c    mov r5, #3
    0xe0015a74     0xc80    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015a78     0xc84    movw r3, #36896 
    0xe0015a7c     0xc88    movt r3, #57346 
    0xe0015a80     0xc8c    mov r2, #9
    0xe0015a84     0xc90    mov r5, #3
    0xe0015a88     0xc94    str r2, [r3, #24]
    0xe0015a8c     0xc98    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015a90     0xc9c    movw r3, #36896 
    0xe0015a94     0xca0    movt r3, #57346 
    0xe0015a98     0xca4    mov r1, #2
    0xe0015a9c     0xca8    mov r2, #1
    0xe0015aa0     0xcac    str r1, [r3, #24]
    0xe0015aa4     0xcb0    str r2, [r3, #4]
    0xe0015aa8     0xcb4    b e0015a70 <decodeARMMMUInvocation+0xc7c>
    0xe0015aac     0xcb8    ldr r3, [sp, #8]      ; stack access
    0xe0015ab0     0xcbc    ldr r2, [r3]
    0xe0015ab4     0xcc0    ldr r3, [r2, #80] 
    0xe0015ab8     0xcc4    mov r0, r2
    0xe0015abc     0xcc8    bic r3, r3, #15
    0xe0015ac0     0xccc    orr r3, r3, #2
    0xe0015ac4     0xcd0    str r3, [r2, #80] 
    0xe0015ac8     0xcd4    bl e0013114 <setThreadState.part.166>
    0xe0015acc     0xcd8    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015ad0     0xcdc    lsr r7, r7, #30
    0xe0015ad4     0xce0    cmp r7, #2
    0xe0015ad8     0xce4    moveq r0, #1048576 
    0xe0015adc     0xce8    beq e0015af8 <decodeARMMMUInvocation+0xd04>
    0xe0015ae0     0xcec    cmp r7, #3
    0xe0015ae4     0xcf0    moveq r0, #16777216 
    0xe0015ae8     0xcf4    beq e0015af8 <decodeARMMMUInvocation+0xd04>
    0xe0015aec     0xcf8    cmp r7, #1
    0xe0015af0     0xcfc    beq e0015e24 <decodeARMMMUInvocation+0x1030>
    0xe0015af4     0xd00    mov r0, #4096 
    0xe0015af8     0xd04    mov r2, #49152 
    0xe0015afc     0xd08    movt r2, #65535 
    0xe0015b00     0xd0c    and r8, r2, r8, lsl #10
    0xe0015b04     0xd10    b e0015568 <decodeARMMMUInvocation+0x774>
    0xe0015b08     0xd14    ubfx r3, r4, #12, #8
    0xe0015b0c     0xd18    bic r2, r2, #1020 
    0xe0015b10     0xd1c    bic r2, r2, #3
    0xe0015b14     0xd20    add r2, r2, r3, lsl #2
    0xe0015b18     0xd24    add r3, r2, #-805306368 
    0xe0015b1c     0xd28    ldr r2, [r3]
    0xe0015b20     0xd2c    tst r2, #2
    0xe0015b24     0xd30    beq e0015d68 <decodeARMMMUInvocation+0xf74>
    0xe0015b28     0xd34    mov r3, #61440 
    0xe0015b2c     0xd38    movt r3, #65535 
    0xe0015b30     0xd3c    and r2, r2, r3
    0xe0015b34     0xd40    mov r1, #4096 
    0xe0015b38     0xd44    mov ip, #12
    0xe0015b3c     0xd48    b e0014fd0 <decodeARMMMUInvocation+0x1dc>
    0xe0015b40     0xd4c    str r2, [sp, #16]     ; stack access
    0xe0015b44     0xd50    bl e0010a48 <APFromVMRights>
    0xe0015b48     0xd54    cmp r4, #1
    0xe0015b4c     0xd58    ldr r2, [sp, #16]     ; stack access
    0xe0015b50     0xd5c    lsl r4, r0, #4
    0xe0015b54     0xd60    and r4, r4, #48 
    0xe0015b58     0xd64    beq e0015c4c <decodeARMMMUInvocation+0xe58>
    0xe0015b5c     0xd68    cmp r3, #0
    0xe0015b60     0xd6c    add r0, sp, #40 
    0xe0015b64     0xd70    orrne r1, r1, #2368 
    0xe0015b68     0xd74    orreq r1, r1, #3072 
    0xe0015b6c     0xd78    orrne r1, r1, #6
    0xe0015b70     0xd7c    orreq r1, r1, #2
    0xe0015b74     0xd80    orr r1, r1, r9
    0xe0015b78     0xd84    orr r4, r1, r4
    0xe0015b7c     0xd88    mov r1, fp
    0xe0015b80     0xd8c    bl e001108c <lookupPTSlot>
    0xe0015b84     0xd90    ldr r7, [sp, #40]     ; stack access
    0xe0015b88     0xd94    ldr r6, [sp, #44]     ; stack access
    0xe0015b8c     0xd98    cmp r7, #0
    0xe0015b90     0xd9c    bne e0015a5c <decodeARMMMUInvocation+0xc68>
    0xe0015b94     0xda0    ldr r3, [r6]
    0xe0015b98     0xda4    tst r3, #2
    0xe0015b9c     0xda8    bne e0015ba8 <decodeARMMMUInvocation+0xdb4>
    0xe0015ba0     0xdac    tst r3, #1
    0xe0015ba4     0xdb0    bne e0015cb0 <decodeARMMMUInvocation+0xebc>
    0xe0015ba8     0xdb4    mov r9, #1
    0xe0015bac     0xdb8    ldr r3, [sp, #8]      ; stack access
    0xe0015bb0     0xdbc    ldr r2, [r3]
    0xe0015bb4     0xdc0    ldr r3, [r2, #80] 
    0xe0015bb8     0xdc4    mov r0, r2
    0xe0015bbc     0xdc8    bic r3, r3, #15
    0xe0015bc0     0xdcc    orr r3, r3, #2
    0xe0015bc4     0xdd0    str r3, [r2, #80] 
    0xe0015bc8     0xdd4    bl e0013114 <setThreadState.part.166>
    0xe0015bcc     0xdd8    ldr r3, [r6]
    0xe0015bd0     0xddc    ldr r2, [sp, #20]     ; stack access
    0xe0015bd4     0xde0    tst r3, #2
    0xe0015bd8     0xde4    str r8, [sl]
    0xe0015bdc     0xde8    str r2, [sl, #4]
    0xe0015be0     0xdec    movne r1, #1
    0xe0015be4     0xdf0    bne e0015bf4 <decodeARMMMUInvocation+0xe00>
    0xe0015be8     0xdf4    tst r3, #1
    0xe0015bec     0xdf8    movne r1, #0
    0xe0015bf0     0xdfc    moveq r1, #2
    0xe0015bf4     0xe00    add r9, r6, r9, lsl #2
    0xe0015bf8     0xe04    mov r3, r6
    0xe0015bfc     0xe08    str r4, [r3], #4
    0xe0015c00     0xe0c    cmp r3, r9
    0xe0015c04     0xe10    bne e0015bfc <decodeARMMMUInvocation+0xe08>
    0xe0015c08     0xe14    add r2, r6, r7
    0xe0015c0c     0xe18    lsr r3, r6, #5
    0xe0015c10     0xe1c    add r2, r2, #3
    0xe0015c14     0xe20    lsr r2, r2, #5
    0xe0015c18     0xe24    add r2, r2, #1
    0xe0015c1c     0xe28    cmp r3, r2
    0xe0015c20     0xe2c    bcs e0015c40 <decodeARMMMUInvocation+0xe4c>
    0xe0015c24     0xe30    lsl r3, r3, #5
    0xe0015c28     0xe34    lsl r2, r2, #5
    0xe0015c2c     0xe38    mcr 15, 0, r3, cr7, cr11, {1}
    0xe0015c30     0xe3c    dmb sy
    0xe0015c34     0xe40    add r3, r3, #32
    0xe0015c38     0xe44    cmp r2, r3
    0xe0015c3c     0xe48    bne e0015c2c <decodeARMMMUInvocation+0xe38>
    0xe0015c40     0xe4c    cmp r1, #2
    0xe0015c44     0xe50    beq e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015c48     0xe54    b e00159a8 <decodeARMMMUInvocation+0xbb4>
    0xe0015c4c     0xe58    cmp r3, #0
    0xe0015c50     0xe5c    lsr r9, r9, #16
    0xe0015c54     0xe60    lsl r3, r1, #15
    0xe0015c58     0xe64    add r0, sp, #40 
    0xe0015c5c     0xe68    orrne r3, r3, #22528 
    0xe0015c60     0xe6c    orreq r3, r3, #3072 
    0xe0015c64     0xe70    orrne r3, r3, #5
    0xe0015c68     0xe74    orreq r3, r3, #1
    0xe0015c6c     0xe78    lsl r9, r9, #16
    0xe0015c70     0xe7c    mov r1, fp
    0xe0015c74     0xe80    orr r9, r3, r9
    0xe0015c78     0xe84    bl e001108c <lookupPTSlot>
    0xe0015c7c     0xe88    ldr r3, [sp, #40]     ; stack access
    0xe0015c80     0xe8c    orr r4, r9, r4
    0xe0015c84     0xe90    ldr r6, [sp, #44]     ; stack access
    0xe0015c88     0xe94    cmp r3, #0
    0xe0015c8c     0xe98    bne e0015a5c <decodeARMMMUInvocation+0xc68>
    0xe0015c90     0xe9c    sub r3, r6, #4
    0xe0015c94     0xea0    add r1, r6, #60 
    0xe0015c98     0xea4    b e0015ca4 <decodeARMMMUInvocation+0xeb0>
    0xe0015c9c     0xea8    cmp r1, r3
    0xe0015ca0     0xeac    beq e0015e44 <decodeARMMMUInvocation+0x1050>
    0xe0015ca4     0xeb0    ldr r2, [r3, #4]!
    0xe0015ca8     0xeb4    tst r2, #2
    0xe0015cac     0xeb8    beq e0015c9c <decodeARMMMUInvocation+0xea8>
    0xe0015cb0     0xebc    movw r3, #36896 
    0xe0015cb4     0xec0    movt r3, #57346 
    0xe0015cb8     0xec4    mov r2, #8
    0xe0015cbc     0xec8    str r2, [r3, #24]
    0xe0015cc0     0xecc    b e0015a70 <decodeARMMMUInvocation+0xc7c>
    0xe0015cc4     0xed0    mov r2, #61440 
    0xe0015cc8     0xed4    movt r2, #65535 
    0xe0015ccc     0xed8    and r8, r2, r8, lsl #8
    0xe0015cd0     0xedc    mov r0, #4096 
    0xe0015cd4     0xee0    b e0015568 <decodeARMMMUInvocation+0x774>
    0xe0015cd8     0xee4    mov r0, r4
    0xe0015cdc     0xee8    bl e0010c4c <makeUserPDE.constprop.186>
    0xe0015ce0     0xeec    add r2, r7, #60 
    0xe0015ce4     0xef0    mov r3, r7
    0xe0015ce8     0xef4    str r0, [sp, #60]     ; stack access
    0xe0015cec     0xef8    b e0015cfc <decodeARMMMUInvocation+0xf08>
    0xe0015cf0     0xefc    cmp r2, r3
    0xe0015cf4     0xf00    beq e0015d88 <decodeARMMMUInvocation+0xf94>
    0xe0015cf8     0xf04    ldr r6, [r3, #4]!
    0xe0015cfc     0xf08    ands r1, r6, #3
    0xe0015d00     0xf0c    beq e0015cf0 <decodeARMMMUInvocation+0xefc>
    0xe0015d04     0xf10    cmp r1, #2
    0xe0015d08     0xf14    bne e0015640 <decodeARMMMUInvocation+0x84c>
    0xe0015d0c     0xf18    tst r6, #262144 
    0xe0015d10     0xf1c    bne e0015cf0 <decodeARMMMUInvocation+0xefc>
    0xe0015d14     0xf20    b e0015640 <decodeARMMMUInvocation+0x84c>
    0xe0015d18     0xf24    mov r9, #805306368 
    0xe0015d1c     0xf28    b e0015860 <decodeARMMMUInvocation+0xa6c>
    0xe0015d20     0xf2c    ubfx r3, r7, #0, #22
    0xe0015d24     0xf30    lsr lr, r6, #10
    0xe0015d28     0xf34    orr r3, r3, r6, lsl #22
    0xe0015d2c     0xf38    mov ip, #61440 
    0xe0015d30     0xf3c    movt ip, #65535 
    0xe0015d34     0xf40    bic r1, r8, #2130706432 
    0xe0015d38     0xf44    lsr r3, r3, #20
    0xe0015d3c     0xf48    and ip, ip, r8, lsl #8
    0xe0015d40     0xf4c    str lr, [sp, #24]     ; stack access
    0xe0015d44     0xf50    add r9, ip, #805306368 
    0xe0015d48     0xf54    lsl r3, r3, #20
    0xe0015d4c     0xf58    orr r8, r1, lr, lsl #24
    0xe0015d50     0xf5c    orr r3, r3, r2, lsr #12
    0xe0015d54     0xf60    str r3, [sp, #20]     ; stack access
    0xe0015d58     0xf64    b e0015894 <decodeARMMMUInvocation+0xaa0>
    0xe0015d5c     0xf68    movw r3, #65535 
    0xe0015d60     0xf6c    movt r3, #15
    0xe0015d64     0xf70    b e0015838 <decodeARMMMUInvocation+0xa44>
    0xe0015d68     0xf74    tst r2, #1
    0xe0015d6c     0xf78    beq e0015aac <decodeARMMMUInvocation+0xcb8>
    0xe0015d70     0xf7c    mov r3, #0
    0xe0015d74     0xf80    movt r3, #65535 
    0xe0015d78     0xf84    and r2, r2, r3
    0xe0015d7c     0xf88    mov r1, #65536 
    0xe0015d80     0xf8c    mov ip, #16
    0xe0015d84     0xf90    b e0014fd0 <decodeARMMMUInvocation+0x1dc>
    0xe0015d88     0xf94    str r7, [sp, #64]     ; stack access
    0xe0015d8c     0xf98    mov r2, #0
    0xe0015d90     0xf9c    mov r3, #16
    0xe0015d94     0xfa0    b e00158f4 <decodeARMMMUInvocation+0xb00>
    0xe0015d98     0xfa4    movw r3, #36896 
    0xe0015d9c     0xfa8    movt r3, #57346 
    0xe0015da0     0xfac    mov r1, #6
    0xe0015da4     0xfb0    mov r2, #0
    0xe0015da8     0xfb4    str r1, [r3, #24]
    0xe0015dac     0xfb8    mov r5, #3
    0xe0015db0     0xfbc    str r2, [r3, #20]
    0xe0015db4     0xfc0    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015db8     0xfc4    ldr r3, [sp, #8]      ; stack access
    0xe0015dbc     0xfc8    mvn r5, #0
    0xe0015dc0     0xfcc    bic r5, r4, r5, lsl ip
    0xe0015dc4     0xfd0    add r5, r5, r2
    0xe0015dc8     0xfd4    ldr r1, [r3]
    0xe0015dcc     0xfd8    ldr r3, [r1, #80] 
    0xe0015dd0     0xfdc    mov r0, r1
    0xe0015dd4     0xfe0    bic r3, r3, #15
    0xe0015dd8     0xfe4    orr r3, r3, #2
    0xe0015ddc     0xfe8    str r3, [r1, #80] 
    0xe0015de0     0xfec    bl e0013114 <setThreadState.part.166>
    0xe0015de4     0xff0    str r5, [sp, #116]    ; stack access
    0xe0015de8     0xff4    str r6, [sp, #112]    ; stack access
    0xe0015dec     0xff8    mov r3, r4
    0xe0015df0     0xffc    mov r2, r7
    0xe0015df4    0x1000    mov r1, r8
    0xe0015df8    0x1004    mov r0, fp
    0xe0015dfc    0x1008    add sp, sp, #76 
    0xe0015e00    0x100c    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0015e04    0x1010    b e00127e0 <performPDFlush>
    0xe0015e08    0x1014    movw r3, #36896 
    0xe0015e0c    0x1018    movt r3, #57346 
    0xe0015e10    0x101c    mov r2, #6
    0xe0015e14    0x1020    mov r5, #3
    0xe0015e18    0x1024    str r9, [r3, #20]
    0xe0015e1c    0x1028    str r2, [r3, #24]
    0xe0015e20    0x102c    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015e24    0x1030    mov r0, #65536 
    0xe0015e28    0x1034    b e0015af8 <decodeARMMMUInvocation+0xd04>
    0xe0015e2c    0x1038    movw r3, #36896 
    0xe0015e30    0x103c    movt r3, #57346 
    0xe0015e34    0x1040    mov r2, #5
    0xe0015e38    0x1044    mov r5, #3
    0xe0015e3c    0x1048    str r2, [r3, #24]
    0xe0015e40    0x104c    b e0015210 <decodeARMMMUInvocation+0x41c>
    0xe0015e44    0x1050    mov r9, #16
    0xe0015e48    0x1054    mov r7, #60 
    0xe0015e4c    0x1058    b e0015bac <decodeARMMMUInvocation+0xdb8>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
1029 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeARMMMUInvocation` has 1730 nodes.

Section decodeTCBInvocation (298 of 299)
========================================

Deriving specifications
-----------------------

Section `decodeTCBInvocation` consists of 174 instructions.
Switch found.


Stack analysis
---------------

51 stack accesses found. Annotated code for `decodeTCBInvocation`:

    0xe0019fdc      0x0    push {r4, r5, r6, lr}  ; stack access
    0xe0019fe0      0x4    sub sp, sp, #24
    0xe0019fe4      0x8    add ip, sp, #16
    0xe0019fe8      0xc    sub r0, r0, #2
    0xe0019fec     0x10    mov lr, r1
    0xe0019ff0     0x14    ldr r1, [sp, #40]     ; stack access
    0xe0019ff4     0x18    stm ip, {r2, r3}      ; stack access
    0xe0019ff8     0x1c    ldr r2, [sp, #56]     ; stack access
    0xe0019ffc     0x20    ldr r4, [sp, #16]     ; stack access
    0xe001a000     0x24    ldr r3, [sp, #60]     ; stack access
    0xe001a004     0x28    cmp r0, #13
    0xe001a008     0x2c    ldrls pc, [pc, r0, lsl #2]
    0xe001a00c     0x30    b e001a264 <decodeTCBInvocation+0x288>
    0xe001a010     0x34    .word 0xe001a09c
    0xe001a014     0x38    .word 0xe001a0b8
    0xe001a018     0x3c    .word 0xe001a0cc
    0xe001a01c     0x40    .word 0xe001a0f4
    0xe001a020     0x44    .word 0xe001a118
    0xe001a024     0x48    .word 0xe001a13c
    0xe001a028     0x4c    .word 0xe001a160
    0xe001a02c     0x50    .word 0xe001a184
    0xe001a030     0x54    .word 0xe001a1a8
    0xe001a034     0x58    .word 0xe001a1cc
    0xe001a038     0x5c    .word 0xe001a200
    0xe001a03c     0x60    .word 0xe001a234
    0xe001a040     0x64    .word 0xe001a254
    0xe001a044     0x68    .word 0xe001a048
    0xe001a048     0x6c    cmp lr, #0
    0xe001a04c     0x70    beq e001a27c <decodeTCBInvocation+0x2a0>
    0xe001a050     0x74    movw r5, #13900 
    0xe001a054     0x78    movt r5, #57347 
    0xe001a058     0x7c    bic r4, r4, #15
    0xe001a05c     0x80    ldr r2, [r5]
    0xe001a060     0x84    ldr r3, [r2, #80] 
    0xe001a064     0x88    mov r0, r2
    0xe001a068     0x8c    ldr r6, [r2, #8]
    0xe001a06c     0x90    bic r3, r3, #15
    0xe001a070     0x94    orr r3, r3, #2
    0xe001a074     0x98    str r3, [r2, #80] 
    0xe001a078     0x9c    bl e0013114 <setThreadState.part.166>
    0xe001a07c     0xa0    ldr r3, [r5]
    0xe001a080     0xa4    str r6, [r4, #72] 
    0xe001a084     0xa8    cmp r4, r3
    0xe001a088     0xac    movne r0, #0
    0xe001a08c     0xb0    bne e001a0ec <decodeTCBInvocation+0x110>
    0xe001a090     0xb4    bl e0013098 <rescheduleRequired>
    0xe001a094     0xb8    mov r0, #0
    0xe001a098     0xbc    b e001a0ec <decodeTCBInvocation+0x110>
    0xe001a09c     0xc0    str r3, [sp, #40]     ; stack access
    0xe001a0a0     0xc4    mov r3, r2
    0xe001a0a4     0xc8    ldm ip, {r0, r1}      ; stack access
    0xe001a0a8     0xcc    mov r2, lr
    0xe001a0ac     0xd0    add sp, sp, #24
    0xe001a0b0     0xd4    pop {r4, r5, r6, lr}  ; stack access
    0xe001a0b4     0xd8    b e0019d3c <decodeReadRegisters>
    0xe001a0b8     0xdc    mov r2, lr
    0xe001a0bc     0xe0    ldm ip, {r0, r1}      ; stack access
    0xe001a0c0     0xe4    add sp, sp, #24
    0xe001a0c4     0xe8    pop {r4, r5, r6, lr}  ; stack access
    0xe001a0c8     0xec    b e0019f20 <decodeWriteRegisters>
    0xe001a0cc     0xf0    add r1, sp, #48 
    0xe001a0d0     0xf4    str r3, [sp, #8]      ; stack access
    0xe001a0d4     0xf8    mov r2, lr
    0xe001a0d8     0xfc    ldr r3, [sp, #44]     ; stack access
    0xe001a0dc    0x100    ldm r1, {r0, r1}      ; stack access
    0xe001a0e0    0x104    stm sp, {r0, r1}      ; stack access
    0xe001a0e4    0x108    ldm ip, {r0, r1}      ; stack access
    0xe001a0e8    0x10c    bl e0019abc <decodeCopyRegisters>
    0xe001a0ec    0x110    add sp, sp, #24
    0xe001a0f0    0x114    pop {r4, r5, r6, pc}  ; stack access
    0xe001a0f4    0x118    add r2, sp, #44 
    0xe001a0f8    0x11c    str r3, [sp, #12]     ; stack access
    0xe001a0fc    0x120    mov r3, r1
    0xe001a100    0x124    ldm r2, {r0, r1, r2}  ; stack access
    0xe001a104    0x128    stm sp, {r0, r1, r2}  ; stack access
    0xe001a108    0x12c    mov r2, lr
    0xe001a10c    0x130    ldm ip, {r0, r1}      ; stack access
    0xe001a110    0x134    bl e0018f20 <decodeTCBConfigure>
    0xe001a114    0x138    b e001a0ec <decodeTCBInvocation+0x110>
    0xe001a118    0x13c    add r1, sp, #48 
    0xe001a11c    0x140    str r3, [sp, #8]      ; stack access
    0xe001a120    0x144    mov r2, lr
    0xe001a124    0x148    ldr r3, [sp, #44]     ; stack access
    0xe001a128    0x14c    ldm r1, {r0, r1}      ; stack access
    0xe001a12c    0x150    stm sp, {r0, r1}      ; stack access
    0xe001a130    0x154    ldm ip, {r0, r1}      ; stack access
    0xe001a134    0x158    bl e001920c <decodeSetPriority>
    0xe001a138    0x15c    b e001a0ec <decodeTCBInvocation+0x110>
    0xe001a13c    0x160    add r1, sp, #48 
    0xe001a140    0x164    str r3, [sp, #8]      ; stack access
    0xe001a144    0x168    mov r2, lr
    0xe001a148    0x16c    ldr r3, [sp, #44]     ; stack access
    0xe001a14c    0x170    ldm r1, {r0, r1}      ; stack access
    0xe001a150    0x174    stm sp, {r0, r1}      ; stack access
    0xe001a154    0x178    ldm ip, {r0, r1}      ; stack access
    0xe001a158    0x17c    bl e0019374 <decodeSetMCPriority>
    0xe001a15c    0x180    b e001a0ec <decodeTCBInvocation+0x110>
    0xe001a160    0x184    add r1, sp, #48 
    0xe001a164    0x188    str r3, [sp, #8]      ; stack access
    0xe001a168    0x18c    mov r2, lr
    0xe001a16c    0x190    ldr r3, [sp, #44]     ; stack access
    0xe001a170    0x194    ldm r1, {r0, r1}      ; stack access
    0xe001a174    0x198    stm sp, {r0, r1}      ; stack access
    0xe001a178    0x19c    ldm ip, {r0, r1}      ; stack access
    0xe001a17c    0x1a0    bl e00194dc <decodeSetSchedParams>
    0xe001a180    0x1a4    b e001a0ec <decodeTCBInvocation+0x110>
    0xe001a184    0x1a8    add r2, sp, #44 
    0xe001a188    0x1ac    str r3, [sp, #12]     ; stack access
    0xe001a18c    0x1b0    mov r3, r1
    0xe001a190    0x1b4    ldm r2, {r0, r1, r2}  ; stack access
    0xe001a194    0x1b8    stm sp, {r0, r1, r2}  ; stack access
    0xe001a198    0x1bc    mov r2, lr
    0xe001a19c    0x1c0    ldm ip, {r0, r1}      ; stack access
    0xe001a1a0    0x1c4    bl e0019650 <decodeSetIPCBuffer>
    0xe001a1a4    0x1c8    b e001a0ec <decodeTCBInvocation+0x110>
    0xe001a1a8    0x1cc    add r2, sp, #44 
    0xe001a1ac    0x1d0    str r3, [sp, #12]     ; stack access
    0xe001a1b0    0x1d4    mov r3, r1
    0xe001a1b4    0x1d8    ldm r2, {r0, r1, r2}  ; stack access
    0xe001a1b8    0x1dc    stm sp, {r0, r1, r2}  ; stack access
    0xe001a1bc    0x1e0    mov r2, lr
    0xe001a1c0    0x1e4    ldm ip, {r0, r1}      ; stack access
    0xe001a1c4    0x1e8    bl e0019780 <decodeSetSpace>
    0xe001a1c8    0x1ec    b e001a0ec <decodeTCBInvocation+0x110>
    0xe001a1cc    0x1f0    movw r3, #13900 
    0xe001a1d0    0x1f4    movt r3, #57347 
    0xe001a1d4    0x1f8    ldr r2, [r3]
    0xe001a1d8    0x1fc    ldr r3, [r2, #80] 
    0xe001a1dc    0x200    mov r0, r2
    0xe001a1e0    0x204    bic r3, r3, #15
    0xe001a1e4    0x208    orr r3, r3, #2
    0xe001a1e8    0x20c    str r3, [r2, #80] 
    0xe001a1ec    0x210    bl e0013114 <setThreadState.part.166>
    0xe001a1f0    0x214    bic r0, r4, #15
    0xe001a1f4    0x218    bl e00167b4 <suspend>
    0xe001a1f8    0x21c    mov r0, #0
    0xe001a1fc    0x220    b e001a0ec <decodeTCBInvocation+0x110>
    0xe001a200    0x224    movw r3, #13900 
    0xe001a204    0x228    movt r3, #57347 
    0xe001a208    0x22c    ldr r2, [r3]
    0xe001a20c    0x230    ldr r3, [r2, #80] 
    0xe001a210    0x234    mov r0, r2
    0xe001a214    0x238    bic r3, r3, #15
    0xe001a218    0x23c    orr r3, r3, #2
    0xe001a21c    0x240    str r3, [r2, #80] 
    0xe001a220    0x244    bl e0013114 <setThreadState.part.166>
    0xe001a224    0x248    bic r0, r4, #15
    0xe001a228    0x24c    bl e0017514 <restart>
    0xe001a22c    0x250    mov r0, #0
    0xe001a230    0x254    b e001a0ec <decodeTCBInvocation+0x110>
    0xe001a234    0x258    ldr lr, [sp, #52]     ; stack access
    0xe001a238    0x25c    add r3, sp, #44 
    0xe001a23c    0x260    ldm ip, {r0, r1}      ; stack access
    0xe001a240    0x264    ldm r3, {r2, r3}      ; stack access
    0xe001a244    0x268    str lr, [sp, #40]     ; stack access
    0xe001a248    0x26c    add sp, sp, #24
    0xe001a24c    0x270    pop {r4, r5, r6, lr}  ; stack access
    0xe001a250    0x274    b e0018ba8 <decodeBindNotification>
    0xe001a254    0x278    ldm ip, {r0, r1}      ; stack access
    0xe001a258    0x27c    add sp, sp, #24
    0xe001a25c    0x280    pop {r4, r5, r6, lr}  ; stack access
    0xe001a260    0x284    b e0018cc8 <decodeUnbindNotification>
    0xe001a264    0x288    movw r3, #36896 
    0xe001a268    0x28c    movt r3, #57346 
    0xe001a26c    0x290    mov r2, #3
    0xe001a270    0x294    mov r0, r2
    0xe001a274    0x298    str r2, [r3, #24]
    0xe001a278    0x29c    b e001a0ec <decodeTCBInvocation+0x110>
    0xe001a27c    0x2a0    movw r3, #36896 
    0xe001a280    0x2a4    movt r3, #57346 
    0xe001a284    0x2a8    mov r2, #7
    0xe001a288    0x2ac    mov r0, #3
    0xe001a28c    0x2b0    str r2, [r3, #24]
    0xe001a290    0x2b4    b e001a0ec <decodeTCBInvocation+0x110>

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
160 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `decodeTCBInvocation` has 291 nodes.

Section init_kernel (299 of 299)
================================

Deriving specifications
-----------------------

Section `init_kernel` consists of 440 instructions.
Skipping ee0d3f90 mcr 15, 0, r3, cr13, cr0, {4}
Skipping eef83a10 vmrs r3, fpexc
Skipping eee83a10 vmsr fpexc, r3
Skipping ee103f51 mrc 15, 0, r3, cr0, cr1, {2}
Skipping ee103f31 mrc 15, 0, r3, cr0, cr1, {1}
Skipping ee0e3f11 mcr 15, 0, r3, cr14, cr1, {0}
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee079f15 mcr 15, 0, r9, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee079f15 mcr 15, 0, r9, cr7, cr5, {0}
Skipping f57ff06f isb sy
Skipping f57ff04f dsb sy
Skipping f57ff04f dsb sy
Skipping ee089f17 mcr 15, 0, r9, cr8, cr7, {0}
Skipping f57ff04f dsb sy
Skipping f57ff06f isb sy


Stack analysis
---------------

101 stack accesses found. Annotated code for `init_kernel`:

    0xe0003d68      0x0    push {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe0003d6c      0x4    sub sp, sp, #156 
    0xe0003d70      0x8    mov r8, r0
    0xe0003d74      0xc    mov r9, r2
    0xe0003d78     0x10    ldr r5, [sp, #192]    ; stack access
    0xe0003d7c     0x14    str r3, [sp, #48]     ; stack access
    0xe0003d80     0x18    cmp r5, #0
    0xe0003d84     0x1c    ldr r3, [sp, #196]    ; stack access
    0xe0003d88     0x20    beq e0004310 <init_kernel+0x5a8>
    0xe0003d8c     0x24    sub r4, r3, #1
    0xe0003d90     0x28    movw r3, #46024 
    0xe0003d94     0x2c    add r4, r4, r5
    0xe0003d98     0x30    movt r3, #57345 
    0xe0003d9c     0x34    bic r4, r4, #4080 
    0xe0003da0     0x38    add fp, r5, #-805306368 
    0xe0003da4     0x3c    bic r4, r4, #15
    0xe0003da8     0x40    ldr r3, [r3, #140] 
    0xe0003dac     0x44    add r0, r4, #4096 
    0xe0003db0     0x48    rsb r2, fp, #8
    0xe0003db4     0x4c    str r0, [sp, #44]     ; stack access
    0xe0003db8     0x50    add r0, r0, #-805306368 
    0xe0003dbc     0x54    str r0, [sp, #40]     ; stack access
    0xe0003dc0     0x58    adds r0, r2, r0
    0xe0003dc4     0x5c    sub sl, r1, r9
    0xe0003dc8     0x60    str r3, [sp, #28]     ; stack access
    0xe0003dcc     0x64    add r6, r1, #-805306368 
    0xe0003dd0     0x68    add r3, sl, #8192 
    0xe0003dd4     0x6c    add r4, r8, #-805306368 
    0xe0003dd8     0x70    str r0, [sp, #32]     ; stack access
    0xe0003ddc     0x74    str r3, [sp, #24]     ; stack access
    0xe0003de0     0x78    str r6, [sp, #92]     ; stack access
    0xe0003de4     0x7c    str r4, [sp, #88]     ; stack access
    0xe0003de8     0x80    bne e0004368 <init_kernel+0x600>
    0xe0003dec     0x84    ldr r3, [sp, #32]     ; stack access
    0xe0003df0     0x88    mov r7, #1
    0xe0003df4     0x8c    str r3, [sp, #36]     ; stack access
    0xe0003df8     0x90    ldr r3, [sp, #24]     ; stack access
    0xe0003dfc     0x94    add r7, r3, r7
    0xe0003e00     0x98    cmn r7, #536870913 
    0xe0003e04     0x9c    bhi e0004364 <init_kernel+0x5fc>
    0xe0003e08     0xa0    bl e0000dc8 <map_kernel_window>
    0xe0003e0c     0xa4    bl e0000a34 <activate_global_pd>
    0xe0003e10     0xa8    ldr r3, [pc, #1568] 
    0xe0003e14     0xac    mcr 15, 0, r3, cr13, cr0, {4}
    0xe0003e18     0xb0    bl e00009f4 <fpsimd_HWCapTest>
    0xe0003e1c     0xb4    cmp r0, #0
    0xe0003e20     0xb8    beq e0003e40 <init_kernel+0xd8>
    0xe0003e24     0xbc    vmrs r3, fpexc
    0xe0003e28     0xc0    bic r3, r3, #1073741824 
    0xe0003e2c     0xc4    vmsr fpexc, r3
    0xe0003e30     0xc8    movw r3, #13908 
    0xe0003e34     0xcc    movt r3, #57347 
    0xe0003e38     0xd0    mov r2, #0
    0xe0003e3c     0xd4    str r2, [r3]
    0xe0003e40     0xd8    bl e00001d4 <cpu_iface_init>
    0xe0003e44     0xdc    mrc 15, 0, r3, cr0, cr1, {2}
    0xe0003e48     0xe0    mrc 15, 0, r3, cr0, cr1, {1}
    0xe0003e4c     0xe4    tst r3, #65536 
    0xe0003e50     0xe8    beq e0003e5c <init_kernel+0xf4>
    0xe0003e54     0xec    mov r3, #0
    0xe0003e58     0xf0    mcr 15, 0, r3, cr14, cr1, {0}
    0xe0003e5c     0xf4    movw r3, #9983 
    0xe0003e60     0xf8    movt r3, #65520 
    0xe0003e64     0xfc    mov r1, #0
    0xe0003e68    0x100    movw r2, #12960 
    0xe0003e6c    0x104    str r1, [r3, #-247] 
    0xe0003e70    0x108    movt r2, #15
    0xe0003e74    0x10c    str r1, [r3, #-243] 
    0xe0003e78    0x110    sub r1, r8, r9
    0xe0003e7c    0x114    str r1, [sp, #52]     ; stack access
    0xe0003e80    0x118    str r2, [r3, #-255] 
    0xe0003e84    0x11c    ldr r2, [r3, #-247] 
    0xe0003e88    0x120    orr r2, r2, #6
    0xe0003e8c    0x124    str r2, [r3, #-247] 
    0xe0003e90    0x128    ldr r2, [r3, #-247] 
    0xe0003e94    0x12c    orr r2, r2, #1
    0xe0003e98    0x130    str r2, [r3, #-247] 
    0xe0003e9c    0x134    bl e0000060 <dist_init>
    0xe0003ea0    0x138    bl e0000ab4 <initL2Cache>
    0xe0003ea4    0x13c    cmp r5, #0
    0xe0003ea8    0x140    movw r3, #17544 
    0xe0003eac    0x144    movt r3, #57344 
    0xe0003eb0    0x148    mov r2, #-536870912 
    0xe0003eb4    0x14c    movw r0, #65535 
    0xe0003eb8    0x150    str r2, [r3, #32]
    0xe0003ebc    0x154    movw r2, #16384 
    0xe0003ec0    0x158    movt r2, #57347 
    0xe0003ec4    0x15c    str r2, [r3, #36] 
    0xe0003ec8    0x160    ldrne r2, [sp, #44]   ; stack access
    0xe0003ecc    0x164    movt r0, #12271 
    0xe0003ed0    0x168    sub r1, r8, r9
    0xe0003ed4    0x16c    addne r5, r5, #-805306368 
    0xe0003ed8    0x170    str r1, [sp, #104]    ; stack access
    0xe0003edc    0x174    moveq r2, #2
    0xe0003ee0    0x178    addne r1, r2, #-805306368 
    0xe0003ee4    0x17c    strne r5, [r3, #40] 
    0xe0003ee8    0x180    strne r1, [r3, #44] 
    0xe0003eec    0x184    movne r2, #3
    0xe0003ef0    0x188    movne r1, #2
    0xe0003ef4    0x18c    moveq r1, #1
    0xe0003ef8    0x190    cmp r8, r0
    0xe0003efc    0x194    str r7, [sp, #108]    ; stack access
    0xe0003f00    0x198    ldr r0, [pc, #1332] 
    0xe0003f04    0x19c    bls e000437c <init_kernel+0x614>
    0xe0003f08    0x1a0    add r3, r3, r1, lsl #3
    0xe0003f0c    0x1a4    ldm r0, {r0, r1}
    0xe0003f10    0x1a8    add r3, r3, #32
    0xe0003f14    0x1ac    stm r3, {r0, r1}
    0xe0003f18    0x1b0    ldr r1, [sp, #36]     ; stack access
    0xe0003f1c    0x1b4    add r3, sp, #104 
    0xe0003f20    0x1b8    movw r4, #46848 
    0xe0003f24    0x1bc    movt r4, #57345 
    0xe0003f28    0x1c0    movw r6, #4351 
    0xe0003f2c    0x1c4    movt r6, #65520 
    0xe0003f30    0x1c8    str r1, [sp, #8]      ; stack access
    0xe0003f34    0x1cc    ldm r3, {r0, r1}      ; stack access
    0xe0003f38    0x1d0    ldr r3, [pc, #1280] 
    0xe0003f3c    0x1d4    stm sp, {r0, r1}      ; stack access
    0xe0003f40    0x1d8    mov r0, #1
    0xe0003f44    0x1dc    movw r1, #17480 
    0xe0003f48    0x1e0    movt r1, #57344 
    0xe0003f4c    0x1e4    bl e0002b08 <init_freemem>
    0xe0003f50    0x1e8    ldr r1, [r4, #144] 
    0xe0003f54    0x1ec    ldr r0, [pc, #1256] 
    0xe0003f58    0x1f0    mov r3, #0
    0xe0003f5c    0x1f4    add r8, r1, #32
    0xe0003f60    0x1f8    bic ip, r1, #31
    0xe0003f64    0x1fc    mov lr, #4096 
    0xe0003f68    0x200    orr r5, ip, #10
    0xe0003f6c    0x204    str lr, [r4, #132] 
    0xe0003f70    0x208    mov r2, r3
    0xe0003f74    0x20c    str r5, [r1, #32]
    0xe0003f78    0x210    mov r1, #170917888 
    0xe0003f7c    0x214    str r3, [r8, #8]
    0xe0003f80    0x218    mov lr, r3
    0xe0003f84    0x21c    str r1, [r8, #4]
    0xe0003f88    0x220    mov r1, #3
    0xe0003f8c    0x224    str r1, [r8, #12]
    0xe0003f90    0x228    mov r8, #1
    0xe0003f94    0x22c    str r3, [ip, #180] 
    0xe0003f98    0x230    str r3, [ip, #184] 
    0xe0003f9c    0x234    mov r3, #62 
    0xe0003fa0    0x238    str r1, [ip, #188] 
    0xe0003fa4    0x23c    str r3, [ip, #176] 
    0xe0003fa8    0x240    lsr r3, r2, #5
    0xe0003fac    0x244    and r1, r2, #31
    0xe0003fb0    0x248    add r3, r3, #96 
    0xe0003fb4    0x24c    add r2, r2, #1
    0xe0003fb8    0x250    cmp r2, #160 
    0xe0003fbc    0x254    str lr, [r0, #4]!
    0xe0003fc0    0x258    add r3, r6, r3, lsl #2
    0xe0003fc4    0x25c    lsl r1, r8, r1
    0xe0003fc8    0x260    str r1, [r3, #-255] 
    0xe0003fcc    0x264    bne e0003fa8 <init_kernel+0x240>
    0xe0003fd0    0x268    movw r3, #36936 
    0xe0003fd4    0x26c    movt r3, #57346 
    0xe0003fd8    0x270    mov r1, #2
    0xe0003fdc    0x274    mov r2, #536870912 
    0xe0003fe0    0x278    str r1, [r3, #116] 
    0xe0003fe4    0x27c    mov r0, #3
    0xe0003fe8    0x280    str r2, [r6, #1]
    0xe0003fec    0x284    mov r1, #14
    0xe0003ff0    0x288    str r0, [ip, #76] 
    0xe0003ff4    0x28c    mov r2, sl
    0xe0003ff8    0x290    str r1, [ip, #64] 
    0xe0003ffc    0x294    mov r0, #0
    0xe0004000    0x298    str lr, [ip, #68] 
    0xe0004004    0x29c    mov r1, #1
    0xe0004008    0x2a0    ldr r3, [sp, #32]     ; stack access
    0xe000400c    0x2a4    str lr, [ip, #72] 
    0xe0004010    0x2a8    bl e0001a74 <populate_bi_frame>
    0xe0004014    0x2ac    cmp fp, #0
    0xe0004018    0x2b0    beq e000406c <init_kernel+0x304>
    0xe000401c    0x2b4    ldr lr, [sp, #40]     ; stack access
    0xe0004020    0x2b8    mov ip, #6
    0xe0004024    0x2bc    ldr r2, [r4, #164] 
    0xe0004028    0x2c0    sub r3, lr, fp
    0xe000402c    0x2c4    cmp r3, #0
    0xe0004030    0x2c8    add r0, r3, #8
    0xe0004034    0x2cc    add r1, r2, #8
    0xe0004038    0x2d0    mov r3, fp
    0xe000403c    0x2d4    str r0, [r2, #4]
    0xe0004040    0x2d8    moveq fp, #8
    0xe0004044    0x2dc    str ip, [r2]
    0xe0004048    0x2e0    beq e000406c <init_kernel+0x304>
    0xe000404c    0x2e4    sub r1, r1, r3
    0xe0004050    0x2e8    mov ip, lr
    0xe0004054    0x2ec    ldrb r2, [r3]
    0xe0004058    0x2f0    strb r2, [r3, r1]
    0xe000405c    0x2f4    add r3, r3, #1
    0xe0004060    0x2f8    cmp r3, ip
    0xe0004064    0x2fc    bne e0004054 <init_kernel+0x2ec>
    0xe0004068    0x300    mov fp, r0
    0xe000406c    0x304    ldr r2, [sp, #32]     ; stack access
    0xe0004070    0x308    cmp r2, fp
    0xe0004074    0x30c    bls e0004090 <init_kernel+0x328>
    0xe0004078    0x310    ldr r3, [r4, #164] 
    0xe000407c    0x314    sub r1, r2, fp
    0xe0004080    0x318    mov r0, #0
    0xe0004084    0x31c    add r2, fp, r3
    0xe0004088    0x320    str r0, [fp, r3]
    0xe000408c    0x324    str r1, [r2, #4]
    0xe0004090    0x328    ldr r2, [r4, #124] 
    0xe0004094    0x32c    add r6, sp, #56 
    0xe0004098    0x330    ldr ip, [sp, #52]     ; stack access
    0xe000409c    0x334    add r8, sp, #72 
    0xe00040a0    0x338    mov r1, #0
    0xe00040a4    0x33c    str r5, [sp, #56]     ; stack access
    0xe00040a8    0x340    str r1, [r2, #52] 
    0xe00040ac    0x344    mov r0, r8
    0xe00040b0    0x348    str r1, [r2, #56] 
    0xe00040b4    0x34c    mov r3, ip
    0xe00040b8    0x350    mov r2, #170917888 
    0xe00040bc    0x354    str r7, [sp]          ; stack access
    0xe00040c0    0x358    str r2, [sp, #60]     ; stack access
    0xe00040c4    0x35c    ldm r6, {r1, r2}      ; stack access
    0xe00040c8    0x360    str ip, [sp, #96]     ; stack access
    0xe00040cc    0x364    str r7, [sp, #100]    ; stack access
    0xe00040d0    0x368    bl e0001e44 <create_it_address_space>
    0xe00040d4    0x36c    ldr r3, [sp, #72]     ; stack access
    0xe00040d8    0x370    and r2, r3, #14
    0xe00040dc    0x374    cmp r2, #14
    0xe00040e0    0x378    andne r3, r3, #15
    0xe00040e4    0x37c    uxtbeq r3, r3
    0xe00040e8    0x380    cmp r3, #0
    0xe00040ec    0x384    beq e0004364 <init_kernel+0x5fc>
    0xe00040f0    0x388    ldm r8, {r2, r3}      ; stack access
    0xe00040f4    0x38c    add fp, sl, #4096 
    0xe00040f8    0x390    str fp, [sp]          ; stack access
    0xe00040fc    0x394    ldm r6, {r0, r1}      ; stack access
    0xe0004100    0x398    bl e00017b8 <create_bi_frame_cap>
    0xe0004104    0x39c    ldr r0, [sp, #32]     ; stack access
    0xe0004108    0x3a0    cmp r0, #0
    0xe000410c    0x3a4    bne e00043c8 <init_kernel+0x660>
    0xe0004110    0x3a8    ldr r3, [sp, #76]     ; stack access
    0xe0004114    0x3ac    add r7, sp, #80 
    0xe0004118    0x3b0    str sl, [sp, #4]      ; stack access
    0xe000411c    0x3b4    mov r2, #170917888 
    0xe0004120    0x3b8    mov r0, r7
    0xe0004124    0x3bc    str r2, [sp, #60]     ; stack access
    0xe0004128    0x3c0    str r3, [sp]          ; stack access
    0xe000412c    0x3c4    ldr r3, [sp, #72]     ; stack access
    0xe0004130    0x3c8    ldm r6, {r1, r2}      ; stack access
    0xe0004134    0x3cc    bl e00014a0 <create_ipcbuf_frame_cap>
    0xe0004138    0x3d0    ldr r3, [sp, #80]     ; stack access
    0xe000413c    0x3d4    and r2, r3, #14
    0xe0004140    0x3d8    cmp r2, #14
    0xe0004144    0x3dc    andne r3, r3, #15
    0xe0004148    0x3e0    uxtbeq r3, r3
    0xe000414c    0x3e4    cmp r3, #0
    0xe0004150    0x3e8    beq e0004364 <init_kernel+0x5fc>
    0xe0004154    0x3ec    add r3, sp, #88 
    0xe0004158    0x3f0    ldr r2, [sp, #76]     ; stack access
    0xe000415c    0x3f4    str r9, [sp, #16]     ; stack access
    0xe0004160    0x3f8    ldm r3, {r0, r1}      ; stack access
    0xe0004164    0x3fc    mov r3, #1
    0xe0004168    0x400    str r2, [sp]          ; stack access
    0xe000416c    0x404    str r3, [sp, #12]     ; stack access
    0xe0004170    0x408    stmib sp, {r0, r1}    ; stack access
    0xe0004174    0x40c    add r0, sp, #128 
    0xe0004178    0x410    ldr r3, [sp, #72]     ; stack access
    0xe000417c    0x414    ldm r6, {r1, r2}      ; stack access
    0xe0004180    0x418    bl e0002230 <create_frames_of_region>
    0xe0004184    0x41c    ldr r3, [sp, #136]    ; stack access
    0xe0004188    0x420    cmp r3, #0
    0xe000418c    0x424    beq e0004364 <init_kernel+0x5fc>
    0xe0004190    0x428    add r2, sp, #128 
    0xe0004194    0x42c    ldr r3, [r4, #124] 
    0xe0004198    0x430    add r9, sp, #64 
    0xe000419c    0x434    ldm r2, {r0, r1}      ; stack access
    0xe00041a0    0x438    add r3, r3, #36 
    0xe00041a4    0x43c    stm r3, {r0, r1}
    0xe00041a8    0x440    mov r0, r9
    0xe00041ac    0x444    ldm r6, {r1, r2}      ; stack access
    0xe00041b0    0x448    bl e0002348 <create_it_asid_pool>
    0xe00041b4    0x44c    ldr r3, [sp, #64]     ; stack access
    0xe00041b8    0x450    and r2, r3, #14
    0xe00041bc    0x454    cmp r2, #14
    0xe00041c0    0x458    andne r3, r3, #15
    0xe00041c4    0x45c    uxtbeq r3, r3
    0xe00041c8    0x460    cmp r3, #0
    0xe00041cc    0x464    beq e0004364 <init_kernel+0x5fc>
    0xe00041d0    0x468    ldm r8, {r2, r3}      ; stack access
    0xe00041d4    0x46c    ldm r9, {r0, r1}      ; stack access
    0xe00041d8    0x470    bl e000056c <write_it_asid_pool>
    0xe00041dc    0x474    bl e0002f68 <create_idle_thread>
    0xe00041e0    0x478    cmp r0, #0
    0xe00041e4    0x47c    beq e0004364 <init_kernel+0x5fc>
    0xe00041e8    0x480    dsb sy
    0xe00041ec    0x484    bl e0012410 <cleanInvalidate_D_PoC>
    0xe00041f0    0x488    dsb sy
    0xe00041f4    0x48c    mov r9, #0
    0xe00041f8    0x490    mcr 15, 0, r9, cr7, cr5, {0}
    0xe00041fc    0x494    isb sy
    0xe0004200    0x498    dsb sy
    0xe0004204    0x49c    ldm r7, {r0, r1}      ; stack access
    0xe0004208    0x4a0    add r3, sp, #12
    0xe000420c    0x4a4    str r5, [sp, #56]     ; stack access
    0xe0004210    0x4a8    mov r7, #170917888 
    0xe0004214    0x4ac    str r7, [sp, #60]     ; stack access
    0xe0004218    0x4b0    stm r3, {r0, r1}      ; stack access
    0xe000421c    0x4b4    ldr r1, [sp, #48]     ; stack access
    0xe0004220    0x4b8    ldm r8, {r2, r3}      ; stack access
    0xe0004224    0x4bc    str sl, [sp, #8]      ; stack access
    0xe0004228    0x4c0    str fp, [sp, #4]      ; stack access
    0xe000422c    0x4c4    str r1, [sp]          ; stack access
    0xe0004230    0x4c8    ldm r6, {r0, r1}      ; stack access
    0xe0004234    0x4cc    bl e0002fcc <create_initial_thread>
    0xe0004238    0x4d0    subs ip, r0, #0
    0xe000423c    0x4d4    beq e0004364 <init_kernel+0x5fc>
    0xe0004240    0x4d8    movw r3, #36880 
    0xe0004244    0x4dc    movt r3, #57346 
    0xe0004248    0x4e0    ldr r8, [r4, #128] 
    0xe000424c    0x4e4    add r6, sp, #112 
    0xe0004250    0x4e8    ldr r0, [r3]
    0xe0004254    0x4ec    movw r1, #13900 
    0xe0004258    0x4f0    ldr r2, [sp, #28]     ; stack access
    0xe000425c    0x4f4    movt r1, #57347 
    0xe0004260    0x4f8    movw r3, #36892 
    0xe0004264    0x4fc    movt r3, #57346 
    0xe0004268    0x500    str r5, [sp, #112]    ; stack access
    0xe000426c    0x504    str r7, [sp, #116]    ; stack access
    0xe0004270    0x508    str r2, [sp, #124]    ; stack access
    0xe0004274    0x50c    mov r2, r8
    0xe0004278    0x510    str r0, [r1]
    0xe000427c    0x514    ldm r6, {r0, r1}      ; stack access
    0xe0004280    0x518    str ip, [r3]
    0xe0004284    0x51c    mov r3, #-536870912 
    0xe0004288    0x520    str r3, [sp, #120]    ; stack access
    0xe000428c    0x524    bl e0002974 <create_device_untypeds>
    0xe0004290    0x528    add r3, sp, #120 
    0xe0004294    0x52c    str r8, [sp]          ; stack access
    0xe0004298    0x530    ldm r6, {r0, r1}      ; stack access
    0xe000429c    0x534    ldm r3, {r2, r3}      ; stack access
    0xe00042a0    0x538    bl e0002a3c <create_kernel_untypeds>
    0xe00042a4    0x53c    ldr r2, [r4, #128] 
    0xe00042a8    0x540    ldr r3, [r4, #124] 
    0xe00042ac    0x544    ldr r1, [r4, #132] 
    0xe00042b0    0x548    str r8, [r3, #76] 
    0xe00042b4    0x54c    str r2, [r3, #80] 
    0xe00042b8    0x550    str r9, [r3, #28]
    0xe00042bc    0x554    str r9, [r3, #32]
    0xe00042c0    0x558    str r2, [r3, #20]
    0xe00042c4    0x55c    str r1, [r3, #24]
    0xe00042c8    0x560    dsb sy
    0xe00042cc    0x564    bl e0012410 <cleanInvalidate_D_PoC>
    0xe00042d0    0x568    dsb sy
    0xe00042d4    0x56c    mcr 15, 0, r9, cr7, cr5, {0}
    0xe00042d8    0x570    isb sy
    0xe00042dc    0x574    dsb sy
    0xe00042e0    0x578    dsb sy
    0xe00042e4    0x57c    mcr 15, 0, r9, cr8, cr7, {0}
    0xe00042e8    0x580    dsb sy
    0xe00042ec    0x584    isb sy
    0xe00042f0    0x588    movw r3, #38088 
    0xe00042f4    0x58c    movt r3, #57346 
    0xe00042f8    0x590    mov r2, #1
    0xe00042fc    0x594    str r2, [r3]
    0xe0004300    0x598    bl e00165a8 <schedule>
    0xe0004304    0x59c    add sp, sp, #156 
    0xe0004308    0x5a0    pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}  ; stack access
    0xe000430c    0x5a4    b e001319c <activateThread>
    0xe0004310    0x5a8    movw r3, #46024 
    0xe0004314    0x5ac    movt r3, #57345 
    0xe0004318    0x5b0    sub sl, r1, r2
    0xe000431c    0x5b4    mov r7, #1
    0xe0004320    0x5b8    ldr r3, [r3, #140] 
    0xe0004324    0x5bc    mov fp, r5
    0xe0004328    0x5c0    add r6, r1, #-805306368 
    0xe000432c    0x5c4    add r4, r0, #-805306368 
    0xe0004330    0x5c8    str r6, [sp, #92]     ; stack access
    0xe0004334    0x5cc    str r3, [sp, #28]     ; stack access
    0xe0004338    0x5d0    add r3, sl, #8192 
    0xe000433c    0x5d4    str r5, [sp, #44]     ; stack access
    0xe0004340    0x5d8    str r3, [sp, #24]     ; stack access
    0xe0004344    0x5dc    str r4, [sp, #88]     ; stack access
    0xe0004348    0x5e0    str r5, [sp, #40]     ; stack access
    0xe000434c    0x5e4    str r5, [sp, #32]     ; stack access
    0xe0004350    0x5e8    str r5, [sp, #36]     ; stack access
    0xe0004354    0x5ec    ldr r3, [sp, #24]     ; stack access
    0xe0004358    0x5f0    add r7, r3, r7
    0xe000435c    0x5f4    cmn r7, #536870913 
    0xe0004360    0x5f8    bls e0003e08 <init_kernel+0xa0>
    0xe0004364    0x5fc    bl e0010a3c <halt>
    0xe0004368    0x600    bl e00002f0 <calculate_extra_bi_size_bits.part.160>
    0xe000436c    0x604    mov r7, #1
    0xe0004370    0x608    str r0, [sp, #36]     ; stack access
    0xe0004374    0x60c    lsl r7, r7, r0
    0xe0004378    0x610    b e0004354 <init_kernel+0x5ec>
    0xe000437c    0x614    cmp r6, #-16777216 
    0xe0004380    0x618    bhi e00043a8 <init_kernel+0x640>
    0xe0004384    0x61c    add ip, r3, r1, lsl #3
    0xe0004388    0x620    add r3, r3, r2, lsl #3
    0xe000438c    0x624    ldm r0, {r0, r1}
    0xe0004390    0x628    add r3, r3, #32
    0xe0004394    0x62c    str r4, [ip, #32]
    0xe0004398    0x630    str r6, [ip, #36] 
    0xe000439c    0x634    stm r3, {r0, r1}
    0xe00043a0    0x638    add r2, r2, #1
    0xe00043a4    0x63c    b e0003f18 <init_kernel+0x1b0>
    0xe00043a8    0x640    add r1, r3, r1, lsl #3
    0xe00043ac    0x644    add r3, r3, r2, lsl #3
    0xe00043b0    0x648    add ip, r1, #32
    0xe00043b4    0x64c    ldm r0, {r0, r1}
    0xe00043b8    0x650    stm ip, {r0, r1}
    0xe00043bc    0x654    str r4, [r3, #32]
    0xe00043c0    0x658    str r6, [r3, #36] 
    0xe00043c4    0x65c    b e00043a0 <init_kernel+0x638>
    0xe00043c8    0x660    ldr r3, [r4, #164] 
    0xe00043cc    0x664    add r1, sp, #128 
    0xe00043d0    0x668    ldr r2, [sp, #76]     ; stack access
    0xe00043d4    0x66c    add r7, sp, #140 
    0xe00043d8    0x670    add r0, r0, r3
    0xe00043dc    0x674    str r0, [sp, #132]    ; stack access
    0xe00043e0    0x678    str r3, [sp, #128]    ; stack access
    0xe00043e4    0x67c    add r3, r3, #805306368 
    0xe00043e8    0x680    ldm r1, {r0, r1}      ; stack access
    0xe00043ec    0x684    ldr ip, [sp, #24]     ; stack access
    0xe00043f0    0x688    str r2, [sp]          ; stack access
    0xe00043f4    0x68c    mov r2, #1
    0xe00043f8    0x690    sub r3, r3, ip
    0xe00043fc    0x694    stmib sp, {r0, r1}    ; stack access
    0xe0004400    0x698    str r3, [sp, #16]     ; stack access
    0xe0004404    0x69c    mov r0, r7
    0xe0004408    0x6a0    str r2, [sp, #12]     ; stack access
    0xe000440c    0x6a4    ldr r3, [sp, #72]     ; stack access
    0xe0004410    0x6a8    ldm r6, {r1, r2}      ; stack access
    0xe0004414    0x6ac    bl e0002230 <create_frames_of_region>
    0xe0004418    0x6b0    ldr r3, [sp, #148]    ; stack access
    0xe000441c    0x6b4    cmp r3, #0
    0xe0004420    0x6b8    beq e0004364 <init_kernel+0x5fc>
    0xe0004424    0x6bc    ldr r3, [r4, #124] 
    0xe0004428    0x6c0    ldm r7, {r0, r1}      ; stack access
    0xe000442c    0x6c4    add r3, r3, #60 
    0xe0004430    0x6c8    stm r3, {r0, r1}
    0xe0004434    0x6cc    b e0004110 <init_kernel+0x3a8>
    0xe0004438    0x6d0    .word 0xe0029010
    0xe000443c    0x6d4    .word 0xe0004480
    0xe0004440    0x6d8    .word 0xe00044a8
    0xe0004444    0x6dc    .word 0xe0029044

Proving inst theorems
---------------------

<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
<<HOL message: inventing new type variable names: 'a>>
436 inst theorems describe instructions.

Evaluating graph
----------------

The graph for `init_kernel` has 728 nodes.

Completing graph
-----------------

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0012BA0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012AAC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012AA4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_0_E0012AA0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr7_cr14_2_E0012B00` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_ip_cr0_cr0_0_E0012ABC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r3_cr0_cr0_0_E0012AC4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_lr_cr0_cr0_0_E0012AC0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_2_r3_cr0_cr0_0_E0012AB4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012AA8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012A88` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012B24` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr7_cr5_7_E0012974` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012944` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr7_cr5_1_E0012940` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr7_cr11_1_E00126F8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00126FC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr10_1_E0012668` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E001267C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00126B4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E001266C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_ip_cr7_cr10_1_E00125A8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr14_1_E0012630` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00125BC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012634` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012644` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00125AC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00125E8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00125FC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr14_cr1_0_E001257C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr0_cr1_1_E001256C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr0_cr1_2_E0012568` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr7_cr14_2_E001251C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r3_cr0_cr0_0_E00124E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r0_cr0_cr0_0_E00124D8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_ip_cr0_cr0_0_E00124DC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_2_r3_cr0_cr0_0_E00124D0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr7_cr14_2_E00124A4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r3_cr0_cr0_0_E0012460` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r6_cr0_cr0_0_E0012458` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_r0_cr0_cr0_0_E001245C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_fp_cr0_cr0_1_E0012414` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_2_r3_cr0_cr0_0_E0012454` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr7_cr10_2_E0012128` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r3_cr0_cr0_0_E00120E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_2_r6_cr0_cr0_0_E00120DC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_r0_cr0_cr0_0_E00120E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_1_fp_cr0_cr0_1_E00120AC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_2_r3_cr0_cr0_0_E00120D8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011824` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr8_cr7_2_E001181C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011814` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011820` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011214` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_ip_cr8_cr7_2_E001120C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011210` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011208` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'wfi_E0010A40` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cpsid_aif_E0010A3C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'wfi_E00107A0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr10_cr0_1_E0010784` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r1_cr10_cr0_0_E0010790` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr10_cr1_1_E0010788` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr10_cr1_0_E0010794` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr8_cr7_1_E0010780` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr10_cr0_1_E001078C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr10_cr0_0_E0010798` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sl_cr6_cr0_0_E00100E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r9_cr5_cr0_0_E00100E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r9_cr5_cr0_1_E00100B0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'udf_0_E00023D0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'udf_0_E0002478` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'udf_0_E00012A4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0000A00` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr1_cr0_2_E00009FC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr1_cr0_2_E00009F4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'vmsr_fpexc_r3_E0000A1C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'vmrs_r3_fpexc_E0000A14` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'vmrs_r3_fpexc_E0000A20` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00129C4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_0_E00129C0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00129C8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00129B0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00129B8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00129A0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_0_E001299C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00129A4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012994` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E001298C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr6_1_E00127C4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00127D8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00127C8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0012784` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012198` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00121B8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_0_E0012194` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r4_cr8_cr7_2_E00121B0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00121A8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E001219C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E001218C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012184` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00121B4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E0011F30` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0011F34` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr5_cr0_0_E001148C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r1_cr6_cr0_0_E0011488` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r0_cr5_cr0_1_E0011460` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00113EC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00113E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011404` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr2_cr0_0_E00113E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr13_cr0_1_E00113E8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr2_cr0_0_E0011400` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00113D4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'strex_r0_r1_r3_E0011360` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r1_cr13_cr0_3_E0010744` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r1_cr13_cr0_2_E001073C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_19_E00100F0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'stmdb_sp_r0_r1_r2_r3_r4_r5_r6_r7_r8_r9_sl_fp_ip_sp_lr_E00100F4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'srsia_sp_19_E00100EC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sp_cr13_cr0_4_E0010108` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_19_E0010040` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'stmdb_sp_r0_r1_r2_r3_r4_r5_r6_r7_r8_r9_sl_fp_ip_sp_lr_E0010044` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'srsia_sp_19_E001003C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sp_cr13_cr0_4_E0010054` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'udf_0_E0001F5C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E0001EC8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0001ECC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E0001B40` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr7_cr11_1_E0001AD0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0001AD4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0001B44` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'udf_0_E0001868` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'udf_0_E00015AC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E0001508` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E000150C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_3_E001860C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_2_E0018604` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'strex_r0_r1_r3_E00164F4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'strex_r0_r1_r3_E0016468` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012A7C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0012A74` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00129E8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_0_E00129E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r4_cr7_cr5_0_E0012A70` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012A78` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012A6C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012A64` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00129EC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00129DC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00129D4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0012A10` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0012A48` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr7_cr11_1_E00117D0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00117D4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011784` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr8_cr7_2_E001177C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011774` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011780` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011510` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr8_cr7_1_E0011508` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E001150C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00114F8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011334` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0011344` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E001132C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00112D4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr13_cr0_1_E0011330` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r4_cr2_cr0_0_E0011328` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r4_cr2_cr0_0_E00112D0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r6_cr2_cr0_0_E0011340` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0011324` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00112CC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_3_E0010160` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_2_E0010158` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_3_E0010138` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r2_cr13_cr0_2_E0010130` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_19_E00100BC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'stmdb_sp_r0_r1_r2_r3_r4_r5_r6_r7_r8_r9_sl_fp_ip_sp_lr_E00100C0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'srsia_sp_19_E00100B8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sp_cr13_cr0_4_E00100D8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_19_E001008C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'stmdb_sp_r0_r1_r2_r3_r4_r5_r6_r7_r8_r9_sl_fp_ip_sp_lr_E0010090` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'srsia_sp_19_E0010088` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sp_cr13_cr0_4_E00100A8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0000A74` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0000A4C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E0000A64` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr2_cr0_0_E0000A60` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr7_cr5_0_E0000A48` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr8_cr7_0_E0000A6C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0000A70` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0000A38` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0000A50` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0000A54` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0000A40` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0000A68` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E001A5B0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E001A4F0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E001A5B4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E001A4F4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'stmdb_sp_r0_r1_r2_r3_r4_r5_r6_r7_r8_r9_sl_fp_ip_sp_lr_E0010068` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'srsia_sp_19_E001005C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_sp_cr13_cr0_4_E001006C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'udf_0_E000332C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_19_E000003C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'cps_23_E0000034` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r4_cr1_cr0_0_E0000020` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r4_cr1_cr0_0_E000000C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E00115E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E00116D0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r0_cr7_cr11_1_E0011630` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr7_cr11_1_E0011728` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E001172C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00115E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0011634` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E00116D4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'strex_r0_r1_r3_E0016688` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00128C0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00128A0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr5_7_E00128B0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr7_cr11_1_E0012870` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r2_cr7_cr5_1_E001289C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0012884` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0012874` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_4_e0010020_ki_boot_end_0x20_E0010014` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_20_e0010038_ki_boot_end_0x38_E001001C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_20_e0010034_ki_boot_end_0x34_E0010018` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_24_e0010030_ki_boot_end_0x30_E0010010` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_24_e001002c_ki_boot_end_0x2c_E001000C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_24_e0010020_ki_boot_end_0x20_E0010000` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_24_e0010028_ki_boot_end_0x28_E0010008` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'ldr_pc_pc_24_e0010024_ki_boot_end_0x24_E0010004` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00159E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E0015C2C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E0015128` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E001598C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr7_cr11_1_E0015618` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr8_cr7_2_E00159DC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00159E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00159D4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0015C30` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E001512C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E0015990` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dmb_sy_E001561C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00041FC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00042EC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'isb_sy_E00042D8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr13_cr0_4_E0003E14` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r3_cr14_cr1_0_E0003E58` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r9_cr7_cr5_0_E00041F8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r9_cr7_cr5_0_E00042D4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mcr_15_0_r9_cr8_cr7_0_E00042E4` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr0_cr1_1_E0003E48` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'mrc_15_0_r3_cr0_cr1_2_E0003E44` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00041E8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00041F0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00042C8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00042E0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00042E8` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E0004200` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00042DC` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'dsb_sy_E00042D0` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'vmsr_fpexc_r3_E0003E2C` has 0 nodes.

Evaluating graph
----------------

The graph for `instruction'vmrs_r3_fpexc_E0003E24` has 0 nodes.

Proving correctness of call offsets
===================================

Offsets proved correct.

Summary
=======

No stack intro failures.
Graph spec failed in _start for pos 0xe0000008.
Graph spec failed in _start for pos 0xe0000008.
No export failures.
No call offset failures.
> 