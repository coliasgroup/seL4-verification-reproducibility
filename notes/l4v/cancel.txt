tools:

ccorres_gen_asm
ccorres_gen_asm2

ccorres_guard_imp{2}

?
ccorres_gen_asm{2}
ccorres_guard_imp{2}
hoare_post_imp
ccorres_symb_exec_r_known_rv_UNIV
hoare_strengthen_postE_R
ccorres_inst
hoare_vcg_conj_lift
ccorres_from_vcg

see in Finalise_C.thy:
    apply (rule_tac P="invs' and (\<lambda>s. sym_refs (state_refs_of' s)) and ko_at' ntfn ntfnptr" and P'=UNIV
             in ccorres_split_nothrow_novcg)

see in Delete_C.thy:
        apply (rule_tac A="λs. invs' s ∧ cte_wp_at' ((=) rv) slot' s
                                ∧ (expo ∨ ex_cte_cap_to' slot' s)
                                ∧ (final_matters' (cteCap rv) ⟶ rva = isFinal (cteCap rv) slot' (cteCaps_of s))"
                    and A'=UNIV
                     in ccorres_guard_imp2)

see in Finalise_C.thy:

    apply (rule_tac xf'=ret__unsigned_longlong_'
            and val="thread_state_to_tsType threadState"
            and R="st_tcb_at' ((=) threadState) thread"
            and R'=UNIV
            in
            ccorres_symb_exec_r_known_rv)

see in IpcCancel_C.thy:

      apply (rule_tac xf'=ret__int_'
                  and val="from_bool (scPtrOpt \<noteq> None)"
                  and R="\<lambda>s. obj_at' (\<lambda>tcb. tcbSchedContext tcb = scPtrOpt) tcbPtr s
                             \<and> valid_tcbs' s \<and> no_0_obj' s"
                  and R'=UNIV
                   in ccorres_symb_exec_r_known_rv)

   apply (rule_tac val="from_bool (\<exists>scPtr. scOpt = Some scPtr)"
               and xf'=ret__int_'
               and R="tcb_at' t and bound_sc_tcb_at' ((=) scOpt) t and valid_objs' and no_0_obj'"
               and R'=UNIV
                in ccorres_symb_exec_r_known_rv)

    apply (rule_tac P="tcb_at' thread" in ccorres_cross_over_guard)


investigate:
    ? ctcb_relation_blockingIPCCanGrantReplyD
    ! threadSet_ccorres_lemma{4,*}

    state_refs_of'_upd
    map_to_ko_at_updI'

    threadSet_pred_tcb_no_state

!!!
sym_ref_Receive_or_Reply_replyTCB'
sym_ref_Receive_or_Reply_replyTCB'

Reply_or_Receive_reply_at

      apply (rule_tac A="λs. sym_refs_asrt s" in ccorres_guard_imp2[where A'=UNIV])

      apply (rule_tac A="λs. bound ro ⟶ obj_at' (λr. replyTCB r = Some thread) (the ro) s" in ccorres_guard_imp2[where A'=UNIV])




see in IpcCancel_R.thy:

       \<comment>\<open>drop sym_refs assumtions; add reply_tcb link\<close>
      apply (rule_tac P="?abs_guard and (\<lambda>s. bound reply_opt \<longrightarrow> reply_tcb_reply_at ((=) (Some t)) (the reply_opt) s)
                         and valid_ep rv
                         and (\<lambda>_. (st = Structures_A.BlockedOnSend epPtr p
                                      \<longrightarrow> (\<exists>list. rv = Structures_A.SendEP list))
                                \<and> (st = Structures_A.thread_state.BlockedOnReceive epPtr reply_opt p'
                                     \<longrightarrow> (\<exists>list. rv = Structures_A.RecvEP list)))"
                  and P'="valid_objs' and st_tcb_at' ((=) st') t and valid_ep' ep
                          and pspace_aligned' and pspace_distinct'"
                   in corres_inst)
      \<comment>\<open>cross over replyTCB\<close>
      apply (rule_tac Q'="\<lambda>s. bound reply_opt \<longrightarrow> obj_at' (\<lambda>r. replyTCB r = Some t) (the reply_opt) s"
                      in corres_cross_add_guard)


NOTES:
- cthread_state_relation_lifted relates H and C thread state

-- -- --

apply (strengthen  invs_pspace_bounded')

see lemma replyUnlink_valid_objs'[wp]
see lemma sts_invs_minor'
see lemma map_to_scs_Some_scRefs_nonzero
    
see:
       apply (rule_tac Q'="λrv. invs' and cte_at' slot and valid_cap' cap" in hoare_strengthen_postE_R)
        apply (wp cteDelete_invs'')

see lemma cteDelete_invs''

apply (rule_tac Q'="λrv. invs' and tcb_at' thread and reply_at' foo and (λs. weak_sch_act_wf (ksSchedulerAction s) s)" in hoare_post_imp)


tools:

             apply (rule_tac P="..." in ccorres_cross_over_guard)

corres_inst?
ccorres_gen_asm{2}
ccorres_guard_imp{2}


hoare_pre
wp_pre
hoare_weaken_pre
ccorres_assume_pre
